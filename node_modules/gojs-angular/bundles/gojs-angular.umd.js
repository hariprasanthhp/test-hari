(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('gojs')) :
    typeof define === 'function' && define.amd ? define('gojs-angular', ['exports', '@angular/core', 'gojs'], factory) :
    (global = global || self, factory(global['gojs-angular'] = {}, global.ng.core, global.go));
}(this, (function (exports, i0, go) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/diagram.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DiagramComponent = /** @class */ (function () {
        /**
         * @param {?} _kvdiffers
         * @param {?} zone
         */
        function DiagramComponent(_kvdiffers, zone) {
            this._kvdiffers = _kvdiffers;
            this.zone = zone;
            // Link data for diagram
            this.linkDataArray = null; // optional
            // optional
            // Model data for diagram
            this.modelData = null; // optional
            // model changed listener function for diagram
            this.modelChangedListener = null;
            this.skipsDiagramUpdate = false;
            // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
            this.modelChange = new i0.EventEmitter();
            this.diagram = null;
            // differs used to check if there have been changed to the array @Inputs
            // without them, changes to the input arrays won't register in ngOnChanges,
            // since the array reference itself may be the same
            this._ndaDiffer = this._kvdiffers.find([]).create();
            this._ldaDiffer = this._kvdiffers.find([]).create();
            this._mdaDiffer = this._kvdiffers.find([]).create();
        }
        /**
         * Initializes diagram / model after view init
         * @return {?}
         */
        DiagramComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.diagram = this.initDiagram();
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the diagram,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.diagram.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.diagramDiv.nativeElement;
            if (divRef === null)
                return;
            this.diagram.div = divRef;
            // initialize the Diagram's model
            this.diagram.delayInitialization(( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var model = _this.diagram.model;
                model.commit(( /**
                 * @param {?} m
                 * @return {?}
                 */function (m) {
                    m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                    if (_this.linkDataArray && m instanceof go.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                    }
                    if (_this.modelData) {
                        m.assignAllDataProperties(m.modelData, _this.modelData);
                    }
                    _this.diagram.layoutDiagram(true);
                }), null);
            }));
            // initializer listener
            this.modelChangedListener = ( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                if (e.isTransactionFinished && _this.diagram && _this.diagram.model && !_this.diagram.model.isReadOnly) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var dataChanges = ( /** @type {?} */(e.model)).toIncrementalData(e);
                        _this.modelChange.emit(dataChanges);
                    }));
                }
            });
            this.diagram.addModelChangedListener(this.modelChangedListener);
        }; // end ngAfterViewInit
        // end ngAfterViewInit
        /**
         * Merges changes from app data into GoJS model data,
         * making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged
         * @param {?} component an instance of DiagramComponent or PaletteComponent
         * @param {?} kvchanges The kvchanges object produced by either a node or link Angular differ object
         * @param {?} str "n" for node data changes, "l" for link data changes
         *
         * @return {?}
         */
        DiagramComponent.mergeChanges = function (component, kvchanges, str) {
            // helper function
            /**
             * @param {?} obj1
             * @param {?} obj2
             * @return {?}
             */
            function compareObjs(obj1, obj2) {
                // Loop through properties in object 1
                for (var p in obj1) {
                    // Check property exists on both objects
                    if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p))
                        return false;
                    switch (typeof (obj1[p])) {
                        // Deep compare objects
                        case 'object':
                            if (!compareObjs(obj1[p], obj2[p]))
                                return false;
                            break;
                        // Compare values
                        default:
                            if (obj1[p] !== obj2[p])
                                return false;
                    }
                }
                // Check object 2 for any extra properties
                for (var p in obj2) {
                    if (typeof (obj1[p]) === 'undefined')
                        return false;
                }
                return true;
            }
            /** @type {?} */
            var dia = component instanceof DiagramComponent ? component.diagram : component.palette;
            if (!dia || !dia.model)
                return;
            if (kvchanges) {
                // handle added nodes / links
                kvchanges.forEachAddedItem(( /**
                 * @param {?} r
                 * @return {?}
                 */function (r) {
                    switch (str) {
                        case "n": {
                            dia.model.addNodeData(r.currentValue);
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            var m = ( /** @type {?} */(dia.model));
                            m.addLinkData(r.currentValue);
                            break;
                        }
                    }
                }));
                // handle removed nodes / links
                kvchanges.forEachRemovedItem(( /**
                 * @param {?} r
                 * @return {?}
                 */function (r) {
                    switch (str) {
                        case "n": {
                            /** @type {?} */
                            var m = dia.model;
                            /** @type {?} */
                            var keyPropName_1 = m.nodeKeyProperty.toString();
                            /** @type {?} */
                            var node = dia.findNodeForKey(r.previousValue[keyPropName_1]);
                            if (node) {
                                dia.remove(node);
                            }
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            var m = ( /** @type {?} */(dia.model));
                            /** @type {?} */
                            var keyPropName = m.linkKeyProperty.toString();
                            /** @type {?} */
                            var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                            if (link) {
                                dia.remove(link);
                            }
                            break;
                        }
                    }
                }));
                // handle changed data for nodes / links
                kvchanges.forEachChangedItem(( /**
                 * @param {?} r
                 * @return {?}
                 */function (r) {
                    // ensure "changes" to array / object / enumerable data properties are legit
                    /** @type {?} */
                    var sameVals = compareObjs(r.currentValue, r.previousValue);
                    // update proper data object for node or link
                    if (!sameVals) {
                        switch (str) {
                            case "n": {
                                /** @type {?} */
                                var m = dia.model;
                                /** @type {?} */
                                var keyPropName_2 = m.nodeKeyProperty.toString();
                                /** @type {?} */
                                var node = dia.findNodeForKey(r.previousValue[keyPropName_2]);
                                if (node) {
                                    dia.model.assignAllDataProperties(node.data, r.currentValue);
                                }
                                break;
                            }
                            case "l": {
                                /** @type {?} */
                                var m = ( /** @type {?} */(dia.model));
                                /** @type {?} */
                                var keyPropName = m.linkKeyProperty.toString();
                                /** @type {?} */
                                var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                                if (link) {
                                    dia.model.assignAllDataProperties(link.data, r.currentValue);
                                }
                                break;
                            }
                        }
                    }
                }));
            }
        };
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        DiagramComponent.prototype.ngDoCheck = function () {
            if (!this.diagram)
                return;
            if (!this.diagram.model)
                return;
            // these need to be run each check, even if no merging happens
            // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,
            // such as remove ops that happened in GoJS when skipsDiagram = true, 
            // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
            // Angular differs are a lot of fun
            /** @type {?} */
            var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
            /** @type {?} */
            var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
            /** @type {?} */
            var modelDiffs = this._mdaDiffer.diff(this.modelData);
            if (!nodeDiffs && !linkDiffs && !modelDiffs)
                return;
            if (this.skipsDiagramUpdate)
                return;
            // don't need model change listener while performing known data updates
            if (this.modelChangedListener !== null)
                this.diagram.model.removeChangedListener(this.modelChangedListener);
            this.diagram.model.startTransaction('update data');
            // update modelData first, in case bindings on nodes / links depend on model data
            this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);
            // merge node / link data
            DiagramComponent.mergeChanges(this, nodeDiffs, "n");
            DiagramComponent.mergeChanges(this, linkDiffs, "l");
            this.diagram.model.commitTransaction('update data');
            // reset the model change listener
            if (this.modelChangedListener !== null)
                this.diagram.model.addChangedListener(this.modelChangedListener);
        }; // end ngDoCheck
        // end ngDoCheck
        /**
         * @return {?}
         */
        DiagramComponent.prototype.ngOnDestroy = function () {
            this.diagram.div = null; // removes event listeners
        };
        return DiagramComponent;
    }());
    DiagramComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'gojs-diagram',
                    template: '<div #ngDiagram [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    DiagramComponent.ctorParameters = function () { return [
        { type: i0.KeyValueDiffers },
        { type: i0.NgZone }
    ]; };
    DiagramComponent.propDecorators = {
        initDiagram: [{ type: i0.Input }],
        nodeDataArray: [{ type: i0.Input }],
        linkDataArray: [{ type: i0.Input }],
        modelData: [{ type: i0.Input }],
        divClassName: [{ type: i0.Input }],
        skipsDiagramUpdate: [{ type: i0.Input }],
        modelChange: [{ type: i0.Output }],
        diagramDiv: [{ type: i0.ViewChild, args: ['ngDiagram', { static: true },] }]
    };
    if (false) {
        /**
         * Diagram initialization function. Returns a go.Diagram.
         * Do not initialize model data in this function.
         * @type {?}
         */
        DiagramComponent.prototype.initDiagram;
        /** @type {?} */
        DiagramComponent.prototype.nodeDataArray;
        /** @type {?} */
        DiagramComponent.prototype.linkDataArray;
        /** @type {?} */
        DiagramComponent.prototype.modelData;
        /** @type {?} */
        DiagramComponent.prototype.divClassName;
        /** @type {?} */
        DiagramComponent.prototype.modelChangedListener;
        /** @type {?} */
        DiagramComponent.prototype.skipsDiagramUpdate;
        /** @type {?} */
        DiagramComponent.prototype.modelChange;
        /** @type {?} */
        DiagramComponent.prototype.diagramDiv;
        /** @type {?} */
        DiagramComponent.prototype.diagram;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._ndaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._ldaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._mdaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._kvdiffers;
        /** @type {?} */
        DiagramComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/palette.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaletteComponent = /** @class */ (function () {
        /**
         * @param {?} _kvdiffers
         * @param {?} zone
         */
        function PaletteComponent(_kvdiffers, zone) {
            this._kvdiffers = _kvdiffers;
            this.zone = zone;
            // Link data for palette. Optional
            this.linkDataArray = null;
            // Model data for palette. Optional
            this.modelData = null;
            this.skipsPaletteUpdate = false;
            // model changed listener function for palette
            this.modelChangedListener = null;
            // event emitter -- fires when palette model changes. Capture this emitted event in parent component
            this.modelChange = new i0.EventEmitter();
            // The Palette itself
            this.palette = null;
            // differs used to check if there have been changed to the array @Inputs
            // without them, changes to the input arrays won't register in ngOnChanges,
            // since the array reference itself may be the same
            this._ndaDiffer = this._kvdiffers.find([]).create();
            this._ldaDiffer = this._kvdiffers.find([]).create();
            this._mdaDiffer = this._kvdiffers.find([]).create();
        } // end constructor
        // end constructor
        /**
         * Initialize Palette after view init
         * @return {?}
         */
        PaletteComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.paletteDiv)
                return;
            this.palette = this.initPalette();
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the palette,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.palette.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.paletteDiv.nativeElement;
            this.palette.div = divRef;
            // initialize palette model
            this.palette.delayInitialization(( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var model = _this.palette.model;
                model.commit(( /**
                 * @param {?} m
                 * @return {?}
                 */function (m) {
                    m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                    if (_this.linkDataArray && m instanceof go.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                    }
                    if (_this.modelData) {
                        m.assignAllDataProperties(m.modelData, _this.modelData);
                    }
                    _this.palette.layoutDiagram(true);
                }), null);
            }));
            // initializer listener
            this.modelChangedListener = ( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                if (e.isTransactionFinished && _this.palette && _this.palette.model && !_this.palette.model.isReadOnly) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var dataChanges = ( /** @type {?} */(e.model)).toIncrementalData(e);
                        _this.modelChange.emit(dataChanges);
                    }));
                }
            });
            this.palette.addModelChangedListener(this.modelChangedListener);
        }; // end ngAfterViewInit
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        PaletteComponent.prototype.ngDoCheck = function () {
            if (!this.palette)
                return;
            if (!this.palette.model)
                return;
            // these need to be run each check, even if no merging happens
            // otherwise, they will detect all diffs that happened since last time skipsPaletteUpdate was false,
            // such as remove ops that happened in GoJS when skipsPaletteUpdate = true, 
            // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
            // Angular differs are a lot of fun
            /** @type {?} */
            var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
            /** @type {?} */
            var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
            /** @type {?} */
            var modelDiffs = this._mdaDiffer.diff(this.modelData);
            if (!nodeDiffs && !linkDiffs && !modelDiffs)
                return;
            if (this.skipsPaletteUpdate)
                return;
            // don't need model change listener while performing known data updates
            if (this.modelChangedListener !== null)
                this.palette.model.removeChangedListener(this.modelChangedListener);
            this.palette.model.startTransaction('update data');
            // update modelData first, in case bindings on nodes / links depend on model data
            this.palette.model.assignAllDataProperties(this.palette.model.modelData, this.modelData);
            DiagramComponent.mergeChanges(this, nodeDiffs, "n");
            DiagramComponent.mergeChanges(this, linkDiffs, "l");
            this.palette.model.commitTransaction('update data');
            // reset the model change listener
            if (this.modelChangedListener !== null)
                this.palette.model.addChangedListener(this.modelChangedListener);
        }; // end ngDoCheck
        // end ngDoCheck
        /**
         * @return {?}
         */
        PaletteComponent.prototype.ngOnDestroy = function () {
            this.palette.div = null; // removes event listeners
        };
        return PaletteComponent;
    }());
    PaletteComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'gojs-palette',
                    template: '<div #ngPalette [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    PaletteComponent.ctorParameters = function () { return [
        { type: i0.KeyValueDiffers },
        { type: i0.NgZone }
    ]; };
    PaletteComponent.propDecorators = {
        initPalette: [{ type: i0.Input }],
        nodeDataArray: [{ type: i0.Input }],
        linkDataArray: [{ type: i0.Input }],
        modelData: [{ type: i0.Input }],
        divClassName: [{ type: i0.Input }],
        skipsPaletteUpdate: [{ type: i0.Input }],
        modelChange: [{ type: i0.Output }],
        paletteDiv: [{ type: i0.ViewChild, args: ['ngPalette', { static: true },] }]
    };
    if (false) {
        /**
         * Palette initialization function. Returns a go.Palette.
         * Do not initialize model data in this function.
         * @type {?}
         */
        PaletteComponent.prototype.initPalette;
        /** @type {?} */
        PaletteComponent.prototype.nodeDataArray;
        /** @type {?} */
        PaletteComponent.prototype.linkDataArray;
        /** @type {?} */
        PaletteComponent.prototype.modelData;
        /** @type {?} */
        PaletteComponent.prototype.divClassName;
        /** @type {?} */
        PaletteComponent.prototype.skipsPaletteUpdate;
        /** @type {?} */
        PaletteComponent.prototype.modelChangedListener;
        /** @type {?} */
        PaletteComponent.prototype.modelChange;
        /** @type {?} */
        PaletteComponent.prototype.paletteDiv;
        /** @type {?} */
        PaletteComponent.prototype.palette;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._ndaDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._ldaDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._mdaDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._kvdiffers;
        /** @type {?} */
        PaletteComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/overview.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverviewComponent = /** @class */ (function () {
        /**
         * @param {?} zone
         */
        function OverviewComponent(zone) {
            this.zone = zone;
            // The Diagram to observe with the Overview
            this.observedDiagram = null;
            // The Overview itself
            this.overview = null;
        }
        /**
         * Initialize the overview
         * @return {?}
         */
        OverviewComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.overviewDiv)
                return;
            if (this.initOverview) {
                this.overview = this.initOverview();
            }
            else {
                this.overview = new go.Overview();
                this.overview.contentAlignment = go.Spot.Center;
            }
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the overview,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.overview.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            this.overview.div = this.overviewDiv.nativeElement;
        };
        /**
         * Only update when the observed diagram changes
         * @param {?} changes
         * @return {?}
         */
        OverviewComponent.prototype.ngOnChanges = function (changes) {
            if (!this.overview)
                return;
            if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {
                this.overview.observed = changes.observedDiagram.currentValue;
            }
        };
        /**
         * @return {?}
         */
        OverviewComponent.prototype.ngOnDestroy = function () {
            this.overview.div = null; // removes event listeners
        };
        return OverviewComponent;
    }());
    OverviewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'gojs-overview',
                    template: '<div #ngOverview [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    OverviewComponent.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };
    OverviewComponent.propDecorators = {
        initOverview: [{ type: i0.Input }],
        divClassName: [{ type: i0.Input }],
        observedDiagram: [{ type: i0.Input }],
        overviewDiv: [{ type: i0.ViewChild, args: ['ngOverview', { static: true },] }]
    };
    if (false) {
        /** @type {?} */
        OverviewComponent.prototype.initOverview;
        /** @type {?} */
        OverviewComponent.prototype.divClassName;
        /** @type {?} */
        OverviewComponent.prototype.observedDiagram;
        /** @type {?} */
        OverviewComponent.prototype.overviewDiv;
        /** @type {?} */
        OverviewComponent.prototype.overview;
        /** @type {?} */
        OverviewComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/gojs-angular.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GojsAngularModule = /** @class */ (function () {
        function GojsAngularModule() {
        }
        return GojsAngularModule;
    }());
    GojsAngularModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        DiagramComponent,
                        OverviewComponent,
                        PaletteComponent
                    ],
                    imports: [],
                    exports: [
                        DiagramComponent,
                        OverviewComponent,
                        PaletteComponent
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/data-sync.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSyncService = /** @class */ (function () {
        function DataSyncService() {
        }
        /**
         * Sync a node data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} nodeData The node data array to merge these changes with
         * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
         * @return {?} A node data array, merged with the changes
         */
        DataSyncService.syncNodeData = function (changes, nodeData, model) {
            if (!changes)
                return nodeData;
            if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
                return nodeData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedNodesMap = new go.Map();
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach(( /**
                 * @param {?} nd
                 * @return {?}
                 */function (nd) {
                    // Get the value of the node key property checking wether is a function or a string
                    /** @type {?} */
                    var key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    modifiedNodesMap.set(key, nd);
                    for (var i = 0; i < nodeData.length; i++) {
                        /** @type {?} */
                        var ndEntry = nodeData[i];
                        /** @type {?} */
                        var keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                        if (keyNdEntry === key) {
                            nodeData[i] = nd;
                        }
                    }
                }));
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    /** @type {?} */
                    var nd = modifiedNodesMap.get(key);
                    if (nd) {
                        nodeData.push(nd);
                    }
                }));
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                nodeData = nodeData.filter(( /**
                 * @param {?} nd
                 * @return {?}
                 */function (nd) {
                    /** @type {?} */
                    var key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    if (changes.removedNodeKeys.includes(key)) {
                        return false;
                    }
                    return true;
                }));
            }
            return nodeData;
        };
        /**
         * Sync a link data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} linkData The link data array to merge these changes with
         * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
         * @return {?} A link data array, merged with the changes
         */
        DataSyncService.syncLinkData = function (changes, linkData, model) {
            if (!changes)
                return linkData;
            if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
                return linkData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedLinksMap = new go.Map();
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach(( /**
                 * @param {?} ld
                 * @return {?}
                 */function (ld) {
                    // Get the value of the link key
                    /** @type {?} */
                    var key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    modifiedLinksMap.set(key, ld);
                    for (var i = 0; i < linkData.length; i++) {
                        /** @type {?} */
                        var ldEntry = linkData[i];
                        /** @type {?} */
                        var keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                        if (keyLdEntry === key) {
                            linkData[i] = ld;
                        }
                    }
                }));
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    /** @type {?} */
                    var nd = modifiedLinksMap.get(key);
                    if (nd) {
                        linkData.push(nd);
                    }
                }));
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                linkData = linkData.filter(( /**
                 * @param {?} ld
                 * @return {?}
                 */function (ld) {
                    /** @type {?} */
                    var key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    if (changes.removedLinkKeys.includes(key)) {
                        return false;
                    }
                    return true;
                }));
            }
            return linkData;
        };
        /**
         * Sync modelData with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} modelData The modelData to merge these changes with
         * @return {?} A modelData object, merged with the changes
         */
        DataSyncService.syncModelData = function (changes, modelData) {
            if (!changes)
                return modelData;
            if (!changes.modelData)
                return modelData;
            if (changes.modelData) {
                return changes.modelData;
            }
        };
        return DataSyncService;
    }());
    DataSyncService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DataSyncService.ctorParameters = function () { return []; };
    /** @nocollapse */ DataSyncService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DataSyncService_Factory() { return new DataSyncService(); }, token: DataSyncService, providedIn: "root" });

    /**
     * @fileoverview added by tsickle
     * Generated from: public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: gojs-angular.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.DataSyncService = DataSyncService;
    exports.DiagramComponent = DiagramComponent;
    exports.GojsAngularModule = GojsAngularModule;
    exports.OverviewComponent = OverviewComponent;
    exports.PaletteComponent = PaletteComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=gojs-angular.umd.js.map
