{"version":3,"sources":["../../../projects/gojs-angular/src/lib/diagram.component.ts","../../../projects/gojs-angular/src/lib/palette.component.ts","../../../projects/gojs-angular/src/lib/overview.component.ts","../../../projects/gojs-angular/src/lib/gojs-angular.module.ts","../../../projects/gojs-angular/src/lib/data-sync.service.ts"],"names":["DiagramComponent","_kvdiffers","zone","this","linkDataArray","modelData","modelChangedListener","skipsDiagramUpdate","modelChange","EventEmitter","diagram","_ndaDiffer","find","create","_ldaDiffer","_mdaDiffer","prototype","ngAfterViewInit","_this","initDiagram","addEventListener","DOMElement","name","listener","capture","superAddEventListener","go.Diagram","runOutsideAngular","call","run","divRef","diagramDiv","nativeElement","div","delayInitialization","model","commit","m","mergeNodeDataArray","cloneDeep","nodeDataArray","go.GraphLinksModel","mergeLinkDataArray","assignAllDataProperties","layoutDiagram","e","isTransactionFinished","isReadOnly","dataChanges","toIncrementalData","emit","addModelChangedListener","mergeChanges","component","kvchanges","str","dia","palette","forEachAddedItem","r","addNodeData","currentValue","addLinkData","forEachRemovedItem","keyPropName_1","nodeKeyProperty","toString","node","findNodeForKey","previousValue","remove","keyPropName","linkKeyProperty","link","findLinkForKey","forEachChangedItem","compareObjs","obj1","obj2","p","hasOwnProperty","keyPropName_2","data","ngDoCheck","nodeDiffs","diff","linkDiffs","modelDiffs","removeChangedListener","startTransaction","commitTransaction","addChangedListener","ngOnDestroy","Component","args","selector","template","KeyValueDiffers","NgZone","Input","Output","ViewChild","static","PaletteComponent","skipsPaletteUpdate","paletteDiv","initPalette","OverviewComponent","observedDiagram","overview","overviewDiv","initOverview","go.Overview","contentAlignment","go.Spot","Center","ngOnChanges","changes","observed","NgModule","declarations","imports","exports","DataSyncService","syncNodeData","nodeData","modifiedNodeData","insertedNodeKeys","removedNodeKeys","modifiedNodesMap","go.Map","forEach","nd","key","getKeyForNodeData","set","i","length","ndEntry","get","push","filter","includes","syncLinkData","linkData","modifiedLinkData","insertedLinkKeys","removedLinkKeys","modifiedLinksMap","ld","getKeyForLinkData","ldEntry","syncModelData","Injectable","providedIn"],"mappings":"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","sourcesContent":["import { Component, ElementRef, EventEmitter, Input, KeyValueDiffer, KeyValueDiffers, NgZone, Output, ViewChild, KeyValueChangeRecord } from '@angular/core';\r\nimport * as go from 'gojs';\r\n\r\n@Component({\r\n  selector: 'gojs-diagram',\r\n  template: '<div #ngDiagram [className]=divClassName></div>'\r\n})\r\nexport class DiagramComponent {\r\n\r\n  /**\r\n   * Diagram initialization function. Returns a go.Diagram.\r\n   * Do not initialize model data in this function.\r\n   */\r\n  @Input() public initDiagram: () => go.Diagram;\r\n\r\n  // Node data for diagram\r\n  @Input() public nodeDataArray: Array<go.ObjectData>;\r\n\r\n  // Link data for diagram\r\n  @Input() public linkDataArray: Array<go.ObjectData> = null; // optional\r\n\r\n  // Model data for diagram\r\n  @Input() public modelData: go.ObjectData = null; // optional\r\n\r\n  // Diagram div class name. Use this name to style your diagram in CSS\r\n  @Input() public divClassName: string;\r\n\r\n  // model changed listener function for diagram\r\n  public modelChangedListener: (e: go.ChangedEvent) => void | null = null;\r\n\r\n  @Input() public skipsDiagramUpdate: boolean = false;\r\n\r\n  // event emitter -- fires when diagram model changes. Capture this emitted event in parent component\r\n  @Output() public modelChange: EventEmitter<go.IncrementalData> = new EventEmitter<go.IncrementalData>();\r\n\r\n  @ViewChild('ngDiagram', { static: true }) public diagramDiv: ElementRef;\r\n  public diagram: go.Diagram = null;\r\n\r\n  // differs for array inputs (node / link data arrays)\r\n  private _ndaDiffer: KeyValueDiffer<string, any>;\r\n  private _ldaDiffer: KeyValueDiffer<string, any>;\r\n\r\n  private _mdaDiffer: KeyValueDiffer<string, any>;\r\n\r\n  constructor(private _kvdiffers: KeyValueDiffers, public zone: NgZone) {\r\n    // differs used to check if there have been changed to the array @Inputs\r\n    // without them, changes to the input arrays won't register in ngOnChanges,\r\n    // since the array reference itself may be the same\r\n    this._ndaDiffer = this._kvdiffers.find([]).create();\r\n    this._ldaDiffer = this._kvdiffers.find([]).create();\r\n\r\n    this._mdaDiffer = this._kvdiffers.find([]).create();\r\n  }\r\n\r\n  /**\r\n   * Initializes diagram / model after view init\r\n   */\r\n  public ngAfterViewInit() {\r\n    this.diagram = this.initDiagram();\r\n\r\n    // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone\r\n    // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance\r\n    // If some state-altering behavior must happen on a mousemove event inside the diagram,\r\n    // you will have to using zone.run() to make sure that event triggers angular change detection\r\n    this.diagram.addEventListener = (DOMElement: Element | Window | Document, name: string, listener: any, capture: boolean) => {\r\n      const superAddEventListener = go.Diagram.prototype.addEventListener;\r\n      if (name === 'mousemove') {\r\n        this.zone.runOutsideAngular(() => superAddEventListener.call(this, DOMElement, name, listener, capture));\r\n      } else {\r\n        this.zone.run(() => {\r\n          superAddEventListener.call(this, DOMElement, name, listener, capture);\r\n        });\r\n      }\r\n    };\r\n\r\n    // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,\r\n    // using the overridden addEventListener function above\r\n    const divRef = this.diagramDiv.nativeElement;\r\n    if (divRef === null) return;\r\n    this.diagram.div = divRef;\r\n\r\n    // initialize the Diagram's model\r\n    this.diagram.delayInitialization(() => {\r\n      const model = this.diagram.model;\r\n      model.commit((m: go.Model) => {\r\n        m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));\r\n        if (this.linkDataArray && m instanceof go.GraphLinksModel) {\r\n          m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));\r\n        }\r\n        if (this.modelData) {\r\n          m.assignAllDataProperties(m.modelData, this.modelData);\r\n        }\r\n        this.diagram.layoutDiagram(true);\r\n      }, null);\r\n    });\r\n\r\n    // initializer listener\r\n    this.modelChangedListener = (e: go.ChangedEvent) => {\r\n      if (e.isTransactionFinished && this.diagram && this.diagram.model && !this.diagram.model.isReadOnly) {\r\n        // this must be done within a NgZone.run block, so changes are detected in the parent component\r\n        this.zone.run(() => {\r\n          const dataChanges = e.model!.toIncrementalData(e);\r\n          this.modelChange.emit(dataChanges);\r\n        });\r\n      }\r\n    };\r\n    this.diagram.addModelChangedListener(this.modelChangedListener);\r\n\r\n\r\n  } // end ngAfterViewInit\r\n\r\n  /**\r\n   * Merges changes from app data into GoJS model data, \r\n   * making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged\r\n   * @param component an instance of DiagramComponent or PaletteComponent\r\n   * @param kvchanges The kvchanges object produced by either a node or link Angular differ object\r\n   * @param str \"n\" for node data changes, \"l\" for link data changes\r\n   *  */ \r\n  public static mergeChanges(component, kvchanges, str): boolean {\r\n\r\n    // helper function\r\n    function compareObjs(obj1, obj2) {\r\n      // Loop through properties in object 1\r\n      for (const p in obj1) {\r\n        // Check property exists on both objects\r\n        if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p)) return false;\r\n\r\n        switch (typeof (obj1[p])) {\r\n          // Deep compare objects\r\n          case 'object':\r\n            if (!compareObjs(obj1[p], obj2[p])) return false;\r\n            break;\r\n          // Compare values\r\n          default:\r\n            if (obj1[p] !== obj2[p]) return false;\r\n        }\r\n      }\r\n\r\n      // Check object 2 for any extra properties\r\n      for (const p in obj2) {\r\n        if (typeof (obj1[p]) === 'undefined') return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    var dia = component instanceof DiagramComponent ? component.diagram : component.palette;\r\n\r\n    if (!dia || !dia.model) return;\r\n\r\n    if (kvchanges) {\r\n\r\n      // handle added nodes / links\r\n      kvchanges.forEachAddedItem((r: KeyValueChangeRecord<string, any>) => {\r\n        switch (str) {\r\n          case \"n\": {\r\n            dia.model.addNodeData(r.currentValue);\r\n            break;\r\n          }\r\n          case \"l\": {\r\n            var m = <go.GraphLinksModel>dia.model;\r\n            m.addLinkData(r.currentValue);\r\n            break;\r\n          }\r\n        }\r\n      });\r\n\r\n      // handle removed nodes / links\r\n      kvchanges.forEachRemovedItem((r: KeyValueChangeRecord<string, any>) => {\r\n        switch (str) {\r\n          case \"n\": {\r\n            let m = dia.model;\r\n            let keyPropName = m.nodeKeyProperty.toString();\r\n            var node = dia.findNodeForKey(r.previousValue[keyPropName]);\r\n            if (node) {\r\n              dia.remove(node);\r\n            }\r\n            break;\r\n          }\r\n          case \"l\": {\r\n            let m = <go.GraphLinksModel>dia.model;\r\n            var keyPropName = m.linkKeyProperty.toString();\r\n            var link = dia.findLinkForKey(r.previousValue[keyPropName]);\r\n            if (link) {\r\n              dia.remove(link);\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      });\r\n\r\n      // handle changed data for nodes / links\r\n      kvchanges.forEachChangedItem((r: KeyValueChangeRecord<string, any>) => {\r\n        \r\n        // ensure \"changes\" to array / object / enumerable data properties are legit\r\n        const sameVals = compareObjs(r.currentValue, r.previousValue);\r\n\r\n        // update proper data object for node or link\r\n        if (!sameVals) {\r\n          switch (str) {\r\n            case \"n\": {\r\n              let m = dia.model;\r\n              let keyPropName = m.nodeKeyProperty.toString();\r\n              var node = dia.findNodeForKey(r.previousValue[keyPropName]);\r\n              if (node) {\r\n                dia.model.assignAllDataProperties(node.data, r.currentValue);\r\n              }\r\n              break;\r\n            }\r\n            case \"l\": {\r\n              let m = <go.GraphLinksModel>dia.model;\r\n              var keyPropName = m.linkKeyProperty.toString();\r\n              var link = dia.findLinkForKey(r.previousValue[keyPropName]);\r\n              if (link) {\r\n                dia.model.assignAllDataProperties(link.data, r.currentValue);\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        \r\n      });\r\n    }\r\n    \r\n  }\r\n\r\n  /**\r\n   * Always be checking if array Input data has changed (node and link data arrays)\r\n   */\r\n  public ngDoCheck() {\r\n\r\n    if (!this.diagram) return;\r\n    if (!this.diagram.model) return;\r\n\r\n    // these need to be run each check, even if no merging happens\r\n    // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,\r\n    // such as remove ops that happened in GoJS when skipsDiagram = true, \r\n    // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)\r\n    // Angular differs are a lot of fun\r\n    var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);\r\n    var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);\r\n\r\n    var modelDiffs = this._mdaDiffer.diff(this.modelData);\r\n\r\n    if (!nodeDiffs && !linkDiffs && !modelDiffs) return;\r\n\r\n    if (this.skipsDiagramUpdate) return;\r\n\r\n    // don't need model change listener while performing known data updates\r\n    if (this.modelChangedListener !== null) this.diagram.model.removeChangedListener(this.modelChangedListener);\r\n\r\n    this.diagram.model.startTransaction('update data');\r\n    // update modelData first, in case bindings on nodes / links depend on model data\r\n    this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);\r\n    // merge node / link data\r\n    DiagramComponent.mergeChanges(this, nodeDiffs, \"n\");\r\n    DiagramComponent.mergeChanges(this, linkDiffs, \"l\");\r\n    this.diagram.model.commitTransaction('update data');\r\n\r\n    // reset the model change listener\r\n    if (this.modelChangedListener !== null) this.diagram.model.addChangedListener(this.modelChangedListener);\r\n\r\n  } // end ngDoCheck\r\n\r\n  public ngOnDestroy() {\r\n    this.diagram.div = null; // removes event listeners\r\n  }\r\n}\r\n","import { Component, ElementRef, EventEmitter, Input, KeyValueDiffer, KeyValueDiffers, NgZone, Output, ViewChild } from '@angular/core';\r\nimport * as go from 'gojs';\r\nimport { DiagramComponent } from './diagram.component';\r\n@Component({\r\n  selector: 'gojs-palette',\r\n  template: '<div #ngPalette [className]=divClassName></div>'\r\n})\r\nexport class PaletteComponent {\r\n\r\n  /**\r\n   * Palette initialization function. Returns a go.Palette.\r\n   * Do not initialize model data in this function.\r\n   */\r\n  @Input() public initPalette: () => go.Palette;\r\n\r\n  // Node data for palette\r\n  @Input() public nodeDataArray: Array<go.ObjectData>;\r\n\r\n  // Link data for palette. Optional\r\n  @Input() public linkDataArray: Array<go.ObjectData> = null;\r\n\r\n  // Model data for palette. Optional\r\n  @Input() public modelData: go.ObjectData = null;\r\n\r\n  // Palette div class name. Use this name to style your palette in CSS\r\n  @Input() public divClassName: string;\r\n\r\n  @Input() public skipsPaletteUpdate: boolean = false;\r\n\r\n  // model changed listener function for palette\r\n  public modelChangedListener: (e: go.ChangedEvent) => void | null = null;\r\n\r\n  // event emitter -- fires when palette model changes. Capture this emitted event in parent component\r\n  @Output() public modelChange: EventEmitter<go.IncrementalData> = new EventEmitter<go.IncrementalData>();\r\n\r\n  @ViewChild('ngPalette', { static: true }) public paletteDiv: ElementRef;\r\n\r\n  // The Palette itself\r\n  public palette: go.Palette | null = null;\r\n\r\n  // differs for array inputs (node / link data arrays)\r\n  private _ndaDiffer: KeyValueDiffer<string, any>;\r\n  private _ldaDiffer: KeyValueDiffer<string, any>;\r\n\r\n  private _mdaDiffer: KeyValueDiffer<string, any>;\r\n\r\n  constructor(private _kvdiffers: KeyValueDiffers, public zone: NgZone) {\r\n    // differs used to check if there have been changed to the array @Inputs\r\n    // without them, changes to the input arrays won't register in ngOnChanges,\r\n    // since the array reference itself may be the same\r\n    this._ndaDiffer = this._kvdiffers.find([]).create();\r\n    this._ldaDiffer = this._kvdiffers.find([]).create();\r\n\r\n    this._mdaDiffer = this._kvdiffers.find([]).create();\r\n\r\n  } // end constructor\r\n\r\n  /**\r\n   * Initialize Palette after view init\r\n   */\r\n  public ngAfterViewInit() {\r\n    if (!this.paletteDiv) return;\r\n\r\n    this.palette = this.initPalette();\r\n\r\n    // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone\r\n    // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance\r\n    // If some state-altering behavior must happen on a mousemove event inside the palette,\r\n    // you will have to using zone.run() to make sure that event triggers angular change detection\r\n    this.palette.addEventListener = (DOMElement: Element | Window | Document, name: string, listener: any, capture: boolean) => {\r\n      const superAddEventListener = go.Diagram.prototype.addEventListener;\r\n      if (name === 'mousemove') {\r\n        this.zone.runOutsideAngular(() => superAddEventListener.call(this, DOMElement, name, listener, capture));\r\n      } else {\r\n        this.zone.run(() => {\r\n          superAddEventListener.call(this, DOMElement, name, listener, capture);\r\n        });\r\n      }\r\n    };\r\n\r\n    // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,\r\n    // using the overridden addEventListener function above\r\n    const divRef = this.paletteDiv.nativeElement;\r\n    this.palette.div = divRef;\r\n\r\n    // initialize palette model\r\n    this.palette.delayInitialization(() => {\r\n      const model = this.palette.model;\r\n      model.commit((m: go.Model) => {\r\n        m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));\r\n        if (this.linkDataArray && m instanceof go.GraphLinksModel) {\r\n          m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));\r\n        }\r\n        if (this.modelData) {\r\n          m.assignAllDataProperties(m.modelData, this.modelData);\r\n        }\r\n        this.palette.layoutDiagram(true);\r\n      }, null);\r\n    });\r\n\r\n\r\n    // initializer listener\r\n    this.modelChangedListener = (e: go.ChangedEvent) => {\r\n      if (e.isTransactionFinished && this.palette && this.palette.model && !this.palette.model.isReadOnly) {\r\n        // this must be done within a NgZone.run block, so changes are detected in the parent component\r\n        this.zone.run(() => {\r\n          const dataChanges = e.model!.toIncrementalData(e);\r\n          this.modelChange.emit(dataChanges);\r\n        });\r\n      }\r\n    };\r\n    this.palette.addModelChangedListener(this.modelChangedListener);\r\n  } // end ngAfterViewInit\r\n\r\n  /**\r\n   * Always be checking if array Input data has changed (node and link data arrays)\r\n   */\r\n  public ngDoCheck() {\r\n\r\n    if (!this.palette) return;\r\n    if (!this.palette.model) return;\r\n\r\n    // these need to be run each check, even if no merging happens\r\n    // otherwise, they will detect all diffs that happened since last time skipsPaletteUpdate was false,\r\n    // such as remove ops that happened in GoJS when skipsPaletteUpdate = true, \r\n    // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)\r\n    // Angular differs are a lot of fun\r\n    var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);\r\n    var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);\r\n\r\n    var modelDiffs = this._mdaDiffer.diff(this.modelData);\r\n\r\n    if (!nodeDiffs && !linkDiffs && !modelDiffs) return;\r\n\r\n    if (this.skipsPaletteUpdate) return;\r\n\r\n    // don't need model change listener while performing known data updates\r\n    if (this.modelChangedListener !== null) this.palette.model.removeChangedListener(this.modelChangedListener);\r\n\r\n    this.palette.model.startTransaction('update data');\r\n    // update modelData first, in case bindings on nodes / links depend on model data\r\n    this.palette.model.assignAllDataProperties(this.palette.model.modelData, this.modelData);\r\n    DiagramComponent.mergeChanges(this, nodeDiffs, \"n\");\r\n    DiagramComponent.mergeChanges(this, linkDiffs, \"l\");\r\n    this.palette.model.commitTransaction('update data');\r\n    // reset the model change listener\r\n    if (this.modelChangedListener !== null) this.palette.model.addChangedListener(this.modelChangedListener);\r\n\r\n  } // end ngDoCheck\r\n\r\n  public ngOnDestroy() {\r\n    this.palette.div = null; // removes event listeners\r\n  }\r\n\r\n}\r\n","import { Component, ElementRef, Input, NgZone, SimpleChanges, ViewChild } from '@angular/core';\r\nimport * as go from 'gojs';\r\n\r\n@Component({\r\n  selector: 'gojs-overview',\r\n  template: '<div #ngOverview [className]=divClassName></div>'\r\n})\r\nexport class OverviewComponent {\r\n\r\n  // The function used to initialize the Overview\r\n  @Input() public initOverview: () => go.Overview;\r\n\r\n  // Overview div class name. Use this name to style your Overview in CSS\r\n  @Input() public divClassName: string;\r\n\r\n  // The Diagram to observe with the Overview\r\n  @Input() public observedDiagram: go.Diagram = null;\r\n\r\n  @ViewChild('ngOverview', { static: true }) public overviewDiv: ElementRef;\r\n\r\n  // The Overview itself\r\n  public overview: go.Overview | null = null;\r\n\r\n  constructor(public zone: NgZone) { }\r\n\r\n  /**\r\n   * Initialize the overview\r\n   */\r\n  public ngAfterViewInit() {\r\n    if (!this.overviewDiv) return;\r\n    if (this.initOverview) {\r\n      this.overview = this.initOverview();\r\n    } else {\r\n      this.overview = new go.Overview();\r\n      this.overview.contentAlignment = go.Spot.Center;\r\n    }\r\n\r\n    // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone\r\n    // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance\r\n    // If some state-altering behavior must happen on a mousemove event inside the overview,\r\n    // you will have to using zone.run() to make sure that event triggers angular change detection\r\n    this.overview.addEventListener = (DOMElement: Element | Window | Document, name: string, listener: any, capture: boolean) => {\r\n      const superAddEventListener = go.Diagram.prototype.addEventListener;\r\n      if (name === 'mousemove') {\r\n        this.zone.runOutsideAngular(() => superAddEventListener.call(this, DOMElement, name, listener, capture));\r\n      } else {\r\n        this.zone.run(() => {\r\n          superAddEventListener.call(this, DOMElement, name, listener, capture);\r\n        });\r\n      }\r\n    };\r\n\r\n    this.overview.div = this.overviewDiv.nativeElement;\r\n  }\r\n\r\n  /**\r\n   * Only update when the observed diagram changes\r\n   * @param changes\r\n   */\r\n  public ngOnChanges(changes: SimpleChanges) {\r\n    if (!this.overview) return;\r\n    if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {\r\n      this.overview.observed = changes.observedDiagram.currentValue;\r\n    }\r\n  }\r\n\r\n  public ngOnDestroy() {\r\n    this.overview.div = null; // removes event listeners\r\n  }\r\n\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { DiagramComponent } from './diagram.component';\r\nimport { OverviewComponent } from './overview.component';\r\nimport { PaletteComponent } from './palette.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    DiagramComponent,\r\n    OverviewComponent,\r\n    PaletteComponent\r\n  ],\r\n  imports: [\r\n  ],\r\n  exports: [\r\n    DiagramComponent,\r\n    OverviewComponent,\r\n    PaletteComponent\r\n  ]\r\n})\r\nexport class GojsAngularModule { }\r\n","import { Injectable } from '@angular/core';\r\nimport * as go from 'gojs';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class DataSyncService {\r\n\r\n  constructor() { }\r\n\r\n  /**\r\n   * Sync a node data array with a set of changes\r\n   * @param changes The set of changes to the GoJS model\r\n   * @param nodeData The node data array to merge these changes with\r\n   * @param model Required if you have defined your model.nodeKeyProperty to be something other than 'key'\r\n   * @returns A node data array, merged with the changes\r\n   */\r\n  public static syncNodeData(changes: go.IncrementalData, nodeData: Array<go.ObjectData>, model?: go.Model) {\r\n    if (!changes) return nodeData;\r\n    if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys) return nodeData;\r\n\r\n    // maintain a map of modified nodes for fast lookup during insertion\r\n    const modifiedNodesMap = new go.Map<go.Key, go.ObjectData>();\r\n\r\n    // account for modified node data\r\n    if (changes.modifiedNodeData) {\r\n      changes.modifiedNodeData.forEach((nd: go.ObjectData) => {\r\n        // Get the value of the node key property checking wether is a function or a string\r\n        const key = model ? model.getKeyForNodeData(nd) : nd['key'];\r\n        modifiedNodesMap.set(key, nd);\r\n        for (let i = 0; i < nodeData.length; i++) {\r\n          const ndEntry = nodeData[i];\r\n          const keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];\r\n          if (keyNdEntry === key) {\r\n            nodeData[i] = nd;\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // account for inserted node data\r\n    if (changes.insertedNodeKeys) {\r\n      changes.insertedNodeKeys.forEach((key: go.Key) => {\r\n        const nd = modifiedNodesMap.get(key);\r\n        if (nd) {\r\n          nodeData.push(nd);\r\n        }\r\n      });\r\n    }\r\n\r\n    // account for removed node data\r\n    if (changes.removedNodeKeys) {\r\n      nodeData = nodeData.filter((nd: go.ObjectData) => {\r\n        const key = model ? model.getKeyForNodeData(nd) : nd['key'];\r\n        if (changes.removedNodeKeys.includes(key)) {\r\n          return false;\r\n        } return true;\r\n      });\r\n    }\r\n\r\n    return nodeData;\r\n  }\r\n\r\n  /**\r\n   * Sync a link data array with a set of changes\r\n   * @param changes The set of changes to the GoJS model\r\n   * @param linkData The link data array to merge these changes with\r\n   * @param model Required if you have defined your model.linkKeyProperty to be something other than 'key'\r\n   * @returns A link data array, merged with the changes\r\n   */\r\n  public static syncLinkData(changes: go.IncrementalData, linkData: Array<go.ObjectData>, model?: go.GraphLinksModel) {\r\n    if (!changes) return linkData;\r\n    if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys) return linkData;\r\n\r\n    // maintain a map of modified nodes for fast lookup during insertion\r\n    const modifiedLinksMap = new go.Map<go.Key, go.ObjectData>();\r\n\r\n    // account for modified link data\r\n    if (changes.modifiedLinkData) {\r\n      changes.modifiedLinkData.forEach((ld: go.ObjectData) => {\r\n        // Get the value of the link key\r\n        const key = model ? model.getKeyForLinkData(ld) : ld['key'];\r\n        modifiedLinksMap.set(key, ld);\r\n\r\n        for (let i = 0; i < linkData.length; i++) {\r\n          const ldEntry = linkData[i];\r\n          const keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];\r\n          if (keyLdEntry === key) {\r\n            linkData[i] = ld;\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // account for inserted link data\r\n    if (changes.insertedLinkKeys) {\r\n      changes.insertedLinkKeys.forEach((key: go.Key) => {\r\n        const nd = modifiedLinksMap.get(key);\r\n        if (nd) {\r\n          linkData.push(nd);\r\n        }\r\n      });\r\n    }\r\n\r\n    // account for removed link data\r\n    if (changes.removedLinkKeys) {\r\n      linkData = linkData.filter((ld: go.ObjectData) => {\r\n        const key = model ? model.getKeyForLinkData(ld) : ld['key'];\r\n        if (changes.removedLinkKeys.includes(key)) {\r\n          return false;\r\n        } return true;\r\n      });\r\n    }\r\n\r\n    return linkData;\r\n  }\r\n\r\n  /**\r\n   * Sync modelData with a set of changes\r\n   * @param changes The set of changes to the GoJS model\r\n   * @param modelData The modelData to merge these changes with\r\n   * @returns A modelData object, merged with the changes\r\n   */\r\n  public static syncModelData(changes: go.IncrementalData, modelData: go.ObjectData) {\r\n    if (!changes) return modelData;\r\n    if (!changes.modelData) return modelData;\r\n    if (changes.modelData) {\r\n      return changes.modelData;\r\n    }\r\n  }\r\n\r\n\r\n}\r\n"]}