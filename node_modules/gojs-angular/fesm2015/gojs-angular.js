import { EventEmitter, Component, KeyValueDiffers, NgZone, Input, Output, ViewChild, NgModule, Injectable, ɵɵdefineInjectable } from '@angular/core';
import { Diagram, GraphLinksModel, Overview, Spot, Map } from 'gojs';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DiagramComponent {
    /**
     * @param {?} _kvdiffers
     * @param {?} zone
     */
    constructor(_kvdiffers, zone) {
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for diagram
        this.linkDataArray = null; // optional
        // optional
        // Model data for diagram
        this.modelData = null; // optional
        // model changed listener function for diagram
        this.modelChangedListener = null;
        this.skipsDiagramUpdate = false;
        // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        this.diagram = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._kvdiffers.find([]).create();
        this._ldaDiffer = this._kvdiffers.find([]).create();
        this._mdaDiffer = this._kvdiffers.find([]).create();
    }
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    ngAfterViewInit() {
        this.diagram = this.initDiagram();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the diagram,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the Diagram's model
        this.diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = this.diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));
                if (this.linkDataArray && m instanceof GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));
                }
                if (this.modelData) {
                    m.assignAllDataProperties(m.modelData, this.modelData);
                }
                this.diagram.layoutDiagram(true);
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished && this.diagram && this.diagram.model && !this.diagram.model.isReadOnly) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.diagram.addModelChangedListener(this.modelChangedListener);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * Merges changes from app data into GoJS model data,
     * making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged
     * @param {?} component an instance of DiagramComponent or PaletteComponent
     * @param {?} kvchanges The kvchanges object produced by either a node or link Angular differ object
     * @param {?} str "n" for node data changes, "l" for link data changes
     *
     * @return {?}
     */
    static mergeChanges(component, kvchanges, str) {
        // helper function
        /**
         * @param {?} obj1
         * @param {?} obj2
         * @return {?}
         */
        function compareObjs(obj1, obj2) {
            // Loop through properties in object 1
            for (const p in obj1) {
                // Check property exists on both objects
                if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p))
                    return false;
                switch (typeof (obj1[p])) {
                    // Deep compare objects
                    case 'object':
                        if (!compareObjs(obj1[p], obj2[p]))
                            return false;
                        break;
                    // Compare values
                    default:
                        if (obj1[p] !== obj2[p])
                            return false;
                }
            }
            // Check object 2 for any extra properties
            for (const p in obj2) {
                if (typeof (obj1[p]) === 'undefined')
                    return false;
            }
            return true;
        }
        /** @type {?} */
        var dia = component instanceof DiagramComponent ? component.diagram : component.palette;
        if (!dia || !dia.model)
            return;
        if (kvchanges) {
            // handle added nodes / links
            kvchanges.forEachAddedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                switch (str) {
                    case "n": {
                        dia.model.addNodeData(r.currentValue);
                        break;
                    }
                    case "l": {
                        /** @type {?} */
                        var m = (/** @type {?} */ (dia.model));
                        m.addLinkData(r.currentValue);
                        break;
                    }
                }
            }));
            // handle removed nodes / links
            kvchanges.forEachRemovedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                switch (str) {
                    case "n": {
                        /** @type {?} */
                        let m = dia.model;
                        /** @type {?} */
                        let keyPropName = m.nodeKeyProperty.toString();
                        /** @type {?} */
                        var node = dia.findNodeForKey(r.previousValue[keyPropName]);
                        if (node) {
                            dia.remove(node);
                        }
                        break;
                    }
                    case "l": {
                        /** @type {?} */
                        let m = (/** @type {?} */ (dia.model));
                        /** @type {?} */
                        var keyPropName = m.linkKeyProperty.toString();
                        /** @type {?} */
                        var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                        if (link) {
                            dia.remove(link);
                        }
                        break;
                    }
                }
            }));
            // handle changed data for nodes / links
            kvchanges.forEachChangedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                // ensure "changes" to array / object / enumerable data properties are legit
                /** @type {?} */
                const sameVals = compareObjs(r.currentValue, r.previousValue);
                // update proper data object for node or link
                if (!sameVals) {
                    switch (str) {
                        case "n": {
                            /** @type {?} */
                            let m = dia.model;
                            /** @type {?} */
                            let keyPropName = m.nodeKeyProperty.toString();
                            /** @type {?} */
                            var node = dia.findNodeForKey(r.previousValue[keyPropName]);
                            if (node) {
                                dia.model.assignAllDataProperties(node.data, r.currentValue);
                            }
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            let m = (/** @type {?} */ (dia.model));
                            /** @type {?} */
                            var keyPropName = m.linkKeyProperty.toString();
                            /** @type {?} */
                            var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                            if (link) {
                                dia.model.assignAllDataProperties(link.data, r.currentValue);
                            }
                            break;
                        }
                    }
                }
            }));
        }
    }
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    ngDoCheck() {
        if (!this.diagram)
            return;
        if (!this.diagram.model)
            return;
        // these need to be run each check, even if no merging happens
        // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,
        // such as remove ops that happened in GoJS when skipsDiagram = true, 
        // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
        // Angular differs are a lot of fun
        /** @type {?} */
        var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
        /** @type {?} */
        var modelDiffs = this._mdaDiffer.diff(this.modelData);
        if (!nodeDiffs && !linkDiffs && !modelDiffs)
            return;
        if (this.skipsDiagramUpdate)
            return;
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            this.diagram.model.removeChangedListener(this.modelChangedListener);
        this.diagram.model.startTransaction('update data');
        // update modelData first, in case bindings on nodes / links depend on model data
        this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);
        // merge node / link data
        DiagramComponent.mergeChanges(this, nodeDiffs, "n");
        DiagramComponent.mergeChanges(this, linkDiffs, "l");
        this.diagram.model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            this.diagram.model.addChangedListener(this.modelChangedListener);
    } // end ngDoCheck
    // end ngDoCheck
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.diagram.div = null; // removes event listeners
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-diagram',
                template: '<div #ngDiagram [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: NgZone }
];
DiagramComponent.propDecorators = {
    initDiagram: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    skipsDiagramUpdate: [{ type: Input }],
    modelChange: [{ type: Output }],
    diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
};
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /** @type {?} */
    DiagramComponent.prototype.nodeDataArray;
    /** @type {?} */
    DiagramComponent.prototype.linkDataArray;
    /** @type {?} */
    DiagramComponent.prototype.modelData;
    /** @type {?} */
    DiagramComponent.prototype.divClassName;
    /** @type {?} */
    DiagramComponent.prototype.modelChangedListener;
    /** @type {?} */
    DiagramComponent.prototype.skipsDiagramUpdate;
    /** @type {?} */
    DiagramComponent.prototype.modelChange;
    /** @type {?} */
    DiagramComponent.prototype.diagramDiv;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._mdaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._kvdiffers;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/palette.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaletteComponent {
    /**
     * @param {?} _kvdiffers
     * @param {?} zone
     */
    constructor(_kvdiffers, zone) {
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for palette. Optional
        this.linkDataArray = null;
        // Model data for palette. Optional
        this.modelData = null;
        this.skipsPaletteUpdate = false;
        // model changed listener function for palette
        this.modelChangedListener = null;
        // event emitter -- fires when palette model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        // The Palette itself
        this.palette = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._kvdiffers.find([]).create();
        this._ldaDiffer = this._kvdiffers.find([]).create();
        this._mdaDiffer = this._kvdiffers.find([]).create();
    } // end constructor
    // end constructor
    /**
     * Initialize Palette after view init
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.paletteDiv)
            return;
        this.palette = this.initPalette();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the palette,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.palette.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.paletteDiv.nativeElement;
        this.palette.div = divRef;
        // initialize palette model
        this.palette.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = this.palette.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));
                if (this.linkDataArray && m instanceof GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));
                }
                if (this.modelData) {
                    m.assignAllDataProperties(m.modelData, this.modelData);
                }
                this.palette.layoutDiagram(true);
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished && this.palette && this.palette.model && !this.palette.model.isReadOnly) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.palette.addModelChangedListener(this.modelChangedListener);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    ngDoCheck() {
        if (!this.palette)
            return;
        if (!this.palette.model)
            return;
        // these need to be run each check, even if no merging happens
        // otherwise, they will detect all diffs that happened since last time skipsPaletteUpdate was false,
        // such as remove ops that happened in GoJS when skipsPaletteUpdate = true, 
        // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
        // Angular differs are a lot of fun
        /** @type {?} */
        var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
        /** @type {?} */
        var modelDiffs = this._mdaDiffer.diff(this.modelData);
        if (!nodeDiffs && !linkDiffs && !modelDiffs)
            return;
        if (this.skipsPaletteUpdate)
            return;
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            this.palette.model.removeChangedListener(this.modelChangedListener);
        this.palette.model.startTransaction('update data');
        // update modelData first, in case bindings on nodes / links depend on model data
        this.palette.model.assignAllDataProperties(this.palette.model.modelData, this.modelData);
        DiagramComponent.mergeChanges(this, nodeDiffs, "n");
        DiagramComponent.mergeChanges(this, linkDiffs, "l");
        this.palette.model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            this.palette.model.addChangedListener(this.modelChangedListener);
    } // end ngDoCheck
    // end ngDoCheck
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.palette.div = null; // removes event listeners
    }
}
PaletteComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-palette',
                template: '<div #ngPalette [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
PaletteComponent.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: NgZone }
];
PaletteComponent.propDecorators = {
    initPalette: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    skipsPaletteUpdate: [{ type: Input }],
    modelChange: [{ type: Output }],
    paletteDiv: [{ type: ViewChild, args: ['ngPalette', { static: true },] }]
};
if (false) {
    /**
     * Palette initialization function. Returns a go.Palette.
     * Do not initialize model data in this function.
     * @type {?}
     */
    PaletteComponent.prototype.initPalette;
    /** @type {?} */
    PaletteComponent.prototype.nodeDataArray;
    /** @type {?} */
    PaletteComponent.prototype.linkDataArray;
    /** @type {?} */
    PaletteComponent.prototype.modelData;
    /** @type {?} */
    PaletteComponent.prototype.divClassName;
    /** @type {?} */
    PaletteComponent.prototype.skipsPaletteUpdate;
    /** @type {?} */
    PaletteComponent.prototype.modelChangedListener;
    /** @type {?} */
    PaletteComponent.prototype.modelChange;
    /** @type {?} */
    PaletteComponent.prototype.paletteDiv;
    /** @type {?} */
    PaletteComponent.prototype.palette;
    /**
     * @type {?}
     * @private
     */
    PaletteComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    PaletteComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    PaletteComponent.prototype._mdaDiffer;
    /**
     * @type {?}
     * @private
     */
    PaletteComponent.prototype._kvdiffers;
    /** @type {?} */
    PaletteComponent.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/overview.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OverviewComponent {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        // The Diagram to observe with the Overview
        this.observedDiagram = null;
        // The Overview itself
        this.overview = null;
    }
    /**
     * Initialize the overview
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.overviewDiv)
            return;
        if (this.initOverview) {
            this.overview = this.initOverview();
        }
        else {
            this.overview = new Overview();
            this.overview.contentAlignment = Spot.Center;
        }
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the overview,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.overview.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        this.overview.div = this.overviewDiv.nativeElement;
    }
    /**
     * Only update when the observed diagram changes
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.overview)
            return;
        if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {
            this.overview.observed = changes.observedDiagram.currentValue;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.overview.div = null; // removes event listeners
    }
}
OverviewComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-overview',
                template: '<div #ngOverview [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
OverviewComponent.ctorParameters = () => [
    { type: NgZone }
];
OverviewComponent.propDecorators = {
    initOverview: [{ type: Input }],
    divClassName: [{ type: Input }],
    observedDiagram: [{ type: Input }],
    overviewDiv: [{ type: ViewChild, args: ['ngOverview', { static: true },] }]
};
if (false) {
    /** @type {?} */
    OverviewComponent.prototype.initOverview;
    /** @type {?} */
    OverviewComponent.prototype.divClassName;
    /** @type {?} */
    OverviewComponent.prototype.observedDiagram;
    /** @type {?} */
    OverviewComponent.prototype.overviewDiv;
    /** @type {?} */
    OverviewComponent.prototype.overview;
    /** @type {?} */
    OverviewComponent.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/gojs-angular.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GojsAngularModule {
}
GojsAngularModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DiagramComponent,
                    OverviewComponent,
                    PaletteComponent
                ],
                imports: [],
                exports: [
                    DiagramComponent,
                    OverviewComponent,
                    PaletteComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/data-sync.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataSyncService {
    constructor() { }
    /**
     * Sync a node data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} nodeData The node data array to merge these changes with
     * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @return {?} A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedNodesMap = new Map();
        // account for modified node data
        if (changes.modifiedNodeData) {
            changes.modifiedNodeData.forEach((/**
             * @param {?} nd
             * @return {?}
             */
            (nd) => {
                // Get the value of the node key property checking wether is a function or a string
                /** @type {?} */
                const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                modifiedNodesMap.set(key, nd);
                for (let i = 0; i < nodeData.length; i++) {
                    /** @type {?} */
                    const ndEntry = nodeData[i];
                    /** @type {?} */
                    const keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                    if (keyNdEntry === key) {
                        nodeData[i] = nd;
                    }
                }
            }));
        }
        // account for inserted node data
        if (changes.insertedNodeKeys) {
            changes.insertedNodeKeys.forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const nd = modifiedNodesMap.get(key);
                if (nd) {
                    nodeData.push(nd);
                }
            }));
        }
        // account for removed node data
        if (changes.removedNodeKeys) {
            nodeData = nodeData.filter((/**
             * @param {?} nd
             * @return {?}
             */
            (nd) => {
                /** @type {?} */
                const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                if (changes.removedNodeKeys.includes(key)) {
                    return false;
                }
                return true;
            }));
        }
        return nodeData;
    }
    /**
     * Sync a link data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} linkData The link data array to merge these changes with
     * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @return {?} A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedLinksMap = new Map();
        // account for modified link data
        if (changes.modifiedLinkData) {
            changes.modifiedLinkData.forEach((/**
             * @param {?} ld
             * @return {?}
             */
            (ld) => {
                // Get the value of the link key
                /** @type {?} */
                const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                modifiedLinksMap.set(key, ld);
                for (let i = 0; i < linkData.length; i++) {
                    /** @type {?} */
                    const ldEntry = linkData[i];
                    /** @type {?} */
                    const keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                    if (keyLdEntry === key) {
                        linkData[i] = ld;
                    }
                }
            }));
        }
        // account for inserted link data
        if (changes.insertedLinkKeys) {
            changes.insertedLinkKeys.forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const nd = modifiedLinksMap.get(key);
                if (nd) {
                    linkData.push(nd);
                }
            }));
        }
        // account for removed link data
        if (changes.removedLinkKeys) {
            linkData = linkData.filter((/**
             * @param {?} ld
             * @return {?}
             */
            (ld) => {
                /** @type {?} */
                const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                if (changes.removedLinkKeys.includes(key)) {
                    return false;
                }
                return true;
            }));
        }
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} modelData The modelData to merge these changes with
     * @return {?} A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
    }
}
DataSyncService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DataSyncService.ctorParameters = () => [];
/** @nocollapse */ DataSyncService.ɵprov = ɵɵdefineInjectable({ factory: function DataSyncService_Factory() { return new DataSyncService(); }, token: DataSyncService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: gojs-angular.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DataSyncService, DiagramComponent, GojsAngularModule, OverviewComponent, PaletteComponent };
//# sourceMappingURL=gojs-angular.js.map
