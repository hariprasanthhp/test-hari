/**
 * @fileoverview added by tsickle
 * Generated from: lib/data-sync.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as go from 'gojs';
import * as i0 from "@angular/core";
export class DataSyncService {
    constructor() { }
    /**
     * Sync a node data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} nodeData The node data array to merge these changes with
     * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @return {?} A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedNodesMap = new go.Map();
        // account for modified node data
        if (changes.modifiedNodeData) {
            changes.modifiedNodeData.forEach((/**
             * @param {?} nd
             * @return {?}
             */
            (nd) => {
                // Get the value of the node key property checking wether is a function or a string
                /** @type {?} */
                const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                modifiedNodesMap.set(key, nd);
                for (let i = 0; i < nodeData.length; i++) {
                    /** @type {?} */
                    const ndEntry = nodeData[i];
                    /** @type {?} */
                    const keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                    if (keyNdEntry === key) {
                        nodeData[i] = nd;
                    }
                }
            }));
        }
        // account for inserted node data
        if (changes.insertedNodeKeys) {
            changes.insertedNodeKeys.forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const nd = modifiedNodesMap.get(key);
                if (nd) {
                    nodeData.push(nd);
                }
            }));
        }
        // account for removed node data
        if (changes.removedNodeKeys) {
            nodeData = nodeData.filter((/**
             * @param {?} nd
             * @return {?}
             */
            (nd) => {
                /** @type {?} */
                const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                if (changes.removedNodeKeys.includes(key)) {
                    return false;
                }
                return true;
            }));
        }
        return nodeData;
    }
    /**
     * Sync a link data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} linkData The link data array to merge these changes with
     * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @return {?} A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedLinksMap = new go.Map();
        // account for modified link data
        if (changes.modifiedLinkData) {
            changes.modifiedLinkData.forEach((/**
             * @param {?} ld
             * @return {?}
             */
            (ld) => {
                // Get the value of the link key
                /** @type {?} */
                const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                modifiedLinksMap.set(key, ld);
                for (let i = 0; i < linkData.length; i++) {
                    /** @type {?} */
                    const ldEntry = linkData[i];
                    /** @type {?} */
                    const keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                    if (keyLdEntry === key) {
                        linkData[i] = ld;
                    }
                }
            }));
        }
        // account for inserted link data
        if (changes.insertedLinkKeys) {
            changes.insertedLinkKeys.forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const nd = modifiedLinksMap.get(key);
                if (nd) {
                    linkData.push(nd);
                }
            }));
        }
        // account for removed link data
        if (changes.removedLinkKeys) {
            linkData = linkData.filter((/**
             * @param {?} ld
             * @return {?}
             */
            (ld) => {
                /** @type {?} */
                const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                if (changes.removedLinkKeys.includes(key)) {
                    return false;
                }
                return true;
            }));
        }
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} modelData The modelData to merge these changes with
     * @return {?} A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
    }
}
DataSyncService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DataSyncService.ctorParameters = () => [];
/** @nocollapse */ DataSyncService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DataSyncService_Factory() { return new DataSyncService(); }, token: DataSyncService, providedIn: "root" });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zeW5jLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9nb2pzLWFuZ3VsYXIvc3JjL2xpYi9kYXRhLXN5bmMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBSzNCLE1BQU0sT0FBTyxlQUFlO0lBRTFCLGdCQUFnQixDQUFDOzs7Ozs7OztJQVNWLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBMkIsRUFBRSxRQUE4QixFQUFFLEtBQWdCO1FBQ3RHLElBQUksQ0FBQyxPQUFPO1lBQUUsT0FBTyxRQUFRLENBQUM7UUFDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlO1lBQUUsT0FBTyxRQUFRLENBQUM7OztjQUdsRyxnQkFBZ0IsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQXlCO1FBRTVELGlDQUFpQztRQUNqQyxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRTtZQUM1QixPQUFPLENBQUMsZ0JBQWdCLENBQUMsT0FBTzs7OztZQUFDLENBQUMsRUFBaUIsRUFBRSxFQUFFOzs7c0JBRS9DLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztnQkFDM0QsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDOUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7OzBCQUNsQyxPQUFPLEdBQUcs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QyxDQUFDLEdBQVcsRUFBRSxFQUFFOztzQkFDekMsRUFBRSxHQUFHLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7Z0JBQ3BDLElBQUksRUFBRSxFQUFFO29CQUNOLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQ25CO1lBQ0gsQ0FBQyxFQUFDLENBQUM7U0FDSjtRQUVELGdDQUFnQztRQUNoQyxJQUFJLE9BQU8sQ0FBQyxlQUFlLEVBQUU7WUFDM0IsUUFBUSxHQUFHLFFBQVEsQ0FBQyxNQUFNOzs7O1lBQUMsQ0FBQyxFQUFpQixFQUFFLEVBQUU7O3NCQUN6QyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUM7Z0JBQzNELElBQUksT0FBTyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ3pDLE9BQU8sS0FBSyxDQUFDO2lCQUNkO2dCQUFDLE9BQU8sSUFBSSxDQUFDO1lBQ2hCLENBQUMsRUFBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDOzs7Ozs7O0lBUU0sTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUEyQixFQUFFLFNBQXdCO1FBQy9FLElBQUksQ0FBQyxPQUFPO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDekMsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3JCLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQztTQUMxQjtJQUNILENBQUM7OztZQTlIRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGdvIGZyb20gJ2dvanMnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF0YVN5bmNTZXJ2aWNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3luYyBhIG5vZGUgZGF0YSBhcnJheSB3aXRoIGEgc2V0IG9mIGNoYW5nZXNcclxuICAgKiBAcGFyYW0gY2hhbmdlcyBUaGUgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIEdvSlMgbW9kZWxcclxuICAgKiBAcGFyYW0gbm9kZURhdGEgVGhlIG5vZGUgZGF0YSBhcnJheSB0byBtZXJnZSB0aGVzZSBjaGFuZ2VzIHdpdGhcclxuICAgKiBAcGFyYW0gbW9kZWwgUmVxdWlyZWQgaWYgeW91IGhhdmUgZGVmaW5lZCB5b3VyIG1vZGVsLm5vZGVLZXlQcm9wZXJ0eSB0byBiZSBzb21ldGhpbmcgb3RoZXIgdGhhbiAna2V5J1xyXG4gICAqIEByZXR1cm5zIEEgbm9kZSBkYXRhIGFycmF5LCBtZXJnZWQgd2l0aCB0aGUgY2hhbmdlc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgc3luY05vZGVEYXRhKGNoYW5nZXM6IGdvLkluY3JlbWVudGFsRGF0YSwgbm9kZURhdGE6IEFycmF5PGdvLk9iamVjdERhdGE+LCBtb2RlbD86IGdvLk1vZGVsKSB7XHJcbiAgICBpZiAoIWNoYW5nZXMpIHJldHVybiBub2RlRGF0YTtcclxuICAgIGlmICghY2hhbmdlcy5tb2RpZmllZE5vZGVEYXRhICYmICFjaGFuZ2VzLmluc2VydGVkTm9kZUtleXMgJiYgIWNoYW5nZXMucmVtb3ZlZE5vZGVLZXlzKSByZXR1cm4gbm9kZURhdGE7XHJcblxyXG4gICAgLy8gbWFpbnRhaW4gYSBtYXAgb2YgbW9kaWZpZWQgbm9kZXMgZm9yIGZhc3QgbG9va3VwIGR1cmluZyBpbnNlcnRpb25cclxuICAgIGNvbnN0IG1vZGlmaWVkTm9kZXNNYXAgPSBuZXcgZ28uTWFwPGdvLktleSwgZ28uT2JqZWN0RGF0YT4oKTtcclxuXHJcbiAgICAvLyBhY2NvdW50IGZvciBtb2RpZmllZCBub2RlIGRhdGFcclxuICAgIGlmIChjaGFuZ2VzLm1vZGlmaWVkTm9kZURhdGEpIHtcclxuICAgICAgY2hhbmdlcy5tb2RpZmllZE5vZGVEYXRhLmZvckVhY2goKG5kOiBnby5PYmplY3REYXRhKSA9PiB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBrZXkgcHJvcGVydHkgY2hlY2tpbmcgd2V0aGVyIGlzIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcclxuICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvck5vZGVEYXRhKG5kKSA6IG5kWydrZXknXTtcclxuICAgICAgICBtb2RpZmllZE5vZGVzTWFwLnNldChrZXksIG5kKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBuZEVudHJ5ID0gbm9kZURhdGFbaV07XHJcbiAgICAgICAgICBjb25zdCBrZXlOZEVudHJ5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JOb2RlRGF0YShuZEVudHJ5KSA6IG5kRW50cnlbJ2tleSddO1xyXG4gICAgICAgICAgaWYgKGtleU5kRW50cnkgPT09IGtleSkge1xyXG4gICAgICAgICAgICBub2RlRGF0YVtpXSA9IG5kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbm9kZSBkYXRhXHJcbiAgICBpZiAoY2hhbmdlcy5pbnNlcnRlZE5vZGVLZXlzKSB7XHJcbiAgICAgIGNoYW5nZXMuaW5zZXJ0ZWROb2RlS2V5cy5mb3JFYWNoKChrZXk6IGdvLktleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWROb2Rlc01hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobmQpIHtcclxuICAgICAgICAgIG5vZGVEYXRhLnB1c2gobmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBub2RlIGRhdGFcclxuICAgIGlmIChjaGFuZ2VzLnJlbW92ZWROb2RlS2V5cykge1xyXG4gICAgICBub2RlRGF0YSA9IG5vZGVEYXRhLmZpbHRlcigobmQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvck5vZGVEYXRhKG5kKSA6IG5kWydrZXknXTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5yZW1vdmVkTm9kZUtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgYSBsaW5rIGRhdGEgYXJyYXkgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIGxpbmtEYXRhIFRoZSBsaW5rIGRhdGEgYXJyYXkgdG8gbWVyZ2UgdGhlc2UgY2hhbmdlcyB3aXRoXHJcbiAgICogQHBhcmFtIG1vZGVsIFJlcXVpcmVkIGlmIHlvdSBoYXZlIGRlZmluZWQgeW91ciBtb2RlbC5saW5rS2V5UHJvcGVydHkgdG8gYmUgc29tZXRoaW5nIG90aGVyIHRoYW4gJ2tleSdcclxuICAgKiBAcmV0dXJucyBBIGxpbmsgZGF0YSBhcnJheSwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNMaW5rRGF0YShjaGFuZ2VzOiBnby5JbmNyZW1lbnRhbERhdGEsIGxpbmtEYXRhOiBBcnJheTxnby5PYmplY3REYXRhPiwgbW9kZWw/OiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIGxpbmtEYXRhO1xyXG4gICAgaWYgKCFjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEgJiYgIWNoYW5nZXMuaW5zZXJ0ZWRMaW5rS2V5cyAmJiAhY2hhbmdlcy5yZW1vdmVkTGlua0tleXMpIHJldHVybiBsaW5rRGF0YTtcclxuXHJcbiAgICAvLyBtYWludGFpbiBhIG1hcCBvZiBtb2RpZmllZCBub2RlcyBmb3IgZmFzdCBsb29rdXAgZHVyaW5nIGluc2VydGlvblxyXG4gICAgY29uc3QgbW9kaWZpZWRMaW5rc01hcCA9IG5ldyBnby5NYXA8Z28uS2V5LCBnby5PYmplY3REYXRhPigpO1xyXG5cclxuICAgIC8vIGFjY291bnQgZm9yIG1vZGlmaWVkIGxpbmsgZGF0YVxyXG4gICAgaWYgKGNoYW5nZXMubW9kaWZpZWRMaW5rRGF0YSkge1xyXG4gICAgICBjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEuZm9yRWFjaCgobGQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBsaW5rIGtleVxyXG4gICAgICAgIGNvbnN0IGtleSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTGlua0RhdGEobGQpIDogbGRbJ2tleSddO1xyXG4gICAgICAgIG1vZGlmaWVkTGlua3NNYXAuc2V0KGtleSwgbGQpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBsZEVudHJ5ID0gbGlua0RhdGFbaV07XHJcbiAgICAgICAgICBjb25zdCBrZXlMZEVudHJ5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JMaW5rRGF0YShsZEVudHJ5KSA6IGxkRW50cnlbJ2tleSddO1xyXG4gICAgICAgICAgaWYgKGtleUxkRW50cnkgPT09IGtleSkge1xyXG4gICAgICAgICAgICBsaW5rRGF0YVtpXSA9IGxkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbGluayBkYXRhXHJcbiAgICBpZiAoY2hhbmdlcy5pbnNlcnRlZExpbmtLZXlzKSB7XHJcbiAgICAgIGNoYW5nZXMuaW5zZXJ0ZWRMaW5rS2V5cy5mb3JFYWNoKChrZXk6IGdvLktleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWRMaW5rc01hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobmQpIHtcclxuICAgICAgICAgIGxpbmtEYXRhLnB1c2gobmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBsaW5rIGRhdGFcclxuICAgIGlmIChjaGFuZ2VzLnJlbW92ZWRMaW5rS2V5cykge1xyXG4gICAgICBsaW5rRGF0YSA9IGxpbmtEYXRhLmZpbHRlcigobGQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvckxpbmtEYXRhKGxkKSA6IGxkWydrZXknXTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5yZW1vdmVkTGlua0tleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaW5rRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgbW9kZWxEYXRhIHdpdGggYSBzZXQgb2YgY2hhbmdlc1xyXG4gICAqIEBwYXJhbSBjaGFuZ2VzIFRoZSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgR29KUyBtb2RlbFxyXG4gICAqIEBwYXJhbSBtb2RlbERhdGEgVGhlIG1vZGVsRGF0YSB0byBtZXJnZSB0aGVzZSBjaGFuZ2VzIHdpdGhcclxuICAgKiBAcmV0dXJucyBBIG1vZGVsRGF0YSBvYmplY3QsIG1lcmdlZCB3aXRoIHRoZSBjaGFuZ2VzXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBzeW5jTW9kZWxEYXRhKGNoYW5nZXM6IGdvLkluY3JlbWVudGFsRGF0YSwgbW9kZWxEYXRhOiBnby5PYmplY3REYXRhKSB7XHJcbiAgICBpZiAoIWNoYW5nZXMpIHJldHVybiBtb2RlbERhdGE7XHJcbiAgICBpZiAoIWNoYW5nZXMubW9kZWxEYXRhKSByZXR1cm4gbW9kZWxEYXRhO1xyXG4gICAgaWYgKGNoYW5nZXMubW9kZWxEYXRhKSB7XHJcbiAgICAgIHJldHVybiBjaGFuZ2VzLm1vZGVsRGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxufVxyXG4iXX0=