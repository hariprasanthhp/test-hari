/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, KeyValueDiffers, NgZone, Output, ViewChild } from '@angular/core';
import * as go from 'gojs';
export class DiagramComponent {
    /**
     * @param {?} _kvdiffers
     * @param {?} zone
     */
    constructor(_kvdiffers, zone) {
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for diagram
        this.linkDataArray = null; // optional
        // optional
        // Model data for diagram
        this.modelData = null; // optional
        // model changed listener function for diagram
        this.modelChangedListener = null;
        this.skipsDiagramUpdate = false;
        // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        this.diagram = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._kvdiffers.find([]).create();
        this._ldaDiffer = this._kvdiffers.find([]).create();
        this._mdaDiffer = this._kvdiffers.find([]).create();
    }
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    ngAfterViewInit() {
        this.diagram = this.initDiagram();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the diagram,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the Diagram's model
        this.diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = this.diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));
                if (this.linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));
                }
                if (this.modelData) {
                    m.assignAllDataProperties(m.modelData, this.modelData);
                }
                this.diagram.layoutDiagram(true);
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished && this.diagram && this.diagram.model && !this.diagram.model.isReadOnly) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.diagram.addModelChangedListener(this.modelChangedListener);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * Merges changes from app data into GoJS model data,
     * making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged
     * @param {?} component an instance of DiagramComponent or PaletteComponent
     * @param {?} kvchanges The kvchanges object produced by either a node or link Angular differ object
     * @param {?} str "n" for node data changes, "l" for link data changes
     *
     * @return {?}
     */
    static mergeChanges(component, kvchanges, str) {
        // helper function
        /**
         * @param {?} obj1
         * @param {?} obj2
         * @return {?}
         */
        function compareObjs(obj1, obj2) {
            // Loop through properties in object 1
            for (const p in obj1) {
                // Check property exists on both objects
                if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p))
                    return false;
                switch (typeof (obj1[p])) {
                    // Deep compare objects
                    case 'object':
                        if (!compareObjs(obj1[p], obj2[p]))
                            return false;
                        break;
                    // Compare values
                    default:
                        if (obj1[p] !== obj2[p])
                            return false;
                }
            }
            // Check object 2 for any extra properties
            for (const p in obj2) {
                if (typeof (obj1[p]) === 'undefined')
                    return false;
            }
            return true;
        }
        /** @type {?} */
        var dia = component instanceof DiagramComponent ? component.diagram : component.palette;
        if (!dia || !dia.model)
            return;
        if (kvchanges) {
            // handle added nodes / links
            kvchanges.forEachAddedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                switch (str) {
                    case "n": {
                        dia.model.addNodeData(r.currentValue);
                        break;
                    }
                    case "l": {
                        /** @type {?} */
                        var m = (/** @type {?} */ (dia.model));
                        m.addLinkData(r.currentValue);
                        break;
                    }
                }
            }));
            // handle removed nodes / links
            kvchanges.forEachRemovedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                switch (str) {
                    case "n": {
                        /** @type {?} */
                        let m = dia.model;
                        /** @type {?} */
                        let keyPropName = m.nodeKeyProperty.toString();
                        /** @type {?} */
                        var node = dia.findNodeForKey(r.previousValue[keyPropName]);
                        if (node) {
                            dia.remove(node);
                        }
                        break;
                    }
                    case "l": {
                        /** @type {?} */
                        let m = (/** @type {?} */ (dia.model));
                        /** @type {?} */
                        var keyPropName = m.linkKeyProperty.toString();
                        /** @type {?} */
                        var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                        if (link) {
                            dia.remove(link);
                        }
                        break;
                    }
                }
            }));
            // handle changed data for nodes / links
            kvchanges.forEachChangedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                // ensure "changes" to array / object / enumerable data properties are legit
                /** @type {?} */
                const sameVals = compareObjs(r.currentValue, r.previousValue);
                // update proper data object for node or link
                if (!sameVals) {
                    switch (str) {
                        case "n": {
                            /** @type {?} */
                            let m = dia.model;
                            /** @type {?} */
                            let keyPropName = m.nodeKeyProperty.toString();
                            /** @type {?} */
                            var node = dia.findNodeForKey(r.previousValue[keyPropName]);
                            if (node) {
                                dia.model.assignAllDataProperties(node.data, r.currentValue);
                            }
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            let m = (/** @type {?} */ (dia.model));
                            /** @type {?} */
                            var keyPropName = m.linkKeyProperty.toString();
                            /** @type {?} */
                            var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                            if (link) {
                                dia.model.assignAllDataProperties(link.data, r.currentValue);
                            }
                            break;
                        }
                    }
                }
            }));
        }
    }
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    ngDoCheck() {
        if (!this.diagram)
            return;
        if (!this.diagram.model)
            return;
        // these need to be run each check, even if no merging happens
        // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,
        // such as remove ops that happened in GoJS when skipsDiagram = true, 
        // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
        // Angular differs are a lot of fun
        /** @type {?} */
        var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
        /** @type {?} */
        var modelDiffs = this._mdaDiffer.diff(this.modelData);
        if (!nodeDiffs && !linkDiffs && !modelDiffs)
            return;
        if (this.skipsDiagramUpdate)
            return;
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            this.diagram.model.removeChangedListener(this.modelChangedListener);
        this.diagram.model.startTransaction('update data');
        // update modelData first, in case bindings on nodes / links depend on model data
        this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);
        // merge node / link data
        DiagramComponent.mergeChanges(this, nodeDiffs, "n");
        DiagramComponent.mergeChanges(this, linkDiffs, "l");
        this.diagram.model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            this.diagram.model.addChangedListener(this.modelChangedListener);
    } // end ngDoCheck
    // end ngDoCheck
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.diagram.div = null; // removes event listeners
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-diagram',
                template: '<div #ngDiagram [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: NgZone }
];
DiagramComponent.propDecorators = {
    initDiagram: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    skipsDiagramUpdate: [{ type: Input }],
    modelChange: [{ type: Output }],
    diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
};
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /** @type {?} */
    DiagramComponent.prototype.nodeDataArray;
    /** @type {?} */
    DiagramComponent.prototype.linkDataArray;
    /** @type {?} */
    DiagramComponent.prototype.modelData;
    /** @type {?} */
    DiagramComponent.prototype.divClassName;
    /** @type {?} */
    DiagramComponent.prototype.modelChangedListener;
    /** @type {?} */
    DiagramComponent.prototype.skipsDiagramUpdate;
    /** @type {?} */
    DiagramComponent.prototype.modelChange;
    /** @type {?} */
    DiagramComponent.prototype.diagramDiv;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._mdaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._kvdiffers;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9nb2pzLWFuZ3VsYXIvc3JjL2xpYi9kaWFncmFtLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWtCLGVBQWUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBd0IsTUFBTSxlQUFlLENBQUM7QUFDN0osT0FBTyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFNM0IsTUFBTSxPQUFPLGdCQUFnQjs7Ozs7SUFxQzNCLFlBQW9CLFVBQTJCLEVBQVMsSUFBWTtRQUFoRCxlQUFVLEdBQVYsVUFBVSxDQUFpQjtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7O1FBekJwRCxrQkFBYSxHQUF5QixJQUFJLENBQUMsQ0FBQyxXQUFXOzs7UUFHdkQsY0FBUyxHQUFrQixJQUFJLENBQUMsQ0FBQyxXQUFXOztRQU1yRCx5QkFBb0IsR0FBd0MsSUFBSSxDQUFDO1FBRXhELHVCQUFrQixHQUFZLEtBQUssQ0FBQzs7UUFHbkMsZ0JBQVcsR0FBcUMsSUFBSSxZQUFZLEVBQXNCLENBQUM7UUFHakcsWUFBTyxHQUFlLElBQUksQ0FBQztRQVNoQyx3RUFBd0U7UUFDeEUsMkVBQTJFO1FBQzNFLG1EQUFtRDtRQUNuRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFcEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMs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OlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBLZXlWYWx1ZURpZmZlciwgS2V5VmFsdWVEaWZmZXJzLCBOZ1pvbmUsIE91dHB1dCwgVmlld0NoaWxkLCBLZXlWYWx1ZUNoYW5nZVJlY29yZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBnbyBmcm9tICdnb2pzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZ29qcy1kaWFncmFtJyxcclxuICB0ZW1wbGF0ZTogJzxkaXYgI25nRGlhZ3JhbSBbY2xhc3NOYW1lXT1kaXZDbGFzc05hbWU+PC9kaXY+J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgRGlhZ3JhbUNvbXBvbmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpYWdyYW0gaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIFJldHVybnMgYSBnby5EaWFncmFtLlxyXG4gICAqIERvIG5vdCBpbml0aWFsaXplIG1vZGVsIGRhdGEgaW4gdGhpcyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBASW5wdXQoKSBwdWJsaWMgaW5pdERpYWdyYW06ICgpID0+IGdvLkRpYWdyYW07XHJcblxyXG4gIC8vIE5vZGUgZGF0YSBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBub2RlRGF0YUFycmF5OiBBcnJheTxnby5PYmplY3REYXRhPjtcclxuXHJcbiAgLy8gTGluayBkYXRhIGZvciBkaWFncmFtXHJcbiAgQElucHV0KCkgcHVibGljIGxpbmtEYXRhQXJyYXk6IEFycmF5PGdvLk9iamVjdERhdGE+ID0gbnVsbDsgLy8gb3B0aW9uYWxcclxuXHJcbiAgLy8gTW9kZWwgZGF0YSBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBtb2RlbERhdGE6IGdvLk9iamVjdERhdGEgPSBudWxsOyAvLyBvcHRpb25hbFxyXG5cclxuICAvLyBEaWFncmFtIGRpdiBjbGFzcyBuYW1lLiBVc2UgdGhpcyBuYW1lIHRvIHN0eWxlIHlvdXIgZGlhZ3JhbSBpbiBDU1NcclxuICBASW5wdXQoKSBwdWJsaWMgZGl2Q2xhc3NOYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8vIG1vZGVsIGNoYW5nZWQgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIGRpYWdyYW1cclxuICBwdWJsaWMgbW9kZWxDaGFuZ2VkTGlzdGVuZXI6IChlOiBnby5DaGFuZ2VkRXZlbnQpID0+IHZvaWQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgQElucHV0KCkgcHVibGljIHNraXBzRGlhZ3JhbVVwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAvLyBldmVudCBlbWl0dGVyIC0tIGZpcmVzIHdoZW4gZGlhZ3JhbSBtb2RlbCBjaGFuZ2VzLiBDYXB0dXJlIHRoaXMgZW1pdHRlZCBldmVudCBpbiBwYXJlbnQgY29tcG9uZW50XHJcbiAgQE91dHB1dCgpIHB1YmxpYyBtb2RlbENoYW5nZTogRXZlbnRFbWl0dGVyPGdvLkluY3JlbWVudGFsRGF0YT4gPSBuZXcgRXZlbnRFbWl0dGVyPGdvLkluY3JlbWVudGFsRGF0YT4oKTtcclxuXHJcbiAgQFZpZXdDaGlsZCgnbmdEaWFncmFtJywgeyBzdGF0aWM6IHRydWUgfSkgcHVibGljIGRpYWdyYW1EaXY6IEVsZW1lbnRSZWY7XHJcbiAgcHVibGljIGRpYWdyYW06IGdvLkRpYWdyYW0gPSBudWxsO1xyXG5cclxuICAvLyBkaWZmZXJzIGZvciBhcnJheSBpbnB1dHMgKG5vZGUgLyBsaW5rIGRhdGEgYXJyYXlzKVxyXG4gIHByaXZhdGUgX25kYURpZmZlcjogS2V5VmFsdWVEaWZmZXI8c3RyaW5nLCBhbnk+O1xyXG4gIHByaXZhdGUgX2xkYURpZmZlcjogS2V5VmFsdWVEaWZmZXI8c3RyaW5nLCBhbnk+O1xyXG5cclxuICBwcml2YXRlIF9tZGFEaWZmZXI6IEtleVZhbHVlRGlmZmVyPHN0cmluZywgYW55PjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfa3ZkaWZmZXJzOiBLZXlWYWx1ZURpZmZlcnMsIHB1YmxpYyB6b25lOiBOZ1pvbmUpIHtcclxuICAgIC8vIGRpZmZlcnMgdXNlZCB0byBjaGVjayBpZiB0aGVyZSBoYXZlIGJlZW4gY2hhbmdlZCB0byB0aGUgYXJyYXkgQElucHV0c1xyXG4gICAgLy8gd2l0aG91dCB0aGVtLCBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBhcnJheXMgd29uJ3QgcmVnaXN0ZXIgaW4gbmdPbkNoYW5nZXMsXHJcbiAgICAvLyBzaW5jZSB0aGUgYXJyYXkgcmVmZXJlbmNlIGl0c2VsZiBtYXkgYmUgdGhlIHNhbWVcclxuICAgIHRoaXMuX25kYURpZmZlciA9IHRoaXMuX2t2ZGlmZmVycy5maW5kKFtdKS5jcmVhdGUoKTtcclxuICAgIHRoaXMuX2xkYURpZmZlciA9IHRoaXMuX2t2ZGlmZmVycy5maW5kKFtdKS5jcmVhdGUoKTtcclxuXHJcbiAgICB0aGlzLl9tZGFEaWZmZXIgPSB0aGlzLl9rdmRpZmZlcnMuZmluZChbXSkuY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyBkaWFncmFtIC8gbW9kZWwgYWZ0ZXIgdmlldyBpbml0XHJcbiAgICovXHJcbiAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IHRoaXMuaW5pdERpYWdyYW0oKTtcclxuXHJcbiAgICAvLyBUaGlzIGJpdCBvZiBjb2RlIG1ha2VzIHN1cmUgdGhlIG1vdXNlbW92ZSBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGNhbnZhcyBhcmUgcnVuIG91dHNpZGUgTmdab25lXHJcbiAgICAvLyBUaGlzIG1ha2VzIGl0IHNvIGNoYW5nZSBkZXRlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIGV2ZXJ5IHRpbWUgdGhlIG1vdXNlIGlzIG1vdmVkIGluc2lkZSB0aGUgY2FudmFzLCBncmVhdGx5IGltcHJvdmluZyBwZXJmb3JtYW5jZVxyXG4gICAgLy8gSWYgc29tZSBzdGF0ZS1hbHRlcmluZyBiZWhhdmlvciBtdXN0IGhhcHBlbiBvbiBhIG1vdXNlbW92ZSBldmVudCBpbnNpZGUgdGhlIGRpYWdyYW0sXHJcbiAgICAvLyB5b3Ugd2lsbCBoYXZlIHRvIHVzaW5nIHpvbmUucnVuKCkgdG8gbWFrZSBzdXJlIHRoYXQgZXZlbnQgdHJpZ2dlcnMgYW5ndWxhciBjaGFuZ2UgZGV0ZWN0aW9uXHJcbiAgICB0aGlzLmRpYWdyYW0uYWRkRXZlbnRMaXN0ZW5lciA9IChET01FbGVtZW50OiBFbGVtZW50IHwgV2luZG93IHwgRG9jdW1lbnQsIG5hbWU6IHN0cmluZywgbGlzdGVuZXI6IGFueSwgY2FwdHVyZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICBjb25zdCBzdXBlckFkZEV2ZW50TGlzdGVuZXIgPSBnby5EaWFncmFtLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG4gICAgICBpZiAobmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc3VwZXJBZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgRE9NRWxlbWVudCwgbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgIHN1cGVyQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIERPTUVsZW1lbnQsIG5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhc3NpZ24gdGhlIERpYWdyYW0ncyBkaXYsIHdoaWNoIChhbW9uZyBtYW55IG90aGVyIHRoaW5ncykgd2lsbCBhdHRhY2ggYSBidW5jaCBvZiBsaXN0ZW5lcnMgdG8gdGhlIGNhbnZhcyxcclxuICAgIC8vIHVzaW5nIHRoZSBvdmVycmlkZGVuIGFkZEV2ZW50TGlzdGVuZXIgZnVuY3Rpb24gYWJvdmVcclxuICAgIGNvbnN0IGRpdlJlZiA9IHRoaXMuZGlhZ3JhbURpdi5uYXRpdmVFbGVtZW50O1xyXG4gICAgaWYgKGRpdlJlZiA9PT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgdGhpcy5kaWFncmFtLmRpdiA9IGRpdlJlZjtcclxuXHJcbiAgICAvLyBpbml0aWFsaXplIHRoZSBEaWFncmFtJ3MgbW9kZWxcclxuICAgIHRoaXMuZGlhZ3JhbS5kZWxheUluaXRpYWxpemF0aW9uKCgpID0+IHtcclxuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmRpYWdyYW0ubW9kZWw7XHJcbiAgICAgIG1vZGVsLmNvbW1pdCgobTogZ28uTW9kZWwpID0+IHtcclxuICAgICAgICBtLm1lcmdlTm9kZURhdGFBcnJheShtLmNsb25lRGVlcCh0aGlzLm5vZGVEYXRhQXJyYXkpKTtcclxuICAgICAgICBpZiAodGhpcy5saW5rRGF0YUFycmF5ICYmIG0gaW5zdGFuY2VvZiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgICAgICAgIG0ubWVyZ2VMaW5rRGF0YUFycmF5KG0uY2xvbmVEZWVwKHRoaXMubGlua0RhdGFBcnJheSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tb2RlbERhdGEpIHtcclxuICAgICAgICAgIG0uYXNzaWduQWxsRGF0YVByb3BlcnRpZXMobS5tb2RlbERhdGEsIHRoaXMubW9kZWxEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaWFncmFtLmxheW91dERpYWdyYW0odHJ1ZSk7XHJcbiAgICAgIH0sIG51bGwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZXIgbGlzdGVuZXJcclxuICAgIHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgPSAoZTogZ28uQ2hhbmdlZEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChlLmlzVHJhbnNhY3Rpb25GaW5pc2hlZCAmJiB0aGlzLmRpYWdyYW0gJiYgdGhpcy5kaWFncmFtLm1vZGVsICYmICF0aGlzLmRpYWdyYW0ubW9kZWwuaXNSZWFkT25seSkge1xyXG4gICAgICAgIC8vIHRoaXMgbXVzdCBiZSBkb25lIHdpdGhpbiBhIE5nWm9uZS5ydW4gYmxvY2ssIHNvIGNoYW5nZXMgYXJlIGRldGVjdGVkIGluIHRoZSBwYXJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBkYXRhQ2hhbmdlcyA9IGUubW9kZWwhLnRvSW5jcmVtZW50YWxEYXRhKGUpO1xyXG4gICAgICAgICAgdGhpcy5tb2RlbENoYW5nZS5lbWl0KGRhdGFDaGFuZ2VzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuZGlhZ3JhbS5hZGRNb2RlbENoYW5nZWRMaXN0ZW5lcih0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyKTtcclxuXHJcblxyXG4gIH0gLy8gZW5kIG5nQWZ0ZXJWaWV3SW5pdFxyXG5cclxuICAvKipcclxuICAgKiBNZXJnZXMgY2hhbmdlcyBmcm9tIGFwcCBkYXRhIGludG8gR29KUyBtb2RlbCBkYXRhLCBcclxuICAgKiBtYWtpbmcgc3VyZSBvbmx5IGFjdHVhbCBjaGFuZ2VzIChhbmQgbm90IGZhbHNlbHkgZmxhZ2dlZCBuby1vcHMgb24gYXJyYXkgLyBvYmogZGF0YSBwcm9wcykgYXJlIGxvZ2dlZFxyXG4gICAqIEBwYXJhbSBjb21wb25lbnQgYW4gaW5zdGFuY2Ugb2YgRGlhZ3JhbUNvbXBvbmVudCBvciBQYWxldHRlQ29tcG9uZW50XHJcbiAgICogQHBhcmFtIGt2Y2hhbmdlcyBUaGUga3ZjaGFuZ2VzIG9iamVjdCBwcm9kdWNlZCBieSBlaXRoZXIgYSBub2RlIG9yIGxpbmsgQW5ndWxhciBkaWZmZXIgb2JqZWN0XHJcbiAgICogQHBhcmFtIHN0ciBcIm5cIiBmb3Igbm9kZSBkYXRhIGNoYW5nZXMsIFwibFwiIGZvciBsaW5rIGRhdGEgY2hhbmdlc1xyXG4gICAqICAqLyBcclxuICBwdWJsaWMgc3RhdGljIG1lcmdlQ2hhbmdlcyhjb21wb25lbnQsIGt2Y2hhbmdlcywgc3RyKTogYm9vbGVhbiB7XHJcblxyXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlT2JqcyhvYmoxLCBvYmoyKSB7XHJcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzIGluIG9iamVjdCAxXHJcbiAgICAgIGZvciAoY29uc3QgcCBpbiBvYmoxKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgcHJvcGVydHkgZXhpc3RzIG9uIGJvdGggb2JqZWN0c1xyXG4gICAgICAgIGlmIChvYmoxLmhhc093blByb3BlcnR5KHApICE9PSBvYmoyLmhhc093blByb3BlcnR5KHApKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIChvYmoxW3BdKSkge1xyXG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHNcclxuICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgIGlmICghY29tcGFyZU9ianMob2JqMVtwXSwgb2JqMltwXSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAvLyBDb21wYXJlIHZhbHVlc1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKG9iajFbcF0gIT09IG9iajJbcF0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIG9iamVjdCAyIGZvciBhbnkgZXh0cmEgcHJvcGVydGllc1xyXG4gICAgICBmb3IgKGNvbnN0IHAgaW4gb2JqMikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iajFbcF0pID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkaWEgPSBjb21wb25lbnQgaW5zdGFuY2VvZiBEaWFncmFtQ29tcG9uZW50ID8gY29tcG9uZW50LmRpYWdyYW0gOiBjb21wb25lbnQucGFsZXR0ZTtcclxuXHJcbiAgICBpZiAoIWRpYSB8fCAhZGlhLm1vZGVsKSByZXR1cm47XHJcblxyXG4gICAgaWYgKGt2Y2hhbmdlcykge1xyXG5cclxuICAgICAgLy8gaGFuZGxlIGFkZGVkIG5vZGVzIC8gbGlua3NcclxuICAgICAga3ZjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oKHI6IEtleVZhbHVlQ2hhbmdlUmVjb3JkPHN0cmluZywgYW55PikgPT4ge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcbiAgICAgICAgICBjYXNlIFwiblwiOiB7XHJcbiAgICAgICAgICAgIGRpYS5tb2RlbC5hZGROb2RlRGF0YShyLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSBcImxcIjoge1xyXG4gICAgICAgICAgICB2YXIgbSA9IDxnby5HcmFwaExpbmtzTW9kZWw+ZGlhLm1vZGVsO1xyXG4gICAgICAgICAgICBtLmFkZExpbmtEYXRhKHIuY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIGhhbmRsZSByZW1vdmVkIG5vZGVzIC8gbGlua3NcclxuICAgICAga3ZjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbSgocjogS2V5VmFsdWVDaGFuZ2VSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuICAgICAgICAgIGNhc2UgXCJuXCI6IHtcclxuICAgICAgICAgICAgbGV0IG0gPSBkaWEubW9kZWw7XHJcbiAgICAgICAgICAgIGxldCBrZXlQcm9wTmFtZSA9IG0ubm9kZUtleVByb3BlcnR5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gZGlhLmZpbmROb2RlRm9yS2V5KHIucHJldmlvdXNWYWx1ZVtrZXlQcm9wTmFtZV0pO1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgIGRpYS5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIFwibFwiOiB7XHJcbiAgICAgICAgICAgIGxldCBtID0gPGdvLkdyYXBoTGlua3NNb2RlbD5kaWEubW9kZWw7XHJcbiAgICAgICAgICAgIHZhciBrZXlQcm9wTmFtZSA9IG0ubGlua0tleVByb3BlcnR5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBsaW5rID0gZGlhLmZpbmRMaW5rRm9yS2V5KHIucHJldmlvdXNWYWx1ZVtrZXlQcm9wTmFtZV0pO1xyXG4gICAgICAgICAgICBpZiAobGluaykge1xyXG4gICAgICAgICAgICAgIGRpYS5yZW1vdmUobGluayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIGhhbmRsZSBjaGFuZ2VkIGRhdGEgZm9yIG5vZGVzIC8gbGlua3NcclxuICAgICAga3ZjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbSgocjogS2V5VmFsdWVDaGFuZ2VSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZW5zdXJlIFwiY2hhbmdlc1wiIHRvIGFycmF5IC8gb2JqZWN0IC8gZW51bWVyYWJsZSBkYXRhIHByb3BlcnRpZXMgYXJlIGxlZ2l0XHJcbiAgICAgICAgY29uc3Qgc2FtZVZhbHMgPSBjb21wYXJlT2JqcyhyLmN1cnJlbnRWYWx1ZSwgci5wcmV2aW91c1ZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHByb3BlciBkYXRhIG9iamVjdCBmb3Igbm9kZSBvciBsaW5rXHJcbiAgICAgICAgaWYgKCFzYW1lVmFscykge1xyXG4gICAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm5cIjoge1xyXG4gICAgICAgICAgICAgIGxldCBtID0gZGlhLm1vZGVsO1xyXG4gICAgICAgICAgICAgIGxldCBrZXlQcm9wTmFtZSA9IG0ubm9kZUtleVByb3BlcnR5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkaWEuZmluZE5vZGVGb3JLZXkoci5wcmV2aW91c1ZhbHVlW2tleVByb3BOYW1lXSk7XHJcbiAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGRpYS5tb2RlbC5hc3NpZ25BbGxEYXRhUHJvcGVydGllcyhub2RlLmRhdGEsIHIuY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcImxcIjoge1xyXG4gICAgICAgICAgICAgIGxldCBtID0gPGdvLkdyYXBoTGlua3NNb2RlbD5kaWEubW9kZWw7XHJcbiAgICAgICAgICAgICAgdmFyIGtleVByb3BOYW1lID0gbS5saW5rS2V5UHJvcGVydHkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICB2YXIgbGluayA9IGRpYS5maW5kTGlua0ZvcktleShyLnByZXZpb3VzVmFsdWVba2V5UHJvcE5hbWVdKTtcclxuICAgICAgICAgICAgICBpZiAobGluaykge1xyXG4gICAgICAgICAgICAgICAgZGlhLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKGxpbmsuZGF0YSwgci5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsd2F5cyBiZSBjaGVja2luZyBpZiBhcnJheSBJbnB1dCBkYXRhIGhhcyBjaGFuZ2VkIChub2RlIGFuZCBsaW5rIGRhdGEgYXJyYXlzKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRpYWdyYW0pIHJldHVybjtcclxuICAgIGlmICghdGhpcy5kaWFncmFtLm1vZGVsKSByZXR1cm47XHJcblxyXG4gICAgLy8gdGhlc2UgbmVlZCB0byBiZSBydW4gZWFjaCBjaGVjaywgZXZlbiBpZiBubyBtZXJnaW5nIGhhcHBlbnNcclxuICAgIC8vIG90aGVyd2lzZSwgdGhleSB3aWxsIGRldGVjdCBhbGwgZGlmZnMgdGhhdCBoYXBwZW5lZCBzaW5jZSBsYXN0IHRpbWUgc2tpcHNEaWFncmFtIHdhcyBmYWxzZSxcclxuICAgIC8vIHN1Y2ggYXMgcmVtb3ZlIG9wcyB0aGF0IGhhcHBlbmVkIGluIEdvSlMgd2hlbiBza2lwc0RpYWdyYW0gPSB0cnVlLCBcclxuICAgIC8vIGFuZCB0aGVuIHJlYWxsbGxsbHkgYmFkIHN0dWZmIGhhcHBlbnMgKGRlbGV0aW5nIHJhbmRvbSBub2RlcywgdXBkYXRpbmcgdGhlIHdyb25nIFBhcnRzKVxyXG4gICAgLy8gQW5ndWxhciBkaWZmZXJzIGFyZSBhIGxvdCBvZiBmdW5cclxuICAgIHZhciBub2RlRGlmZnMgPSB0aGlzLl9uZGFEaWZmZXIuZGlmZih0aGlzLm5vZGVEYXRhQXJyYXkpO1xyXG4gICAgdmFyIGxpbmtEaWZmcyA9IHRoaXMuX2xkYURpZmZlci5kaWZmKHRoaXMubGlua0RhdGFBcnJheSk7XHJcblxyXG4gICAgdmFyIG1vZGVsRGlmZnMgPSB0aGlzLl9tZGFEaWZmZXIuZGlmZih0aGlzLm1vZGVsRGF0YSk7XHJcblxyXG4gICAgaWYgKCFub2RlRGlmZnMgJiYgIWxpbmtEaWZmcyAmJiAhbW9kZWxEaWZmcykgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLnNraXBzRGlhZ3JhbVVwZGF0ZSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIGRvbid0IG5lZWQgbW9kZWwgY2hhbmdlIGxpc3RlbmVyIHdoaWxlIHBlcmZvcm1pbmcga25vd24gZGF0YSB1cGRhdGVzXHJcbiAgICBpZiAodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkgdGhpcy5kaWFncmFtLm1vZGVsLnJlbW92ZUNoYW5nZWRMaXN0ZW5lcih0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyKTtcclxuXHJcbiAgICB0aGlzLmRpYWdyYW0ubW9kZWwuc3RhcnRUcmFuc2FjdGlvbigndXBkYXRlIGRhdGEnKTtcclxuICAgIC8vIHVwZGF0ZSBtb2RlbERhdGEgZmlyc3QsIGluIGNhc2UgYmluZGluZ3Mgb24gbm9kZXMgLyBsaW5rcyBkZXBlbmQgb24gbW9kZWwgZGF0YVxyXG4gICAgdGhpcy5kaWFncmFtLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKHRoaXMuZGlhZ3JhbS5tb2RlbC5tb2RlbERhdGEsIHRoaXMubW9kZWxEYXRhKTtcclxuICAgIC8vIG1lcmdlIG5vZGUgLyBsaW5rIGRhdGFcclxuICAgIERpYWdyYW1Db21wb25lbnQubWVyZ2VDaGFuZ2VzKHRoaXMsIG5vZGVEaWZmcywgXCJuXCIpO1xyXG4gICAgRGlhZ3JhbUNvbXBvbmVudC5tZXJnZUNoYW5nZXModGhpcywgbGlua0RpZmZzLCBcImxcIik7XHJcbiAgICB0aGlzLmRpYWdyYW0ubW9kZWwuY29tbWl0VHJhbnNhY3Rpb24oJ3VwZGF0ZSBkYXRhJyk7XHJcblxyXG4gICAgLy8gcmVzZXQgdGhlIG1vZGVsIGNoYW5nZSBsaXN0ZW5lclxyXG4gICAgaWYgKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHRoaXMuZGlhZ3JhbS5tb2RlbC5hZGRDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcblxyXG4gIH0gLy8gZW5kIG5nRG9DaGVja1xyXG5cclxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0uZGl2ID0gbnVsbDsgLy8gcmVtb3ZlcyBldmVudCBsaXN0ZW5lcnNcclxuICB9XHJcbn1cclxuIl19