{"ast":null,"code":"import { isNumber, assign, forEach, every, debounce, bind, reduce } from 'min-dash';\nimport { add as collectionAdd, remove as collectionRemove } from '../util/Collections';\nimport { getType } from '../util/Elements';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, transform as svgTransform } from 'tiny-svg';\nimport { createMatrix } from 'tiny-svg';\nfunction round(number, resolution) {\n  return Math.round(number * resolution) / resolution;\n}\nfunction ensurePx(number) {\n  return isNumber(number) ? number + 'px' : number;\n}\n\n/**\n * Creates a HTML container element for a SVG element with\n * the given configuration\n *\n * @param  {Object} options\n * @return {HTMLElement} the container element\n */\nfunction createContainer(options) {\n  options = assign({}, {\n    width: '100%',\n    height: '100%'\n  }, options);\n  var container = options.container || document.body;\n\n  // create a <div> around the svg element with the respective size\n  // this way we can always get the correct container size\n  // (this is impossible for <svg> elements at the moment)\n  var parent = document.createElement('div');\n  parent.setAttribute('class', 'djs-container');\n  assign(parent.style, {\n    position: 'relative',\n    overflow: 'hidden',\n    width: ensurePx(options.width),\n    height: ensurePx(options.height)\n  });\n  container.appendChild(parent);\n  return parent;\n}\nfunction createGroup(parent, cls, childIndex) {\n  var group = svgCreate('g');\n  svgClasses(group).add(cls);\n  var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;\n\n  // must ensure second argument is node or _null_\n  // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n  parent.insertBefore(group, parent.childNodes[index] || null);\n  return group;\n}\nvar BASE_LAYER = 'base';\nvar REQUIRED_MODEL_ATTRS = {\n  shape: ['x', 'y', 'width', 'height'],\n  connection: ['waypoints']\n};\n\n/**\n * The main drawing canvas.\n *\n * @class\n * @constructor\n *\n * @emits Canvas#canvas.init\n *\n * @param {Object} config\n * @param {EventBus} eventBus\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementRegistry} elementRegistry\n */\nexport default function Canvas(config, eventBus, graphicsFactory, elementRegistry) {\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n  this._graphicsFactory = graphicsFactory;\n  this._init(config || {});\n}\nCanvas.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'];\nCanvas.prototype._init = function (config) {\n  var eventBus = this._eventBus;\n\n  // Creates a <svg> element that is wrapped into a <div>.\n  // This way we are always able to correctly figure out the size of the svg element\n  // by querying the parent node.\n  //\n  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)\n  //\n  // <div class=\"djs-container\" style=\"width: {desired-width}, height: {desired-height}\">\n  //   <svg width=\"100%\" height=\"100%\">\n  //    ...\n  //   </svg>\n  // </div>\n\n  // html container\n  var container = this._container = createContainer(config);\n  var svg = this._svg = svgCreate('svg');\n  svgAttr(svg, {\n    width: '100%',\n    height: '100%'\n  });\n  svgAppend(container, svg);\n  var viewport = this._viewport = createGroup(svg, 'viewport');\n  this._layers = {};\n\n  // debounce canvas.viewbox.changed events\n  // for smoother diagram interaction\n  if (config.deferUpdate !== false) {\n    this._viewboxChanged = debounce(bind(this._viewboxChanged, this), 300);\n  }\n  eventBus.on('diagram.init', function () {\n    /**\n     * An event indicating that the canvas is ready to be drawn on.\n     *\n     * @memberOf Canvas\n     *\n     * @event canvas.init\n     *\n     * @type {Object}\n     * @property {SVGElement} svg the created svg element\n     * @property {SVGElement} viewport the direct parent of diagram elements and shapes\n     */\n    eventBus.fire('canvas.init', {\n      svg: svg,\n      viewport: viewport\n    });\n  }, this);\n\n  // reset viewbox on shape changes to\n  // recompute the viewbox\n  eventBus.on(['shape.added', 'connection.added', 'shape.removed', 'connection.removed', 'elements.changed'], function () {\n    delete this._cachedViewbox;\n  }, this);\n  eventBus.on('diagram.destroy', 500, this._destroy, this);\n  eventBus.on('diagram.clear', 500, this._clear, this);\n};\nCanvas.prototype._destroy = function (emit) {\n  this._eventBus.fire('canvas.destroy', {\n    svg: this._svg,\n    viewport: this._viewport\n  });\n  var parent = this._container.parentNode;\n  if (parent) {\n    parent.removeChild(this._container);\n  }\n  delete this._svg;\n  delete this._container;\n  delete this._layers;\n  delete this._rootElement;\n  delete this._viewport;\n};\nCanvas.prototype._clear = function () {\n  var self = this;\n  var allElements = this._elementRegistry.getAll();\n\n  // remove all elements\n  allElements.forEach(function (element) {\n    var type = getType(element);\n    if (type === 'root') {\n      self.setRootElement(null, true);\n    } else {\n      self._removeElement(element, type);\n    }\n  });\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n};\n\n/**\n * Returns the default layer on which\n * all elements are drawn.\n *\n * @returns {SVGElement}\n */\nCanvas.prototype.getDefaultLayer = function () {\n  return this.getLayer(BASE_LAYER, 0);\n};\n\n/**\n * Returns a layer that is used to draw elements\n * or annotations on it.\n *\n * Non-existing layers retrieved through this method\n * will be created. During creation, the optional index\n * may be used to create layers below or above existing layers.\n * A layer with a certain index is always created above all\n * existing layers with the same index.\n *\n * @param {string} name\n * @param {number} index\n *\n * @returns {SVGElement}\n */\nCanvas.prototype.getLayer = function (name, index) {\n  if (!name) {\n    throw new Error('must specify a name');\n  }\n  var layer = this._layers[name];\n  if (!layer) {\n    layer = this._layers[name] = this._createLayer(name, index);\n  }\n\n  // throw an error if layer creation / retrival is\n  // requested on different index\n  if (typeof index !== 'undefined' && layer.index !== index) {\n    throw new Error('layer <' + name + '> already created at index <' + index + '>');\n  }\n  return layer.group;\n};\n\n/**\n * Creates a given layer and returns it.\n *\n * @param {string} name\n * @param {number} [index=0]\n *\n * @return {Object} layer descriptor with { index, group: SVGGroup }\n */\nCanvas.prototype._createLayer = function (name, index) {\n  if (!index) {\n    index = 0;\n  }\n  var childIndex = reduce(this._layers, function (childIndex, layer) {\n    if (index >= layer.index) {\n      childIndex++;\n    }\n    return childIndex;\n  }, 0);\n  return {\n    group: createGroup(this._viewport, 'layer-' + name, childIndex),\n    index: index\n  };\n};\n\n/**\n * Returns the html element that encloses the\n * drawing canvas.\n *\n * @return {DOMNode}\n */\nCanvas.prototype.getContainer = function () {\n  return this._container;\n};\n\n// markers //////////////////////\n\nCanvas.prototype._updateMarker = function (element, marker, add) {\n  var container;\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  // we need to access all\n  container = this._elementRegistry._elements[element.id];\n  if (!container) {\n    return;\n  }\n  forEach([container.gfx, container.secondaryGfx], function (gfx) {\n    if (gfx) {\n      // invoke either addClass or removeClass based on mode\n      if (add) {\n        svgClasses(gfx).add(marker);\n      } else {\n        svgClasses(gfx).remove(marker);\n      }\n    }\n  });\n\n  /**\n   * An event indicating that a marker has been updated for an element\n   *\n   * @event element.marker.update\n   * @type {Object}\n   * @property {djs.model.Element} element the shape\n   * @property {Object} gfx the graphical representation of the shape\n   * @property {string} marker\n   * @property {boolean} add true if the marker was added, false if it got removed\n   */\n  this._eventBus.fire('element.marker.update', {\n    element: element,\n    gfx: container.gfx,\n    marker: marker,\n    add: !!add\n  });\n};\n\n/**\n * Adds a marker to an element (basically a css class).\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @example\n * canvas.addMarker('foo', 'some-marker');\n *\n * var fooGfx = canvas.getGraphics('foo');\n *\n * fooGfx; // <g class=\"... some-marker\"> ... </g>\n *\n * @param {string|djs.model.Base} element\n * @param {string} marker\n */\nCanvas.prototype.addMarker = function (element, marker) {\n  this._updateMarker(element, marker, true);\n};\n\n/**\n * Remove a marker from an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param  {string|djs.model.Base} element\n * @param  {string} marker\n */\nCanvas.prototype.removeMarker = function (element, marker) {\n  this._updateMarker(element, marker, false);\n};\n\n/**\n * Check the existence of a marker on element.\n *\n * @param  {string|djs.model.Base} element\n * @param  {string} marker\n */\nCanvas.prototype.hasMarker = function (element, marker) {\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n  var gfx = this.getGraphics(element);\n  return svgClasses(gfx).has(marker);\n};\n\n/**\n * Toggles a marker on an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param  {string|djs.model.Base} element\n * @param  {string} marker\n */\nCanvas.prototype.toggleMarker = function (element, marker) {\n  if (this.hasMarker(element, marker)) {\n    this.removeMarker(element, marker);\n  } else {\n    this.addMarker(element, marker);\n  }\n};\nCanvas.prototype.getRootElement = function () {\n  if (!this._rootElement) {\n    this.setRootElement({\n      id: '__implicitroot',\n      children: []\n    });\n  }\n  return this._rootElement;\n};\n\n// root element handling //////////////////////\n\n/**\n * Sets a given element as the new root element for the canvas\n * and returns the new root element.\n *\n * @param {Object|djs.model.Root} element\n * @param {boolean} [override] whether to override the current root element, if any\n *\n * @return {Object|djs.model.Root} new root element\n */\nCanvas.prototype.setRootElement = function (element, override) {\n  if (element) {\n    this._ensureValid('root', element);\n  }\n  var currentRoot = this._rootElement,\n    elementRegistry = this._elementRegistry,\n    eventBus = this._eventBus;\n  if (currentRoot) {\n    if (!override) {\n      throw new Error('rootElement already set, need to specify override');\n    }\n\n    // simulate element remove event sequence\n    eventBus.fire('root.remove', {\n      element: currentRoot\n    });\n    eventBus.fire('root.removed', {\n      element: currentRoot\n    });\n    elementRegistry.remove(currentRoot);\n  }\n  if (element) {\n    var gfx = this.getDefaultLayer();\n\n    // resemble element add event sequence\n    eventBus.fire('root.add', {\n      element: element\n    });\n    elementRegistry.add(element, gfx, this._svg);\n    eventBus.fire('root.added', {\n      element: element,\n      gfx: gfx\n    });\n  }\n  this._rootElement = element;\n  return element;\n};\n\n// add functionality //////////////////////\n\nCanvas.prototype._ensureValid = function (type, element) {\n  if (!element.id) {\n    throw new Error('element must have an id');\n  }\n  if (this._elementRegistry.get(element.id)) {\n    throw new Error('element with id ' + element.id + ' already exists');\n  }\n  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];\n  var valid = every(requiredAttrs, function (attr) {\n    return typeof element[attr] !== 'undefined';\n  });\n  if (!valid) {\n    throw new Error('must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);\n  }\n};\nCanvas.prototype._setParent = function (element, parent, parentIndex) {\n  collectionAdd(parent.children, element, parentIndex);\n  element.parent = parent;\n};\n\n/**\n * Adds an element to the canvas.\n *\n * This wires the parent <-> child relationship between the element and\n * a explicitly specified parent or an implicit root element.\n *\n * During add it emits the events\n *\n *  * <{type}.add> (element, parent)\n *  * <{type}.added> (element, gfx)\n *\n * Extensions may hook into these events to perform their magic.\n *\n * @param {string} type\n * @param {Object|djs.model.Base} element\n * @param {Object|djs.model.Base} [parent]\n * @param {number} [parentIndex]\n *\n * @return {Object|djs.model.Base} the added element\n */\nCanvas.prototype._addElement = function (type, element, parent, parentIndex) {\n  parent = parent || this.getRootElement();\n  var eventBus = this._eventBus,\n    graphicsFactory = this._graphicsFactory;\n  this._ensureValid(type, element);\n  eventBus.fire(type + '.add', {\n    element: element,\n    parent: parent\n  });\n  this._setParent(element, parent, parentIndex);\n\n  // create graphics\n  var gfx = graphicsFactory.create(type, element, parentIndex);\n  this._elementRegistry.add(element, gfx);\n\n  // update its visual\n  graphicsFactory.update(type, element, gfx);\n  eventBus.fire(type + '.added', {\n    element: element,\n    gfx: gfx\n  });\n  return element;\n};\n\n/**\n * Adds a shape to the canvas\n *\n * @param {Object|djs.model.Shape} shape to add to the diagram\n * @param {djs.model.Base} [parent]\n * @param {number} [parentIndex]\n *\n * @return {djs.model.Shape} the added shape\n */\nCanvas.prototype.addShape = function (shape, parent, parentIndex) {\n  return this._addElement('shape', shape, parent, parentIndex);\n};\n\n/**\n * Adds a connection to the canvas\n *\n * @param {Object|djs.model.Connection} connection to add to the diagram\n * @param {djs.model.Base} [parent]\n * @param {number} [parentIndex]\n *\n * @return {djs.model.Connection} the added connection\n */\nCanvas.prototype.addConnection = function (connection, parent, parentIndex) {\n  return this._addElement('connection', connection, parent, parentIndex);\n};\n\n/**\n * Internal remove element\n */\nCanvas.prototype._removeElement = function (element, type) {\n  var elementRegistry = this._elementRegistry,\n    graphicsFactory = this._graphicsFactory,\n    eventBus = this._eventBus;\n  element = elementRegistry.get(element.id || element);\n  if (!element) {\n    // element was removed already\n    return;\n  }\n  eventBus.fire(type + '.remove', {\n    element: element\n  });\n  graphicsFactory.remove(element);\n\n  // unset parent <-> child relationship\n  collectionRemove(element.parent && element.parent.children, element);\n  element.parent = null;\n  eventBus.fire(type + '.removed', {\n    element: element\n  });\n  elementRegistry.remove(element);\n  return element;\n};\n\n/**\n * Removes a shape from the canvas\n *\n * @param {string|djs.model.Shape} shape or shape id to be removed\n *\n * @return {djs.model.Shape} the removed shape\n */\nCanvas.prototype.removeShape = function (shape) {\n  /**\n   * An event indicating that a shape is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event shape.remove\n   * @type {Object}\n   * @property {djs.model.Shape} element the shape descriptor\n   * @property {Object} gfx the graphical representation of the shape\n   */\n\n  /**\n   * An event indicating that a shape has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event shape.removed\n   * @type {Object}\n   * @property {djs.model.Shape} element the shape descriptor\n   * @property {Object} gfx the graphical representation of the shape\n   */\n  return this._removeElement(shape, 'shape');\n};\n\n/**\n * Removes a connection from the canvas\n *\n * @param {string|djs.model.Connection} connection or connection id to be removed\n *\n * @return {djs.model.Connection} the removed connection\n */\nCanvas.prototype.removeConnection = function (connection) {\n  /**\n   * An event indicating that a connection is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event connection.remove\n   * @type {Object}\n   * @property {djs.model.Connection} element the connection descriptor\n   * @property {Object} gfx the graphical representation of the connection\n   */\n\n  /**\n   * An event indicating that a connection has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event connection.removed\n   * @type {Object}\n   * @property {djs.model.Connection} element the connection descriptor\n   * @property {Object} gfx the graphical representation of the connection\n   */\n  return this._removeElement(connection, 'connection');\n};\n\n/**\n * Return the graphical object underlaying a certain diagram element\n *\n * @param {string|djs.model.Base} element descriptor of the element\n * @param {boolean} [secondary=false] whether to return the secondary connected element\n *\n * @return {SVGElement}\n */\nCanvas.prototype.getGraphics = function (element, secondary) {\n  return this._elementRegistry.getGraphics(element, secondary);\n};\n\n/**\n * Perform a viewbox update via a given change function.\n *\n * @param {Function} changeFn\n */\nCanvas.prototype._changeViewbox = function (changeFn) {\n  // notify others of the upcoming viewbox change\n  this._eventBus.fire('canvas.viewbox.changing');\n\n  // perform actual change\n  changeFn.apply(this);\n\n  // reset the cached viewbox so that\n  // a new get operation on viewbox or zoom\n  // triggers a viewbox re-computation\n  this._cachedViewbox = null;\n\n  // notify others of the change; this step\n  // may or may not be debounced\n  this._viewboxChanged();\n};\nCanvas.prototype._viewboxChanged = function () {\n  this._eventBus.fire('canvas.viewbox.changed', {\n    viewbox: this.viewbox()\n  });\n};\n\n/**\n * Gets or sets the view box of the canvas, i.e. the\n * area that is currently displayed.\n *\n * The getter may return a cached viewbox (if it is currently\n * changing). To force a recomputation, pass `false` as the first argument.\n *\n * @example\n *\n * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })\n *\n * // sets the visible area of the diagram to (100|100) -> (600|100)\n * // and and scales it according to the diagram width\n *\n * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.\n *\n * console.log(viewbox);\n * // {\n * //   inner: Dimensions,\n * //   outer: Dimensions,\n * //   scale,\n * //   x, y,\n * //   width, height\n * // }\n *\n * // if the current diagram is zoomed and scrolled, you may reset it to the\n * // default zoom via this method, too:\n *\n * var zoomedAndScrolledViewbox = canvas.viewbox();\n *\n * canvas.viewbox({\n *   x: 0,\n *   y: 0,\n *   width: zoomedAndScrolledViewbox.outer.width,\n *   height: zoomedAndScrolledViewbox.outer.height\n * });\n *\n * @param  {Object} [box] the new view box to set\n * @param  {number} box.x the top left X coordinate of the canvas visible in view box\n * @param  {number} box.y the top left Y coordinate of the canvas visible in view box\n * @param  {number} box.width the visible width\n * @param  {number} box.height\n *\n * @return {Object} the current view box\n */\nCanvas.prototype.viewbox = function (box) {\n  if (box === undefined && this._cachedViewbox) {\n    return this._cachedViewbox;\n  }\n  var viewport = this._viewport,\n    innerBox,\n    outerBox = this.getSize(),\n    matrix,\n    transform,\n    scale,\n    x,\n    y;\n  if (!box) {\n    // compute the inner box based on the\n    // diagrams default layer. This allows us to exclude\n    // external components, such as overlays\n    innerBox = this.getDefaultLayer().getBBox();\n    transform = svgTransform(viewport);\n    matrix = transform ? transform.matrix : createMatrix();\n    scale = round(matrix.a, 1000);\n    x = round(-matrix.e || 0, 1000);\n    y = round(-matrix.f || 0, 1000);\n    box = this._cachedViewbox = {\n      x: x ? x / scale : 0,\n      y: y ? y / scale : 0,\n      width: outerBox.width / scale,\n      height: outerBox.height / scale,\n      scale: scale,\n      inner: {\n        width: innerBox.width,\n        height: innerBox.height,\n        x: innerBox.x,\n        y: innerBox.y\n      },\n      outer: outerBox\n    };\n    return box;\n  } else {\n    this._changeViewbox(function () {\n      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);\n      var matrix = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);\n      svgTransform(viewport, matrix);\n    });\n  }\n  return box;\n};\n\n/**\n * Gets or sets the scroll of the canvas.\n *\n * @param {Object} [delta] the new scroll to apply.\n *\n * @param {number} [delta.dx]\n * @param {number} [delta.dy]\n */\nCanvas.prototype.scroll = function (delta) {\n  var node = this._viewport;\n  var matrix = node.getCTM();\n  if (delta) {\n    this._changeViewbox(function () {\n      delta = assign({\n        dx: 0,\n        dy: 0\n      }, delta || {});\n      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);\n      setCTM(node, matrix);\n    });\n  }\n  return {\n    x: matrix.e,\n    y: matrix.f\n  };\n};\n\n/**\n * Gets or sets the current zoom of the canvas, optionally zooming\n * to the specified position.\n *\n * The getter may return a cached zoom level. Call it with `false` as\n * the first argument to force recomputation of the current level.\n *\n * @param {string|number} [newScale] the new zoom level, either a number, i.e. 0.9,\n *                                   or `fit-viewport` to adjust the size to fit the current viewport\n * @param {string|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null\n *\n * @return {number} the current scale\n */\nCanvas.prototype.zoom = function (newScale, center) {\n  if (!newScale) {\n    return this.viewbox(newScale).scale;\n  }\n  if (newScale === 'fit-viewport') {\n    return this._fitViewport(center);\n  }\n  var outer, matrix;\n  this._changeViewbox(function () {\n    if (typeof center !== 'object') {\n      outer = this.viewbox().outer;\n      center = {\n        x: outer.width / 2,\n        y: outer.height / 2\n      };\n    }\n    matrix = this._setZoom(newScale, center);\n  });\n  return round(matrix.a, 1000);\n};\nfunction setCTM(node, m) {\n  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';\n  node.setAttribute('transform', mstr);\n}\nCanvas.prototype._fitViewport = function (center) {\n  var vbox = this.viewbox(),\n    outer = vbox.outer,\n    inner = vbox.inner,\n    newScale,\n    newViewbox;\n\n  // display the complete diagram without zooming in.\n  // instead of relying on internal zoom, we perform a\n  // hard reset on the canvas viewbox to realize this\n  //\n  // if diagram does not need to be zoomed in, we focus it around\n  // the diagram origin instead\n\n  if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center) {\n    newViewbox = {\n      x: 0,\n      y: 0,\n      width: Math.max(inner.width + inner.x, outer.width),\n      height: Math.max(inner.height + inner.y, outer.height)\n    };\n  } else {\n    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);\n    newViewbox = {\n      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),\n      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),\n      width: outer.width / newScale,\n      height: outer.height / newScale\n    };\n  }\n  this.viewbox(newViewbox);\n  return this.viewbox(false).scale;\n};\nCanvas.prototype._setZoom = function (scale, center) {\n  var svg = this._svg,\n    viewport = this._viewport;\n  var matrix = svg.createSVGMatrix();\n  var point = svg.createSVGPoint();\n  var centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;\n  currentMatrix = viewport.getCTM();\n  var currentScale = currentMatrix.a;\n  if (center) {\n    centerPoint = assign(point, center);\n\n    // revert applied viewport transformations\n    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());\n\n    // create scale matrix\n    scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);\n    newMatrix = currentMatrix.multiply(scaleMatrix);\n  } else {\n    newMatrix = matrix.scale(scale);\n  }\n  setCTM(this._viewport, newMatrix);\n  return newMatrix;\n};\n\n/**\n * Returns the size of the canvas\n *\n * @return {Dimensions}\n */\nCanvas.prototype.getSize = function () {\n  return {\n    width: this._container.clientWidth,\n    height: this._container.clientHeight\n  };\n};\n\n/**\n * Return the absolute bounding box for the given element\n *\n * The absolute bounding box may be used to display overlays in the\n * callers (browser) coordinate system rather than the zoomed in/out\n * canvas coordinates.\n *\n * @param  {ElementDescriptor} element\n * @return {Bounds} the absolute bounding box\n */\nCanvas.prototype.getAbsoluteBBox = function (element) {\n  var vbox = this.viewbox();\n  var bbox;\n\n  // connection\n  // use svg bbox\n  if (element.waypoints) {\n    var gfx = this.getGraphics(element);\n    bbox = gfx.getBBox();\n  }\n\n  // shapes\n  // use data\n  else {\n    bbox = element;\n  }\n  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;\n  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;\n  var width = bbox.width * vbox.scale;\n  var height = bbox.height * vbox.scale;\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n};\n\n/**\n * Fires an event in order other modules can react to the\n * canvas resizing\n */\nCanvas.prototype.resized = function () {\n  // force recomputation of view box\n  delete this._cachedViewbox;\n  this._eventBus.fire('canvas.resized');\n};","map":null,"metadata":{},"sourceType":"module"}