{"ast":null,"code":"var fromCharCode = String.fromCharCode;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function (k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\nfunction replaceEntities(_, d, x, z) {\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} str\n *\n * @return {string} decoded string\n */\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n  return s;\n}\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar XSI_PREFIX = 'xsi';\nvar XSI_TYPE = 'xsi:type';\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\nfunction error(msg) {\n  return new Error(msg);\n}\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {},\n    key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n    uri,\n    prefix;\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n  return nsMatrix;\n}\nfunction noopGetContext() {\n  return {\n    'line': 0,\n    'column': 0\n  };\n}\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nfunction Parser(options) {\n  if (!this) {\n    return new Parser(options);\n  }\n  var proxy = options && options['proxy'];\n  var onText,\n    onOpenTag,\n    onCloseTag,\n    onCDATA,\n    onError = throwFunc,\n    onWarning,\n    onComment,\n    onQuestion,\n    onAttention;\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n    returnError = err;\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n    if (!onWarning) {\n      return;\n    }\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function (name, cb) {\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n    switch (name) {\n      case 'openTag':\n        onOpenTag = cb;\n        break;\n      case 'text':\n        onText = cb;\n        break;\n      case 'closeTag':\n        onCloseTag = cb;\n        break;\n      case 'error':\n        onError = cb;\n        break;\n      case 'warn':\n        onWarning = cb;\n        break;\n      case 'cdata':\n        onCDATA = cb;\n        break;\n      case 'attention':\n        onAttention = cb;\n        break;\n      // <!XXXXX zzzz=\"eeee\">\n      case 'question':\n        onQuestion = cb;\n        break;\n      // <? ....  ?>\n      case 'comment':\n        onComment = cb;\n        break;\n      default:\n        throw error('unsupported event: ' + name);\n    }\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function (nsMap) {\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n    var _nsUriToPrefix = {},\n      k;\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    // FORCE default mapping for schema instance\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function (xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n    returnError = null;\n    parse(xml);\n    getContext = noopGetContext;\n    parseStop = false;\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function () {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n      nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n      _nsMatrix,\n      nodeStack = [],\n      anonymousNsCount = 0,\n      tagStart = false,\n      tagEnd = false,\n      i = 0,\n      j = 0,\n      x,\n      y,\n      q,\n      w,\n      v,\n      xmlns,\n      elementName,\n      _elementName,\n      elementProxy;\n    var attrsString = '',\n      attrsStart = 0,\n      cachedAttrs // false = parsed with errors, null = needs parsing\n    ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n      var nsUri,\n        nsUriPrefix,\n        nsName,\n        defaultAlias = isNamespace && nsMatrix['xmlns'],\n        attrList = isNamespace && maybeNS ? [] : null,\n        i = attrsStart,\n        s = attrsString,\n        l = s.length,\n        hasNewMatrix,\n        newalias,\n        value,\n        alias,\n        name,\n        attrs = {},\n        seenAttrs = {},\n        skipAttr,\n        w,\n        j;\n      parseAttr: for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n        if (w === 32 || w < 14 && w > 8) {\n          // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || w > 90 && w < 97) {\n          if (w !== 95 && w !== 58) {\n            // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 ||\n          // '.'\n          w === 45 ||\n          // '-'\n          w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) {\n            // \"=\" == 61\n            break;\n          }\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n        name = s.substring(i, j);\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n        w = s.charCodeAt(j + 1);\n        if (w === 34) {\n          // '\"'\n          j = s.indexOf('\"', i = j + 2);\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else if (w === 39) {\n          // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n            if (w === 32 || w < 14 && w > 8) {\n              // WHITESPACE\n              break;\n            }\n          }\n        }\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n          j = l;\n          skipAttr = true;\n        }\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n        seenAttrs[name] = true;\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null;\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n            alias = nsUriToPrefix[nsUri];\n            if (!alias) {\n              // no prefix defined or prefix collision\n              if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + anonymousNsCount++;\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n              nsUriToPrefix[nsUri] = alias;\n            }\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n        name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        // normalize xsi:type ns attribute value\n        if (name === XSI_TYPE) {\n          w = value.indexOf(':');\n          if (w !== -1) {\n            nsName = value.substring(0, w);\n\n            // handle default prefixes, i.e. xs:String gracefully\n            nsName = nsMatrix[nsName] || nsName;\n            value = nsName + value.substring(w);\n          } else {\n            value = defaultAlias + ':' + value;\n          }\n        }\n\n        // end: normalize xsi:type ns attribute value\n\n        attrs[name] = value;\n      }\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n          name = attrList[i++];\n          value = attrList[i];\n          w = name.indexOf(':');\n          if (w !== -1) {\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n            name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n\n            // normalize xsi:type ns attribute value\n            if (name === XSI_TYPE) {\n              w = value.indexOf(':');\n              if (w !== -1) {\n                nsName = value.substring(0, w);\n\n                // handle default prefixes, i.e. xs:String gracefully\n                nsName = nsMatrix[nsName] || nsName;\n                value = nsName + value.substring(w);\n              } else {\n                value = defaultAlias + ':' + value;\n              }\n            }\n\n            // end: normalize xsi:type ns attribute value\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n      while (i >= startOfLine) {\n        match = splitsRe.exec(xml);\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n        // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        }\n\n        // other errors\n        else {\n          column = i - startOfLine;\n          data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);\n        }\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n    getContext = getParseContext;\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function () {\n          return elementName;\n        }),\n        'originalName': getter(function () {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function () {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n      if (xml.charCodeAt(j) === 60) {\n        // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n      w = xml.charCodeAt(i + 1);\n\n      // parse comments + CDATA\n      if (w === 33) {\n        // \"!\"\n        q = xml.charCodeAt(i + 2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {\n          // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) {\n          // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) {\n        // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1;; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) {\n          //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) {\n          // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) {\n          // '>'\n          j = x;\n          break;\n        }\n      }\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) {\n        // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) {\n        // </...\n        tagStart = false;\n        tagEnd = true;\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n          if (w === 32 || w > 8 && w < 14) {\n            // \\f\\n\\r\\t\\v space\n            continue;\n          }\n          return handleError('close tag');\n        }\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) {\n          // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n          tagStart = true;\n          tagEnd = true;\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n          tagStart = true;\n          tagEnd = false;\n        }\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {\n          // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n          if (w === 32 || w < 14 && w > 8) {\n            // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n          return handleError('invalid nodeName');\n        }\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n      if (isNamespace) {\n        _nsMatrix = nsMatrix;\n        if (tagStart) {\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n          if (cachedAttrs === null) {\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if (maybeNS = x.indexOf('xmlns', q) !== -1) {\n              attrsStart = q;\n              attrsString = x;\n              getAttrs();\n              maybeNS = false;\n            }\n          }\n        }\n        _elementName = elementName;\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n      }\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n          if (parseStop) {\n            return;\n          }\n        }\n      }\n      if (tagEnd) {\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n      j += 1;\n    }\n  } /** end parse */\n}\n\nexport { Parser, decodeEntities as decode };","map":null,"metadata":{},"sourceType":"module"}