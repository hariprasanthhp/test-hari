{"ast":null,"code":"import { toPoint } from '../../util/Event';\nimport { getMidPoint, pointsAligned } from '../../util/Geometry';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate } from 'tiny-svg';\nimport { rotate, translate } from '../../util/SvgTransformUtil';\nimport { getApproxIntersection } from '../../util/LineIntersection';\nexport var BENDPOINT_CLS = 'djs-bendpoint';\nexport var SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';\nexport function toCanvasCoordinates(canvas, event) {\n  var position = toPoint(event),\n    clientRect = canvas._container.getBoundingClientRect(),\n    offset;\n\n  // canvas relative position\n\n  offset = {\n    x: clientRect.left,\n    y: clientRect.top\n  };\n\n  // update actual event payload with canvas relative measures\n\n  var viewbox = canvas.viewbox();\n  return {\n    x: viewbox.x + (position.x - offset.x) / viewbox.scale,\n    y: viewbox.y + (position.y - offset.y) / viewbox.scale\n  };\n}\nexport function getConnectionIntersection(canvas, waypoints, event) {\n  var localPosition = toCanvasCoordinates(canvas, event),\n    intersection = getApproxIntersection(waypoints, localPosition);\n  return intersection;\n}\nexport function addBendpoint(parentGfx, cls) {\n  var groupGfx = svgCreate('g');\n  svgClasses(groupGfx).add(BENDPOINT_CLS);\n  svgAppend(parentGfx, groupGfx);\n  var visual = svgCreate('circle');\n  svgAttr(visual, {\n    cx: 0,\n    cy: 0,\n    r: 4\n  });\n  svgClasses(visual).add('djs-visual');\n  svgAppend(groupGfx, visual);\n  var hit = svgCreate('circle');\n  svgAttr(hit, {\n    cx: 0,\n    cy: 0,\n    r: 10\n  });\n  svgClasses(hit).add('djs-hit');\n  svgAppend(groupGfx, hit);\n  if (cls) {\n    svgClasses(groupGfx).add(cls);\n  }\n  return groupGfx;\n}\nfunction createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {\n  var draggerGfx = svgCreate('g');\n  svgAppend(parentGfx, draggerGfx);\n  var width = 14,\n    height = 3,\n    padding = 11,\n    hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment),\n    hitHeight = height + padding;\n  var visual = svgCreate('rect');\n  svgAttr(visual, {\n    x: -width / 2,\n    y: -height / 2,\n    width: width,\n    height: height\n  });\n  svgClasses(visual).add('djs-visual');\n  svgAppend(draggerGfx, visual);\n  var hit = svgCreate('rect');\n  svgAttr(hit, {\n    x: -hitWidth / 2,\n    y: -hitHeight / 2,\n    width: hitWidth,\n    height: hitHeight\n  });\n  svgClasses(hit).add('djs-hit');\n  svgAppend(draggerGfx, hit);\n  rotate(draggerGfx, alignment === 'v' ? 90 : 0, 0, 0);\n  return draggerGfx;\n}\nexport function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {\n  var groupGfx = svgCreate('g'),\n    mid = getMidPoint(segmentStart, segmentEnd),\n    alignment = pointsAligned(segmentStart, segmentEnd);\n  svgAppend(parentGfx, groupGfx);\n  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);\n  svgClasses(groupGfx).add(SEGMENT_DRAGGER_CLS);\n  svgClasses(groupGfx).add(alignment === 'h' ? 'horizontal' : 'vertical');\n  translate(groupGfx, mid.x, mid.y);\n  return groupGfx;\n}\n\n/**\n * Calculates region for segment move which is 2/3 of the full segment length\n * @param {number} segmentLength\n *\n * @return {number}\n */\nexport function calculateSegmentMoveRegion(segmentLength) {\n  return Math.abs(Math.round(segmentLength * 2 / 3));\n}\n\n// helper //////////\n\nfunction calculateHitWidth(segmentStart, segmentEnd, alignment) {\n  var segmentLengthXAxis = segmentEnd.x - segmentStart.x,\n    segmentLengthYAxis = segmentEnd.y - segmentStart.y;\n  return alignment === 'h' ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);\n}","map":null,"metadata":{},"sourceType":"module"}