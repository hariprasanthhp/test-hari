{"ast":null,"code":"import { assign, find, isArray, without } from 'min-dash';\nimport { getOrientation, getMid } from './LayoutUtil';\nimport { pointInRect, pointDistance, pointsAligned, pointsOnLine } from '../util/Geometry';\nvar MIN_SEGMENT_LENGTH = 20,\n  POINT_ORIENTATION_PADDING = 5;\nvar round = Math.round;\nvar INTERSECTION_THRESHOLD = 20,\n  ORIENTATION_THRESHOLD = {\n    'h:h': 20,\n    'v:v': 20,\n    'h:v': -10,\n    'v:h': -10\n  };\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n  var startDirection = directions.split(':')[0];\n  var xmid = round((b.x - a.x) / 2 + a.x),\n    ymid = round((b.y - a.y) / 2 + a.y);\n  var segmentEnd, segmentDirections;\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n    layoutHorizontal = /h|r|l/.test(startDirection),\n    layoutTurn = false;\n  var turnNextDirections = false;\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? {\n      x: xmid,\n      y: a.y\n    } : {\n      x: a.x,\n      y: ymid\n    };\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n    if (layoutTurn) {\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions: segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\nfunction getMidSegment(startSegment, endSegment) {\n  var startDirection = startSegment.directions.split(':')[1],\n    endDirection = endSegment.directions.split(':')[0];\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n  var directions = startDirection + ':' + endDirection;\n  var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions);\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\nfunction getSimpleBendpoints(a, b, directions) {\n  var xmid = round((b.x - a.x) / 2 + a.x),\n    ymid = round((b.y - a.y) / 2 + a.y);\n\n  // one point, right or left from a\n  if (directions === 'h:v') {\n    return [{\n      x: b.x,\n      y: a.y\n    }];\n  }\n\n  // one point, above or below a\n  if (directions === 'v:h') {\n    return [{\n      x: a.x,\n      y: b.y\n    }];\n  }\n\n  // vertical segment between a and b\n  if (directions === 'h:h') {\n    return [{\n      x: xmid,\n      y: a.y\n    }, {\n      x: xmid,\n      y: b.y\n    }];\n  }\n\n  // horizontal segment between a and b\n  if (directions === 'v:v') {\n    return [{\n      x: a.x,\n      y: ymid\n    }, {\n      x: b.x,\n      y: ymid\n    }];\n  }\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param  {Point} a\n * @param  {Point} b\n * @param  {string} directions\n *\n * @return {Array<Point>}\n */\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n  if (!isValidDirections(directions)) {\n    throw new Error('unknown directions: <' + directions + '>: ' + 'must be specified as <start>:<end> ' + 'with start/end in { h,v,t,r,b,l }');\n  }\n\n  // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n      endSegment = getEndSegment(a, b, directions),\n      midSegment = getMidSegment(startSegment, endSegment);\n    return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);\n  }\n\n  // handle simple [hv]:[hv] cases that can be easily computed\n  return getSimpleBendpoints(a, b, directions);\n}\n\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @param {string} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\n *\n * @return {Array<Point>}\n */\nexport function connectPoints(a, b, directions) {\n  var points = getBendpoints(a, b, directions);\n  points.unshift(a);\n  points.push(b);\n  return withoutRedundantPoints(points);\n}\n\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Bounds} source source rectangle\n * @param {Bounds} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n *\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking=source] preserve docking on selected side\n * @param {Array<string>} [hints.preferredLayouts]\n * @param {Point|boolean} [hints.connectionStart] whether the start changed\n * @param {Point|boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Array<Point>} connection points\n */\nexport function connectRectangles(source, target, start, end, hints) {\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n  var orientation = getOrientation(source, target, threshold);\n  var directions = getDirections(orientation, preferredLayout);\n  start = start || getMid(source);\n  end = end || getMid(target);\n  var directionSplit = directions.split(':');\n\n  // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n    endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n  return connectPoints(startDocking, endDocking, directions);\n}\n\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Array<Point>} [waypoints]\n * @param {Object} [hints]\n * @param {Array<string>} [hints.preferredLayouts] list of preferred layouts\n * @param {boolean} [hints.connectionStart]\n * @param {boolean} [hints.connectionEnd]\n *\n * @return {Array<Point>} repaired waypoints\n */\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n    start = getMid(source);\n    end = getMid(target);\n  }\n  hints = assign({\n    preferredLayouts: []\n  }, hints);\n  waypoints = waypoints || [];\n  var preferredLayouts = hints.preferredLayouts,\n    preferStraight = preferredLayouts.indexOf('straight') !== -1,\n    repairedWaypoints;\n\n  // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n\n  // attempt to layout a straight line\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from end\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from start\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // or whether nothing seems to have changed\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  }\n\n  // simply reconnect if nothing else worked\n  return connectRectangles(source, target, start, end, hints);\n}\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n\n/**\n * Layout a straight connection\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n *\n * @return {Array<Point>|null} waypoints if straight layout worked\n */\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n    primaryAxis,\n    orientation;\n  orientation = getOrientation(source, target);\n\n  // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n  if (hints.preserveDocking === 'target') {\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n    axis[primaryAxis] = end[primaryAxis];\n    return [{\n      x: axis.x !== undefined ? axis.x : start.x,\n      y: axis.y !== undefined ? axis.y : start.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y\n      }\n    }, {\n      x: end.x,\n      y: end.y\n    }];\n  } else {\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n    axis[primaryAxis] = start[primaryAxis];\n    return [{\n      x: start.x,\n      y: start.y\n    }, {\n      x: axis.x !== undefined ? axis.x : end.x,\n      y: axis.y !== undefined ? axis.y : end.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y\n      }\n    }];\n  }\n}\n\n/**\n * Repair a connection from start.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n\n/**\n * Repair a connection from end.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n  return waypoints ? waypoints.reverse() : null;\n}\n\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>} the repaired points between the two rectangles\n */\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n  function needsRelayout(points) {\n    if (points.length < 3) {\n      return true;\n    }\n    if (points.length > 4) {\n      return false;\n    }\n\n    // relayout if two points overlap\n    // this is most likely due to\n    return !!find(points, function (p, idx) {\n      var q = points[idx - 1];\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n    var alignment = pointsAligned(oldPeer, candidate);\n    switch (alignment) {\n      case 'v':\n        // repair horizontal alignment\n        return {\n          x: newPeer.x,\n          y: candidate.y\n        };\n      case 'h':\n        // repair vertical alignment\n        return {\n          x: candidate.x,\n          y: newPeer.y\n        };\n    }\n    return {\n      x: candidate.x,\n      y: candidate.y\n    };\n  }\n  function removeOverlapping(points, a, b) {\n    var i;\n    for (i = points.length - 2; i !== 0; i--) {\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) || pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n    return points;\n  }\n\n  // (0) only repair what has layoutable bendpoints\n\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n  if (needsRelayout(points)) {\n    return null;\n  }\n  var oldDocking = points[0],\n    newPoints = points.slice(),\n    slicedPoints;\n\n  // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\n\n  // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n  if (slicedPoints !== newPoints) {\n    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  // (4) do NOT repair if repaired bendpoints are aligned\n  if (newPoints && pointsAligned(newPoints)) {\n    return null;\n  }\n  return newPoints;\n}\n\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n *\n *\n * @param {string} orientation\n * @param {string} defaultLayout\n *\n * @return {string}\n */\nfunction getDirections(orientation, defaultLayout) {\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n  switch (orientation) {\n    case 'intersect':\n      return 't:t';\n    case 'top':\n    case 'bottom':\n      return 'v:v';\n    case 'left':\n    case 'right':\n      return 'h:h';\n\n    // 'top-left'\n    // 'top-right'\n    // 'bottom-left'\n    // 'bottom-right'\n    default:\n      return defaultLayout;\n  }\n}\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right'\n  }[orientation];\n}\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n  if (dockingDirection === 't') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y\n    };\n  }\n  if (dockingDirection === 'r') {\n    return {\n      original: point,\n      x: rectangle.x + rectangle.width,\n      y: point.y\n    };\n  }\n  if (dockingDirection === 'b') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y + rectangle.height\n    };\n  }\n  if (dockingDirection === 'l') {\n    return {\n      original: point,\n      x: rectangle.x,\n      y: point.y\n    };\n  }\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param  {Array<Point>} waypoints\n *\n * @return {Array<Point>}\n */\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function (points, p, idx) {\n    var previous = points[points.length - 1],\n      next = waypoints[idx + 1];\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n    return points;\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}