{"ast":null,"code":"import inherits from 'inherits';\nimport CreateMoveSnapping from 'diagram-js/lib/features/snapping/CreateMoveSnapping';\nimport { isSnapped, setSnapped, topLeft, bottomRight } from 'diagram-js/lib/features/snapping/SnapUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nimport { asTRBL, getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport { getBoundaryAttachment } from './BpmnSnappingUtil';\nimport { forEach } from 'min-dash';\nvar HIGH_PRIORITY = 1500;\n\n/**\n * Snap during create and move.\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function BpmnCreateMoveSnapping(eventBus, injector) {\n  injector.invoke(CreateMoveSnapping, this);\n\n  // creating first participant\n  eventBus.on(['create.move', 'create.end'], HIGH_PRIORITY, setSnappedIfConstrained);\n\n  // snap boundary events\n  eventBus.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      canExecute = context.canExecute,\n      target = context.target;\n    var canAttach = canExecute && (canExecute === 'attach' || canExecute.attach);\n    if (canAttach && !isSnapped(event)) {\n      snapBoundaryEvent(event, target);\n    }\n  });\n}\ninherits(BpmnCreateMoveSnapping, CreateMoveSnapping);\nBpmnCreateMoveSnapping.$inject = ['eventBus', 'injector'];\nBpmnCreateMoveSnapping.prototype.initSnap = function (event) {\n  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event);\n  var shape = event.shape;\n  var isMove = !!this._elementRegistry.get(shape.id);\n\n  // snap to docking points\n  forEach(shape.outgoing, function (connection) {\n    var docking = connection.waypoints[0];\n    docking = docking.original || docking;\n    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));\n  });\n  forEach(shape.incoming, function (connection) {\n    var docking = connection.waypoints[connection.waypoints.length - 1];\n    docking = docking.original || docking;\n    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));\n  });\n  if (is(shape, 'bpmn:Participant')) {\n    // snap to borders with higher priority\n    snapContext.setSnapLocations(['top-left', 'bottom-right', 'mid']);\n  }\n  return snapContext;\n};\nBpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target) {\n  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);\n  var snapTargets = this.getSnapTargets(shape, target);\n  forEach(snapTargets, function (snapTarget) {\n    // handle TRBL alignment\n    //\n    // * with container elements\n    // * with text annotations\n    if (isContainer(snapTarget) || areAll([shape, snapTarget], 'bpmn:TextAnnotation')) {\n      snapPoints.add('top-left', topLeft(snapTarget));\n      snapPoints.add('bottom-right', bottomRight(snapTarget));\n    }\n  });\n  var elementRegistry = this._elementRegistry;\n\n  // snap to docking points if not create mode\n  forEach(shape.incoming, function (connection) {\n    if (elementRegistry.get(shape.id)) {\n      if (!includes(snapTargets, connection.source)) {\n        snapPoints.add('mid', getMid(connection.source));\n      }\n      var docking = connection.waypoints[0];\n      snapPoints.add(connection.id + '-docking', docking.original || docking);\n    }\n  });\n  forEach(shape.outgoing, function (connection) {\n    if (elementRegistry.get(shape.id)) {\n      if (!includes(snapTargets, connection.target)) {\n        snapPoints.add('mid', getMid(connection.target));\n      }\n      var docking = connection.waypoints[connection.waypoints.length - 1];\n      snapPoints.add(connection.id + '-docking', docking.original || docking);\n    }\n  });\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);\n  }\n  return snapPoints;\n};\nBpmnCreateMoveSnapping.prototype.getSnapTargets = function (shape, target) {\n  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function (snapTarget) {\n    // do not snap to lanes\n    return !is(snapTarget, 'bpmn:Lane');\n  });\n};\n\n// helpers //////////\n\nfunction snapBoundaryEvent(event, target) {\n  var targetTRBL = asTRBL(target);\n  var direction = getBoundaryAttachment(event, target);\n  var context = event.context,\n    shape = context.shape;\n  var offset;\n  if (shape.parent) {\n    offset = {\n      x: 0,\n      y: 0\n    };\n  } else {\n    offset = getMid(shape);\n  }\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top - offset.y);\n  } else if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom - offset.y);\n  }\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left - offset.x);\n  } else if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right - offset.x);\n  }\n}\nfunction areAll(elements, type) {\n  return elements.every(function (el) {\n    return is(el, type);\n  });\n}\nfunction isContainer(element) {\n  if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {\n    return true;\n  }\n  return is(element, 'bpmn:Participant');\n}\nfunction setSnappedIfConstrained(event) {\n  var context = event.context,\n    createConstraints = context.createConstraints;\n  if (!createConstraints) {\n    return;\n  }\n  var top = createConstraints.top,\n    right = createConstraints.right,\n    bottom = createConstraints.bottom,\n    left = createConstraints.left;\n  if (left && left >= event.x || right && right <= event.x) {\n    setSnapped(event, 'x', event.x);\n  }\n  if (top && top >= event.y || bottom && bottom <= event.y) {\n    setSnapped(event, 'y', event.y);\n  }\n}\nfunction includes(array, value) {\n  return array.indexOf(value) !== -1;\n}\nfunction getDockingSnapOrigin(docking, isMove, event) {\n  return isMove ? {\n    x: docking.x - event.x,\n    y: docking.y - event.y\n  } : {\n    x: docking.x,\n    y: docking.y\n  };\n}","map":null,"metadata":{},"sourceType":"module"}