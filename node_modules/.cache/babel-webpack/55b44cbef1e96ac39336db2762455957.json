{"ast":null,"code":"import { DatePipe, TitleCasePipe } from '@angular/common';\nimport * as moment from 'moment';\nimport { DateTime } from \"luxon\";\nimport * as Highcharts from 'highcharts';\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/support/support-traffic-reports/service/fa-utils.service\";\nimport * as i2 from \"src/app/shared-utils/date-utils.service\";\nimport * as i3 from \"src/app/shared/services/export-excel.service\";\nimport * as i4 from \"src/app/shared/services/custom-translate.service\";\nimport * as i5 from \"src/app/sys-admin/services/common.service\";\nimport * as i6 from \"src/app/shared/services/convertor.service\";\nimport * as i7 from \"@angular/router\";\nimport * as i8 from \"src/app/shared/services/sso-auth.service\";\nimport * as i9 from \"../network/reports/network-report-api.service\";\nexport let ChartOptionsService = /*#__PURE__*/(() => {\n  class ChartOptionsService {\n    constructor(utils, dateUtils, excel, customTranslateService, commonOrgService, convert, router, sso, service) {\n      this.utils = utils;\n      this.dateUtils = dateUtils;\n      this.excel = excel;\n      this.customTranslateService = customTranslateService;\n      this.commonOrgService = commonOrgService;\n      this.convert = convert;\n      this.router = router;\n      this.sso = sso;\n      this.service = service;\n      this.btnDisabled = false;\n      this.language = this.customTranslateService.defualtLanguage;\n      this.customTranslateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n    }\n    makeOptionsForNWTraffic(data, params, module) {\n      var _a, _b;\n      let that = this;\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      let upUsage,\n        upUsageTotal = 0,\n        downUsage,\n        downUsageTotal = 0;\n      let pipe = new DatePipe('en-US');\n      // let timezoneName = 'UTC';\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let title = '',\n        subTitle = '';\n      let fileName = \"\";\n      let criteria = params.criteriaSelected ? params.criteriaSelected : 'usage';\n      let granularity = this.getGranularity(params.startDate, params.endDate);\n      timezoneName = \"Coordinated Universal Time\";\n      if (data.length) {\n        for (let i = 0; i < data.length; i++) {\n          let period = this.getDateTime(data[i].startPeriodSec, false, 'MM/dd/yyyy');\n          if (granularity === '1hour') {\n            period = this.getDateTime(data[i].startPeriodSec, false, 'MM/dd HH:mm');\n          }\n          categories.push(period);\n          seriesData1.push(data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : null);\n          seriesData2.push(data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : null);\n          upUsageTotal += data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : 0;\n          downUsageTotal += data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : 0;\n        }\n      }\n      let upUsageUnit = this.getStackedUnit(upUsageTotal);\n      let downUsageUnit = this.getStackedUnit(downUsageTotal);\n      upUsage = (upUsageTotal / upUsageUnit[0]).toFixed(2) + ' ' + upUsageUnit[1];\n      downUsage = (downUsageTotal / downUsageUnit[0]).toFixed(2) + ' ' + downUsageUnit[1];\n      if (module && module == 'locations') {\n        fileName = \"Location_Traffic\";\n        title = this.language.locationsTrafficTitle;\n        let locationParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      } else if (module && module == 'applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        fileName = \"Application_Traffic\";\n        title = this.language['Application Traffic'];\n        let locationParams = '';\n        let appParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        appParams = this.getTitleApplicationNames(params['applicationsSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.application}: ${appParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      } else if (module && module == 'applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n        fileName = \"Application_Groups_Traffic\";\n        title = this.language['Application Groups Traffic'];\n        let locationParams = '';\n        let appParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        appParams = this.getTitleApplicationNames(params['applicationGroupSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.applicationGroup}: ${appParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      } else {\n        fileName = \"Network_Traffic\";\n        title = this.language.networkTrafficTitle;\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      }\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: title\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories,\n          labels: {\n            style: {\n              textOverflow: 'ellipsis'\n            }\n          }\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          opposite: false,\n          tickLength: 2,\n          minRange: 1,\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n              s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' : ' ' + unit[1]);\n              return s;\n            }\n          }\n        },\n        legend: {\n          reversed: false\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            minPointLength: 3,\n            colors: [\"#0027FF\", \"#5ACFEA\"]\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var unit = that.getStackedUnit(m);\n            var s = `<b>  ${this.x} </b><br/>\n          <p> ${this.series.name} <span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p>`;\n            return s;\n          }\n        },\n        series: [{\n          name: this.language['Up Usage'] ? this.language['Up Usage'] : 'Up Usage',\n          data: seriesData1,\n          color: \"#0027FF\"\n        }, {\n          name: this.language['Down Usage'] ? this.language['Down Usage'] : 'Down Usage',\n          data: seriesData2,\n          color: \"#5ACFEA\"\n        }],\n        exporting: {\n          filename: fileName,\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  var _a, _b;\n                  let dataExport = [];\n                  let extraData = '';\n                  let subsId = '';\n                  if (module && module == 'locations') {\n                    let locationParams = params['locationsSelectedNames'];\n                    extraData = `Locations Traffic\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\\r\\n`;\n                  } else if (module && module == 'applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                    let locationParams = params['locationsSelectedNames'];\n                    let appParams = params['applicationsSelectedNames'];\n                    extraData = `Applications Traffic\\r\\nApplications: ${appParams}\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\n                  \\r\\n`;\n                  } else if (module && module == 'applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    let locationParams = params['locationsSelectedNames'];\n                    let appParams = params['applicationGroupSelectedNames'];\n                    extraData = `Application Groups Traffic\\r\\nApplication Groups: ${appParams}\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\n                  \\r\\n`;\n                  } else {\n                    extraData = `Network Traffic\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}] \\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\n                  \\r\\n`;\n                  }\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.getDateTime(data[i].startPeriodSec, false, granularity === \"1hour\" ? 'MM/dd HH:mm' : \"MM/dd/yyyy\"),\n                      'Up Usage(Bytes)': data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets.toLocaleString() : 0,\n                      'Down Usage(Bytes)': data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets.toLocaleString() : 0\n                    });\n                  }\n                  that.excel.downLoadCSV(fileName, dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        }\n      };\n      return options;\n    }\n    makeOptionsForLineChart(data, params, module) {\n      var _a, _b;\n      let up = this.language['max_up_rate'];\n      let down = this.language['maxDownRate'];\n      let that = this;\n      let categories = [];\n      let upData = [];\n      let downData = [];\n      let subsId = '';\n      let fileName = \"\";\n      // let upRate: any, upRateTotal = 0, downRate: any, downRateTotal = 0;\n      let upUsage,\n        upUsageTotal = 0,\n        downUsage,\n        downUsageTotal = 0;\n      let tickInterval = 1;\n      let pipe = new DatePipe('en-US');\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].peakUsRate && data[i].peakUsRate !== -1 || data[i].peakDsRate && data[i].peakDsRate !== -1) {\n          categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd/yyyy HH:mm'));\n          upData.push(data[i].peakUsRate && data[i].peakUsRate !== -1 ? data[i].peakUsRate : null);\n          downData.push(data[i].peakDsRate && data[i].peakDsRate !== -1 ? data[i].peakDsRate : null);\n          // upRateTotal += data[i].peakUsRate ? data[i].peakUsRate : 0;\n          // downRateTotal += data[i].peakDsRate ? data[i].peakDsRate : 0;\n        }\n\n        upUsageTotal += data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : 0;\n        downUsageTotal += data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : 0;\n      }\n      if (categories && categories.length <= 45) {\n        tickInterval = 1;\n      } else if (categories && categories.length > 45) {\n        tickInterval = Math.floor(categories.length / 45);\n      }\n      // if (categories.length > 90) {\n      //   tickInterval = 14;\n      // } else if (categories.length > 50) {\n      //   tickInterval = 7;\n      // }\n      // upRate = this.utils.bitsToSize(upRateTotal, true);\n      // downRate = this.utils.bitsToSize(downRateTotal, true);\n      let upUsageUnit = this.getStackedUnit(upUsageTotal);\n      let downUsageUnit = this.getStackedUnit(downUsageTotal);\n      upUsage = (upUsageTotal / upUsageUnit[0]).toFixed(2) + ' ' + upUsageUnit[1];\n      downUsage = (downUsageTotal / downUsageUnit[0]).toFixed(2) + ' ' + downUsageUnit[1];\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      // let timezoneName = \"Coordinated Universal Time\";\n      let title,\n        subTitle = ``;\n      let startTime = ``;\n      let endTime = ``;\n      let startDate = this.service.getStartUTCDate(params.startDate, 0);\n      let endDate = this.service.getEndUTCDate(params.endDate);\n      let dayDiff = moment(endDate).diff(moment(startDate), \"days\");\n      if (params.criteriaSelected != 'usage' && dayDiff <= 3) {\n        startTime = params.startTime >= 48 ? params.startTime - 48 : params.startTime >= 24 ? params.startTime - 24 : params.startTime;\n        endTime = params.endTime > 48 ? params.endTime - 48 : params.endTime > 24 ? params.endTime - 24 : params.endTime;\n        startTime = startTime.toString().length < 2 ? `0${startTime}:00` : `${startTime}:00`;\n        endTime = endTime.toString().length < 2 ? `0${endTime}:00` : `${endTime}:00`;\n        params.startDate = params.APIStartDate;\n        params.endDate = this.getISOEndOfDay(params.APIendDate, endTime);\n      }\n      if (module && module == 'locations') {\n        fileName = \"Location_Traffic\";\n        title = this.language.locationsTrafficTitle;\n        let locationParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      } else if (module && module == 'applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        fileName = \"Application_Traffic\";\n        title = this.language['Application Traffic'];\n        let locationParams = '';\n        let appParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        appParams = this.getTitleApplicationNames(params['applicationsSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.application}: ${appParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      } else if (module && module == 'applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n        fileName = \"Application_Groups_Traffic\";\n        title = this.language['Application Groups Traffic'];\n        let locationParams = '';\n        let appParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        appParams = this.getTitleApplicationNames(params['applicationGroupSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.application}: ${appParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      } else {\n        fileName = \"Network_Traffic\";\n        title = this.language.networkTrafficTitle;\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]</span>\n    <br><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: ${upUsage}</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: ${downUsage}</span>`;\n      }\n      let options = {\n        chart: {\n          type: 'line',\n          zoomType: \"xy\"\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: title\n        },\n        subtitle: {\n          text: subTitle\n        },\n        mapNavigation: {\n          enableMouseWheelZoom: true\n        },\n        xAxis: {\n          categories: categories ? categories : [],\n          tickInterval: tickInterval,\n          labels: {\n            style: {\n              textOverflow: 'ellipsis'\n            },\n            allowOverlap: false,\n            maxStaggerLines: 1,\n            formatter: function () {\n              let label = this.value;\n              if (this.isLast) {\n                let len = this.axis.categories.length;\n                label = this.axis.categories[len - 1];\n              }\n              return label;\n            }\n          }\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              return that.bitsToSize(this.value, false);\n            }\n          },\n          min: 0,\n          minRange: 1\n        },\n        legend: {\n          align: 'center',\n          verticalAlign: 'bottom',\n          layout: 'horizontal',\n          symbolRadius: 0\n        },\n        tooltip: {\n          formatter: function () {\n            var unit = that.utils.bitsToSize(this.y, false);\n            var s = `<b>${this.x}</b><br/>\n          <p>${this.series.name} <span>:<b> ${unit} </b><br/></span></p>`;\n            return s;\n          }\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        plotOptions: {\n          series: {\n            marker: {\n              enabled: (upData === null || upData === void 0 ? void 0 : upData.length) == 1 || (downData === null || downData === void 0 ? void 0 : downData.length) == 1 ? true : false\n            }\n          },\n          column: {\n            stacking: 'normal',\n            dataLabels: {\n              enabled: false\n              //color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'\n            }\n          }\n        },\n\n        series: [{\n          name: up,\n          color: '#0027FF',\n          data: upData ? upData : []\n        }, {\n          name: down,\n          color: '#5ACFEA',\n          data: downData ? downData : []\n        }],\n        exporting: {\n          filename: fileName,\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  var _a, _b;\n                  let dataExport = [];\n                  let extraData = '';\n                  let subsId = '';\n                  if (module && module == 'locations') {\n                    let locationParams = params['locationsSelectedNames'];\n                    extraData = `Locations Traffic\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]\\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\\r\\n`;\n                  } else if (module && module == 'applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                    let locationParams = params['locationsSelectedNames'];\n                    let appParams = params['applicationsSelectedNames'];\n                    extraData = `Applications Traffic\\r\\nApplications: ${appParams}\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]\\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\n                  \\r\\n`;\n                  } else if (module && module == 'applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    let locationParams = params['locationsSelectedNames'];\n                    let appParams = params['applicationGroupSelectedNames'];\n                    extraData = `Application Groups Traffic\\r\\nApplication Groups: ${appParams}\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]\\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\n                  \\r\\n`;\n                  } else {\n                    extraData = `Network Traffic\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}] \\r\\nUp Usage: ${upUsage},Down Usage: ${downUsage}\n                  \\r\\n`;\n                  }\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.getDateTime(data[i].startPeriodSec, true, 'MM/dd/yyyy HH:mm'),\n                      'Max Up Rate(bps)': data[i].peakUsRate && data[i].peakUsRate !== -1 ? data[i].peakUsRate.toLocaleString() : 0,\n                      'Max Down Rate(bps)': data[i].peakDsRate && data[i].peakDsRate !== -1 ? data[i].peakDsRate.toLocaleString() : 0\n                    });\n                  }\n                  that.excel.downLoadCSV(fileName, dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        }\n      };\n      return options;\n    }\n    makeOptionsForApplications(data, type, params, module) {\n      let that = this;\n      let categories = [];\n      let seriesData = [];\n      let direction = \"\";\n      let fileName = \"\";\n      let pipe = new DatePipe('en-US');\n      // let timezoneName = 'Coordinated Universal Time';\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      if (params['criteriaSelected'] == 'usage') {\n        timezoneName = 'Coordinated Universal Time';\n      }\n      let title = '',\n        subTitle = '';\n      direction = this.getSelectDirectionName(params.directionSelected);\n      if (module && module == 'locations') {\n        fileName = params.groupSelected == 'no' ? \"Location_Top_Applications\" : \"Location_Top_Application_Groups\";\n        title = this.language.location + ' ' + (params.groupSelected == 'no' ? this.language.Top_Appln : this.language.Top_Application + ' ' + this.language.Groups);\n        let locationParams = '';\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params.directionSelected ? direction : ''}</span>`;\n      } else {\n        fileName = params.groupSelected == 'no' ? \"Network_Top_Applications\" : \"Network_Top_Application_Groups\";\n        title = this.language.network + ' ' + (params.groupSelected == 'no' ? this.language.Top_Appln : this.language.Top_Application + ' ' + this.language.Groups);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params.directionSelected ? direction : ''}</span>`;\n      }\n      let percentage = this.arraysObjectsPercentageCalculator;\n      let options = {\n        chart: {\n          type: type,\n          zoomType: \"xy\",\n          events: {\n            load: function () {\n              that.axisLabelClickEvent(this);\n            }\n          }\n        },\n        title: {\n          text: title\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories,\n          labels: {\n            style: {\n              // cursor: 'pointer',\n              textOverflow: \"ellipsis\",\n              overflow: \"hidden\",\n              fontSize: '13px',\n              fontWeight: 500\n            },\n            formatter: function () {\n              return that.showLabel(this.value);\n            },\n            events: {\n              click: function () {\n                let xAxisValue = this.axis.categories[this.pos];\n                that.navigateByUrl(data, xAxisValue, params, 'App');\n              }\n            }\n          }\n        },\n        yAxis: {\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              if (params['criteriaSelected'] == 'usage') {\n                var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n                s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' + unit[1] : '');\n                ;\n              } else {\n                var unit = m > 1000000000000 ? [1000000000000, 'Tbps'] : m > 1000000000 ? [1000000000, 'Gbps'] : m > 1000000 ? [1000000, 'Mbps'] : m > 1000 ? [1000, 'Kbps'] : [1, 'bps'];\n                s = (y.isFirst ? 0 : (y.value / unit[0]).toFixed(1)) + (y.isFirst ? ' ' + unit[1] : '');\n              }\n              return s;\n            }\n          },\n          min: 0,\n          title: {\n            text: ''\n          }\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: false\n        },\n        credits: {\n          enabled: false\n        },\n        plotOptions: {\n          series: {\n            minPointLength: 3,\n            color: '#0027FF',\n            //colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"]\n            // cursor: 'pointer',\n            point: {\n              events: {\n                mouseOver: function () {\n                  let xAxisValue = type === 'bar' ? this.category : this.name;\n                  if (xAxisValue !== \"Unknown\" && xAxisValue !== \"Unknown Application\" && xAxisValue !== \"Unknown and Other\" && xAxisValue !== \"00000000-0000-0000-0000-000000000000\" && xAxisValue !== 'Unclassified Applications') {\n                    this.graphic.attr({\n                      cursor: 'pointer'\n                    });\n                  }\n                },\n                click: function () {\n                  let xAxisValue = type === 'bar' ? this.category : this.name;\n                  that.navigateByUrl(data, xAxisValue, params, 'App');\n                }\n              }\n            }\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var unit;\n            var s;\n            if (params['criteriaSelected'] == 'usage') {\n              unit = that.getStackedUnit(m);\n              s = `<b> ${this.key} </b><br/>\n              <p>${this.series.name}<span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p>`;\n            } else {\n              unit = that.utils.bitsToSize(m, false);\n              s = `<b> ${this.key} </b><br/>\n              <p>${this.series.name}<span>: <b>${unit}</b><br/></span></p>`;\n            }\n            return s;\n          }\n        },\n        series: [],\n        exporting: {\n          filename: fileName,\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  if (module && module == 'locations') {\n                    let locationParams = params['locationsSelectedNames'];\n                    extraData = `${params.groupSelected == 'no' ? 'Locations Top Applications' : 'Locations Top Application Groups'}\\r\\nLocations: ${locationParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection: ${params.directionSelected ? direction : ''}\n                  \\r\\n`;\n                  } else {\n                    extraData = `${params.groupSelected == 'no' ? 'Network Top Applications' : 'Network Top Application Groups'}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection: ${params.directionSelected ? direction : ''}\n                  \\r\\n`;\n                  }\n                  for (var i = 0; i < data.length; i++) {\n                    if (params['criteriaSelected'] == 'usage') {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : data[i].key,\n                        'Up Usage(Byte)': data[i].usOctets ? data[i].usOctets.toLocaleString() : 0,\n                        'Down Usage(Byte)': data[i].dsOctets ? data[i].dsOctets.toLocaleString() : 0,\n                        'Both(Down+Up) Usage(Byte)': data[i].totalOctets ? data[i].totalOctets.toLocaleString() : 0\n                      });\n                    } else {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : data[i].key,\n                        'Up Max Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate.toLocaleString() : 0,\n                        'Up Average Rate(bps)': data[i].usRate ? data[i].usRate.toLocaleString() : 0,\n                        'Down Max Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate.toLocaleString() : 0,\n                        'Down Average Rate(bps)': data[i].dsRate ? data[i].dsRate.toLocaleString() : 0\n                      });\n                    }\n                  }\n                  that.excel.downLoadCSV(fileName, dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        }\n      };\n\n      if (type === 'bar') {\n        if (params['criteriaSelected'] == 'usage') {\n          for (let i = 0; i < data.length; i++) {\n            categories.push(data[i].name ? data[i].name : data[i].key);\n            if (params.directionSelected == 'both') {\n              seriesData.push(data[i].dsOctets + data[i].usOctets);\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsOctets);\n            } else {\n              seriesData.push(data[i].usOctets);\n            }\n          }\n        } else {\n          for (let i = 0; i < data.length; i++) {\n            categories.push(data[i].name ? data[i].name : data[i].key);\n            if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsRate);\n            } else {\n              seriesData.push(data[i].usRate);\n            }\n          }\n        }\n        options.series = [{\n          name: direction + ' ' + that.language[params['criteriaSelected']],\n          data: seriesData\n        }];\n      } else if (type === 'pie') {\n        if (params['criteriaSelected'] == 'usage') {\n          for (let i = 0; i < data.length; i++) {\n            if (params.directionSelected == 'both') {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].dsOctets + data[i].usOctets\n              });\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].dsOctets\n              });\n            } else {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].usOctets\n              });\n            }\n          }\n        } else {\n          for (let i = 0; i < data.length; i++) {\n            if (params.directionSelected == 'Down') {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].dsRate\n              });\n            } else {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].usRate\n              });\n            }\n          }\n        }\n        options.series = [{\n          //colorByPoint: true,\n          data: seriesData,\n          name: that.language[params['directionSelected']]\n        }];\n        options.plotOptions.pie = {\n          size: '80%',\n          allowPointSelect: true,\n          cursor: 'pointer',\n          showInLegend: true,\n          colors: [\"#f3722c\", \"#f94144\", \"#f9c74f\", \"#f8961e\", \"#f9844a\", \"#90be6d\", \"#43aa8b\", \"#4d908e\", \"#577590\", \"#277da1\", \"#4361ee\", \"#bc4749\", \"#affc41\", \"#d4a373\", \"#8d99ae\", \"#c9ada7\", \"#735d78\", \"#403d39\", \"#d8d78f\", \"#43bccd\", \"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n          dataLabels: {\n            enabled: true,\n            formatter: function () {\n              let arrayofUsage = [];\n              seriesData.forEach(el => {\n                arrayofUsage.push(+el.y);\n              });\n              return `<b>${seriesData[this.point.x].name} ${percentage(arrayofUsage, seriesData[this.point.x].y, 1)} % </b> <br/>`;\n            }\n          }\n        };\n      }\n      return options;\n    }\n    makeOptionsForLocations(data, type, params, module) {\n      var _a, _b;\n      let that = this;\n      let categories = [];\n      let seriesData = [];\n      let direction = this.language.DOWN;\n      let pipe = new DatePipe('en-US');\n      // let timezoneName = 'Coordinated Universal Time';\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      if (params['criteriaSelected'] == 'usage') {\n        timezoneName = 'Coordinated Universal Time';\n      }\n      let title = '',\n        subTitle = '';\n      let fileName = \"\";\n      if (params.directionSelected == 'both') {\n        data = this.commonOrgService.sortByColumn(data, 'desc', 'totalOctets', true);\n        direction = this.language['Both(Down+Up)'];\n      } else if (params.directionSelected == 'Down') {\n        data = this.commonOrgService.sortByColumn(data, 'desc', 'dsOctets', true);\n        direction = this.language['Down'];\n      } else {\n        data = this.commonOrgService.sortByColumn(data, 'desc', 'usOctets', true);\n        direction = this.language['Up'];\n      }\n      if (module && module == 'applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        fileName = \"Application_Top_Locations\";\n        title = this.language['Application'] + ' ' + this.language['appsTopLocsTitle'];\n        let appParams = '';\n        appParams = this.getTitleApplicationNames(params['applicationsSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.application}: ${appParams}</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${direction ? direction : ''}</span>`;\n      } else if (module && module == 'applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n        fileName = \"Application_Groups_Top_Locations\";\n        title = this.language['applicationgroups'] + ' ' + this.language['appsTopLocsTitle'];\n        let appParams = '';\n        appParams = this.getTitleApplicationNames(params['applicationGroupSelectedNames']);\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.applicationgroups}: ${appParams}</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${direction ? direction : ''}</span>`;\n      } else {\n        fileName = \"Network_Top_Locations\";\n        title = this.language.network + ' ' + this.language.networkTopLocsTitle;\n        subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>\n      <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${direction ? direction : ''}</span>`;\n      }\n      let options = {\n        chart: {\n          type: type,\n          zoomType: \"xy\",\n          events: {\n            load: function () {\n              that.axisLabelClickEvent(this);\n            }\n          }\n        },\n        title: {\n          text: title\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories,\n          labels: {\n            style: {\n              // cursor: 'pointer',\n              textOverflow: \"ellipsis\",\n              overflow: \"hidden\",\n              fontSize: '13px',\n              fontWeight: 500\n            },\n            formatter: function () {\n              return that.showLabel(this.value);\n            },\n            events: {\n              click: function () {\n                let xAxisValue = this.axis.categories[this.pos];\n                that.navigateByUrl(data, xAxisValue, params, 'Loc');\n              }\n            }\n          }\n        },\n        yAxis: {\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              if (params['criteriaSelected'] == 'usage') {\n                var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n                s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' + unit[1] : '');\n                ;\n              } else {\n                var unit = m > 1000000000000 ? [1000000000000, 'Tbps'] : m > 1000000000 ? [1000000000, 'Gbps'] : m > 1000000 ? [1000000, 'Mbps'] : m > 1000 ? [1000, 'Kbps'] : [1, 'bps'];\n                s = (y.isFirst ? 0 : (y.value / unit[0]).toFixed(1)) + (y.isFirst ? ' ' + unit[1] : '');\n              }\n              return s;\n            }\n          },\n          min: 0,\n          title: {\n            text: ''\n          },\n          minRange: 1\n        },\n        legend: {\n          reversed: true\n        },\n        credits: {\n          enabled: false\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        plotOptions: {\n          series: {\n            minPointLength: 3,\n            color: '#0027FF',\n            //colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"]\n            // cursor: 'pointer',\n            point: {\n              events: {\n                mouseOver: function () {\n                  let xAxisValue = type === 'bar' ? this.category : this.name;\n                  if (xAxisValue !== \"Unknown\" && xAxisValue !== \"Unknown Location\" && xAxisValue !== \"Unknown and Other\" && xAxisValue !== \"00000000-0000-0000-0000-000000000000\") {\n                    this.graphic.attr({\n                      cursor: 'pointer'\n                    });\n                  }\n                },\n                click: function () {\n                  let xAxisValue = type === 'bar' ? this.category : this.name;\n                  that.navigateByUrl(data, xAxisValue, params, 'Loc');\n                }\n              }\n            }\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var unit;\n            var s;\n            if (params['criteriaSelected'] == 'usage') {\n              unit = that.getStackedUnit(m);\n              s = `<b> ${this.key} </b><br/>\n                <p>${this.series.name}<span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p>`;\n            } else {\n              unit = that.utils.bitsToSize(m, false);\n              s = `<b> ${this.key} </b><br/>\n                <p>${this.series.name}<span>: <b>${unit}</b><br/></span></p>`;\n            }\n            return s;\n          }\n        },\n        series: [],\n        exporting: {\n          filename: fileName,\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  var _a, _b;\n                  let dataExport = [];\n                  let extraData = '';\n                  if (module && module == 'applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                    let appParams = params['applicationsSelectedNames'];\n                    extraData = `Applications Top Locations\\r\\nApplications: ${appParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection: ${direction ? direction : ''}\n                  \\r\\n`;\n                  } else if (module && module == 'applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    let appParams = params['applicationGroupSelectedNames'];\n                    extraData = `Application Groups Top Locations\\r\\nApplication Group: ${appParams}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection: ${direction ? direction : ''}\n                  \\r\\n`;\n                  } else {\n                    extraData = `Network Top Locations\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection: ${direction ? direction : ''}\n                  \\r\\n`;\n                  }\n                  for (var i = 0; i < data.length; i++) {\n                    if (params['criteriaSelected'] == 'usage') {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : '',\n                        'Up Usage(Byte)': data[i].usOctets ? data[i].usOctets.toLocaleString() : 0,\n                        'Down Usage(Byte)': data[i].dsOctets ? data[i].dsOctets.toLocaleString() : 0,\n                        'Both(Down+Up) Usage(Byte)': data[i].totalOctets ? data[i].totalOctets.toLocaleString() : 0,\n                        'SubnetIPv4': data[i].subnets ? data[i].subnets : '',\n                        'SubnetIPv6': data[i].subnetsV6 ? data[i].subnetsV6 : ''\n                      });\n                    } else {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : data[i].key,\n                        'Up Max Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate.toLocaleString() : 0,\n                        'Up Average Rate(bps)': data[i].usRate ? data[i].usRate.toLocaleString() : 0,\n                        'Down Max Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate.toLocaleString() : 0,\n                        'Down Average Rate(bps)': data[i].dsRate ? data[i].dsRate.toLocaleString() : 0,\n                        'SubnetIPv4': data[i].subnets ? data[i].subnets : '',\n                        'SubnetIPv6': data[i].subnetsV6 ? data[i].subnetsV6 : ''\n                      });\n                    }\n                  }\n                  that.excel.downLoadCSV(fileName, dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        }\n      };\n\n      if (type === 'bar') {\n        if (params['criteriaSelected'] == 'usage') {\n          for (let i = 0; i < data.length; i++) {\n            categories.push(data[i].name ? data[i].name : data[i].key);\n            if (params.directionSelected == 'both') {\n              seriesData.push(data[i].totalOctets);\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsOctets);\n            } else {\n              seriesData.push(data[i].usOctets);\n            }\n          }\n        } else {\n          for (let i = 0; i < data.length; i++) {\n            categories.push(data[i].name ? data[i].name : data[i].key);\n            if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsRate);\n            } else {\n              seriesData.push(data[i].usRate);\n            }\n          }\n        }\n        options.series = [{\n          name: direction + ' ' + that.language[params['criteriaSelected']],\n          data: seriesData\n        }];\n      } else if (type === 'pie') {\n        if (params['criteriaSelected'] == 'usage') {\n          for (let i = 0; i < data.length; i++) {\n            if (params.directionSelected == 'both') {\n              seriesData.push({\n                name: data[i].name,\n                y: data[i].dsOctets + data[i].usOctets\n              });\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push({\n                name: data[i].name,\n                y: data[i].dsOctets\n              });\n            } else {\n              seriesData.push({\n                name: data[i].name,\n                y: data[i].usOctets\n              });\n            }\n          }\n        } else {\n          for (let i = 0; i < data.length; i++) {\n            if (params.directionSelected == 'Down') {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].dsRate\n              });\n            } else {\n              seriesData.push({\n                name: data[i].name ? data[i].name : data[i].key,\n                y: data[i].usRate\n              });\n            }\n          }\n        }\n        options.series = [{\n          //colorByPoint: true,\n          data: seriesData,\n          name: direction\n        }];\n        options.plotOptions.pie = {\n          allowPointSelect: true,\n          cursor: 'pointer'\n        };\n      }\n      return options;\n    }\n    convertDate(ts) {\n      var date = new Date(ts);\n      var mm = date.getMonth().toString();\n      var dd = date.getDate().toString();\n      var mmChars = mm.split('');\n      var ddChars = dd.split('');\n      return (mmChars[1] ? mm : \"0\" + mmChars[0]) + '/' + (ddChars[1] ? dd : \"0\" + ddChars[0]);\n    }\n    topSub_ChartOptions(data, params) {\n      var _a, _b;\n      let that = this;\n      let categories = [];\n      let seriesData = [];\n      let direction = this.getSelectDirectionName(params.directionSelected);\n      if (data.length) {\n        if (params['criteriaSelected'] == 'usage') {\n          for (let i = 0; i < data.length; i++) {\n            categories.push(data[i].name ? data[i].name : data[i].title ? data[i].title : data[i].key);\n            if (params.directionSelected == 'both') {\n              seriesData.push(data[i].dsOctets + data[i].usOctets);\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsOctets);\n            } else {\n              seriesData.push(data[i].usOctets);\n            }\n          }\n        } else {\n          for (let i = 0; i < data.length; i++) {\n            categories.push(data[i].name ? data[i].name : data[i].key);\n            if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsRate);\n            } else {\n              seriesData.push(data[i].usRate);\n            }\n          }\n        }\n      }\n      let titlePrefix = \"network\";\n      let addApplication = '',\n        addLocation = '';\n      let appParams = '';\n      let locationParams = '';\n      let fileName = \"Network_Top_Subscribers\";\n      if (params.From === 'Applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        fileName = \"Application_Top_Subscribers\";\n        appParams = this.getTitleApplicationNames(params['applicationsSelectedNames']);\n        addApplication = `<span style=\"font-size:16px; color:#ffffff\" >...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.Application}: ${appParams} </span >`;\n        titlePrefix = 'Application';\n      } else if (params.From === 'Applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n        fileName = \"Application_Groups_Top_Subscribers\";\n        appParams = this.getTitleApplicationNames(params['applicationGroupSelectedNames']);\n        addApplication = `<span style=\"font-size:16px; color:#ffffff\" >...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.applicationGroup}: ${appParams} </span >`;\n        titlePrefix = 'applicationGroup';\n      } else if (params.From === 'Locations') {\n        fileName = \"Location_Top_Subscribers\";\n        locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n        addLocation = `<span style=\"font-size:16px; color:#ffffff\" >...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.Location}: ${locationParams} </span >`;\n        titlePrefix = 'Location';\n      }\n      let subTitle;\n      let pipe = new DatePipe('en-US');\n      // let timezoneName = 'Coordinated Universal Time';\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      if (params['criteriaSelected'] == 'usage') {\n        timezoneName = 'Coordinated Universal Time';\n      }\n      let temp = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.criteria}: ${this.language[params['criteriaSelected']]}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]  </span>\n    <br><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.limit}: ${params['limit']} </span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params['directionSelected'] ? direction : \"\"} </span>`;\n      if (addApplication) {\n        subTitle = addApplication + temp;\n      } else if (addLocation) {\n        subTitle = addLocation + temp;\n      } else {\n        subTitle = temp;\n      }\n      let options = {\n        chart: {\n          type: 'bar',\n          zoomType: \"xy\",\n          events: {\n            load: function () {\n              that.axisLabelClickEvent(this);\n            }\n          }\n        },\n        title: {\n          text: this.language[titlePrefix] + \" \" + this.language.networkTopSubsTitle\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories,\n          labels: {\n            style: {\n              // cursor: 'pointer',\n              textOverflow: \"ellipsis\",\n              overflow: \"hidden\",\n              fontSize: '13px',\n              fontWeight: 500\n            },\n            formatter: function () {\n              return that.showLabel(this.value);\n            },\n            events: {\n              click: function (event) {\n                let xAxisValue = this.axis.categories[this.pos];\n                //that.navigateByUrl(data, xAxisValue, params, 'Sub');\n              }\n            }\n          }\n        },\n\n        yAxis: {\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              if (params['criteriaSelected'] == 'usage') {\n                var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n                s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' + unit[1] : '');\n              } else {\n                var unit = m > 1000000000000 ? [1000000000000, 'Tbps'] : m > 1000000000 ? [1000000000, 'Gbps'] : m > 1000000 ? [1000000, 'Mbps'] : m > 1000 ? [1000, 'Kbps'] : [1, 'bps'];\n                s = (y.isFirst ? 0 : (y.value / unit[0]).toFixed(1)) + (y.isFirst ? ' ' + unit[1] : '');\n              }\n              return s;\n            }\n          },\n          min: 0,\n          title: {\n            text: ''\n          },\n          opposite: false,\n          tickLength: 2,\n          minRange: 1\n          // type: 'logarithmic'\n        },\n\n        legend: {\n          reversed: false\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            minPointLength: 3,\n            color: '#0027FF',\n            // colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            // cursor: 'pointer',\n            point: {\n              events: {\n                mouseOver: function () {\n                  if (this.category !== \"Unknown\" && this.category !== \"Unknown and Other\" && this.category !== \"00000000-0000-0000-0000-000000000000\") {\n                    this.graphic.attr({\n                      cursor: 'pointer'\n                    });\n                  }\n                },\n                click: function () {\n                  let xAxisValue = this.category;\n                  let xAxisKey = data[this.index].key;\n                  that.navigateByUrl(data, xAxisValue, params, 'Sub', xAxisKey);\n                }\n              }\n            }\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            let ipAddress;\n            let macAddress;\n            let serialNumber;\n            let mappedBy;\n            data.forEach(element => {\n              if (element.name === this.x || element.title === this.x || element.key === this.x) {\n                ipAddress = element.ipAddress ? element.ipAddress : '';\n                macAddress = element.macAddress ? element.macAddress : '';\n                serialNumber = element.serialNumber ? element.serialNumber : '';\n                mappedBy = element.mappedBy ? element.mappedBy : '';\n              }\n            });\n            var m = this.y;\n            var unit;\n            var s;\n            let sub = ipAddress ? `<p>IP Address<span>: <b>${ipAddress}</b><br/></span></p> <br/>` : ``;\n            sub = sub + (serialNumber ? `<p> Serial Number<span>: <b>${serialNumber}</b><br/></span></p> <br/>` : ``);\n            sub = sub + (macAddress ? `<p> MAC Address<span>: <b>${macAddress}</b><br/></span></p> <br/>` : ``);\n            sub = sub + (mappedBy ? `<p> Mapped By<span>: <b>${mappedBy}</b><br/></span></p> <br/>` : ``);\n            if (params['criteriaSelected'] == 'usage') {\n              unit = that.getStackedUnit(m);\n              s = `<b> ${this.key} </b><br/>\n                <p>${this.series.name} <span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p> <br/>\n                ${sub}`;\n            } else {\n              unit = that.utils.bitsToSize(m, false);\n              s = `<b> ${this.key} </b><br/>\n                <p>${this.series.name} <span>: <b>${unit}</b><br/></span></p> <br/>\n                ${sub}`;\n            }\n            return s;\n          }\n        },\n        series: [],\n        exporting: {\n          filename: fileName,\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.setSize(this.chartWidth, this.chartHeight);\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  var _a, _b;\n                  let dataExport = [];\n                  let extraData = '';\n                  if (params.From === 'Applications' && ((_a = params['applicationsSelectedNames']) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                    extraData = `Applications Top Subscribers\\r\\nApplications : ${params['applicationsSelectedNames']}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLimit: ${params['limit']}\\r\\nDirection: ${params['directionSelected'] ? direction : \"\"}\\r\\n\\r\\n`;\n                  } else if (params.From === 'Applications' && ((_b = params['applicationGroupSelectedNames']) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    extraData = `Application Groups Top Subscribers\\r\\nApplication Groups : ${params['applicationGroupSelectedNames']}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLimit: ${params['limit']}\\r\\nDirection: ${params['directionSelected'] ? direction : \"\"}\\r\\n\\r\\n`;\n                  } else if (params.From === 'Locations') {\n                    extraData = `nLocations Top Subscribers\\r\\nLocations: ${params['locationsSelectedNames']}\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLimit: ${params['limit']}\\r\\nDirection: ${params['directionSelected'] ? direction : \"\"}\\r\\n\\r\\n`;\n                  } else {\n                    extraData = `Top Subscribers\\r\\nCriteria: ${that.language[params['criteriaSelected']]}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLimit: ${params['limit']}\\r\\nDirection: ${params['directionSelected'] ? direction : \"\"}\\r\\n\\r\\n`;\n                  }\n                  for (var i = 0; i < data.length; i++) {\n                    if (params['criteriaSelected'] == 'usage') {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : data[i].title ? data[i].title : data[i].key,\n                        'Up Usage(Byte)': data[i].usOctets ? data[i].usOctets.toLocaleString() : 0,\n                        'Down Usage(Byte)': data[i].dsOctets ? data[i].dsOctets.toLocaleString() : 0,\n                        'Both(Down+Up) Usage': data[i].totalOctets ? data[i].totalOctets.toLocaleString() : 0,\n                        'IP Address': data[i].ipAddress ? data[i].ipAddress : \"\",\n                        'Mapped By': data[i].mappedBy ? data[i].mappedBy : \"\",\n                        'Endpoint Title': data[i].title ? data[i].title : \"\",\n                        'Mapped Name': data[i].mappedName ? data[i].mappedName : \"\",\n                        'Radius  User Name': data[i].radiusName ? data[i].radiusName : \"\",\n                        'Serial Number': data[i].serialNumber ? data[i].serialNumber : \"\",\n                        'MAC Address': data[i].macAddress ? data[i].macAddress : \"\"\n                      });\n                    } else {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : data[i].key,\n                        'Up Max Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate.toLocaleString() : 0,\n                        'Up Average Rate(bps)': data[i].usRate ? data[i].usRate.toLocaleString() : 0,\n                        'Down Max Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate.toLocaleString() : 0,\n                        'Down Average Rate(bps)': data[i].dsRate ? data[i].dsRate.toLocaleString() : 0,\n                        'IP Address': data[i].ipAddress ? data[i].ipAddress : \"\",\n                        'Mapped By': data[i].mappedBy ? data[i].mappedBy : \"\",\n                        'Endpoint Title': data[i].title ? data[i].title : \"\",\n                        'Mapped Name': data[i].mappedName ? data[i].mappedName : \"\",\n                        'Radius  User Name': data[i].radiusName ? data[i].radiusName : \"\",\n                        'Serial Number': data[i].serialNumber ? data[i].serialNumber : \"\",\n                        'MAC Address': data[i].macAddress ? data[i].macAddress : \"\"\n                      });\n                    }\n                  }\n                  that.excel.downLoadCSV(fileName, dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n            }\n          }\n        },\n        credits: {\n          enabled: false\n        }\n      };\n      options.series = [{\n        name: direction + ' ' + that.language[params['criteriaSelected']],\n        data: seriesData\n      }];\n      return options;\n    }\n    monthlyUsageByAppChartOptions(data, params) {\n      let that = this;\n      var seriesName = [];\n      let direction = \"\";\n      let date = this.getMonthlyUsageDates();\n      let startDate = date.startDate;\n      let endDate = date.endDate;\n      if (params.directionSelected == 'both') {\n        direction = this.language['Both(Down+Up)'] + \" Usage\";\n      } else if (params.directionSelected == 'Down') {\n        direction = this.language['Down'] + \" Usage\";\n      } else {\n        direction = this.language['Up'] + \" Usage\";\n      }\n      var seriesData = [];\n      var xAxisCategories = [];\n      if (data.length) {\n        data.forEach(element => {\n          if (!element.name) {\n            element.name = element.key;\n          }\n          if (seriesName.indexOf(element.name) === -1) {\n            seriesName.push(element.name);\n          }\n          let categories = this.getUTCDateFormatFromUTCTime(element.startPeriodSec, true, \"MM/yyyy\");\n          if (!xAxisCategories.includes(categories)) {\n            xAxisCategories.push(categories);\n          }\n        });\n      }\n      let json = {};\n      data.forEach(element => {\n        if (!json[element['startPeriodSec']]) {\n          json[element['startPeriodSec']] = [];\n        }\n        let value = 0;\n        let name = element['name'] ? element['name'] : element['key'];\n        if (params.directionSelected == 'both') {\n          value = element.totalOctets && element.totalOctets !== -1 ? element.totalOctets : null;\n        } else if (params.directionSelected == 'Down') {\n          value = element.dsOctets && element.dsOctets !== -1 ? element.dsOctets : null;\n        } else {\n          value = element.usOctets && element.usOctets !== -1 ? element.usOctets : null;\n        }\n        let isDuplicate = json[element['startPeriodSec']].filter(element => {\n          return element.name === name;\n        });\n        if (isDuplicate.length === 0) json[element['startPeriodSec']].push({\n          name,\n          value\n        });\n      });\n      let ouputData = {};\n      seriesName.forEach(element => {\n        Object.keys(json).forEach(key => {\n          if (!ouputData[element]) {\n            ouputData[element] = [];\n          }\n          let isPuhsed = false;\n          json[key].forEach(item => {\n            if (element === item.name) {\n              isPuhsed = true;\n              ouputData[element].push(item.value);\n            }\n          });\n          if (!isPuhsed) {\n            ouputData[element].push(null);\n          }\n        });\n      });\n      Object.keys(ouputData).forEach(key => {\n        seriesData.push({\n          name: key,\n          data: ouputData[key]\n        });\n      });\n      let locationParams = \"\";\n      locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n      let titleDirection = this.getSelectDirectionName(params.directionSelected);\n      let pipe = new DatePipe('en-US');\n      let timezoneName = 'Coordinated Universal Time';\n      let subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} to ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]  </span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params['directionSelected'] ? titleDirection : ''} </span>`;\n      if (params.type === 'location') {\n        subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.Location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} to ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]  </span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params['directionSelected'] ? titleDirection : ''} </span>`;\n      }\n      if (seriesData.length == 0) {\n        seriesData = [{\n          name: direction,\n          data: []\n        }];\n      }\n      let colors = this.monthlyUsagebyAppColors();\n      let name = `${this.language.network} ${this.language.monthusageapp} (Top 5)`;\n      if (params.type === 'location') {\n        name = `${this.language.location} ${this.language.monthusageapp} (Top 5)`;\n      }\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: name\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: xAxisCategories,\n          tickPositions: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n          alignTicks: false,\n          labels: {\n            style: {\n              textOverflow: 'ellipsis'\n            }\n          }\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        yAxis: {\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n              return (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' + unit[1] : '');\n            }\n          },\n          min: 0,\n          title: {\n            text: ''\n          },\n          opposite: false,\n          tickLength: 2\n        },\n        legend: {\n          reversed: false\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var unit = that.getStackedUnit(m);\n            var s = `<b> ${this.series.name} </b><br/>\n          <p> ${direction} <span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p>`;\n            return s;\n          }\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            minPointLength: 3,\n            colors: [\"#0027FF\", \"#5ACFEA\", \"#FF8238\", \"#F7C343\", \"#B926F0\", \"#FF489D\", \"#E51A1A\"]\n          }\n        },\n        series: seriesData,\n        colors: colors,\n        exporting: {\n          filename: params.type === 'location' ? 'Location_Monthly_Usage_By_Application' : 'Network_Monthly_Usage_By_Application',\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  let name = params.type === 'location' ? 'Location_Monthly_Usage_By_Application' : 'Network_Monthly_Usage_By_Application';\n                  extraData = `Network Monthly Usage By Application\\r\\n${that.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} - ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection: ${params['directionSelected'] ? titleDirection : ''}\\r\\n`;\n                  if (params.type === 'location') {\n                    extraData = `Location Monthly Usage By Application\\r\\n${that.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} - ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLocation : ${params['locationsSelectedNames']}\\r\\nDirection: ${params['directionSelected'] ? titleDirection : ''}\\r\\n`;\n                  }\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true, 'MM/dd/yyyy'),\n                      'Application Name': data[i].name ? data[i].name : data[i].key,\n                      \"Monthly Usage (Byte)\": that.getCSVData(data[i], params['directionSelected'])\n                    });\n                  }\n                  that.excel.downLoadCSV(name, dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n            }\n          }\n        },\n        credits: {\n          enabled: false\n        }\n      };\n      return options;\n    }\n    monthlyUsageByServiceChartOptions(data, params) {\n      let that = this;\n      var seriesName = [];\n      let direction = \"\";\n      let date = this.getMonthlyUsageDates();\n      let startDate = date.startDate;\n      let endDate = date.endDate;\n      if (params.directionSelected == 'both') {\n        direction = this.language['Both(Down+Up)'] + ` ${this.language.Usage}`;\n      } else if (params.directionSelected == 'Down') {\n        direction = this.language['Down Usage'];\n      } else {\n        direction = this.language['Up Usage'];\n      }\n      if (data.length) {\n        data.forEach(element => {\n          if (!element.name) {\n            element.name = element.key;\n          }\n          if (seriesName.indexOf(element.name) === -1) {\n            seriesName.push(element.name);\n          }\n        });\n      }\n      var seriesData = [];\n      var xAxisCategories = [];\n      $.each(seriesName, (key, value) => {\n        var obj = {};\n        obj.name = value;\n        obj.data = [];\n        $.each(data, (k, v) => {\n          if (!v.key) {\n            v.name = v.key;\n          }\n          if (v.name === value) {\n            if (params.directionSelected == 'both') {\n              obj.data.push(v.totalOctets && v.totalOctets !== -1 ? v.totalOctets : null);\n            } else if (params.directionSelected == 'Down') {\n              obj.data.push(v.dsOctets && v.dsOctets !== -1 ? v.dsOctets : null);\n            } else {\n              obj.data.push(v.usOctets && v.usOctets !== -1 ? v.usOctets : null);\n            }\n            xAxisCategories.push(this.getUTCDateFormatFromUTCTime(v.startPeriodSec, true, \"MM/yyyy\"));\n          }\n        });\n        seriesData.push(obj);\n      });\n      let locationParams = \"\";\n      locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n      let titleDirection = this.getSelectDirectionName(params.directionSelected);\n      let pipe = new DatePipe('en-US');\n      let timezoneName = 'Coordinated Universal Time';\n      let subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} to ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]  </span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params['directionSelected'] ? titleDirection : ''} </span>`;\n      if (params.type === 'location') {\n        subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.Location}: ${locationParams}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} to ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]  </span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params['directionSelected'] ? titleDirection : ''} </span>`;\n      }\n      if (seriesData.length == 0) {\n        seriesData = [{\n          name: direction,\n          data: []\n        }];\n      }\n      let colors = this.monthlyUsagebyAppColors();\n      let name = `${this.language.network} ${this.language.locationMenuMonthlyUsageByServiceCategory}`;\n      if (params.type === 'location') {\n        name = `${this.language.location} ${this.language.locationMenuMonthlyUsageByServiceCategory}`;\n      }\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: name\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: xAxisCategories,\n          labels: {\n            style: {\n              textOverflow: 'ellipsis'\n            }\n          }\n        },\n        yAxis: {\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n              return (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' + unit[1] : '');\n            }\n          },\n          min: 0,\n          title: {\n            text: ''\n          },\n          opposite: false,\n          tickLength: 2\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: false\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var unit = that.getStackedUnit(m);\n            var s = `<b> ${this.series.name} </b><br/>\n          <p> ${direction} <span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p>`;\n            return s;\n          }\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            minPointLength: 3,\n            colors: [\"#0027FF\", \"#5ACFEA\", \"#FF8238\", \"#F7C343\", \"#B926F0\", \"#FF489D\", \"#E51A1A\"],\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: seriesData,\n        colors: colors,\n        exporting: {\n          enabled: false\n          // buttons: {\n          //   contextButton: {\n          //     menuItems: [{\n          //       textKey: 'downloadPDF',\n          //       text: 'Export PDF',\n          //       onclick: function () {\n          //         this.exportChart({\n          //           type: 'application/pdf'\n          //         });\n          //       }\n          //     }, {\n          //       textKey: 'downloadCSV',\n          //       text: 'Export CSV',\n          //       onclick: function () {\n          //         let dataExport = [];\n          //         let extraData: string = '';\n          //         extraData = `Monthly Usage By Application\\r\\n${that.language['time_win']}: ${pipe.transform(startDate, 'MM/dd/yyyy')} - ${pipe.transform(endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLocation : ${LocationNames}\\r\\nDirection: ${params['directionSelected']}\\r\\n`;\n          //         for (var i = 0; i < data.length; i++) {\n          //           dataExport.push(\n          //             {\n          //               'Date Time': that.dateUtils.getChartFormatDate(data[i].startPeriodSec),\n          //               'Application Name': data[i].key,\n          //               \"Monthly Usage (Byte)\": data[i].totalOctets\n          //             }\n          //           )\n          //         }\n          //         that.excel.downLoadCSV('Monthly_Usage_By_Application', dataExport, extraData);\n          //       }\n          //     }],\n          //     text: that.language['export'],\n          //   }\n          // }\n        },\n\n        credits: {\n          enabled: false\n        }\n      };\n      return options;\n    }\n    monthlyUsageByServiceChartOptions1(data, params) {\n      let that = this;\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      if (data.length) {\n        for (let i = 0; i < data.length; i++) {\n          let period = this.convertDate(data[i].startPeriodSec);\n          categories.push(period);\n          if (params.directionSelected == 'both') {\n            seriesData1.push(data[i].usOctets);\n            seriesData2.push(data[i].dsOctets);\n          } else if (params.directionSelected == 'Down') {\n            seriesData2.push(data[i].dsOctets);\n          } else {\n            seriesData1.push(data[i].usOctets);\n          }\n        }\n      }\n      let pipe = new DatePipe('en-US');\n      let timezoneName = 'Coordinated Universal Time';\n      let subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.Location}: ${params.locationsSelected}</span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]  </span>\n    <span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.direction}: ${params['directionSelected']} </span>\n    <br><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language.upUsageTitle}: 28.85019 TB</span> <span style=\"font-size:16px; color:#ffffff\">...</span> <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language.downUsageTitle}: 125.85019 TB</span>`;\n      let options = {\n        chart: {\n          type: 'bar',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: this.language.monthusageservice\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories,\n          labels: {\n            style: {\n              textOverflow: 'ellipsis'\n            }\n          }\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          opposite: false,\n          tickLength: 2,\n          minRange: 1\n        },\n        legend: {\n          reversed: false\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            colors: [\"#0027FF\", \"#5ACFEA\", \"#FF8238\", \"#F7C343\", \"#B926F0\", \"#FF489D\", \"#E51A1A\"],\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        exporting: {\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  // Data will flow for export\n                  extraData = `Monthly Usage By Service Category\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nLocation : ${params['locationsSelected']}\\r\\nDirection: ${params['directionSelected']}\\r\\n`;\n                  for (var i = 0; i < 10; i++) {\n                    dataExport.push({\n                      'Name': \"Testing\",\n                      'Date Time': that.dateUtils.getChartFormat(params.startDate)\n                    });\n                  }\n                  that.excel.downLoadCSV('Monthly_Usage_By_Service', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n            }\n          }\n        },\n        credits: {\n          enabled: false\n        }\n      };\n      if (seriesData1.length > 0) {\n        let obj = {\n          name: this.language['Up Usage'] ? this.language['Up Usage'] : 'Up Usage',\n          data: seriesData1,\n          color: \"#0027FF\"\n        };\n        options.series.push(obj);\n      }\n      if (seriesData2.length > 0) {\n        let obj = {\n          name: this.language['Down Usage'] ? this.language['Down Usage'] : 'Down Usage',\n          data: seriesData2,\n          color: \"#5ACFEA\"\n        };\n        options.series.push(obj);\n      }\n      return options;\n    }\n    subDistributionChartOption(data, params) {\n      let that = this;\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      if (data.length) {\n        for (let i = 0; i < data.length; i++) {\n          categories.push(data[i].strInterval);\n          seriesData1.push(parseFloat(data[i].strSubPercent));\n          seriesData2.push(parseFloat(data[i].strBytePercent));\n        }\n      }\n      let pipe = new DatePipe('en-US');\n      let timezoneName = 'Coordinated Universal Time';\n      let Title = \"\";\n      if (params.directionSelected == 'both') {\n        Title = this.language[\"Both Direction\"];\n      } else if (params.directionSelected == 'Down') {\n        Title = this.language['Downstream'];\n      } else {\n        Title = this.language['Upstream'];\n      }\n      let locationParams = '';\n      locationParams = this.getTitleLocationNames(params['locationsSelectedNames']);\n      const self = this;\n      let options = {\n        chart: {\n          type: 'column'\n        },\n        title: {\n          text: (locationParams ? locationParams : 'All') + ' - ' + Title\n        },\n        subtitle: {\n          text: \"\"\n        },\n        xAxis: {\n          categories: categories,\n          labels: {\n            style: {\n              textOverflow: 'ellipsis'\n            }\n          }\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: this.language.Percentage + ' %'\n          },\n          opposite: false,\n          minRange: 1\n        },\n        legend: {\n          reversed: false\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        },\n        plotOptions: {\n          series: {\n            colors: [\"#0027FF\", \"#5ACFEA\"],\n            cursor: 'pointer'\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            var s = `<b> ${this.key} </b><br/>\n          <p> ${self.language.Percentage}: ${this.y}% <br/></span></p>`;\n            return s;\n          }\n        },\n        // exporting: {\n        //   buttons: {\n        //     contextButton: {\n        //       menuItems: [{\n        //         textKey: 'downloadPDF',\n        //         text: 'Export PDF',\n        //         onclick: function () {\n        //           this.exportChart({\n        //             type: 'application/pdf'\n        //           });\n        //         }\n        //       }, {\n        //         textKey: 'downloadCSV',\n        //         text: 'Export CSV',\n        //         onclick: function () {\n        //           let dataExport = [];\n        //           let extraData: string = '';\n        //           extraData = `Subscriber Distribution\\r\\nLocation : ${params['locationsSelectedNames']}\\r\\nMonth : ${pipe.transform(params['monthSelected'], 'MM/dd/yyyy')} [${timezoneName}]\\r\\nDirection : ${params['directionSelected']}\\r\\nThreshold (KB): ${params['threshold']}\\r\\nAggregate : ${params['aggregateSelected']}\\r\\nEliminate Unknown: ${params['eliminateUnknownSelected']}\\r\\nThreshold Type: ${params['thresholdTypeSelected']}\\r\\n\\r\\n`;\n        //           let total = this.language['Both(Down+Up)'];\n        //           let subsCount = this.language['# of Subs'];\n        //           let subsCPercent = this.language['% of Subs'];\n        //           let bytesCount = this.language['# of Bytes(GB)'];\n        //           let bytesPercent = this.language['% of Bytes'];\n        //           for (var i = 0; i < 10; i++) {\n        //             dataExport.push(\n        //               {\n        //                 total : data[i].strInterval ? data[i].strInterval : '',\n        //                 subsCount : data[i].subCount ? data[i].subCount : 0,\n        //                 subsCPercent : data[i].strSubPercent ? data[i].strSubPercent : '',\n        //                 bytesCount : data[i].totalBytes ? data[i].totalBytes : 0,\n        //                 bytesPercent : data[i].strBytePercent ? data[i].strBytePercent : ''\n        //               }\n        //             )\n        //           }\n        //           that.excel.downLoadCSV('Subscriber_Distributions', dataExport, extraData);\n        //         }\n        //       }],\n        //       text: that.language['export'],\n        //     }\n        //   }\n        // },\n        exporting: {\n          enabled: false\n        },\n        series: [],\n        credits: {\n          enabled: false\n        }\n      };\n      if (seriesData1.length > 0) {\n        let obj = {\n          name: this.language['% of Subscribers'],\n          data: seriesData1,\n          color: \"#0027FF\"\n        };\n        options.series.push(obj);\n      }\n      if (seriesData2.length > 0) {\n        let obj = {\n          name: this.language['% of Bytes'],\n          data: seriesData2,\n          color: \"#5ACFEA\"\n        };\n        options.series.push(obj);\n      }\n      return options;\n    }\n    makeOptionsEndpointTopApp(data, type, params, downloadData) {\n      let title = this.language.Subscriber + ' ' + downloadData.title;\n      let that = this;\n      let pipe = new DatePipe('en-US');\n      let capitalize = new TitleCasePipe();\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      if (params.criteriaSelected == 'usage') {\n        timezoneName = 'Coordinated Universal Time';\n      }\n      let categories = [];\n      let seriesData = [];\n      let direction = this.language['Down'];\n      if (params.directionSelected == 'both') {\n        direction = this.language['Both(Down+Up)'];\n      } else if (params.directionSelected == 'Down') {\n        direction = this.language['Down'];\n      } else {\n        direction = this.language['Up'];\n      }\n      let subscriber = ``;\n      if (this.sso.getTrafficReportChartSubscriberInfo()) {\n        subscriber = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Subscriber']}: ${this.sso.getTrafficReportChartSubscriberInfo()}</span><span style=\"font-size:16px; color:#ffffff\">...</span>`;\n      }\n      let subTitle = `${subscriber}<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['criteria']}: ${this.language[params['criteriaSelected']]}</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['direction']}: ${direction}</span>`;\n      let options = {\n        chart: {\n          type: type,\n          zoomType: \"xy\"\n        },\n        title: {\n          text: title\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              if (params['criteriaSelected'] == 'usage') {\n                var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n                s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' + unit[1] : '');\n                ;\n              } else {\n                var unit = m > 1000000000000 ? [1000000000000, 'Tbps'] : m > 1000000000 ? [1000000000, 'Gbps'] : m > 1000000 ? [1000000, 'Mbps'] : m > 1000 ? [1000, 'Kbps'] : [1, 'bps'];\n                s = (y.isFirst ? 0 : (y.value / unit[0]).toFixed(1)) + (y.isFirst ? ' ' + unit[1] : '');\n              }\n              return s;\n            }\n          }\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: true\n        },\n        plotOptions: {\n          series: {\n            color: '#0279FF',\n            // cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var unit;\n            var s;\n            if (params['criteriaSelected'] == 'usage') {\n              unit = that.getStackedUnit(m);\n              s = `<b> ${this.key} </b><br/>\n              <p>${this.series.name}<span>: <b>${(this.y / unit[0]).toFixed(2) + ' ' + unit[1]}</b><br/></span></p>`;\n            } else {\n              unit = that.utils.bitsToSize(m, false);\n              s = `<b> ${this.key} </b><br/>\n              <p>${this.series.name}<span>: <b>${unit}</b><br/></span></p>`;\n            }\n            return s;\n          }\n        },\n        series: [],\n        exporting: {\n          filename: 'Subscriber ' + downloadData.title,\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  for (var i = 0; i < data.length; i++) {\n                    if (params['criteriaSelected'] == 'usage') {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : '',\n                        'Up Usage(Byte)': data[i].usOctets ? data[i].usOctets.toLocaleString() : 0,\n                        'Down Usage(Byte)': data[i].dsOctets ? data[i].dsOctets.toLocaleString() : 0,\n                        'Both(Down+Up) Usage(Byte)': data[i].totalOctets ? data[i].totalOctets.toLocaleString() : 0\n                      });\n                    } else {\n                      dataExport.push({\n                        'Name': data[i].name ? data[i].name : data[i].key,\n                        'Up Max Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate.toLocaleString() : 0,\n                        'Up Average Rate(bps)': data[i].usRate ? data[i].usRate.toLocaleString() : 0,\n                        'Down Max Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate.toLocaleString() : 0,\n                        'Down Average Rate(bps)': data[i].dsRate ? data[i].dsRate.toLocaleString() : 0\n                      });\n                    }\n                  }\n                  let extraData = '';\n                  let subscriber = ``;\n                  if (that.sso.getTrafficReportChartSubscriberInfo()) {\n                    subscriber = `${that.language['Subscriber']}: ${that.sso.getTrafficReportChartSubscriberInfo()}\\r\\n`;\n                  }\n                  extraData = `${title}\\r\\n ${subscriber}Criteria: ${that.language[params['criteriaSelected']]} \\r\\n ${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\n Direction: ${direction} \\r\\n`;\n                  let chartName = '';\n                  downloadData.title == \"Top Application Groups\" ? chartName = \"Subscriber_Top_Application_Groups\" : chartName = \"Subscriber_Top_Applications\";\n                  that.excel.downLoadCSV(chartName, dataExport, extraData);\n                }\n              }],\n              text: this.language['export']\n            }\n          }\n        },\n        credits: {\n          enabled: false\n        }\n      };\n      if (type === 'bar') {\n        for (let i = 0; i < data.length; i++) {\n          if (data[i].name) {\n            categories.push(data[i].name);\n          } else {\n            if (!data[i].key) {\n              data[i].key = 'others';\n            }\n            categories.push(data[i].key);\n          }\n          if (params['criteriaSelected'] == 'usage') {\n            if (params.directionSelected == 'both') {\n              seriesData.push(data[i].totalOctets);\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsOctets);\n            } else {\n              seriesData.push(data[i].usOctets);\n            }\n          } else if (params['criteriaSelected'] == 'rate') {\n            if (params.directionSelected == 'both') {\n              seriesData.push(data[i].dsRate + data[i].usRate);\n            } else if (params.directionSelected == 'Down') {\n              seriesData.push(data[i].dsRate);\n            } else {\n              seriesData.push(data[i].usRate);\n            }\n          }\n        }\n        options.series = [{\n          name: `${params.directionSelected == 'both' ? this.language['Both(Down+Up)'] : this.language[params.directionSelected]} ${this.language[params['criteriaSelected']]}`,\n          data: seriesData\n        }];\n      } else if (type === 'pie') {\n        for (let i = 0; i < data.length; i++) {\n          if (params.directionSelected == 'Both(Down+Up)') {\n            seriesData.push({\n              name: data[i].name,\n              y: data[i].dsOctets + data[i].usOctets\n            });\n          } else if (params.directionSelected == 'Down') {\n            seriesData.push({\n              name: data[i].name,\n              y: data[i].dsOctets\n            });\n          } else {\n            seriesData.push({\n              name: data[i].name,\n              y: data[i].usOctets\n            });\n          }\n        }\n        options.series = [{\n          data: seriesData,\n          name: params.directionSelected\n        }];\n        options.plotOptions.pie = {\n          allowPointSelect: true,\n          cursor: 'pointer'\n        };\n      }\n      return options;\n    }\n    makeOptionsForRateChart(data, params) {\n      let up = this.language['max_up_rate'];\n      let down = this.language['max_down_rate'];\n      let that = this;\n      let categories = [];\n      let upData = [];\n      let downData = [];\n      if (params['rateSelected'] == 'Average') {\n        up = this.language['avg_up_rate'];\n        down = this.language['avg_down_rate'];\n      }\n      let pipe = new DatePipe('en-US');\n      for (let i = 0; i < data.length; i++) {\n        categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd/yyyy HH:mm'));\n      }\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Subscriber']}: ${this.sso.getTrafficReportChartSubscriberInfo()}</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">Rate: ${this.language[params['rateSelected']]}</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>`;\n      let options = {\n        chart: {\n          type: 'line'\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: this.language['subscriberRate']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: [],\n          labels: {\n            formatter: function () {\n              let label = this.value;\n              if (this.isLast) {\n                let len = this.axis.categories.length;\n                label = this.axis.categories[len - 1];\n              }\n              return label;\n            }\n          }\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              return that.utils.bitsToSize(this.value, true);\n            }\n          }\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          align: 'center',\n          verticalAlign: 'bottom',\n          layout: 'horizontal',\n          symbolRadius: 0\n        },\n        tooltip: {\n          formatter: function () {\n            return '<b>' + this.x + '<b><br/>' + this.series.name + ': <b>' + that.utils.bitsToSize(this.y, false) + '</b>';\n          }\n        },\n        plotOptions: {\n          series: {\n            marker: {\n              enabled: false\n            }\n          },\n          column: {\n            stacking: 'normal',\n            dataLabels: {\n              enabled: false\n              //color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'\n            }\n          }\n        },\n\n        series: [{\n          name: up,\n          color: '#82BF00',\n          data: []\n        }, {\n          name: down,\n          color: '#0279FF',\n          data: []\n        }],\n        exporting: {\n          filename: 'Subscriber_Rate',\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  extraData = `Subscriber Rate\\r\\n${that.language['Subscriber']}: ${that.sso.getTrafficReportChartSubscriberInfo()}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nRate: ${params['rateSelected']}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.dateUtils.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'),\n                      'Max Up Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate : 0,\n                      'Max Down Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate : 0,\n                      'Average Up Rate(bps)': data[i].usRate ? data[i].usRate : 0,\n                      'Average Down Rate(bps)': data[i].dsRate ? data[i].dsRate : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('Subscriber_Rate', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n            }\n          }\n        },\n        credits: {\n          enabled: false\n        }\n      };\n      for (let i = 0; i < data.length; i++) {\n        categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd/yyyy HH:mm'));\n        if (params['rateSelected'] == 'Average') {\n          upData.push(data[i].usRate);\n          downData.push(data[i].dsRate);\n        } else {\n          upData.push(data[i].peakUsRate);\n          downData.push(data[i].peakDsRate);\n        }\n      }\n      options.xAxis.categories = categories;\n      if (categories && categories.length <= 45) {\n        options.xAxis['tickInterval'] = 1;\n      } else if (categories && categories.length > 45) {\n        options.xAxis['tickInterval'] = Math.floor(categories.length / 45);\n      }\n      options.series[0].data = upData;\n      options.series[1].data = downData;\n      return options;\n    }\n    makeOptionsForEPLineChart(data, params) {\n      let up = this.language['max_up_rate'];\n      let down = this.language['max_down_rate'];\n      let that = this;\n      let categories = [];\n      let upData = [];\n      let downData = [];\n      if (params['rateSelected'] == 'Average') {\n        up = this.language['Average_Up_Rate'];\n        down = this.language['Average_Down_Rate'];\n      }\n      let pipe = new DatePipe('en-US');\n      // for (let i = 0; i < data.length; i++) {\n      //   categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'));\n      // }\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      // let diff = moment(params.endDate).diff(moment(params.startDate), \"hour\");\n      let subscriber = ``;\n      let startTime = ``;\n      let endTime = ``;\n      let dayDiff = moment(params.endDate).diff(moment(params.startDate), \"days\");\n      if (dayDiff < 3) {\n        startTime = params.startTime >= 48 ? params.startTime - 48 : params.startTime >= 24 ? params.startTime - 24 : params.startTime;\n        endTime = params.endTime > 48 ? params.endTime - 48 : params.endTime > 24 ? params.endTime - 24 : params.endTime;\n        startTime = startTime.toString().length < 2 ? `0${startTime}:00` : `${startTime}:00`;\n        endTime = endTime.toString().length < 2 ? `0${endTime}:00` : `${endTime}:00`;\n        params.startDate = params.APIStartDate;\n        params.endDate = this.getISOEndOfDay(params.APIendDate, endTime);\n      }\n      if (this.sso.getTrafficReportChartSubscriberInfo()) {\n        subscriber = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Subscriber']}: ${this.sso.getTrafficReportChartSubscriberInfo()}</span><span style=\"font-size:16px; color:#ffffff\">...</span>`;\n      }\n      let subTitle = `${subscriber}<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Rate']}: ${this.language[params['rateSelected']]}</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]</span>`;\n      let options = {\n        chart: {\n          type: 'line'\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: this.language['subscriberRate']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: [],\n          labels: {\n            rotation: -65,\n            formatter: function () {\n              let label = this.value;\n              if (this.isLast) {\n                let len = this.axis.categories.length;\n                label = this.axis.categories[len - 1];\n              }\n              return label;\n            }\n          }\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              return that.utils.bitsToSize(this.value, true);\n            }\n          },\n          min: 0,\n          minRange: 1\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          align: 'center',\n          verticalAlign: 'bottom',\n          layout: 'horizontal',\n          symbolRadius: 0\n        },\n        tooltip: {\n          formatter: function () {\n            return '<p><b>' + this.x + '</b> <br/>' + this.series.name + ': <b>' + that.utils.bitsToSize(this.y, false) + '</b></p>';\n          }\n        },\n        plotOptions: {\n          series: {\n            marker: {\n              enabled: data.length === 1 ? true : false\n            }\n          },\n          column: {\n            stacking: 'normal',\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: [{\n          name: up,\n          color: '#82BF00',\n          data: []\n        }, {\n          name: down,\n          color: '#0279FF',\n          data: []\n        }],\n        exporting: {\n          filename: 'Subscriber_Rate',\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  let subscriber = ``;\n                  if (that.sso.getTrafficReportChartSubscriberInfo()) {\n                    subscriber = `${that.language['Subscriber']}: ${that.sso.getTrafficReportChartSubscriberInfo()}\\r\\n`;\n                  }\n                  extraData = `Subscriber Rate\\r\\n${subscriber}${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} ${startTime} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} ${endTime} [${timezoneName}]\\r\\nRate: ${params['rateSelected']}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'),\n                      'Max Up Rate(bps)': data[i].peakUsRate && data[i].peakUsRate !== -1 ? data[i].peakUsRate.toLocaleString() : 0,\n                      'Max Down Rate(bps)': data[i].peakDsRate && data[i].peakDsRate !== -1 ? data[i].peakDsRate.toLocaleString() : 0,\n                      'Average Up Rate(bps)': data[i].usRate && data[i].usRate !== -1 ? data[i].usRate.toLocaleString() : 0,\n                      'Average Down Rate(bps)': data[i].dsRate && data[i].dsRate !== -1 ? data[i].dsRate.toLocaleString() : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('Subscriber_Rate', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n            }\n          }\n        },\n        credits: {\n          enabled: false\n        }\n      };\n      for (let i = 0; i < data.length; i++) {\n        if (params['rateSelected'] == 'Average') {\n          if (data[i].usRate && data[i].usRate !== -1 || data[i].dsRate && data[i].dsRate !== -1) {\n            upData.push(data[i].usRate && data[i].usRate !== -1 ? data[i].usRate : null);\n            downData.push(data[i].dsRate && data[i].dsRate !== -1 ? data[i].dsRate : null);\n            categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'));\n          }\n        } else {\n          if (data[i].peakUsRate && data[i].peakUsRate !== -1 || data[i].peakDsRate && data[i].peakDsRate !== -1) {\n            upData.push(data[i].peakUsRate && data[i].peakUsRate !== -1 ? data[i].peakUsRate : null);\n            downData.push(data[i].peakDsRate && data[i].peakDsRate !== -1 ? data[i].peakDsRate : null);\n            categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'));\n          }\n        }\n      }\n      options.xAxis.categories = categories;\n      if (categories && categories.length <= 45) {\n        options.xAxis['tickInterval'] = 1;\n      } else if (categories && categories.length > 45) {\n        options.xAxis['tickInterval'] = Math.floor(categories.length / 45);\n      }\n      if (upData.length === 1 || downData.length === 1) {\n        options.plotOptions.series.marker.enabled = true;\n      } else {\n        options.plotOptions.series.marker.enabled = false;\n      }\n      options.series[0].data = upData;\n      options.series[1].data = downData;\n      return options;\n    }\n    sortByNumber(list, key) {\n      list.sort(function (x, y) {\n        x[key] = x[key] ? parseInt(x[key]) : 0;\n        y[key] = y[key] ? parseInt(y[key]) : 0;\n        return x[key] - y[key];\n      });\n      return list;\n    }\n    sortByColumn(data, type, column, isNum) {\n      return this.commonOrgService.sortByColumn(data, type, column, isNum);\n    }\n    monthlyUsagebyAppColors() {\n      var arr = [\"#0027FF\", \"#5ACFEA\", \"#FF8238\", \"#F7C343\", \"#B926F0\", \"#FF489D\", \"#E51A1A\", \"#90be6d\", \"#277da1\"];\n      if (3 <= 10) {\n        return arr;\n      } else {\n        var num = 3 - 10;\n        for (var i = 0; i < num; i++) {\n          var colorStr = arr[i];\n          var curColor = new Object();\n          curColor.r = parseInt(colorStr.substr(1, 2), 16);\n          curColor.g = parseInt(colorStr.substr(3, 2), 16);\n          curColor.b = parseInt(colorStr.substr(5, 2), 16);\n          if (curColor.r > 202) {\n            curColor.r = curColor.r >= 218 ? (curColor.r - 202).toString(16) : '0' + (curColor.r - 202).toString(16);\n          } else {\n            curColor.r = (curColor.r + 53).toString(16);\n          }\n          if (curColor.g > 202) {\n            curColor.g = curColor.g >= 218 ? (curColor.g - 202).toString(16) : '0' + (curColor.g - 202).toString(16);\n          } else {\n            curColor.g = (curColor.g + 53).toString(16);\n          }\n          if (curColor.b > 202) {\n            curColor.b = curColor.b >= 218 ? (curColor.b - 202).toString(16) : '0' + (curColor.b - 202).toString(16);\n          } else {\n            curColor.b = (curColor.b + 53).toString(16);\n          }\n          var strColor = '#' + curColor.r + curColor.g + curColor.b;\n          arr.push(strColor);\n        }\n        return arr;\n      }\n    }\n    makeIsoDate(value) {\n      let a = value.split('.');\n      let b = a[0].split(\":\");\n      b.pop();\n      return b.join(':') + ':00Z';\n    }\n    arraysObjectsPercentageCalculator(obj, value, digit) {\n      let numbersArray = obj;\n      if (typeof obj == 'object') {\n        numbersArray = Object.values(obj);\n      }\n      const reducer = (accumulator, currentValue) => accumulator + currentValue;\n      let total = numbersArray.reduce(reducer, 0);\n      return (100 * value / total).toFixed(digit ? digit : 2);\n    }\n    getGranularity(startDate, endDate) {\n      let granularity = '24hour';\n      let diff = moment(endDate).diff(moment(startDate), \"hour\");\n      if (diff <= 24) {\n        granularity = \"1hour\";\n      } else {\n        granularity = \"24hour\";\n      }\n      return granularity;\n    }\n    getDateTime(time, utc, format) {\n      let offset = -1 * (new Date().getTimezoneOffset() * 60);\n      if (utc) {\n        time = parseInt(time + offset) * 1000;\n      } else {\n        time = parseInt(time) * 1000;\n      }\n      let date = DateTime.fromMillis(time);\n      let dateString = '';\n      if (format) {\n        dateString = date.toUTC().toFormat(format);\n      } else {\n        dateString = date.toUTC().toFormat('MM/dd/yyyy');\n      }\n      return dateString;\n    }\n    getUTCDateFormatFromUTCTime(time, utc, format) {\n      if (utc) {\n        time = parseInt(time) * 1000;\n      }\n      let date = DateTime.fromMillis(time);\n      let dateString = '';\n      if (format) {\n        dateString = date.toUTC().toFormat(format);\n      } else {\n        dateString = date.toUTC().toFormat('MM/dd/yyyy');\n      }\n      return dateString;\n    }\n    bitsToSize(bits, round) {\n      let bytes = bits;\n      let sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps', 'pbps', 'ebps'];\n      if (bytes == 0) return '0';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      if (round) {\n        return Math.round(bytes / Math.pow(1000, i)) + ' ' + sizes[i];\n      }\n      if (i < 0) {\n        i = 0;\n      }\n      let n = 1;\n      if (Number.isInteger(+Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 1))) {\n        n = 0;\n      }\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), n) + ' ' + sizes[i];\n    }\n    getStackedUnit(m) {\n      let unit;\n      if (m > 1000000000000) {\n        unit = [1000000000000, 'TB'];\n      } else if (m > 1000000000) {\n        unit = [1000000000, 'GB'];\n      } else if (m > 1000000) {\n        unit = [1000000, 'MB'];\n      } else if (m > 1000) {\n        unit = [1000, 'KB'];\n      } else {\n        unit = [1, 'KB'];\n      }\n      return unit;\n    }\n    getTitleLocationNames(locationsSelectedNames) {\n      let locationNames = \"\";\n      if (locationsSelectedNames) {\n        locationsSelectedNames.forEach((element, i) => {\n          if (i < 3) {\n            locationNames += `${i == 0 ? '' : ','} ${element}`;\n          }\n        });\n        if (locationsSelectedNames.length > 3) {\n          locationNames += `, ...`;\n        }\n      }\n      return locationNames;\n    }\n    getTitleApplicationNames(names) {\n      let applicationNames = \"\";\n      if (names) {\n        names.forEach((element, i) => {\n          if (i < 3) {\n            applicationNames += `${i == 0 ? '' : ','} ${element}`;\n          }\n        });\n        if (names.length > 3) {\n          applicationNames += `, ...`;\n        }\n      }\n      return applicationNames;\n    }\n    getSelectDirectionName(directionSelected) {\n      let directionName = \"\";\n      if (directionSelected == 'both') {\n        directionName = this.language['Both(Down+Up)'];\n      } else if (directionSelected == 'Down') {\n        directionName = this.language['Down'];\n      } else {\n        directionName = this.language['Up'];\n      }\n      return directionName;\n    }\n    navigateByUrl(data, xAxisValue, filters, from, xAxisKey = '') {\n      if (xAxisValue === \"Unknown\" || xAxisValue === \"Unknown and Other\" || xAxisValue === \"00000000-0000-0000-0000-000000000000\" || xAxisValue === 'Unclassified Applications') {\n        return;\n      }\n      if (xAxisValue === \"Unknown Application\" || xAxisValue === \"Unknown Location\") {\n        return;\n      }\n      let url = '';\n      let applicationsNames = [];\n      let locationNames = [];\n      let applicationsSelected = [];\n      let locationsSelected = [];\n      let subscriberId = xAxisValue;\n      if (from === 'App') {\n        for (let i = 0; i < data.length; i++) {\n          if (data[i].name === xAxisValue || data[i].key === xAxisValue) {\n            applicationsSelected.push(data[i].key);\n            applicationsNames.push(data[i].name ? data[i].name : data[i].key);\n          }\n        }\n        url = '/cco/traffic/applications/reports';\n        if (!(window.location.pathname.indexOf('/cco/traffic/') > -1)) {\n          url = this.router.url.indexOf(`/${environment.SYS_ADMIN_ROUTE}/`) > -1 ? '/systemAdministration/flowAnalyze/traffic/application/reports' : '/organization-admin/flowAnalyze/traffic/application/reports';\n        }\n      } else if (from === 'Loc') {\n        for (let i = 0; i < data.length; i++) {\n          if (data[i].name === xAxisValue || data[i].key === xAxisValue) {\n            locationsSelected.push(data[i].key);\n            locationNames.push(data[i].name ? data[i].name : data[i].key);\n          }\n        }\n        url = '/cco/traffic/locations/reports';\n        if (!(window.location.pathname.indexOf('/cco/traffic/') > -1)) {\n          url = this.router.url.indexOf(`/${environment.SYS_ADMIN_ROUTE}/`) > -1 ? '/systemAdministration/flowAnalyze/traffic/location/reports' : '/organization-admin/flowAnalyze/traffic/location/reports';\n        }\n      } else if (from === 'Sub') {\n        window.sessionStorage.setItem('traffic_TopSub_Endpoint_filters', JSON.stringify(filters));\n        for (let i = 0; i < data.length; i++) {\n          if (xAxisKey) {\n            if (data[i].key === xAxisKey) {\n              subscriberId = data[i].key;\n              window.sessionStorage.setItem('endpointName', data[i].name);\n            }\n          } else {\n            if (data[i].name === xAxisValue || data[i].title === xAxisValue) {\n              subscriberId = data[i].key;\n              window.sessionStorage.setItem('endpointName', data[i].name);\n            }\n          }\n        }\n        this.sso.setEPRredirectFrom(window.location.pathname);\n        url = '/cco/traffic/endpoints/realtime';\n        if (!(window.location.pathname.indexOf('/cco/traffic/') > -1)) {\n          url = this.router.url.indexOf(`/${environment.SYS_ADMIN_ROUTE}/`) > -1 ? '/systemAdministration/flowAnalyze/traffic/endpoint/realtime' : '/organization-admin/flowAnalyze/traffic/endpoint/realtime';\n        }\n      }\n      let filter = {\n        startDate: moment(filters.startDate).format(\"YYYY-MM-DD\"),\n        endDate: moment(filters.endDate).format(\"YYYY-MM-DD\"),\n        criteria: filters.criteriaSelected,\n        applicationsSelected: applicationsSelected,\n        locationsSelected: locationsSelected,\n        typeSelected: 'traffic',\n        isApplicationGroup: filters.groupSelected,\n        applicationsNames: applicationsNames,\n        locationNames: locationNames\n      };\n      this.router.navigate([url], {\n        queryParams: from === 'Sub' ? {\n          id: subscriberId\n        } : filter\n      });\n    }\n    showLabel(xAxisValue) {\n      let showPointer = false;\n      if (xAxisValue !== \"Unknown\" && xAxisValue !== \"Unknown and Other\" && xAxisValue !== \"00000000-0000-0000-0000-000000000000\" && xAxisValue !== 'Unclassified Applications' && xAxisValue !== \"Unknown Application\" && xAxisValue !== \"Unknown Location\") {\n        showPointer = true;\n      }\n      return `<span  class=\"text-primary axis_label\" title=\"${xAxisValue}\" style=\"cursor:${showPointer ? 'pointer' : ''}\">${xAxisValue}</span>`;\n    }\n    getISOEndOfDay(dt, tm) {\n      //returns 12AM UTC of Next day of End date\n      let d = new Date(dt);\n      d.setDate(new Date(d).getDate() - (parseInt(tm) === 24 ? 1 : 0));\n      let year = d.getFullYear();\n      let month = `${d.getMonth() + 1}`;\n      let day = `${d.getDate()}`;\n      if (month.length < 2) {\n        month = `0${month}`;\n      }\n      if (day.length < 2) {\n        day = `0${day}`;\n      }\n      let date = `${year}-${month}-${day}T00:00:00Z`;\n      return date;\n    }\n    getMonthlyUsageDates() {\n      let date = new Date();\n      let firstDay = new Date(date.getFullYear() - 1, date.getMonth(), 1);\n      let lastDay = new Date(date.getFullYear(), date.getMonth(), 0);\n      let startDate = new Date(firstDay).toISOString();\n      startDate = this.makeIsoDate(startDate);\n      let endDate = new Date(lastDay).toISOString();\n      endDate = this.makeIsoDate(endDate);\n      return {\n        startDate,\n        endDate\n      };\n    }\n    getCSVData(data, criteria) {\n      let value = 0;\n      if (criteria == 'both') {\n        value = data.totalOctets && data.totalOctets !== -1 ? data.totalOctets.toLocaleString() : 0;\n      } else if (criteria == 'Down') {\n        value = data.dsOctets && data.dsOctets !== -1 ? data.dsOctets.toLocaleString() : 0;\n      } else {\n        value = data.usOctets && data.usOctets !== -1 ? data.usOctets.toLocaleString() : 0;\n      }\n      return value;\n    }\n    axisLabelClickEvent(chart) {\n      var axis = chart.xAxis[0];\n      var ticks = axis.ticks;\n      var points = chart.series[0].points;\n      points.forEach(function (point, i) {\n        if (ticks[i]) {\n          var label = ticks[i].label.element;\n          label.onclick = function () {\n            point.firePointEvent('click');\n          };\n        }\n      });\n    }\n  }\n  ChartOptionsService.fac = function ChartOptionsService_Factory(t) {\n    return new (t || ChartOptionsService)(i0.inject(i1.FaUtilsService), i0.inject(i2.DateUtilsService), i0.inject(i3.ExportExcelService), i0.inject(i4.CustomTranslateService), i0.inject(i5.CommonService), i0.inject(i6.ConvertorService), i0.inject(i7.Router), i0.inject(i8.SsoAuthService), i0.inject(i9.NetworkReportApiService));\n  };\n  ChartOptionsService.prov = /*@__PURE__*/i0.defineInjectable({\n    token: ChartOptionsService,\n    factory: ChartOptionsService.fac,\n    providedIn: 'root'\n  });\n  return ChartOptionsService;\n})();","map":null,"metadata":{},"sourceType":"module"}