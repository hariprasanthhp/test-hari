{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { event as domEvent, query as domQuery, queryAll as domQueryAll } from 'min-dom';\nimport { BENDPOINT_CLS, SEGMENT_DRAGGER_CLS, addBendpoint, addSegmentDragger, calculateSegmentMoveRegion, getConnectionIntersection } from './BendpointUtil';\nimport { escapeCSS } from '../../util/EscapeUtil';\nimport { pointsAligned, getMidPoint } from '../../util/Geometry';\nimport { isPrimaryButton } from '../../util/Mouse';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\n\n/**\n * A service that adds editable bendpoints to connections.\n */\nexport default function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {\n  /**\n   * Returns true if intersection point is inside middle region of segment, adjusted by\n   * optional threshold\n   */\n  function isIntersectionMiddle(intersection, waypoints, treshold) {\n    var idx = intersection.index,\n      p = intersection.point,\n      p0,\n      p1,\n      mid,\n      aligned,\n      xDelta,\n      yDelta;\n    if (idx <= 0 || intersection.bendpoint) {\n      return false;\n    }\n    p0 = waypoints[idx - 1];\n    p1 = waypoints[idx];\n    mid = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);\n    xDelta = Math.abs(p.x - mid.x);\n    yDelta = Math.abs(p.y - mid.y);\n    return aligned && xDelta <= treshold && yDelta <= treshold;\n  }\n\n  /**\n   * Calculates the threshold from a connection's middle which fits the two-third-region\n   */\n  function calculateIntersectionThreshold(connection, intersection) {\n    var waypoints = connection.waypoints,\n      relevantSegment,\n      alignment,\n      segmentLength,\n      threshold;\n    if (intersection.index <= 0 || intersection.bendpoint) {\n      return null;\n    }\n\n    // segment relative to connection intersection\n    relevantSegment = {\n      start: waypoints[intersection.index - 1],\n      end: waypoints[intersection.index]\n    };\n    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);\n    if (!alignment) {\n      return null;\n    }\n    if (alignment === 'h') {\n      segmentLength = relevantSegment.end.x - relevantSegment.start.x;\n    } else {\n      segmentLength = relevantSegment.end.y - relevantSegment.start.y;\n    }\n\n    // calculate threshold relative to 2/3 of segment length\n    threshold = calculateSegmentMoveRegion(segmentLength) / 2;\n    return threshold;\n  }\n  function activateBendpointMove(event, connection) {\n    var waypoints = connection.waypoints,\n      intersection = getConnectionIntersection(canvas, waypoints, event),\n      threshold;\n    if (!intersection) {\n      return;\n    }\n    threshold = calculateIntersectionThreshold(connection, intersection);\n    if (isIntersectionMiddle(intersection, waypoints, threshold)) {\n      connectionSegmentMove.start(event, connection, intersection.index);\n    } else {\n      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);\n    }\n\n    // we've handled the event\n    return true;\n  }\n  function bindInteractionEvents(node, eventName, element) {\n    domEvent.bind(node, eventName, function (event) {\n      interactionEvents.triggerMouseEvent(eventName, event, element);\n      event.stopPropagation();\n    });\n  }\n  function getBendpointsContainer(element, create) {\n    var layer = canvas.getLayer('overlays'),\n      gfx = domQuery('.djs-bendpoints[data-element-id=\"' + escapeCSS(element.id) + '\"]', layer);\n    if (!gfx && create) {\n      gfx = svgCreate('g');\n      svgAttr(gfx, {\n        'data-element-id': element.id\n      });\n      svgClasses(gfx).add('djs-bendpoints');\n      svgAppend(layer, gfx);\n      bindInteractionEvents(gfx, 'mousedown', element);\n      bindInteractionEvents(gfx, 'click', element);\n      bindInteractionEvents(gfx, 'dblclick', element);\n    }\n    return gfx;\n  }\n  function getSegmentDragger(idx, parentGfx) {\n    return domQuery('.djs-segment-dragger[data-segment-idx=\"' + idx + '\"]', parentGfx);\n  }\n  function createBendpoints(gfx, connection) {\n    connection.waypoints.forEach(function (p, idx) {\n      var bendpoint = addBendpoint(gfx);\n      svgAppend(gfx, bendpoint);\n      translate(bendpoint, p.x, p.y);\n    });\n\n    // add floating bendpoint\n    addBendpoint(gfx, 'floating');\n  }\n  function createSegmentDraggers(gfx, connection) {\n    var waypoints = connection.waypoints;\n    var segmentStart, segmentEnd, segmentDraggerGfx;\n    for (var i = 1; i < waypoints.length; i++) {\n      segmentStart = waypoints[i - 1];\n      segmentEnd = waypoints[i];\n      if (pointsAligned(segmentStart, segmentEnd)) {\n        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);\n        svgAttr(segmentDraggerGfx, {\n          'data-segment-idx': i\n        });\n        bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);\n      }\n    }\n  }\n  function clearBendpoints(gfx) {\n    forEach(domQueryAll('.' + BENDPOINT_CLS, gfx), function (node) {\n      svgRemove(node);\n    });\n  }\n  function clearSegmentDraggers(gfx) {\n    forEach(domQueryAll('.' + SEGMENT_DRAGGER_CLS, gfx), function (node) {\n      svgRemove(node);\n    });\n  }\n  function addHandles(connection) {\n    var gfx = getBendpointsContainer(connection);\n    if (!gfx) {\n      gfx = getBendpointsContainer(connection, true);\n      createBendpoints(gfx, connection);\n      createSegmentDraggers(gfx, connection);\n    }\n    return gfx;\n  }\n  function updateHandles(connection) {\n    var gfx = getBendpointsContainer(connection);\n    if (gfx) {\n      clearSegmentDraggers(gfx);\n      clearBendpoints(gfx);\n      createSegmentDraggers(gfx, connection);\n      createBendpoints(gfx, connection);\n    }\n  }\n  function updateFloatingBendpointPosition(parentGfx, intersection) {\n    var floating = domQuery('.floating', parentGfx),\n      point = intersection.point;\n    if (!floating) {\n      return;\n    }\n    translate(floating, point.x, point.y);\n  }\n  function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {\n    var draggerGfx = getSegmentDragger(intersection.index, parentGfx),\n      segmentStart = waypoints[intersection.index - 1],\n      segmentEnd = waypoints[intersection.index],\n      point = intersection.point,\n      mid = getMidPoint(segmentStart, segmentEnd),\n      alignment = pointsAligned(segmentStart, segmentEnd),\n      draggerVisual,\n      relativePosition;\n    if (!draggerGfx) {\n      return;\n    }\n    draggerVisual = getDraggerVisual(draggerGfx);\n    relativePosition = {\n      x: point.x - mid.x,\n      y: point.y - mid.y\n    };\n    if (alignment === 'v') {\n      // rotate position\n      relativePosition = {\n        x: relativePosition.y,\n        y: relativePosition.x\n      };\n    }\n    translate(draggerVisual, relativePosition.x, relativePosition.y);\n  }\n  eventBus.on('connection.changed', function (event) {\n    updateHandles(event.element);\n  });\n  eventBus.on('connection.remove', function (event) {\n    var gfx = getBendpointsContainer(event.element);\n    if (gfx) {\n      svgRemove(gfx);\n    }\n  });\n  eventBus.on('element.marker.update', function (event) {\n    var element = event.element,\n      bendpointsGfx;\n    if (!element.waypoints) {\n      return;\n    }\n    bendpointsGfx = addHandles(element);\n    if (event.add) {\n      svgClasses(bendpointsGfx).add(event.marker);\n    } else {\n      svgClasses(bendpointsGfx).remove(event.marker);\n    }\n  });\n  eventBus.on('element.mousemove', function (event) {\n    var element = event.element,\n      waypoints = element.waypoints,\n      bendpointsGfx,\n      intersection;\n    if (waypoints) {\n      bendpointsGfx = getBendpointsContainer(element, true);\n      intersection = getConnectionIntersection(canvas, waypoints, event.originalEvent);\n      if (!intersection) {\n        return;\n      }\n      updateFloatingBendpointPosition(bendpointsGfx, intersection);\n      if (!intersection.bendpoint) {\n        updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);\n      }\n    }\n  });\n  eventBus.on('element.mousedown', function (event) {\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n    var originalEvent = event.originalEvent,\n      element = event.element;\n    if (!element.waypoints) {\n      return;\n    }\n    return activateBendpointMove(originalEvent, element);\n  });\n  eventBus.on('selection.changed', function (event) {\n    var newSelection = event.newSelection,\n      primary = newSelection[0];\n    if (primary && primary.waypoints) {\n      addHandles(primary);\n    }\n  });\n  eventBus.on('element.hover', function (event) {\n    var element = event.element;\n    if (element.waypoints) {\n      addHandles(element);\n      interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');\n    }\n  });\n  eventBus.on('element.out', function (event) {\n    interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');\n  });\n\n  // update bendpoint container data attribute on element ID change\n  eventBus.on('element.updateId', function (context) {\n    var element = context.element,\n      newId = context.newId;\n    if (element.waypoints) {\n      var bendpointContainer = getBendpointsContainer(element);\n      if (bendpointContainer) {\n        svgAttr(bendpointContainer, {\n          'data-element-id': newId\n        });\n      }\n    }\n  });\n\n  // API\n\n  this.addHandles = addHandles;\n  this.updateHandles = updateHandles;\n  this.getBendpointsContainer = getBendpointsContainer;\n  this.getSegmentDragger = getSegmentDragger;\n}\nBendpoints.$inject = ['eventBus', 'canvas', 'interactionEvents', 'bendpointMove', 'connectionSegmentMove'];\n\n// helper /////////////\n\nfunction getDraggerVisual(draggerGfx) {\n  return domQuery('.djs-visual', draggerGfx);\n}","map":null,"metadata":{},"sourceType":"module"}