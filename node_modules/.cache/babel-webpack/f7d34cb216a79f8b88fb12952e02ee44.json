{"ast":null,"code":"import { every, isArray } from 'min-dash';\n\n/**\n * Computes the distance between two points\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {number}  distance\n */\nexport function pointDistance(a, b) {\n  if (!a || !b) {\n    return -1;\n  }\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n\n/**\n * Returns true if the point r is on the line between p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n * @param  {Point}  r\n * @param  {number} [accuracy=5] accuracy for points on line check (lower is better)\n *\n * @return {boolean}\n */\nexport function pointsOnLine(p, q, r, accuracy) {\n  if (typeof accuracy === 'undefined') {\n    accuracy = 5;\n  }\n  if (!p || !q || !r) {\n    return false;\n  }\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\n    dist = pointDistance(p, q);\n\n  // @see http://stackoverflow.com/a/907491/412190\n  return Math.abs(val / dist) <= accuracy;\n}\nvar ALIGNED_THRESHOLD = 2;\n\n/**\n * Check whether two points are horizontally or vertically aligned.\n *\n * @param {Array<Point>|Point}\n * @param {Point}\n *\n * @return {string|boolean}\n */\nexport function pointsAligned(a, b) {\n  var points;\n  if (isArray(a)) {\n    points = a;\n  } else {\n    points = [a, b];\n  }\n  if (pointsAlignedHorizontally(points)) {\n    return 'h';\n  }\n  if (pointsAlignedVertically(points)) {\n    return 'v';\n  }\n  return false;\n}\nexport function pointsAlignedHorizontally(a, b) {\n  var points;\n  if (isArray(a)) {\n    points = a;\n  } else {\n    points = [a, b];\n  }\n  var firstPoint = points.slice().shift();\n  return every(points, function (point) {\n    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;\n  });\n}\nexport function pointsAlignedVertically(a, b) {\n  var points;\n  if (isArray(a)) {\n    points = a;\n  } else {\n    points = [a, b];\n  }\n  var firstPoint = points.slice().shift();\n  return every(points, function (point) {\n    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;\n  });\n}\n\n/**\n * Returns true if the point p is inside the rectangle rect\n *\n * @param  {Point}  p\n * @param  {Rect} rect\n * @param  {number} tolerance\n *\n * @return {boolean}\n */\nexport function pointInRect(p, rect, tolerance) {\n  tolerance = tolerance || 0;\n  return p.x > rect.x - tolerance && p.y > rect.y - tolerance && p.x < rect.x + rect.width + tolerance && p.y < rect.y + rect.height + tolerance;\n}\n\n/**\n * Returns a point in the middle of points p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Point} middle point\n */\nexport function getMidPoint(p, q) {\n  return {\n    x: Math.round(p.x + (q.x - p.x) / 2.0),\n    y: Math.round(p.y + (q.y - p.y) / 2.0)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}