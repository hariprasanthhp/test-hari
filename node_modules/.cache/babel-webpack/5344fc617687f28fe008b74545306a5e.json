{"ast":null,"code":"import { event, classes, attr as attr$1, query } from 'min-dom';\nimport { create, attr, append, classes as classes$1, remove, clone } from 'tiny-svg';\nimport { assign, every, isObject, isNumber } from 'min-dash';\nimport cssEscape from 'css.escape';\nimport { getVisual } from 'diagram-js/lib/util/GraphicsUtil';\nvar MINIMAP_VIEWBOX_PADDING = 50;\nvar RANGE = {\n    min: 0.2,\n    max: 4\n  },\n  NUM_STEPS = 10;\nvar DELTA_THRESHOLD = 0.1;\nvar LOW_PRIORITY = 250;\n\n/**\n * A minimap that reflects and lets you navigate the diagram.\n */\nfunction Minimap(config, injector, eventBus, canvas, elementRegistry) {\n  var self = this;\n  this._canvas = canvas;\n  this._elementRegistry = elementRegistry;\n  this._eventBus = eventBus;\n  this._injector = injector;\n  this._state = {\n    isOpen: undefined,\n    isDragging: false,\n    initialDragPosition: null,\n    offsetViewport: null,\n    cachedViewbox: null,\n    dragger: null,\n    svgClientRect: null,\n    parentClientRect: null,\n    zoomDelta: 0\n  };\n  this._init();\n  this.toggle(config && config.open || false);\n  function setViewboxCenteredAroundClickEvent(event) {\n    // getBoundingClientRect might return zero-dimensional when called for the first time\n    if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {\n      self._state._svgClientRect = self._svg.getBoundingClientRect();\n    }\n    var diagramPoint = mapMousePositionToDiagramPoint({\n      x: event.clientX - self._state._svgClientRect.left,\n      y: event.clientY - self._state._svgClientRect.top\n    }, self._svg, self._lastViewbox);\n    setViewboxCenteredAroundPoint(diagramPoint, self._canvas);\n    self._update();\n  }\n\n  // set viewbox on click\n  event.bind(this._svg, 'click', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    setViewboxCenteredAroundClickEvent(event);\n  });\n  function mousedown(center) {\n    return function onMousedown(event$1) {\n      // getBoundingClientRect might return zero-dimensional when called for the first time\n      if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {\n        self._state._svgClientRect = self._svg.getBoundingClientRect();\n      }\n      if (center) {\n        setViewboxCenteredAroundClickEvent(event$1);\n      }\n      var diagramPoint = mapMousePositionToDiagramPoint({\n        x: event$1.clientX - self._state._svgClientRect.left,\n        y: event$1.clientY - self._state._svgClientRect.top\n      }, self._svg, self._lastViewbox);\n      var viewbox = canvas.viewbox();\n      var offsetViewport = getOffsetViewport(diagramPoint, viewbox);\n      var initialViewportDomRect = self._viewportDom.getBoundingClientRect();\n\n      // take border into account (regardless of width)\n      var offsetViewportDom = {\n        x: event$1.clientX - initialViewportDomRect.left + 1,\n        y: event$1.clientY - initialViewportDomRect.top + 1\n      };\n\n      // init dragging\n      assign(self._state, {\n        cachedViewbox: viewbox,\n        initialDragPosition: {\n          x: event$1.clientX,\n          y: event$1.clientY\n        },\n        isDragging: true,\n        offsetViewport: offsetViewport,\n        offsetViewportDom: offsetViewportDom,\n        viewportClientRect: self._viewport.getBoundingClientRect(),\n        parentClientRect: self._parent.getBoundingClientRect()\n      });\n      event.bind(document, 'mousemove', onMousemove);\n      event.bind(document, 'mouseup', onMouseup);\n    };\n  }\n  function onMousemove(event) {\n    // set viewbox if dragging active\n    if (self._state.isDragging) {\n      // getBoundingClientRect might return zero-dimensional when called for the first time\n      if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {\n        self._state._svgClientRect = self._svg.getBoundingClientRect();\n      }\n\n      // update viewport DOM\n      var offsetViewportDom = self._state.offsetViewportDom,\n        viewportClientRect = self._state.viewportClientRect,\n        parentClientRect = self._state.parentClientRect;\n      assign(self._viewportDom.style, {\n        top: event.clientY - offsetViewportDom.y - parentClientRect.top + 'px',\n        left: event.clientX - offsetViewportDom.x - parentClientRect.left + 'px'\n      });\n\n      // update overlay\n      var clipPath = getOverlayClipPath(parentClientRect, {\n        top: event.clientY - offsetViewportDom.y - parentClientRect.top,\n        left: event.clientX - offsetViewportDom.x - parentClientRect.left,\n        width: viewportClientRect.width,\n        height: viewportClientRect.height\n      });\n      assign(self._overlay.style, {\n        clipPath: clipPath\n      });\n      var diagramPoint = mapMousePositionToDiagramPoint({\n        x: event.clientX - self._state._svgClientRect.left,\n        y: event.clientY - self._state._svgClientRect.top\n      }, self._svg, self._lastViewbox);\n      setViewboxCenteredAroundPoint({\n        x: diagramPoint.x - self._state.offsetViewport.x,\n        y: diagramPoint.y - self._state.offsetViewport.y\n      }, self._canvas);\n    }\n  }\n  function onMouseup(event$1) {\n    if (self._state.isDragging) {\n      // treat event as click\n      if (self._state.initialDragPosition.x === event$1.clientX && self._state.initialDragPosition.y === event$1.clientY) {\n        setViewboxCenteredAroundClickEvent(event$1);\n      }\n      self._update();\n\n      // end dragging\n      assign(self._state, {\n        cachedViewbox: null,\n        initialDragPosition: null,\n        isDragging: false,\n        offsetViewport: null,\n        offsetViewportDom: null\n      });\n      event.unbind(document, 'mousemove', onMousemove);\n      event.unbind(document, 'mouseup', onMouseup);\n    }\n  }\n\n  // dragging viewport scrolls canvas\n  event.bind(this._viewportDom, 'mousedown', mousedown(false));\n  event.bind(this._svg, 'mousedown', mousedown(true));\n  event.bind(this._parent, 'wheel', function (event) {\n    // stop propagation and handle scroll differently\n    event.preventDefault();\n    event.stopPropagation();\n\n    // only zoom in on ctrl; this aligns with diagram-js navigation behavior\n    if (!event.ctrlKey) {\n      return;\n    }\n\n    // getBoundingClientRect might return zero-dimensional when called for the first time\n    if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {\n      self._state._svgClientRect = self._svg.getBoundingClientRect();\n    }\n\n    // disallow zooming through viewport outside of minimap as it is very confusing\n    if (!isPointInside(event, self._state._svgClientRect)) {\n      return;\n    }\n    var factor = event.deltaMode === 0 ? 0.020 : 0.32;\n    var delta = Math.sqrt(Math.pow(event.deltaY, 2) + Math.pow(event.deltaX, 2)) * sign(event.deltaY) * -factor;\n\n    // add until threshold reached\n    self._state.zoomDelta += delta;\n    if (Math.abs(self._state.zoomDelta) > DELTA_THRESHOLD) {\n      var direction = delta > 0 ? 1 : -1;\n      var currentLinearZoomLevel = Math.log(canvas.zoom()) / Math.log(10);\n\n      // zoom with half the step size of stepZoom\n      var stepSize = getStepSize(RANGE, NUM_STEPS * 2);\n\n      // snap to a proximate zoom step\n      var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;\n\n      // increase or decrease one zoom step in the given direction\n      newLinearZoomLevel += stepSize * direction;\n\n      // calculate the absolute logarithmic zoom level based on the linear zoom level\n      // (e.g. 2 for an absolute x2 zoom)\n      var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);\n      canvas.zoom(cap(RANGE, newLogZoomLevel), diagramPoint);\n\n      // reset\n      self._state.zoomDelta = 0;\n      var diagramPoint = mapMousePositionToDiagramPoint({\n        x: event.clientX - self._state._svgClientRect.left,\n        y: event.clientY - self._state._svgClientRect.top\n      }, self._svg, self._lastViewbox);\n      setViewboxCenteredAroundPoint(diagramPoint, self._canvas);\n      self._update();\n    }\n  });\n  event.bind(this._toggle, 'click', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    self.toggle();\n  });\n\n  // add shape on shape/connection added\n  eventBus.on(['shape.added', 'connection.added'], function (context) {\n    var element = context.element;\n    self._addElement(element);\n    self._update();\n  });\n\n  // remove shape on shape/connection removed\n  eventBus.on(['shape.removed', 'connection.removed'], function (context) {\n    var element = context.element;\n    self._removeElement(element);\n    self._update();\n  });\n\n  // update on elements changed\n  eventBus.on('elements.changed', LOW_PRIORITY, function (context) {\n    var elements = context.elements;\n    elements.forEach(function (element) {\n      self._updateElement(element);\n    });\n    self._update();\n  });\n\n  // update on element ID update\n  eventBus.on('element.updateId', function (context) {\n    var element = context.element,\n      newId = context.newId;\n    self._updateElementId(element, newId);\n  });\n\n  // update on viewbox changed\n  eventBus.on('canvas.viewbox.changed', function () {\n    if (!self._state.isDragging) {\n      self._update();\n    }\n  });\n  eventBus.on('canvas.resized', function () {\n    // only update if present in DOM\n    if (document.body.contains(self._parent)) {\n      if (!self._state.isDragging) {\n        self._update();\n      }\n      self._state._svgClientRect = self._svg.getBoundingClientRect();\n    }\n  });\n}\nMinimap.$inject = ['config.minimap', 'injector', 'eventBus', 'canvas', 'elementRegistry'];\nMinimap.prototype._init = function () {\n  var canvas = this._canvas,\n    container = canvas.getContainer();\n\n  // create parent div\n  var parent = this._parent = document.createElement('div');\n  classes(parent).add('djs-minimap');\n  container.appendChild(parent);\n\n  // create toggle\n  var toggle = this._toggle = document.createElement('div');\n  classes(toggle).add('toggle');\n  parent.appendChild(toggle);\n\n  // create map\n  var map = this._map = document.createElement('div');\n  classes(map).add('map');\n  parent.appendChild(map);\n\n  // create svg\n  var svg = this._svg = create('svg');\n  attr(svg, {\n    width: '100%',\n    height: '100%'\n  });\n  append(map, svg);\n\n  // add groups\n  var elementsGroup = this._elementsGroup = create('g');\n  append(svg, elementsGroup);\n  var viewportGroup = this._viewportGroup = create('g');\n  append(svg, viewportGroup);\n\n  // add viewport SVG\n  var viewport = this._viewport = create('rect');\n  classes$1(viewport).add('viewport');\n  append(viewportGroup, viewport);\n\n  // prevent drag propagation\n  event.bind(parent, 'mousedown', function (event) {\n    event.stopPropagation();\n  });\n\n  // add viewport DOM\n  var viewportDom = this._viewportDom = document.createElement('div');\n  classes(viewportDom).add('viewport-dom');\n  this._parent.appendChild(viewportDom);\n\n  // add overlay\n  var overlay = this._overlay = document.createElement('div');\n  classes(overlay).add('overlay');\n  this._parent.appendChild(overlay);\n};\nMinimap.prototype._update = function () {\n  var viewbox = this._canvas.viewbox(),\n    innerViewbox = viewbox.inner,\n    outerViewbox = viewbox.outer;\n  if (!validViewbox(viewbox)) {\n    return;\n  }\n  var x, y, width, height;\n  var widthDifference = outerViewbox.width - innerViewbox.width,\n    heightDifference = outerViewbox.height - innerViewbox.height;\n\n  // update viewbox\n  // x\n  if (innerViewbox.width < outerViewbox.width) {\n    x = innerViewbox.x - widthDifference / 2;\n    width = outerViewbox.width;\n    if (innerViewbox.x + innerViewbox.width < outerViewbox.width) {\n      x = Math.min(0, innerViewbox.x);\n    }\n  } else {\n    x = innerViewbox.x;\n    width = innerViewbox.width;\n  }\n\n  // y\n  if (innerViewbox.height < outerViewbox.height) {\n    y = innerViewbox.y - heightDifference / 2;\n    height = outerViewbox.height;\n    if (innerViewbox.y + innerViewbox.height < outerViewbox.height) {\n      y = Math.min(0, innerViewbox.y);\n    }\n  } else {\n    y = innerViewbox.y;\n    height = innerViewbox.height;\n  }\n\n  // apply some padding\n  x = x - MINIMAP_VIEWBOX_PADDING;\n  y = y - MINIMAP_VIEWBOX_PADDING;\n  width = width + MINIMAP_VIEWBOX_PADDING * 2;\n  height = height + MINIMAP_VIEWBOX_PADDING * 2;\n  this._lastViewbox = {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n  attr(this._svg, {\n    viewBox: x + ', ' + y + ', ' + width + ', ' + height\n  });\n\n  // update viewport SVG\n  attr(this._viewport, {\n    x: viewbox.x,\n    y: viewbox.y,\n    width: viewbox.width,\n    height: viewbox.height\n  });\n\n  // update viewport DOM\n  var parentClientRect = this._state._parentClientRect = this._parent.getBoundingClientRect();\n  var viewportClientRect = this._viewport.getBoundingClientRect();\n  var withoutParentOffset = {\n    top: viewportClientRect.top - parentClientRect.top,\n    left: viewportClientRect.left - parentClientRect.left,\n    width: viewportClientRect.width,\n    height: viewportClientRect.height\n  };\n  assign(this._viewportDom.style, {\n    top: withoutParentOffset.top + 'px',\n    left: withoutParentOffset.left + 'px',\n    width: withoutParentOffset.width + 'px',\n    height: withoutParentOffset.height + 'px'\n  });\n\n  // update overlay\n  var clipPath = getOverlayClipPath(parentClientRect, withoutParentOffset);\n  assign(this._overlay.style, {\n    clipPath: clipPath\n  });\n};\nMinimap.prototype.open = function () {\n  assign(this._state, {\n    isOpen: true\n  });\n  classes(this._parent).add('open');\n  var translate = this._injector.get('translate', false) || function (s) {\n    return s;\n  };\n  attr$1(this._toggle, 'title', translate('Close minimap'));\n  this._update();\n  this._eventBus.fire('minimap.toggle', {\n    open: true\n  });\n};\nMinimap.prototype.close = function () {\n  assign(this._state, {\n    isOpen: false\n  });\n  classes(this._parent).remove('open');\n  var translate = this._injector.get('translate', false) || function (s) {\n    return s;\n  };\n  attr$1(this._toggle, 'title', translate('Open minimap'));\n  this._eventBus.fire('minimap.toggle', {\n    open: false\n  });\n};\nMinimap.prototype.toggle = function (open) {\n  var currentOpen = this.isOpen();\n  if (typeof open === 'undefined') {\n    open = !currentOpen;\n  }\n  if (open == currentOpen) {\n    return;\n  }\n  if (open) {\n    this.open();\n  } else {\n    this.close();\n  }\n};\nMinimap.prototype.isOpen = function () {\n  return this._state.isOpen;\n};\nMinimap.prototype._updateElement = function (element) {\n  try {\n    // if parent is null element has been removed, if parent is undefined parent is root\n    if (element.parent !== undefined && element.parent !== null) {\n      this._removeElement(element);\n      this._addElement(element);\n    }\n  } catch (error) {\n    console.warn('Minimap#_updateElement errored', error);\n  }\n};\nMinimap.prototype._updateElementId = function (element, newId) {\n  try {\n    var elementGfx = query('#' + cssEscape(element.id), this._elementsGroup);\n    if (elementGfx) {\n      elementGfx.id = newId;\n    }\n  } catch (error) {\n    console.warn('Minimap#_updateElementId errored', error);\n  }\n};\n\n/**\n * Adds an element to the minimap.\n */\nMinimap.prototype._addElement = function (element) {\n  var self = this;\n  this._removeElement(element);\n  var parent, x, y;\n  var newElementGfx = this._createElement(element);\n  var newElementParentGfx = query('#' + cssEscape(element.parent.id), this._elementsGroup);\n  if (newElementGfx) {\n    var elementGfx = this._elementRegistry.getGraphics(element);\n    var parentGfx = this._elementRegistry.getGraphics(element.parent);\n    var index = getIndexOfChildInParentChildren(elementGfx, parentGfx);\n\n    // index can be 0\n    if (index !== 'undefined') {\n      if (newElementParentGfx) {\n        // in cases of doubt add as last child\n        if (newElementParentGfx.childNodes.length > index) {\n          insertChildAtIndex(newElementGfx, newElementParentGfx, index);\n        } else {\n          insertChildAtIndex(newElementGfx, newElementParentGfx, newElementParentGfx.childNodes.length - 1);\n        }\n      } else {\n        this._elementsGroup.appendChild(newElementGfx);\n      }\n    } else {\n      // index undefined\n      this._elementsGroup.appendChild(newElementGfx);\n    }\n    if (isConnection(element)) {\n      parent = element.parent;\n      x = 0;\n      y = 0;\n      if (typeof parent.x !== 'undefined' && typeof parent.y !== 'undefined') {\n        x = -parent.x;\n        y = -parent.y;\n      }\n      attr(newElementGfx, {\n        transform: 'translate(' + x + ' ' + y + ')'\n      });\n    } else {\n      x = element.x;\n      y = element.y;\n      if (newElementParentGfx) {\n        parent = element.parent;\n        x -= parent.x;\n        y -= parent.y;\n      }\n      attr(newElementGfx, {\n        transform: 'translate(' + x + ' ' + y + ')'\n      });\n    }\n    if (element.children && element.children.length) {\n      element.children.forEach(function (child) {\n        self._addElement(child);\n      });\n    }\n    return newElementGfx;\n  }\n};\nMinimap.prototype._removeElement = function (element) {\n  var elementGfx = this._svg.getElementById(element.id);\n  if (elementGfx) {\n    remove(elementGfx);\n  }\n};\nMinimap.prototype._createElement = function (element) {\n  var gfx = this._elementRegistry.getGraphics(element),\n    visual;\n  if (gfx) {\n    visual = getVisual(gfx);\n    if (visual) {\n      var elementGfx = clone(visual);\n      attr(elementGfx, {\n        id: element.id\n      });\n      return elementGfx;\n    }\n  }\n};\nfunction isConnection(element) {\n  return element.waypoints;\n}\nfunction getOffsetViewport(diagramPoint, viewbox) {\n  var centerViewbox = {\n    x: viewbox.x + viewbox.width / 2,\n    y: viewbox.y + viewbox.height / 2\n  };\n  return {\n    x: diagramPoint.x - centerViewbox.x,\n    y: diagramPoint.y - centerViewbox.y\n  };\n}\nfunction mapMousePositionToDiagramPoint(position, svg, lastViewbox) {\n  // firefox returns 0 for clientWidth and clientHeight\n  var boundingClientRect = svg.getBoundingClientRect();\n\n  // take different aspect ratios of default layers bounding box and minimap into account\n  var bBox = fitAspectRatio(lastViewbox, boundingClientRect.width / boundingClientRect.height);\n\n  // map click position to diagram position\n  var diagramX = map(position.x, 0, boundingClientRect.width, bBox.x, bBox.x + bBox.width),\n    diagramY = map(position.y, 0, boundingClientRect.height, bBox.y, bBox.y + bBox.height);\n  return {\n    x: diagramX,\n    y: diagramY\n  };\n}\nfunction setViewboxCenteredAroundPoint(point, canvas) {\n  // get cached viewbox to preserve zoom\n  var cachedViewbox = canvas.viewbox(),\n    cachedViewboxWidth = cachedViewbox.width,\n    cachedViewboxHeight = cachedViewbox.height;\n  canvas.viewbox({\n    x: point.x - cachedViewboxWidth / 2,\n    y: point.y - cachedViewboxHeight / 2,\n    width: cachedViewboxWidth,\n    height: cachedViewboxHeight\n  });\n}\nfunction fitAspectRatio(bounds, targetAspectRatio) {\n  var aspectRatio = bounds.width / bounds.height;\n\n  // assigning to bounds throws exception in IE11\n  var newBounds = assign({}, {\n    x: bounds.x,\n    y: bounds.y,\n    width: bounds.width,\n    height: bounds.height\n  });\n  if (aspectRatio > targetAspectRatio) {\n    // height needs to be fitted\n    var height = newBounds.width * (1 / targetAspectRatio),\n      y = newBounds.y - (height - newBounds.height) / 2;\n    assign(newBounds, {\n      y: y,\n      height: height\n    });\n  } else if (aspectRatio < targetAspectRatio) {\n    // width needs to be fitted\n    var width = newBounds.height * targetAspectRatio,\n      x = newBounds.x - (width - newBounds.width) / 2;\n    assign(newBounds, {\n      x: x,\n      width: width\n    });\n  }\n  return newBounds;\n}\nfunction map(x, inMin, inMax, outMin, outMax) {\n  var inRange = inMax - inMin,\n    outRange = outMax - outMin;\n  return (x - inMin) * outRange / inRange + outMin;\n}\n\n/**\n * Returns index of child in children of parent.\n *\n * g\n * '- g.djs-element // parentGfx\n * '- g.djs-children\n *    '- g\n *       '-g.djs-element // childGfx\n */\nfunction getIndexOfChildInParentChildren(childGfx, parentGfx) {\n  var childrenGroup = query('.djs-children', parentGfx.parentNode);\n  if (!childrenGroup) {\n    return;\n  }\n  var childrenArray = [].slice.call(childrenGroup.childNodes);\n  var indexOfChild = -1;\n  childrenArray.forEach(function (childGroup, index) {\n    if (query('.djs-element', childGroup) === childGfx) {\n      indexOfChild = index;\n    }\n  });\n  return indexOfChild;\n}\nfunction insertChildAtIndex(childGfx, parentGfx, index) {\n  var childrenArray = [].slice.call(parentGfx.childNodes);\n  var childAtIndex = childrenArray[index];\n  parentGfx.insertBefore(childGfx, childAtIndex.nextSibling);\n}\nfunction isZeroDimensional(clientRect) {\n  return clientRect.width === 0 && clientRect.height === 0;\n}\nfunction isPointInside(point, rect) {\n  return point.x > rect.left && point.x < rect.left + rect.width && point.y > rect.top && point.y < rect.top + rect.height;\n}\nvar sign = Math.sign || function (n) {\n  return n >= 0 ? 1 : -1;\n};\n\n/**\n * Get step size for given range and number of steps.\n *\n * @param {Object} range - Range.\n * @param {number} range.min - Range minimum.\n * @param {number} range.max - Range maximum.\n */\nfunction getStepSize(range, steps) {\n  var minLinearRange = Math.log(range.min) / Math.log(10),\n    maxLinearRange = Math.log(range.max) / Math.log(10);\n  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);\n  return absoluteLinearRange / steps;\n}\nfunction cap(range, scale) {\n  return Math.max(range.min, Math.min(range.max, scale));\n}\nfunction getOverlayClipPath(outer, inner) {\n  var coordinates = [toCoordinatesString(inner.left, inner.top), toCoordinatesString(inner.left + inner.width, inner.top), toCoordinatesString(inner.left + inner.width, inner.top + inner.height), toCoordinatesString(inner.left, inner.top + inner.height), toCoordinatesString(inner.left, outer.height), toCoordinatesString(outer.width, outer.height), toCoordinatesString(outer.width, 0), toCoordinatesString(0, 0), toCoordinatesString(0, outer.height), toCoordinatesString(inner.left, outer.height)].join(', ');\n  return 'polygon(' + coordinates + ')';\n}\nfunction toCoordinatesString(x, y) {\n  return x + 'px ' + y + 'px';\n}\nfunction validViewbox(viewBox) {\n  return every(viewBox, function (value) {\n    // check deeper structures like inner or outer viewbox\n    if (isObject(value)) {\n      return validViewbox(value);\n    }\n    return isNumber(value) && isFinite(value);\n  });\n}\nvar index = {\n  __init__: ['minimap'],\n  minimap: ['type', Minimap]\n};\nexport default index;","map":null,"metadata":{},"sourceType":"module"}