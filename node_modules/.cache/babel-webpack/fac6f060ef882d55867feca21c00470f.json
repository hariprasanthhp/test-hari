{"ast":null,"code":"import inherits from 'inherits';\nimport { assign } from 'min-dash';\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\nimport { repairConnection, withoutRedundantPoints } from 'diagram-js/lib/layout/ManhattanLayout';\nimport { getMid, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nvar ATTACH_ORIENTATION_PADDING = -10,\n  BOUNDARY_TO_HOST_THRESHOLD = 40;\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\nexport default function BpmnLayouter() {}\ninherits(BpmnLayouter, BaseLayouter);\nBpmnLayouter.prototype.layoutConnection = function (connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n  var source = hints.source || connection.source,\n    target = hints.target || connection.target,\n    waypoints = hints.waypoints || connection.waypoints,\n    connectionStart = hints.connectionStart,\n    connectionEnd = hints.connectionEnd;\n  var manhattanOptions, updatedWaypoints;\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') || is(connection, 'bpmn:DataAssociation')) {\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);\n    }\n  }\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n    // layout all connection between flow elements h:h, except for\n    // (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n    // (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n    // (3) loops\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)\n      };\n    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {\n      manhattanOptions = getSubProcessManhattanOptions(source);\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: ['v:h']\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: ['h:v']\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: ['h:h']\n      };\n    }\n  }\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));\n  }\n  return updatedWaypoints || [connectionStart, connectionEnd];\n};\n\n// helpers //////////\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: ['straight', 'v:v'],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\nfunction getMessageFlowPreserveDocking(source, target) {\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n  return null;\n}\nfunction getSubProcessManhattanOptions(source) {\n  return {\n    preferredLayouts: ['straight', 'h:h'],\n    preserveDocking: getSubProcessPreserveDocking(source)\n  };\n}\nfunction getSubProcessPreserveDocking(source) {\n  return isExpandedSubProcess(source) ? 'target' : 'source';\n}\nfunction getConnectionDocking(point, shape) {\n  return point ? point.original || point : getMid(shape);\n}\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') && is(source, 'bpmn:BoundaryEvent') && target.businessObject.isForCompensation;\n}\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\nfunction isSame(a, b) {\n  return a === b;\n}\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n  return matches && matches[0];\n}\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n  return matches && matches[0];\n}\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\nfunction getLoopPreferredLayout(source, connection) {\n  var waypoints = connection.waypoints;\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n  if (orientation === 'top') {\n    return ['t:r'];\n  } else if (orientation === 'right') {\n    return ['r:b'];\n  } else if (orientation === 'left') {\n    return ['l:t'];\n  }\n  return ['b:l'];\n}\nfunction getBoundaryEventPreferredLayouts(source, target, end) {\n  var sourceMid = getMid(source),\n    targetMid = getMid(target),\n    attachOrientation = getAttachOrientation(source),\n    sourceLayout,\n    targetLayout;\n  var isLoop = isSame(source.host, target);\n  var attachedToSide = isAnyOrientation(attachOrientation, ['top', 'right', 'bottom', 'left']);\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);\n  }\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);\n  return [sourceLayout + ':' + targetLayout];\n}\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {\n  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation),\n    sourceLayout = orientationDirectionMapping[orientation],\n    targetLayout;\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : 'b';\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : 'l';\n    }\n  } else {\n    targetLayout = 'v';\n  }\n  return [sourceLayout + ':' + targetLayout];\n}\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {\n    x: target.x + target.width,\n    y: target.y + target.height\n  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));\n}\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[axis] - b[axis]) < threshold;\n}\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // same vertical or opposite horizontal orientation\n  if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) || isOppositeOrientation(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {\n    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];\n  }\n\n  // fallback\n  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];\n}\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is right or left\n\n      // opposite horizontal orientation or same orientation\n      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n      // orientation is top or bottom\n\n      // opposite vertical orientation or same orientation\n      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // orientation is right, left\n  // or same vertical orientation but also right or left\n  if (isHorizontalOrientation(targetOrientation) || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}","map":null,"metadata":{},"sourceType":"module"}