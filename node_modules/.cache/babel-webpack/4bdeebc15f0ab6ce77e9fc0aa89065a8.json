{"ast":null,"code":"import { filterRedundantWaypoints } from '../../layout/LayoutUtil';\nvar round = Math.round;\nvar RECONNECT_START = 'reconnectStart',\n  RECONNECT_END = 'reconnectEnd',\n  UPDATE_WAYPOINTS = 'updateWaypoints';\n\n/**\n * Move bendpoints through drag and drop to add/remove bendpoints or reconnect connection.\n */\nexport default function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {\n  this._injector = injector;\n  this.start = function (event, connection, bendpointIndex, insert) {\n    var gfx = canvas.getGraphics(connection),\n      source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      type;\n    if (!insert && bendpointIndex === 0) {\n      type = RECONNECT_START;\n    } else if (!insert && bendpointIndex === waypoints.length - 1) {\n      type = RECONNECT_END;\n    } else {\n      type = UPDATE_WAYPOINTS;\n    }\n    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';\n    var allowed = rules.allowed(command, {\n      connection: connection,\n      source: source,\n      target: target\n    });\n    if (allowed === false) {\n      allowed = rules.allowed(command, {\n        connection: connection,\n        source: target,\n        target: source\n      });\n    }\n    if (allowed === false) {\n      return;\n    }\n    dragging.init(event, 'bendpoint.move', {\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: {\n          allowed: allowed,\n          bendpointIndex: bendpointIndex,\n          connection: connection,\n          source: source,\n          target: target,\n          insert: insert,\n          type: type\n        }\n      }\n    });\n  };\n  eventBus.on('bendpoint.move.hover', function (event) {\n    var context = event.context,\n      connection = context.connection,\n      source = connection.source,\n      target = connection.target,\n      hover = event.hover,\n      type = context.type;\n\n    // cache hover state\n    context.hover = hover;\n    var allowed;\n    if (!hover) {\n      return;\n    }\n    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';\n    allowed = context.allowed = rules.allowed(command, {\n      connection: connection,\n      source: type === RECONNECT_START ? hover : source,\n      target: type === RECONNECT_END ? hover : target\n    });\n    if (allowed) {\n      context.source = type === RECONNECT_START ? hover : source;\n      context.target = type === RECONNECT_END ? hover : target;\n      return;\n    }\n    if (allowed === false) {\n      allowed = context.allowed = rules.allowed(command, {\n        connection: connection,\n        source: type === RECONNECT_END ? hover : target,\n        target: type === RECONNECT_START ? hover : source\n      });\n    }\n    if (allowed) {\n      context.source = type === RECONNECT_END ? hover : target;\n      context.target = type === RECONNECT_START ? hover : source;\n    }\n  });\n  eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], function (event) {\n    var context = event.context,\n      type = context.type;\n    context.hover = null;\n    context.source = null;\n    context.target = null;\n    if (type !== UPDATE_WAYPOINTS) {\n      context.allowed = false;\n    }\n  });\n  eventBus.on('bendpoint.move.end', function (event) {\n    var context = event.context,\n      allowed = context.allowed,\n      bendpointIndex = context.bendpointIndex,\n      connection = context.connection,\n      insert = context.insert,\n      newWaypoints = connection.waypoints.slice(),\n      source = context.source,\n      target = context.target,\n      type = context.type,\n      hints = context.hints || {};\n\n    // ensure integer values (important if zoom level was > 1 during move)\n    var docking = {\n      x: round(event.x),\n      y: round(event.y)\n    };\n    if (!allowed) {\n      return false;\n    }\n    if (type === UPDATE_WAYPOINTS) {\n      if (insert) {\n        // insert new bendpoint\n        newWaypoints.splice(bendpointIndex, 0, docking);\n      } else {\n        // swap previous waypoint with moved one\n        newWaypoints[bendpointIndex] = docking;\n      }\n\n      // pass hints about actual moved bendpoint\n      // useful for connection/label layout\n      hints.bendpointMove = {\n        insert: insert,\n        bendpointIndex: bendpointIndex\n      };\n      newWaypoints = this.cropWaypoints(connection, newWaypoints);\n      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);\n    } else {\n      if (type === RECONNECT_START) {\n        hints.docking = 'source';\n        if (isReverse(context)) {\n          hints.docking = 'target';\n          hints.newWaypoints = newWaypoints.reverse();\n        }\n      } else if (type === RECONNECT_END) {\n        hints.docking = 'target';\n        if (isReverse(context)) {\n          hints.docking = 'source';\n          hints.newWaypoints = newWaypoints.reverse();\n        }\n      }\n      modeling.reconnect(connection, source, target, docking, hints);\n    }\n  }, this);\n}\nBendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'rules', 'modeling'];\nBendpointMove.prototype.cropWaypoints = function (connection, newWaypoints) {\n  var connectionDocking = this._injector.get('connectionDocking', false);\n  if (!connectionDocking) {\n    return newWaypoints;\n  }\n  var waypoints = connection.waypoints;\n  connection.waypoints = newWaypoints;\n  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n  newWaypoints = connection.waypoints;\n  connection.waypoints = waypoints;\n  return newWaypoints;\n};\n\n// helpers //////////\n\nexport function isReverse(context) {\n  var hover = context.hover,\n    source = context.source,\n    target = context.target,\n    type = context.type;\n  if (type === RECONNECT_START) {\n    return hover && target && hover === target && source !== target;\n  }\n  if (type === RECONNECT_END) {\n    return hover && source && hover === source && source !== target;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}