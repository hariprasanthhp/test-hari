{"ast":null,"code":"import { forEach, sortBy } from 'min-dash';\n\n/**\n * A handler that distributes elements evenly.\n */\nexport default function DistributeElements(modeling) {\n  this._modeling = modeling;\n}\nDistributeElements.$inject = ['modeling'];\nvar OFF_AXIS = {\n  x: 'y',\n  y: 'x'\n};\nDistributeElements.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var groups = context.groups,\n    axis = context.axis,\n    dimension = context.dimension;\n  function updateRange(group, element) {\n    group.range.min = Math.min(element[axis], group.range.min);\n    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);\n  }\n  function center(element) {\n    return element[axis] + element[dimension] / 2;\n  }\n  function lastIdx(arr) {\n    return arr.length - 1;\n  }\n  function rangeDiff(range) {\n    return range.max - range.min;\n  }\n  function centerElement(refCenter, element) {\n    var delta = {\n      y: 0\n    };\n    delta[axis] = refCenter - center(element);\n    if (delta[axis]) {\n      delta[OFF_AXIS[axis]] = 0;\n      modeling.moveElements([element], delta, element.parent);\n    }\n  }\n  var firstGroup = groups[0],\n    lastGroupIdx = lastIdx(groups),\n    lastGroup = groups[lastGroupIdx];\n  var margin,\n    spaceInBetween,\n    groupsSize = 0; // the size of each range\n\n  forEach(groups, function (group, idx) {\n    var sortedElements, refElem, refCenter;\n    if (group.elements.length < 2) {\n      if (idx && idx !== groups.length - 1) {\n        updateRange(group, group.elements[0]);\n        groupsSize += rangeDiff(group.range);\n      }\n      return;\n    }\n    sortedElements = sortBy(group.elements, axis);\n    refElem = sortedElements[0];\n    if (idx === lastGroupIdx) {\n      refElem = sortedElements[lastIdx(sortedElements)];\n    }\n    refCenter = center(refElem);\n\n    // wanna update the ranges after the shapes have been centered\n    group.range = null;\n    forEach(sortedElements, function (element) {\n      centerElement(refCenter, element);\n      if (group.range === null) {\n        group.range = {\n          min: element[axis],\n          max: element[axis] + element[dimension]\n        };\n        return;\n      }\n\n      // update group's range after centering the range elements\n      updateRange(group, element);\n    });\n    if (idx && idx !== groups.length - 1) {\n      groupsSize += rangeDiff(group.range);\n    }\n  });\n  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);\n  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));\n  if (margin < groups.length - 1) {\n    return;\n  }\n  forEach(groups, function (group, groupIdx) {\n    var delta = {},\n      prevGroup;\n    if (group === firstGroup || group === lastGroup) {\n      return;\n    }\n    prevGroup = groups[groupIdx - 1];\n    group.range.max = 0;\n    forEach(group.elements, function (element, idx) {\n      delta[OFF_AXIS[axis]] = 0;\n      delta[axis] = prevGroup.range.max - element[axis] + margin;\n      if (group.range.min !== element[axis]) {\n        delta[axis] += element[axis] - group.range.min;\n      }\n      if (delta[axis]) {\n        modeling.moveElements([element], delta, element.parent);\n      }\n      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);\n    });\n  });\n};\nDistributeElements.prototype.postExecute = function (context) {};","map":null,"metadata":{},"sourceType":"module"}