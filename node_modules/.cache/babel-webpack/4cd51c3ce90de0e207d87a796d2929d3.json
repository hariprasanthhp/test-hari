{"ast":null,"code":"import { forEach, find, matchPattern } from 'min-dash';\nimport inherits from 'inherits';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { is } from '../../../util/ModelUtil';\nexport default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {\n  CommandInterceptor.call(this, eventBus);\n  var dragging = injector.get('dragging', false);\n  function fixConnection(connection) {\n    var source = connection.source,\n      target = connection.target,\n      parent = connection.parent;\n\n    // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n    if (!parent) {\n      return;\n    }\n    var replacementType, remove;\n\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    }\n\n    // transform message flows into sequence flows, if possible\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {\n      remove = true;\n    }\n\n    // remove invalid connection,\n    // unless it has been removed already\n    if (remove) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace SequenceFlow <> MessageFlow\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n  function replaceReconnectedConnection(event) {\n    var context = event.context,\n      connection = context.connection,\n      source = context.newSource || connection.source,\n      target = context.newTarget || connection.target,\n      allowed,\n      replacement;\n    allowed = bpmnRules.canConnect(source, target);\n    if (!allowed || allowed.type === connection.type) {\n      return;\n    }\n    replacement = modeling.connect(source, target, {\n      type: allowed.type,\n      waypoints: connection.waypoints.slice()\n    });\n\n    // remove old connection\n    modeling.removeConnection(connection);\n\n    // replace connection in context to reconnect end/start\n    context.connection = replacement;\n    if (dragging) {\n      cleanDraggingSelection(connection, replacement);\n    }\n  }\n\n  // monkey-patch selection saved in dragging in order to re-select it when operation is finished\n  function cleanDraggingSelection(oldConnection, newConnection) {\n    var context = dragging.context(),\n      previousSelection = context && context.payload.previousSelection,\n      index;\n\n    // do nothing if not dragging or no selection was present\n    if (!previousSelection || !previousSelection.length) {\n      return;\n    }\n    index = previousSelection.indexOf(oldConnection);\n    if (index === -1) {\n      return;\n    }\n    previousSelection.splice(index, 1, newConnection);\n  }\n\n  // lifecycle hooks\n\n  this.postExecuted('elements.move', function (context) {\n    var closure = context.closure,\n      allConnections = closure.allConnections;\n    forEach(allConnections, fixConnection);\n  }, true);\n  this.preExecute('connection.reconnect', replaceReconnectedConnection);\n  this.postExecuted('element.updateProperties', function (event) {\n    var context = event.context,\n      properties = context.properties,\n      element = context.element,\n      businessObject = element.businessObject,\n      connection;\n\n    // remove condition on change to default\n    if (properties.default) {\n      connection = find(element.outgoing, matchPattern({\n        id: element.businessObject.default.id\n      }));\n      if (connection) {\n        modeling.updateProperties(connection, {\n          conditionExpression: undefined\n        });\n      }\n    }\n\n    // remove default from source on change to conditional\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\n      modeling.updateProperties(element.source, {\n        default: undefined\n      });\n    }\n  });\n}\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\nReplaceConnectionBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules', 'injector'];","map":null,"metadata":{},"sourceType":"module"}