{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport * as Highcharts from 'highcharts/highstock';\nimport more from 'highcharts/highcharts-more';\nimport StreamgraphModule from 'highcharts/modules/streamgraph';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/shared/services/sso-auth.service\";\nimport * as i2 from \"src/app/cco/shared/services/websocket.service\";\nimport * as i3 from \"src/app-services/translate.service\";\nimport * as i4 from \"src/app/shared-utils/date-utils.service\";\nimport * as i5 from \"@angular/router\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"highcharts-angular\";\nfunction MultipleChartComponent_div_9_div_2_span_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 26);\n    i0.ɵɵelement(1, \"i\", 27);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.upRate, \" \");\n  }\n}\nfunction MultipleChartComponent_div_9_div_2_span_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 28);\n    i0.ɵɵelement(1, \"i\", 29);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.downRate, \"\");\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"background-color\": a0\n  };\n};\nfunction MultipleChartComponent_div_9_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵelementStart(1, \"div\", 13);\n    i0.ɵɵelementStart(2, \"div\", 14);\n    i0.ɵɵelementStart(3, \"div\", 15);\n    i0.ɵɵelementStart(4, \"a\", 16);\n    i0.ɵɵlistener(\"click\", function MultipleChartComponent_div_9_div_2_Template_a_click_4_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext(2);\n      return ctx_r4.toggleUpStream();\n    });\n    i0.ɵɵelement(5, \"span\", 17);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"a\", 18);\n    i0.ɵɵlistener(\"click\", function MultipleChartComponent_div_9_div_2_Template_a_click_7_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return ctx_r6.toggleDownStream();\n    });\n    i0.ɵɵelement(8, \"span\", 17);\n    i0.ɵɵtext(9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"span\", 19);\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(12, \"div\", 20);\n    i0.ɵɵelementStart(13, \"span\", 21);\n    i0.ɵɵtemplate(14, MultipleChartComponent_div_9_div_2_span_14_Template, 3, 1, \"span\", 22);\n    i0.ɵɵtemplate(15, MultipleChartComponent_div_9_div_2_span_15_Template, 3, 1, \"span\", 23);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(16, \"div\", 24);\n    i0.ɵɵelement(17, \"highcharts-chart\", 25);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(10, _c0, ctx_r1.isUpStreamVisible === true ? \"#0027FF\" : \"grey\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.language.up, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(12, _c0, ctx_r1.isDownStreamVisible === true ? \"#00d0ff\" : \"grey\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.language.down, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r1.language.interval, \" 1 sec\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isUpStreamVisible);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isDownStreamVisible);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"Highcharts\", ctx_r1.highcharts)(\"options\", ctx_r1.streamOptions)(\"callbackFunction\", ctx_r1.chartCallback);\n  }\n}\nfunction MultipleChartComponent_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵelementStart(1, \"div\", 10);\n    i0.ɵɵtemplate(2, MultipleChartComponent_div_9_div_2_Template, 18, 14, \"div\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.pageAvailable);\n  }\n}\nmore(Highcharts);\nStreamgraphModule(Highcharts);\nrequire('highcharts/highcharts-more.js')(Highcharts);\nexport let MultipleChartComponent = /*#__PURE__*/(() => {\n  class MultipleChartComponent {\n    constructor(sso, webSocketService, translateService, dateUtilsService, router) {\n      this.sso = sso;\n      this.webSocketService = webSocketService;\n      this.translateService = translateService;\n      this.dateUtilsService = dateUtilsService;\n      this.router = router;\n      this.monitorId = \"\";\n      this.EventName = \"\";\n      this.Name = \"\";\n      this.Type = \"\";\n      this.valueChange = new EventEmitter();\n      this.highcharts = Highcharts;\n      this.selectedOption = 1;\n      this.showRealTime = true;\n      this.data = {};\n      this.yAxixTitle = \"bps\";\n      this.chartName = \"\";\n      this.cachePacketData = {};\n      this.cacheRateData = {};\n      this.applicationWSRequestObj = {\n        \"orgId\": \"\",\n        \"networkId\": \"\",\n        \"monitorType\": \"\",\n        \"monitorId\": \"\",\n        \"graphType\": \"TRF\"\n      };\n      this.load = true;\n      this.pageAvailable = false;\n      this.lastData = [0, 0];\n      this.currentData = [0, 0];\n      this.chartData = [0, 0];\n      this.lastChartDataObj = {};\n      this.time = 0;\n      this.msgLen = 0;\n      this.reloadChart = false;\n      this.inc = 0;\n      this.renderOnce = false;\n      this.ddoptions = [{\n        id: 1,\n        name: '5 Minutes'\n      }, {\n        id: 2,\n        name: '10 Minutes'\n      }, {\n        id: 3,\n        name: '15 Minutes'\n      }, {\n        id: 4,\n        name: '20 Minutes'\n      }, {\n        id: 5,\n        name: '25 Minutes'\n      }, {\n        id: 6,\n        name: '30 Minutes'\n      }];\n      this.windowType = \"5 Minutes\";\n      this.yATitle = \"bps\";\n      this.isDownStreamVisible = true;\n      this.isUpStreamVisible = true;\n      this.cacheRateRTDataObj = {};\n      this.cachePacketRTDataObj = {};\n      this.conversions = {\n        'bps': 1,\n        'Kbps': 1000,\n        'Mbps': 1000000,\n        'Gbps': 1000000000,\n        'Tbps': 1000000000000,\n        'pps': 1,\n        'Kpps': 1000,\n        'Mpps': 1000000,\n        'Gpps': 1000000000,\n        'Tpps': 1000000000000\n      };\n      this.sizes = {\n        'bps': 1,\n        'Kbps': 1000,\n        'Mbps': 1000000,\n        'Gbps': 1000000000,\n        'Tbps': 1000000000000,\n        'pps': 1,\n        'Kpps': 1000,\n        'Mpps': 1000000,\n        'Gpps': 1000000000,\n        'Tpps': 1000000000000\n      };\n      this.count = 0;\n      this.lastSubscriptionData = {};\n    }\n    ngOnInit() {\n      this.checkLastSubscriptiontime();\n      this.ddoptions.forEach(element => {\n        if (element.id === this.selectedTime) {\n          this.windowType = element.name;\n        }\n      });\n      this.language = this.translateService.defualtLanguage;\n      if (this.language) {\n        this.pageAvailable = true;\n      }\n      this.languageSubject = this.translateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n      this.load = true;\n      this.chartName = this.Type;\n      this.yAxixTitle = this.Type === \"Rate\" ? \"bps\" : \"pps\";\n      // this.orgId = this.sso.getOrgId();\n      let url = this.router.url;\n      this.orgId = this.sso.getOrganizationID(url);\n      this.orgid_tenantid = this.orgId + '_' + '0';\n      this.applicationWSRequestObj.orgId = this.orgId;\n      this.applicationWSRequestObj.monitorType = this.EventName;\n      this.applicationWSRequestObj.networkId = this.orgid_tenantid;\n      this.applicationWSRequestObj.monitorId = this.monitorId;\n      this.applicationWSRequestObj['startTime'] = this.startTime;\n      this.yATitle = this.Type === \"Rate\" ? \"bps\" : \"pps\";\n      this.buildNewChart();\n      if (!this.replay) {\n        if (!this.doWSCall) {\n          this.getRtData();\n        } else {\n          this.getRtData();\n          this.send(this.EventName, this.applicationWSRequestObj);\n          this.webSocketService.listenMultiple(this.EventName);\n        }\n      } else if (this.replay) {\n        this.getRtData();\n        this.applicationWSRequestObj['replay'] = 'true';\n        this.applicationWSRequestObj['endTime'] = new Date().getTime();\n        this.send(this.EventName, this.applicationWSRequestObj);\n        this.webSocketService.listenMultiple('REPLAY');\n        this.webSocketService.listenMultiple(this.EventName);\n      }\n      let that = this;\n      document.addEventListener(\"visibilitychange\", function () {\n        that.rebuildData();\n      });\n    }\n    ngOnChanges(changes) {\n      // console.log(\"changes\", changes);\n    }\n    ngOnDestroy() {\n      this.streamOptions = {};\n      clearInterval(this.interval);\n      this.interval = null;\n      clearInterval(this.lastSubscriptionInterval);\n      this.lastSubscriptionInterval = null;\n      if (this.streamSubscription) {\n        this.streamSubscription.unsubscribe();\n      }\n      if (this.multipleStreamSubscription) {\n        this.multipleStreamSubscription.unsubscribe();\n      }\n      if (this.languageSubject) {\n        this.languageSubject.unsubscribe();\n      }\n    }\n    send(eventname, data) {\n      this.webSocketService.multipleEmit(eventname, data);\n    }\n    getRtData() {\n      if (this.streamSubscription) {\n        this.streamSubscription.unsubscribe();\n      }\n      if (this.multipleStreamSubscription) {\n        this.multipleStreamSubscription.unsubscribe();\n      }\n      this.multipleStreamSubscription = this.webSocketService.multipleRatePacketStreamData$.subscribe(cdata => {\n        this.cacheRateRTDataObj = {};\n        this.cachePacketRTDataObj = {};\n        if (cdata && cdata.length) {\n          cdata = cdata.slice();\n          if (cdata[0].includes(this.monitorId)) {\n            cdata.forEach(element => {\n              let data;\n              if (this.IsJsonString(element)) {\n                data = JSON.parse(element);\n              } else {\n                data = element;\n              }\n              this.cacheRTData(data, this.Type);\n              if (this.Type === 'Rate') {\n                this.data = data.maxRate;\n              } else {\n                this.data = data.packet;\n              }\n            });\n            this.lastChartDataObj = this.getCachedata(this.Type);\n            this.lastData = this.data;\n            this.chartData = this.data;\n            this.currentData = this.data;\n            setTimeout(() => {\n              this.rebuildData();\n            }, 500);\n          }\n        }\n      });\n      this.streamSubscription = this.webSocketService.multipleStreamData$.subscribe(data => {\n        this.showRealTime = true;\n        if (data.monitorId === this.monitorId) {\n          if (data.graphType === 'TRF') {\n            this.lastSubscriptionData = data;\n            this.lastSubscriptionTime = new Date().getTime();\n            if (this.Type === \"Rate\") {\n              this.data = data.maxRate;\n            } else {\n              this.data = data.packet;\n            }\n            this.time = data.sendTime;\n            this.showRealTime = true;\n            if (this.data) {\n              this.yAxixTitle = this.getYAxisTitle(this.data);\n              this.yAxixTitle = this.yAxixTitle ? this.yAxixTitle : this.Type === \"Rate\" ? \"bps\" : \"pps\";\n              if (this.currentData) {\n                this.lastData = Object.assign([], this.currentData);\n                this.chartData = Object.assign([], this.currentData);\n              } else {\n                this.lastData = [0, 0];\n                this.chartData = [0, 0];\n              }\n              setTimeout(() => {\n                this.currentData = Object.assign([], this.data);\n              }, 100);\n            } else {\n              this.currentData = [0, 0];\n              this.lastData = [0, 0];\n              this.chartData = [0, 0];\n            }\n            if (this.count === 1) {\n              this.buildNewChart();\n            }\n          }\n        }\n      });\n    }\n    closeChart() {\n      let obj = {\n        \"monitorId\": this.monitorId,\n        \"Type\": this.Type,\n        \"Position\": this.Position\n      };\n      this.valueChange.emit(obj);\n    }\n    toggleDownStream() {\n      if (this.streamOptions.series[1].visible) {\n        this.streamOptions.series[1].visible = false;\n        this.isDownStreamVisible = false;\n      } else {\n        this.streamOptions.series[1].visible = true;\n        this.isDownStreamVisible = true;\n      }\n      this.rebuildData();\n    }\n    toggleUpStream() {\n      if (this.streamOptions.series[0].visible) {\n        this.streamOptions.series[0].visible = false;\n        this.isUpStreamVisible = false;\n      } else {\n        this.streamOptions.series[0].visible = true;\n        this.isUpStreamVisible = true;\n      }\n      this.rebuildData();\n    }\n    transformData(currentData, lastData, data) {\n      if (this.chartName.toLowerCase() === 'rate') {}\n      if (!lastData || !lastData.length) {\n        lastData = [0, 0];\n      }\n      let chartData = [];\n      for (let i = 0; i < currentData.length; i++) {\n        let delta = parseFloat(currentData[i]) - parseFloat(lastData[i]);\n        if (!parseFloat(currentData[i]) && !parseFloat(lastData[i])) {\n          data[i] = 0;\n        }\n        let deltaRate = delta / 15;\n        let value = parseFloat(data[i]) + deltaRate;\n        chartData.push(value);\n      }\n      if (!chartData[0] && !chartData[1] && (currentData[0] || currentData[1]) && this.msgLen > 2) {\n        chartData = currentData;\n      }\n      return chartData;\n    }\n    cacheRTData(data, type) {\n      if (type === 'Rate') {\n        if (this.currentDataRate) {\n          this.lastDataRate = this.currentDataRate;\n        } else {\n          this.chartDataRate = [0, 0];\n        }\n        this.currentDataRate = data.maxRate ? data.maxRate : [0, 0];\n        this.yAxixTitle = 'bps';\n        let loadTime = data.sendTime ? data.sendTime : 0;\n        for (let i = 1; i <= 15; i++) {\n          var time = loadTime + i * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cacheRateRTDataObj[key] = this.generateRTforCache(this.currentDataRate, this.lastDataRate, this.chartDataRate);\n          this.removeReplayOldKeys(this.cacheRateRTDataObj, type);\n        }\n      } else {\n        if (this.currentDataPacket) {\n          this.lastDataPacket = this.currentDataPacket;\n        } else {\n          this.chartDataPacket = [0, 0];\n        }\n        this.currentDataPacket = data.packet ? data.packet : [];\n        this.yAxixTitlePacket = 'pps';\n        let loadTime = data.sendTime ? data.sendTime : 0;\n        for (let i = 1; i <= 15; i++) {\n          var time = loadTime + i * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cachePacketRTDataObj[key] = this.generateRTforCache(this.currentDataPacket, this.lastDataPacket, this.chartDataPacket);\n          this.removeReplayOldKeys(this.cachePacketRTDataObj, type);\n        }\n      }\n    }\n    getCachedata(chartName) {\n      if (chartName === 'Rate') {\n        return this.cacheRateRTDataObj;\n      } else {\n        return this.cachePacketRTDataObj;\n      }\n    }\n    removeReplayOldKeys(lastChartDataObj, chartName) {\n      let keys = Object.keys(lastChartDataObj);\n      let len = keys.length;\n      let windowLen = this.selectedTime * 300;\n      if (len > windowLen) {\n        let obj = lastChartDataObj;\n        let removeLen = len - windowLen;\n        for (let i = 0; i < removeLen; i++) {\n          delete obj[keys[i]];\n        }\n        if (chartName === 'rate') {\n          this.cacheRateRTDataObj = obj;\n        } else {\n          this.cachePacketRTDataObj = obj;\n        }\n      }\n    }\n    generateRTforCache(currentData, lastData, chartData) {\n      let data = this.transformData(currentData, lastData, chartData);\n      if (this.chartName === 'Rate') {\n        this.chartDataRate = data;\n      } else {\n        this.chartDataPacket = data;\n      }\n      if (!data[0]) {\n        data[0] = 0;\n      }\n      if (!data[1]) {\n        data[1] = 0;\n      }\n      let upRate = this.bitsToSize(data[0]);\n      let downRate = this.bitsToSize(data[1]);\n      let vArr1 = upRate.split(\" \");\n      let vArr2 = downRate.split(\" \");\n      let upRateUnit = vArr1[1] ? vArr1[1] : this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      let downRateUnit = vArr2[1] ? vArr2[1] : this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      let maxUnit = '';\n      if (data[0] || data[1]) {\n        if (data[0] > data[1]) {\n          maxUnit = vArr1[1];\n        } else {\n          maxUnit = vArr2[1];\n        }\n      } else {\n        if (this.chartName.toLowerCase() === 'rate') {\n          maxUnit = this.yAxixTitle ? this.yAxixTitle : this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        } else {\n          maxUnit = this.yAxixTitlePacket ? this.yAxixTitlePacket : this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        }\n      }\n      if (maxUnit == 'undefined') {\n        //maxUnit = this.yAxixTitle ? this.yAxixTitle : (chartName.toLowerCase() === 'rate') ? 'bps' : 'pps';\n        if (this.chartName.toLowerCase() === 'rate') {\n          maxUnit = this.yAxixTitle ? this.yAxixTitle : this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        } else {\n          maxUnit = this.yAxixTitlePacket ? this.yAxixTitlePacket : this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        }\n      }\n      if (typeof maxUnit === 'string') {\n        //this.yAxixTitle = maxUnit;\n        if (this.chartName.toLowerCase() === 'rate') {\n          this.yAxixTitle = maxUnit;\n        } else {\n          this.yAxixTitlePacket = maxUnit;\n        }\n      }\n      if (data) {\n        if (this.chartName.toLowerCase() === 'rate') {\n          return [data[0], data[1], this.yAxixTitle, upRateUnit, downRateUnit];\n        } else {\n          return [data[0], data[1], this.yAxixTitlePacket, upRateUnit, downRateUnit];\n        }\n      }\n    }\n    bitsToSize(bits) {\n      let bytes = parseFloat(bits);\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && this.chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && this.chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2) + ' ' + sizes[i];\n    }\n    removeLast3Chars(str) {\n      str = str.toString();\n      str = str.slice(0, -3);\n      str = parseInt(str);\n      return str;\n    }\n    removeOldKeys() {\n      let keys = Object.keys(this.lastChartDataObj);\n      let len = keys.length;\n      if (len > 300 * this.selectedTime) {\n        let obj = this.lastChartDataObj;\n        let removeLen = len - 300 * this.selectedTime;\n        for (let i = 0; i < removeLen; i++) {\n          delete obj[keys[i]];\n        }\n        this.lastChartDataObj = obj;\n      }\n    }\n    getPacketRate(bits) {\n      let bytes = bits;\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && this.chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && this.chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1024));\n      return Math.round(bytes / Math.pow(1000, i)) + ' ' + sizes[i];\n    }\n    timezoneDetected() {\n      var dtDate = new Date('1/1/' + new Date().getUTCFullYear());\n      var intOffset = 10000;\n      var intMonth;\n      for (intMonth = 0; intMonth < 12; intMonth++) {\n        dtDate.setUTCMonth(dtDate.getUTCMonth() + 1);\n        if (intOffset > dtDate.getTimezoneOffset() * -1) {\n          intOffset = dtDate.getTimezoneOffset() * -1;\n        }\n      }\n      return parseInt(this.sso.getRealtimeDelay());\n      // return -75 * 1000;\n      // return 0;\n      //return intOffset * 60 * 1000;\n    }\n\n    rebuildData() {\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      let keys = Object.keys(this.lastChartDataObj);\n      let length = keys.length;\n      if (length) {\n        let time = new Date().getTime() + this.timezoneDetected(),\n          i;\n        for (i = -299; i <= 0; i += 1) {\n          let timeKey = time + i * 1000;\n          let key = this.removeLast3Chars(timeKey);\n          if (typeof this.lastChartDataObj[key] == 'undefined' && typeof this.lastChartDataObj[key - 1] !== 'undefined') {\n            this.lastChartDataObj[key] = this.lastChartDataObj[key - 1];\n          } else if (typeof this.lastChartDataObj[key] == 'undefined' && typeof this.lastChartDataObj[key - 2] !== 'undefined') {\n            this.lastChartDataObj[key] = this.lastChartDataObj[key - 2];\n          }\n        }\n        this.reloadChart = true;\n        this.buildNewChart();\n      }\n    }\n    chartCallback(chart) {}\n    buildNewChart() {\n      var _a, _b;\n      this.count = this.count + 1;\n      this.renderOnce = true;\n      this.time = this.dateUtilsService.getCurrentUtcTime() * 1000;\n      this.streamOptions = {};\n      let timezoneDetected = this.timezoneDetected();\n      let loadTime = new Date().getTime();\n      var chartxaxis = {\n        type: 'datetime',\n        tickPixelInterval: 120\n      };\n      var charcredits = {\n        enabled: false\n      };\n      var chartyaxis = {\n        gridLineDashStyle: 'longdash',\n        opposite: false,\n        startOnTick: false,\n        endOnTick: false,\n        title: {\n          text: this.yAxixTitle,\n          margin: 40\n        },\n        labels: {\n          align: 'left',\n          x: -35,\n          formatter: function () {\n            return Math.abs(this.value);\n          }\n        }\n      };\n      let that = this;\n      this.streamOptions = {\n        chart: {\n          type: 'areaspline',\n          zoomType: 'x',\n          height: 170,\n          events: {\n            load: function () {\n              let sizes = that.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n              var series = this.series;\n              that.interval = setInterval(function () {\n                that.inc++;\n                let data = that.transformData(that.currentData, that.lastData, that.chartData);\n                that.chartData = data;\n                if (!data[0]) {\n                  data[0] = 0;\n                }\n                if (!data[1]) {\n                  data[1] = 0;\n                }\n                let upRate = that.bitsToSize(data[0]);\n                let downRate = that.bitsToSize(data[1]);\n                let vArr1 = upRate.split(\" \");\n                let vArr2 = downRate.split(\" \");\n                let upRateValue = vArr1[0];\n                let downRateValue = vArr2[0];\n                let upRateUnit = vArr1[1] ? vArr1[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let downRateUnit = vArr2[1] ? vArr2[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let maxUnit = '';\n                upRateUnit = upRateUnit == 'undefined' ? that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps' : upRateUnit;\n                downRateUnit = downRateUnit == 'undefined' ? that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps' : downRateUnit;\n                if (data[0] || data[1]) {\n                  if (data[0] > data[1]) {\n                    maxUnit = vArr1[1];\n                  } else {\n                    maxUnit = vArr2[1];\n                  }\n                } else {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit == 'undefined') {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit != undefined && that.yAxixTitle != maxUnit && (data[0] || data[1])) {\n                  that.yAxixTitle = maxUnit;\n                  that.streamOptions.yAxis.title.text = that.yAxixTitle;\n                  that.rebuildData();\n                  return;\n                }\n                if (maxUnit != undefined && that.yATitle != maxUnit && (data[0] || data[1])) {\n                  that.yATitle = maxUnit;\n                  that.streamOptions.yAxis.title.text = that.yATitle;\n                  that.rebuildData();\n                  return;\n                }\n                if (typeof maxUnit === 'string') {\n                  that.yAxixTitle = maxUnit;\n                }\n                let v1 = parseFloat(vArr1[0]);\n                let v2 = parseFloat(vArr2[0]);\n                if ((data[0] || data[1]) && data[0] < data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV2 - indexV1;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v1 = v1 / 1000;\n                    }\n                  }\n                }\n                if ((data[0] || data[1]) && data[0] > data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV1 - indexV2;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v2 = v2 / 1000;\n                    }\n                  }\n                }\n                if (data) {\n                  var time = new Date().getTime() + timezoneDetected;\n                  let num = parseFloat(Highcharts.numberFormat(Math.abs(v1), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.upRate = `${upRateValue} ${upRateUnit ? upRateUnit : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps'}`;\n                  num = parseFloat(Highcharts.numberFormat(Math.abs(v2), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.removeOldKeys();\n                  that.downRate = `${downRateValue} ${downRateUnit ? downRateUnit : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps'}`;\n                  var x = time,\n                    y = v1;\n                  series[0].addPoint([x, y], true, true);\n                  var sx = time,\n                    sy = -v2;\n                  series[1].addPoint([sx, sy], true, true);\n                  let key = that.removeLast3Chars(time);\n                  that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.lastChartDataObj[key + 1] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                }\n                if (series[0].chart.resetZoomButton && series[0].xData.length) {\n                  let range = series[0].chart.xAxis[0].getExtremes();\n                  series[0].chart.xAxis[0].setExtremes(range.min + 1200, range.max + 1200);\n                }\n              }, 1000);\n            }\n          }\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: ''\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        //colors: ['#FF8238', '#836EE8'],\n        xAxis: chartxaxis,\n        yAxis: chartyaxis,\n        credits: charcredits,\n        plotOptions: {\n          areaspline: {\n            lineWidth: 1,\n            marker: {\n              enabled: false\n            },\n            fillOpacity: 0.75\n          },\n          spline: {\n            animation: false,\n            marker: {\n              enabled: false,\n              radius: 0.9,\n              lineWidth: 0.7\n            }\n          },\n          series: {\n            turboThreshold: 1000000\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            let dateValue = this.point.x;\n            var dateStr = that.dateUtilsService.getLocalRealtimeDateFormat(dateValue);\n            let datakey = that.removeLast3Chars(this.point.x);\n            let unit = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][2] : '';\n            if (this.series.name == 'up') {\n              return `<b> ${dateStr}  </b><br/>\n            ${that.language.Upstream}: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle}`;\n            }\n            if (this.series.name == 'down') {\n              return `<b> ${dateStr}  </b><br/>\n            ${that.language.Downstream}: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle}`;\n            }\n          }\n        },\n        legend: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        series: [{\n          name: ((_a = that === null || that === void 0 ? void 0 : that.language) === null || _a === void 0 ? void 0 : _a.upStream) ? that.language.upStream : 'up',\n          data: function () {\n            var data = [],\n              time = new Date().getTime() + timezoneDetected,\n              i;\n            for (i = -299 * that.selectedTime; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][0] : that.lastChartDataObj[key - 1] && that.lastChartDataObj[key - 1][0] ? that.lastChartDataObj[key - 1][0] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][0] : that.lastChartDataObj[key - 2] && that.lastChartDataObj[key - 2][0] ? that.lastChartDataObj[key - 2][0] : 0;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            return data;\n          }()\n        }, {\n          name: ((_b = that === null || that === void 0 ? void 0 : that.language) === null || _b === void 0 ? void 0 : _b.downStream) ? that.language.downStream : 'down',\n          data: function () {\n            var data = [],\n              time = new Date().getTime() + timezoneDetected,\n              i;\n            for (i = -299 * that.selectedTime; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][1] : that.lastChartDataObj[key - 1] && that.lastChartDataObj[key - 1][1] ? that.lastChartDataObj[key - 1][1] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][1] : that.lastChartDataObj[key - 2] && that.lastChartDataObj[key - 2][1] ? that.lastChartDataObj[key - 2][1] : 0;\n              }\n              if (that.lastChartDataObj[key]) {\n                that.lastChartDataObj[key][1] = value;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              value = value * -1;\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            return data;\n          }()\n        }]\n      };\n      this.streamOptions.series[0].visible = this.isUpStreamVisible;\n      this.streamOptions.series[1].visible = this.isDownStreamVisible;\n      this.streamOptions = Object.assign({}, this.streamOptions);\n    }\n    bitsConversion(bits) {\n      let down = false;\n      if (bits < 0) {\n        bits = -bits;\n        down = true;\n      }\n      let bytes = parseFloat(bits);\n      if (bytes == 0) return 0;\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      var val = parseInt(Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2));\n      return down ? -1 * val : val;\n    }\n    getYAxisTitle(bits) {\n      let bytes = bits[0] > bits[1] ? bits[0] : bits[1];\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      var i = Math.floor(Math.log(bytes) / Math.log(1024));\n      return sizes[i];\n    }\n    checkLastSubscriptiontime() {\n      this.lastSubscriptionInterval = setInterval(() => {\n        let diff = new Date().getTime() - this.lastSubscriptionTime;\n        if (diff >= 30000) {\n          this.lastSubscriptionData.maxRate = [0, 0];\n          this.lastSubscriptionData.packet = [0, 0];\n          this.webSocketService.multipleStreamData$.next(this.lastSubscriptionData);\n          if (this.currentData) {\n            this.lastData = Object.assign([], this.currentData);\n            this.chartData = Object.assign([], this.currentData);\n          } else {\n            this.lastData = [0, 0];\n            this.chartData = [0, 0];\n          }\n          this.currentData = [0, 0];\n        }\n      }, 15000);\n    }\n    IsJsonString(str) {\n      try {\n        JSON.parse(str);\n      } catch (e) {\n        return false;\n      }\n      return true;\n    }\n  }\n  MultipleChartComponent.ɵfac = function MultipleChartComponent_Factory(t) {\n    return new (t || MultipleChartComponent)(i0.ɵɵdirectiveInject(i1.SsoAuthService), i0.ɵɵdirectiveInject(i2.WebsocketService), i0.ɵɵdirectiveInject(i3.TranslateService), i0.ɵɵdirectiveInject(i4.DateUtilsService), i0.ɵɵdirectiveInject(i5.Router));\n  };\n  MultipleChartComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MultipleChartComponent,\n    selectors: [[\"app-multiple-chart\"]],\n    inputs: {\n      monitorId: \"monitorId\",\n      EventName: \"EventName\",\n      Name: \"Name\",\n      Type: \"Type\",\n      windowLen: \"windowLen\",\n      selectedTime: \"selectedTime\",\n      Position: \"Position\",\n      doWSCall: \"doWSCall\",\n      replay: \"replay\",\n      startTime: \"startTime\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 7,\n    consts: [[1, \"row\", 2, \"padding\", \"10px\"], [1, \"col-md-12\", \"px-0\"], [1, \"mwc-header\", \"flex\", \"w-100\", \"border-bottom\", \"mb-2\"], [\"data-toggle\", \"tooltip\", \"data-placement\", \"top\", 1, \"cco-secondary-title\", \"title-tooltip\", 3, \"title\"], [1, \"mwc-btns\", \"flex\", \"align-items-center\"], [\"type\", \"button\", \"aria-label\", \"Close\", 1, \"close\", \"m-2\", 3, \"click\"], [\"aria-hidden\", \"true\"], [1, \"col-md-12\", \"col-lg-12\", \"col-xl-12\", \"col-sm-12\", \"px-0\"], [\"id\", \"traffic-location-realtime-rate\", \"class\", \"card m-10\", 4, \"ngIf\"], [\"id\", \"traffic-location-realtime-rate\", 1, \"card\", \"m-10\"], [\"id\", \"ngx-stream-path-chart-rate\", 1, \"\"], [\"class\", \"analytic-widget\", 4, \"ngIf\"], [1, \"analytic-widget\"], [1, \"analytic-widget-header\"], [1, \"d-flex\", \"justify-content-between\"], [1, \"ml-1\"], [1, \"legend-label\", \"toggle-up\", 3, \"click\"], [1, \"legend-glyph\", 3, \"ngStyle\"], [1, \"legend-label\", \"toggle-down\", 3, \"click\"], [1, \"interval\"], [1, \"mr-1\", 2, \"text-align\", \"right\"], [1, \"traffic-volume\", \"monitor-status-normal\"], [\"style\", \"color: #0027FF;\", 4, \"ngIf\"], [\"style\", \"color: #5ACFEA;\", 4, \"ngIf\"], [1, \"analytic-widget-body\"], [\"id\", \"custom-mirrot-chart\", 2, \"width\", \"100%\", \"display\", \"block\", 3, \"Highcharts\", \"options\", \"callbackFunction\"], [2, \"color\", \"#0027FF\"], [\"aria-hidden\", \"true\", 1, \"fa\", \"fa-arrow-up\"], [2, \"color\", \"#5ACFEA\"], [\"aria-hidden\", \"true\", 1, \"fa\", \"fa-arrow-down\"]],\n    template: function MultipleChartComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"div\", 4);\n        i0.ɵɵelementStart(6, \"button\", 5);\n        i0.ɵɵlistener(\"click\", function MultipleChartComponent_Template_button_click_6_listener() {\n          return ctx.closeChart();\n        });\n        i0.ɵɵelement(7, \"span\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(8, \"div\", 7);\n        i0.ɵɵtemplate(9, MultipleChartComponent_div_9_Template, 3, 1, \"div\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵpropertyInterpolate3(\"title\", \"\", ctx.Name, \" \", ctx.Type, \" (\", ctx.windowType, \")\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate3(\" \", ctx.Name, \" \", ctx.Type, \" (\", ctx.windowType, \") \");\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.data.length || ctx.showRealTime);\n      }\n    },\n    directives: [i6.NgIf, i6.NgStyle, i7.HighchartsChartComponent],\n    styles: [\"@charset \\\"UTF-8\\\";.health-pon-menu-wrapper[_ngcontent-%COMP%]{display:flex;width:100%;flex-wrap:wrap;justify-content:space-between;align-items:center}.health-pon-menu-item[_ngcontent-%COMP%]{flex-grow:1;border-left:3px solid #cdcdcd}.health-pon-menu-item[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{font-weight:600}.health-pon-menu-item[_ngcontent-%COMP%]   .menu-title[_ngcontent-%COMP%]{font-size:14px;font-weight:500}.health-pon-menu-item[_ngcontent-%COMP%]   .red[_ngcontent-%COMP%]{color:#ff3600}.health-pon-menu-item[_ngcontent-%COMP%]   .orange[_ngcontent-%COMP%]{color:#fc7235}.health-pon-menu-item[_ngcontent-%COMP%]   .blue[_ngcontent-%COMP%]{color:#72b4ff}.health-pon-menu-item[_ngcontent-%COMP%]   .yellow[_ngcontent-%COMP%]{color:#f3b426}.health-pon-menu-item[_ngcontent-%COMP%]   .green[_ngcontent-%COMP%]{color:#82bf00}.btn-secondary[_ngcontent-%COMP%]{color:#5f6165!important;background-color:#f8f8fa!important;border-color:#f8f8fa!important;padding:3px \\\\200b 10px}.all-icon[_ngcontent-%COMP%]{font-size:10px;color:#9c9c9c;line-height:31px}.undo-icon[_ngcontent-%COMP%]{background-color:#f8f8fa;padding:3px;color:#9e9e9e;border-radius:15px;margin:2px;font-size:17px;cursor:pointer;width:30px;height:30px;text-align:center}.current-issue-menu-container[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;justify-content:space-between;aling-items:center;margin:0;justify-self:start}.current-issue-menu-item[_ngcontent-%COMP%]{flex-grow:0;width:16%}.subscriber-trends-wrapper[_ngcontent-%COMP%]{display:flex;width:100%}.subscriber-trends-item[_ngcontent-%COMP%]{flex-grow:1;width:calc(100% / 3)}.subscriber-trends-item[_ngcontent-%COMP%] + .subscriber-trends-item[_ngcontent-%COMP%]{margin-left:5%}.cco-health-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]   .test[_ngcontent-%COMP%]{display:none}.cco-health-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover   td[_ngcontent-%COMP%]   .test[_ngcontent-%COMP%]{display:block;font-size:13px;cursor:pointer;float:right}.cco-secondary-title[_ngcontent-%COMP%]{font-size:24px;font-style:normal;font-weight:400;line-height:30px;letter-spacing:0em;text-align:left;color:#1a1f22}@media screen and (max-width: 767px){.subscriber-trends-wrapper[_ngcontent-%COMP%]{display:block}.subscriber-trends-item[_ngcontent-%COMP%]{width:100%}.subscriber-trends-item[_ngcontent-%COMP%] + .subscriber-trends-item[_ngcontent-%COMP%]{margin-left:0%!important}.md-block[_ngcontent-%COMP%]{display:block!important}}.mwc-header[_ngcontent-%COMP%]{justify-content:space-between;margin-bottom:20px}.mwc-btns[_ngcontent-%COMP%]{justify-content:flex-end}.expand-icon[_ngcontent-%COMP%]{background-color:#ebeaef;color:#ebeaef;width:25px;height:25px;border-radius:20px;font-size:1px;text-align:center;line-height:24px;font-weight:normal;justify-content:center;background-image:url(ic_expand_grey.a00ec25dcedb0cff0b8c.svg);background-position:50%;background-repeat:no-repeat}.expand-inverted-icon[_ngcontent-%COMP%]{background-color:#ebeaef;color:#ebeaef;width:25px;height:25px;border-radius:20px;font-size:1px;text-align:center;line-height:24px;font-weight:normal;justify-content:center;background-image:url(ic_expand_inverted_grey.044960530517ee37a1a9.svg);background-position:50%;background-repeat:no-repeat}.highcharts-data-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{min-width:320px;max-width:800px;margin:1em auto}.highcharts-data-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{font-family:Verdana,sans-serif;border-collapse:collapse;border:1px solid #EBEBEB;margin:10px auto;text-align:center;width:100%;max-width:500px}.highcharts-data-table[_ngcontent-%COMP%]   caption[_ngcontent-%COMP%]{padding:1em 0;font-size:1.2em;color:#555}.highcharts-data-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{font-weight:600;padding:.5em}.highcharts-data-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   caption[_ngcontent-%COMP%]{padding:.5em}.highcharts-data-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:nth-child(even){background:#f8f8f8}.highcharts-data-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{background:#f1f7ff}.analytic-widget[_ngcontent-%COMP%]   .analytic-widget-header[_ngcontent-%COMP%]{display:block}.analytic-widget[_ngcontent-%COMP%]   .analytic-widget-header-cell[_ngcontent-%COMP%]{display:block;padding:5px 5px 5px 10px;position:relative}.analytic-widget[_ngcontent-%COMP%]   .legend-glyph[_ngcontent-%COMP%]{display:inline-block;margin-left:4px;margin-right:4px;width:10px;height:10px;border-radius:6px}.analytic-widget[_ngcontent-%COMP%]   .legend-label[_ngcontent-%COMP%]{display:inline-block;font-size:12px;padding-right:3px;margin-right:2px;border-color:#e1dfec;background-color:#eae8f3;border-width:1px;text-decoration:none;cursor:pointer}.analytic-widget[_ngcontent-%COMP%]   .interval[_ngcontent-%COMP%]{background:#efefef;padding:2px 7px;font-size:10px;border-radius:2px;color:#666;margin-right:5px}.analytic-widget[_ngcontent-%COMP%]   .traffic-volume.monitor-status-normal[_ngcontent-%COMP%]{margin-top:0;background-color:#eae8f3;border-color:#e1dfec;border-width:1px;font-size:12px}.title-tooltip[_ngcontent-%COMP%]{width:80%;text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.tooltip[_ngcontent-%COMP%]{display:inline;position:relative}.tooltip[_ngcontent-%COMP%]:hover:after{display:flex;justify-content:center;background:#444;border-radius:8px;color:#fff;content:attr(title);margin:-82px auto 0;font-size:16px;padding:13px;width:220px}.tooltip[_ngcontent-%COMP%]:hover:before{border:solid;border-color:#444 transparent;border-width:12px 6px 0 6px;content:\\\"\\\";left:45%;bottom:30px;position:absolute}\"]\n  });\n  return MultipleChartComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}