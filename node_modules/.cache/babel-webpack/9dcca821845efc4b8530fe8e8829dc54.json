{"ast":null,"code":"import inherits from 'inherits';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { find } from 'min-dash';\nimport { is } from '../../../util/ModelUtil';\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n  CommandInterceptor.call(this, eventBus);\n  this.executed(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));\n  this.reverted(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));\n  function usesTargetRef(element, targetRef, removedConnection) {\n    var inputAssociations = element.get('dataInputAssociations');\n    return find(inputAssociations, function (association) {\n      return association !== removedConnection && association.targetRef === targetRef;\n    });\n  }\n  function getTargetRef(element, create) {\n    var properties = element.get('properties');\n    var targetRefProp = find(properties, function (p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n      collectionAdd(properties, targetRefProp);\n    }\n    return targetRefProp;\n  }\n  function cleanupTargetRef(element, connection) {\n    var targetRefProp = getTargetRef(element);\n    if (!targetRefProp) {\n      return;\n    }\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n    var context = event.context,\n      connection = context.connection,\n      connectionBo = connection.businessObject,\n      target = connection.target,\n      targetBo = target && target.businessObject,\n      newTarget = context.newTarget,\n      newTargetBo = newTarget && newTarget.businessObject,\n      oldTarget = context.oldTarget || context.target,\n      oldTargetBo = oldTarget && oldTarget.businessObject;\n    var dataAssociation = connection.businessObject,\n      targetRefProp;\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\nDataInputAssociationBehavior.$inject = ['eventBus', 'bpmnFactory'];\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n\n/**\n * Only call the given function when the event\n * touches a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\nfunction ifDataInputAssociation(fn) {\n  return function (event) {\n    var context = event.context,\n      connection = context.connection;\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}