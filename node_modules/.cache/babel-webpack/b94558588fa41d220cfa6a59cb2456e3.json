{"ast":null,"code":"import { DatePipe } from '@angular/common';\nimport * as Highcharts from 'highcharts';\nimport * as moment from 'moment';\nimport { environment } from 'src/environments/environment';\nimport * as $ from 'jquery';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"@ng-bootstrap/ng-bootstrap\";\nimport * as i3 from \"src/app-services/translate.service\";\nimport * as i4 from \"../../data.service\";\nimport * as i5 from \"src/app/shared/services/sso-auth.service\";\nimport * as i6 from \"../../support-device/service/device.service\";\nimport * as i7 from \"./../services/issues.service\";\nimport * as i8 from \"@angular/platform-browser\";\nimport * as i9 from \"@angular/common\";\nimport * as i10 from \"../../shared/component/subscriber-menu/subscriber-menu.component\";\nimport * as i11 from \"@ng-select/ng-select\";\nimport * as i12 from \"@angular/forms\";\nimport * as i13 from \"primeng/calendar\";\nimport * as i14 from \"@angular-slider/ngx-slider\";\nconst _c0 = [\"clientEfficencyChartTest\"];\nfunction QualityOfExperienceComponent_app_subscriber_menu_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"app-subscriber-menu\");\n  }\n}\nfunction QualityOfExperienceComponent_div_1_li_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 45);\n    i0.ɵɵelementStart(1, \"a\", 46);\n    i0.ɵɵelementStart(2, \"span\", 6);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵpropertyInterpolate1(\"routerLink\", \"/\", ctx_r2.MODULE, \"/overview/topology\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.language.Topology, \"\");\n  }\n}\nfunction QualityOfExperienceComponent_div_1_li_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 47);\n    i0.ɵɵelementStart(1, \"a\", 46);\n    i0.ɵɵelementStart(2, \"span\", 6);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵpropertyInterpolate1(\"routerLink\", \"/\", ctx_r3.MODULE, \"/overview/quality-of-experience\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.language[\"Quality of Experience\"]);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 48);\n    i0.ɵɵelementStart(1, \"span\", 49);\n    i0.ɵɵelement(2, \"img\", 50);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 51);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_div_16_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return ctx_r17.isError = false;\n    });\n    i0.ɵɵelement(4, \"span\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(5, \"div\", 52);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"innerHtml\", ctx_r4.alertMessage, i0.ɵɵsanitizeHtml);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 48);\n    i0.ɵɵelementStart(1, \"span\", 49);\n    i0.ɵɵelement(2, \"img\", 50);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 51);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_div_17_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.isDateAreEqual = false;\n    });\n    i0.ɵɵelement(5, \"span\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r5.language[\"Both Start Time And End Time are Same\"]);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_23_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵelementStart(1, \"label\", 16);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"ng-select\", 17);\n    i0.ɵɵlistener(\"change\", function QualityOfExperienceComponent_div_1_div_23_Template_ng_select_change_3_listener() {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return ctx_r21.dropDownchange();\n    })(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_23_Template_ng_select_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return ctx_r23.TimeFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r6.language.TTimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"clearable\", false)(\"searchable\", false)(\"items\", ctx_r6.FrameSV)(\"ngModel\", ctx_r6.TimeFrame);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_24_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 53);\n    i0.ɵɵelementStart(1, \"label\", 16);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"ng-select\", 54);\n    i0.ɵɵlistener(\"change\", function QualityOfExperienceComponent_div_1_div_24_Template_ng_select_change_3_listener() {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.dropDownchange();\n    })(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_24_Template_ng_select_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.WeekFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r7.language[\"Day_s\"]);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"items\", ctx_r7.WeekFramedata)(\"clearable\", false)(\"searchable\", false)(\"ngModel\", ctx_r7.WeekFrame);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_span_25_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 55);\n    i0.ɵɵelementStart(1, \"i\", 56);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_span_25_Template_i_click_1_listener() {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return ctx_r27.reload();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c1 = function () {\n  return {\n    width: \"100%\",\n    height: \"38px\"\n  };\n};\nconst _c2 = function () {\n  return {\n    height: \"36px\"\n  };\n};\nconst _c3 = function () {\n  return {\n    standalone: true\n  };\n};\nfunction QualityOfExperienceComponent_div_1_div_26_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 65);\n    i0.ɵɵelementStart(1, \"label\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p-calendar\", 66);\n    i0.ɵɵlistener(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_26_div_5_Template_p_calendar_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(3);\n      return ctx_r32.weekDate = $event;\n    })(\"onSelect\", function QualityOfExperienceComponent_div_1_div_26_div_5_Template_p_calendar_onSelect_3_listener() {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r34 = i0.ɵɵnextContext(3);\n      return ctx_r34.dayUpdate();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r29.language.Date);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(10, _c1));\n    i0.ɵɵproperty(\"inputStyle\", i0.ɵɵpureFunction0(11, _c2))(\"autoZIndex\", true)(\"ngModel\", ctx_r29.weekDate)(\"showIcon\", true)(\"ngModelOptions\", i0.ɵɵpureFunction0(12, _c3))(\"maxDate\", ctx_r29.maxDate)(\"minDate\", ctx_r29.minDate);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_26_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 67);\n    i0.ɵɵelementStart(1, \"label\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p-calendar\", 68);\n    i0.ɵɵlistener(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_26_div_6_Template_p_calendar_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r35 = i0.ɵɵnextContext(3);\n      return ctx_r35.startDate = $event;\n    })(\"onSelect\", function QualityOfExperienceComponent_div_1_div_26_div_6_Template_p_calendar_onSelect_3_listener() {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r37 = i0.ɵɵnextContext(3);\n      return ctx_r37.startTimeUpdate();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r30 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r30.language[\"Start Time\"], \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(13, _c1));\n    i0.ɵɵproperty(\"ngModel\", ctx_r30.startDate)(\"stepMinute\", ctx_r30.stepMinuteVal)(\"inputStyle\", i0.ɵɵpureFunction0(14, _c2))(\"autoZIndex\", true)(\"showIcon\", true)(\"ngModelOptions\", i0.ɵɵpureFunction0(15, _c3))(\"timeOnly\", ctx_r30.showHrs)(\"panelStyleClass\", !ctx_r30.isLastDay15minSelected ? \"hideMin\" : \"\")(\"minDate\", ctx_r30.minStartTime)(\"maxDate\", ctx_r30.maxStartTime);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_26_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 67);\n    i0.ɵɵelementStart(1, \"label\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p-calendar\", 69);\n    i0.ɵɵlistener(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_26_div_7_Template_p_calendar_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r39);\n      const ctx_r38 = i0.ɵɵnextContext(3);\n      return ctx_r38.endDate = $event;\n    })(\"onSelect\", function QualityOfExperienceComponent_div_1_div_26_div_7_Template_p_calendar_onSelect_3_listener() {\n      i0.ɵɵrestoreView(_r39);\n      const ctx_r40 = i0.ɵɵnextContext(3);\n      return ctx_r40.endTimeUpdate();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r31.language[\"End Time\"], \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(14, _c1));\n    i0.ɵɵproperty(\"stepMinute\", ctx_r31.stepMinuteVal)(\"inputStyle\", i0.ɵɵpureFunction0(15, _c2))(\"autoZIndex\", true)(\"ngModel\", ctx_r31.endDate)(\"showIcon\", true)(\"ngModelOptions\", i0.ɵɵpureFunction0(16, _c3))(\"timeOnly\", ctx_r31.showHrs)(\"disabled\", ctx_r31.isEndDateDisabled)(\"panelStyleClass\", !ctx_r31.isLastDay15minSelected ? \"hideMin\" : \"\")(\"minDate\", ctx_r31.minEndTime)(\"maxDate\", ctx_r31.maxEndTime);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_26_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r42 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 57);\n    i0.ɵɵelementStart(1, \"div\", 58);\n    i0.ɵɵelementStart(2, \"label\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"ng-select\", 59);\n    i0.ɵɵlistener(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_26_Template_ng_select_ngModelChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r41 = i0.ɵɵnextContext(2);\n      return ctx_r41.onTimeFrameChange($event);\n    })(\"ngModelChange\", function QualityOfExperienceComponent_div_1_div_26_Template_ng_select_ngModelChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r43 = i0.ɵɵnextContext(2);\n      return ctx_r43.TimeFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, QualityOfExperienceComponent_div_1_div_26_div_5_Template, 4, 13, \"div\", 60);\n    i0.ɵɵtemplate(6, QualityOfExperienceComponent_div_1_div_26_div_6_Template, 4, 16, \"div\", 61);\n    i0.ɵɵtemplate(7, QualityOfExperienceComponent_div_1_div_26_div_7_Template, 4, 17, \"div\", 61);\n    i0.ɵɵelementStart(8, \"div\", 62);\n    i0.ɵɵelementStart(9, \"div\", 63);\n    i0.ɵɵelementStart(10, \"button\", 64);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_div_26_Template_button_click_10_listener() {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r44 = i0.ɵɵnextContext(2);\n      return ctx_r44.loadChart();\n    });\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r9.language.TTimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"items\", ctx_r9.Frame)(\"ngModel\", ctx_r9.TimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.start && !ctx_r9.isLastDay15minSelected);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.start);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.start);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.language.apply, \" \");\n  }\n}\nfunction QualityOfExperienceComponent_div_1_section_27_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 73);\n    i0.ɵɵelementStart(1, \"div\", 74);\n    i0.ɵɵelementStart(2, \"div\", 75);\n    i0.ɵɵelementStart(3, \"div\", 76);\n    i0.ɵɵelement(4, \"span\", 77);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\nfunction QualityOfExperienceComponent_div_1_section_27_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r46 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r46.language[\"Last 24h\"]);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_section_27_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r47.language[\"Last 1week\"]);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_section_27_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r51 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 78);\n    i0.ɵɵelementStart(1, \"ngx-slider\", 79);\n    i0.ɵɵlistener(\"valueChange\", function QualityOfExperienceComponent_div_1_section_27_div_7_Template_ngx_slider_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r51);\n      const ctx_r50 = i0.ɵɵnextContext(3);\n      return ctx_r50.selectedInterval = $event;\n    })(\"userChangeEnd\", function QualityOfExperienceComponent_div_1_section_27_div_7_Template_ngx_slider_userChangeEnd_1_listener() {\n      i0.ɵɵrestoreView(_r51);\n      const ctx_r52 = i0.ɵɵnextContext(3);\n      return ctx_r52.sliderEvent();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\", 80);\n    i0.ɵɵelementStart(3, \"label\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\", 81);\n    i0.ɵɵelementStart(6, \"label\");\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r48 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", ctx_r48.selectedInterval)(\"options\", ctx_r48.timeIntervalOptions);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r48.leftSliderTime, \"\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r48.rightSliderTime);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_section_27_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r54 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 57);\n    i0.ɵɵelementStart(1, \"div\", 82);\n    i0.ɵɵelementStart(2, \"div\", 63);\n    i0.ɵɵelementStart(3, \"button\", 64);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_section_27_div_8_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r54);\n      const ctx_r53 = i0.ɵɵnextContext(3);\n      return ctx_r53.loadChart();\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r49 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r49.language.apply, \" \");\n  }\n}\nfunction QualityOfExperienceComponent_div_1_section_27_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"section\", 70);\n    i0.ɵɵtemplate(1, QualityOfExperienceComponent_div_1_section_27_div_1_Template, 5, 0, \"div\", 24);\n    i0.ɵɵelementStart(2, \"div\", 71);\n    i0.ɵɵelementStart(3, \"label\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, QualityOfExperienceComponent_div_1_section_27_span_5_Template, 2, 1, \"span\", 0);\n    i0.ɵɵtemplate(6, QualityOfExperienceComponent_div_1_section_27_span_6_Template, 2, 1, \"span\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, QualityOfExperienceComponent_div_1_section_27_div_7_Template, 8, 4, \"div\", 72);\n    i0.ɵɵtemplate(8, QualityOfExperienceComponent_div_1_section_27_div_8_Template, 5, 1, \"div\", 21);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.loader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵpropertyInterpolate(\"title\", ctx_r10.language[\"Chart Timeframe\"]);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r10.language[\"Chart Timeframe\"]);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.TimeFrame == 6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.TimeFrame == 4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.showIntervalSlider);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", false);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_30_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 73);\n    i0.ɵɵelementStart(1, \"div\", 74);\n    i0.ɵɵelementStart(2, \"div\", 75);\n    i0.ɵɵelementStart(3, \"div\", 76);\n    i0.ɵɵelement(4, \"span\", 77);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_51_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 73);\n    i0.ɵɵelementStart(1, \"div\", 74);\n    i0.ɵɵelementStart(2, \"div\", 75);\n    i0.ɵɵelementStart(3, \"div\", 76);\n    i0.ɵɵelement(4, \"span\", 77);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_72_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 73);\n    i0.ɵɵelementStart(1, \"div\", 74);\n    i0.ɵɵelementStart(2, \"div\", 75);\n    i0.ɵɵelementStart(3, \"div\", 76);\n    i0.ɵɵelement(4, \"span\", 77);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\nfunction QualityOfExperienceComponent_div_1_div_90_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 73);\n    i0.ɵɵelementStart(1, \"div\", 74);\n    i0.ɵɵelementStart(2, \"div\", 75);\n    i0.ɵɵelementStart(3, \"div\", 76);\n    i0.ɵɵelement(4, \"span\", 77);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\nfunction QualityOfExperienceComponent_div_1_ng_template_100_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 74);\n    i0.ɵɵelementStart(1, \"div\", 75);\n    i0.ɵɵelementStart(2, \"div\", 76);\n    i0.ɵɵelementStart(3, \"span\", 77);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r57 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r57.language.Loading);\n  }\n}\nfunction QualityOfExperienceComponent_div_1_ng_template_100_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r59 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, QualityOfExperienceComponent_div_1_ng_template_100_div_0_Template, 5, 1, \"div\", 83);\n    i0.ɵɵelementStart(1, \"div\", 84);\n    i0.ɵɵelement(2, \"h4\", 85);\n    i0.ɵɵelementStart(3, \"button\", 86);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_ng_template_100_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r59);\n      const ctx_r58 = i0.ɵɵnextContext(2);\n      return ctx_r58.close();\n    });\n    i0.ɵɵelement(4, \"span\", 87);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"div\", 88);\n    i0.ɵɵelementStart(6, \"section\");\n    i0.ɵɵelementStart(7, \"div\", 57);\n    i0.ɵɵelementStart(8, \"div\", 25);\n    i0.ɵɵelementStart(9, \"div\", 89);\n    i0.ɵɵtext(10);\n    i0.ɵɵelementStart(11, \"span\", 90);\n    i0.ɵɵtext(12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(13, \"div\", 27);\n    i0.ɵɵelement(14, \"div\", 91);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r16.effLoader);\n    i0.ɵɵadvance(10);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r16.language[\"Client Efficiency\"], \" - \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r16.clientDates, \" \");\n  }\n}\nconst _c4 = function (a0) {\n  return {\n    \"opac\": a0\n  };\n};\nfunction QualityOfExperienceComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r62 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵelementStart(1, \"div\", 1);\n    i0.ɵɵelementStart(2, \"div\", 2);\n    i0.ɵɵelementStart(3, \"ul\", 3);\n    i0.ɵɵelementStart(4, \"li\", 4);\n    i0.ɵɵelementStart(5, \"a\", 5);\n    i0.ɵɵlistener(\"Click\", function QualityOfExperienceComponent_div_1_Template_a_Click_5_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelementStart(6, \"span\", 6);\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(8, QualityOfExperienceComponent_div_1_li_8_Template, 4, 2, \"li\", 7);\n    i0.ɵɵtemplate(9, QualityOfExperienceComponent_div_1_li_9_Template, 4, 2, \"li\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"div\", 9);\n    i0.ɵɵelementStart(11, \"div\", 10);\n    i0.ɵɵelement(12, \"div\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(13, \"div\", 12);\n    i0.ɵɵelement(14, \"div\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(15, \"section\");\n    i0.ɵɵtemplate(16, QualityOfExperienceComponent_div_1_div_16_Template, 6, 1, \"div\", 13);\n    i0.ɵɵtemplate(17, QualityOfExperienceComponent_div_1_div_17_Template, 6, 1, \"div\", 13);\n    i0.ɵɵelementStart(18, \"div\", 14);\n    i0.ɵɵelementStart(19, \"div\", 15);\n    i0.ɵɵelementStart(20, \"label\", 16);\n    i0.ɵɵtext(21);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(22, \"ng-select\", 17);\n    i0.ɵɵlistener(\"change\", function QualityOfExperienceComponent_div_1_Template_ng_select_change_22_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r61 = i0.ɵɵnextContext();\n      return ctx_r61.dropDownchange();\n    })(\"ngModelChange\", function QualityOfExperienceComponent_div_1_Template_ng_select_ngModelChange_22_listener($event) {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r63 = i0.ɵɵnextContext();\n      return ctx_r63.TimeFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(23, QualityOfExperienceComponent_div_1_div_23_Template, 4, 5, \"div\", 18);\n    i0.ɵɵtemplate(24, QualityOfExperienceComponent_div_1_div_24_Template, 4, 5, \"div\", 19);\n    i0.ɵɵtemplate(25, QualityOfExperienceComponent_div_1_span_25_Template, 2, 0, \"span\", 20);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(26, QualityOfExperienceComponent_div_1_div_26_Template, 12, 7, \"div\", 21);\n    i0.ɵɵtemplate(27, QualityOfExperienceComponent_div_1_section_27_Template, 9, 7, \"section\", 22);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(28, \"section\");\n    i0.ɵɵelementStart(29, \"div\", 23);\n    i0.ɵɵtemplate(30, QualityOfExperienceComponent_div_1_div_30_Template, 5, 0, \"div\", 24);\n    i0.ɵɵelementStart(31, \"div\", 25);\n    i0.ɵɵelementStart(32, \"div\", 26);\n    i0.ɵɵtext(33);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(34, \"div\", 27);\n    i0.ɵɵelement(35, \"div\", 28);\n    i0.ɵɵelementStart(36, \"div\", 29);\n    i0.ɵɵelement(37, \"span\", 30);\n    i0.ɵɵelementStart(38, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_38_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r64 = i0.ɵɵnextContext();\n      return ctx_r64.filterContent(1, \"qoeGood\");\n    });\n    i0.ɵɵtext(39);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(40, \"span\", 32);\n    i0.ɵɵelementStart(41, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_41_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r65 = i0.ɵɵnextContext();\n      return ctx_r65.filterContent(1, \"qoeFair\");\n    });\n    i0.ɵɵtext(42);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(43, \"span\", 33);\n    i0.ɵɵelementStart(44, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_44_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r66 = i0.ɵɵnextContext();\n      return ctx_r66.filterContent(1, \"qoePoor\");\n    });\n    i0.ɵɵtext(45);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(46, \"span\", 34);\n    i0.ɵɵelementStart(47, \"span\", 35);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_47_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r67 = i0.ɵɵnextContext();\n      return ctx_r67.filterContent(1, \"qoeNoData\");\n    });\n    i0.ɵɵtext(48);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(49, \"section\");\n    i0.ɵɵelementStart(50, \"div\", 23);\n    i0.ɵɵtemplate(51, QualityOfExperienceComponent_div_1_div_51_Template, 5, 0, \"div\", 24);\n    i0.ɵɵelementStart(52, \"div\", 25);\n    i0.ɵɵelementStart(53, \"div\", 36);\n    i0.ɵɵtext(54);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(55, \"div\", 27);\n    i0.ɵɵelement(56, \"div\", 37);\n    i0.ɵɵelementStart(57, \"div\", 29);\n    i0.ɵɵelement(58, \"span\", 30);\n    i0.ɵɵelementStart(59, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_59_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r68 = i0.ɵɵnextContext();\n      return ctx_r68.filterContent(2, \"serviceGood\");\n    });\n    i0.ɵɵtext(60);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(61, \"span\", 32);\n    i0.ɵɵelementStart(62, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_62_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r69 = i0.ɵɵnextContext();\n      return ctx_r69.filterContent(2, \"serviceFair\");\n    });\n    i0.ɵɵtext(63);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(64, \"span\", 33);\n    i0.ɵɵelementStart(65, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_65_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r70 = i0.ɵɵnextContext();\n      return ctx_r70.filterContent(2, \"servicePoor\");\n    });\n    i0.ɵɵtext(66);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(67, \"span\", 34);\n    i0.ɵɵelementStart(68, \"span\", 35);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_68_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r71 = i0.ɵɵnextContext();\n      return ctx_r71.filterContent(2, \"serviceNoData\");\n    });\n    i0.ɵɵtext(69);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(70, \"section\");\n    i0.ɵɵelementStart(71, \"div\", 23);\n    i0.ɵɵtemplate(72, QualityOfExperienceComponent_div_1_div_72_Template, 5, 0, \"div\", 24);\n    i0.ɵɵelementStart(73, \"div\", 25);\n    i0.ɵɵelementStart(74, \"div\", 38);\n    i0.ɵɵtext(75);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(76, \"div\", 27);\n    i0.ɵɵelement(77, \"div\", 39);\n    i0.ɵɵelementStart(78, \"div\", 29);\n    i0.ɵɵelement(79, \"span\", 30);\n    i0.ɵɵelementStart(80, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_80_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r72 = i0.ɵɵnextContext();\n      return ctx_r72.filterContent(3, \"contGood\");\n    });\n    i0.ɵɵtext(81);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(82, \"span\", 33);\n    i0.ɵɵelementStart(83, \"span\", 31);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_83_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r73 = i0.ɵɵnextContext();\n      return ctx_r73.filterContent(3, \"contPoor\");\n    });\n    i0.ɵɵtext(84);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(85, \"span\", 34);\n    i0.ɵɵelementStart(86, \"span\", 35);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_86_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r74 = i0.ɵɵnextContext();\n      return ctx_r74.filterContent(3, \"contNoData\");\n    });\n    i0.ɵɵtext(87);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(88, \"section\");\n    i0.ɵɵelementStart(89, \"div\", 23);\n    i0.ɵɵtemplate(90, QualityOfExperienceComponent_div_1_div_90_Template, 5, 0, \"div\", 24);\n    i0.ɵɵelementStart(91, \"div\", 25);\n    i0.ɵɵelementStart(92, \"div\", 40);\n    i0.ɵɵtext(93);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(94, \"div\", 27);\n    i0.ɵɵelement(95, \"div\", 41);\n    i0.ɵɵelementStart(96, \"div\", 29);\n    i0.ɵɵelement(97, \"span\", 42);\n    i0.ɵɵelementStart(98, \"span\", 43);\n    i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_div_1_Template_span_click_98_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r75 = i0.ɵɵnextContext();\n      return ctx_r75.filterContent(4, \"homeData\");\n    });\n    i0.ɵɵtext(99);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(100, QualityOfExperienceComponent_div_1_ng_template_100_Template, 15, 3, \"ng-template\", null, 44, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(5);\n    i0.ɵɵpropertyInterpolate1(\"routerLink\", \"/\", ctx_r1.MODULE, \"/overview/issues\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.language.Issues, \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showTopologyTab);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showQoeTab);\n    i0.ɵɵadvance(7);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isError);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isDateAreEqual);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r1.language.TTimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"clearable\", false)(\"searchable\", false)(\"items\", ctx_r1.Frame)(\"ngModel\", ctx_r1.TimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.softwareVersion < 22.1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.TimeFrame == 4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.TimeFrame == 6 || ctx_r1.TimeFrame == 4);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loader);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r1.language[\"QoE Score\"], \" \");\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(48, _c4, !ctx_r1.legendType[\"qoeGood\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language.Good);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(50, _c4, !ctx_r1.legendType[\"qoeFair\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language.Fair);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(52, _c4, !ctx_r1.legendType[\"qoePoor\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language.Poor);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(54, _c4, !ctx_r1.legendType[\"qoeNoData\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language[\"No Data Available\"]);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loader);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.language[\"WAN Service\"], \" \");\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(56, _c4, !ctx_r1.legendType[\"serviceGood\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language.Good);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(58, _c4, !ctx_r1.legendType[\"serviceFair\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language.Fair);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(60, _c4, !ctx_r1.legendType[\"servicePoor\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language.Poor);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(62, _c4, !ctx_r1.legendType[\"serviceNoData\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language[\"No Data Available\"]);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loader);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.language[\"WAN Continuity\"], \" \");\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(64, _c4, !ctx_r1.legendType[\"contGood\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language[\"WAN Up\"]);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(66, _c4, !ctx_r1.legendType[\"contPoor\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language[\"WAN Down\"]);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(68, _c4, !ctx_r1.legendType[\"contNoData\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language[\"No Data Available\"]);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loader);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.language[\"Whole Home Efficiency\"], \"\");\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(70, _c4, !ctx_r1.legendType[\"homeData\"]));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.language[\"Whole Home Efficiency Score\"]);\n  }\n}\nexport let QualityOfExperienceComponent = /*#__PURE__*/(() => {\n  class QualityOfExperienceComponent {\n    // get isDateAreEqual() {\n    //   if (this.start && moment(this.startDate).isSame(this.endDate)) {\n    //     return true;\n    //   }\n    //   return false\n    // }\n    // set isDateAreEqual(flag: boolean) {\n    //   this.isDateAreEqual = flag;\n    // }\n    // closeErrorMessage() {\n    //   this.isDateAreEqual = false;\n    // }\n    // 'MMMM d, y'\n    constructor(router, dialogService, translateService, dataChartService, ssoService, deviceService, IssuesService, titleService, elementRef, cdRef) {\n      this.router = router;\n      this.dialogService = dialogService;\n      this.translateService = translateService;\n      this.dataChartService = dataChartService;\n      this.ssoService = ssoService;\n      this.deviceService = deviceService;\n      this.IssuesService = IssuesService;\n      this.titleService = titleService;\n      this.elementRef = elementRef;\n      this.cdRef = cdRef;\n      this.lastSeventhDay = moment().subtract(144, 'hours').format('dddd');\n      this.lastSixthDay = moment().subtract(120, 'hours').format('dddd');\n      this.lastfifthDay = moment().subtract(96, 'hours').format('dddd');\n      this.lastFourthDay = moment().subtract(72, 'hours').format('dddd');\n      this.lastThirdDay = moment().subtract(48, 'hours').format('dddd');\n      this.yesterDay = moment().subtract(24, 'hours').format('dddd');\n      this.toDay = moment().format('dddd');\n      this.WeekFramedata = [];\n      this.pipe = new DatePipe('en-US');\n      this.MODULE = 'support';\n      this.deviceInfo = [];\n      this.globalObj = {};\n      this.mess = false;\n      this.isError = false;\n      this.error = false;\n      this.loader = false;\n      this.effLoader = false;\n      this.showHrs = true;\n      this.scope = {\n        qoeRead: false,\n        topologyRead: false\n      };\n      this.isDateAreEqual = false;\n      this.appliedTimeFrame = 2;\n      this.avgEff = {};\n      this.summaryData = [];\n      this.legendType = {\n        qoeDash: true,\n        qoeSolid: true,\n        serviceGood: true,\n        serviceFair: true,\n        servicePoor: true,\n        qoeGood: true,\n        qoeFair: true,\n        qoePoor: true,\n        qoeNoData: true,\n        serviceNoData: true,\n        contGood: true,\n        contFair: true,\n        contPoor: true,\n        contNoData: true,\n        homeData: true,\n        clientData: true\n      };\n      this.timeIntervalOptions = {\n        hideLimitLabels: true,\n        onlyBindHandles: true,\n        stepsArray: []\n      };\n      this.showIntervalSlider = false;\n      this.TimeInterval = 1;\n      this.showTopologyTab = false;\n      this.showQoeTab = false;\n      this.isDevEnv = false;\n      this.userClickTimeout = setTimeout(() => {}, 0);\n      this.value3 = 0;\n      this.options3 = {\n        disabled: true,\n        showTicksValues: false,\n        stepsArray: [{\n          value: 0\n        }, {\n          value: 1\n        }, {\n          value: 2\n        }, {\n          value: 3\n        }, {\n          value: 4\n        }, {\n          value: 5\n        }]\n      };\n      // start = new Date();\n      // start.setDate(start.getDate() - 6)\n      this.WeekFrame = 7;\n      this.TimeFrame = 2;\n      this.Frame = [{\n        id: 1,\n        name: 'Last 7 days'\n      }, {\n        id: 2,\n        name: 'Last 24 hours'\n      }, {\n        id: 3,\n        name: 'Last 3 hours'\n      }, {\n        id: 5,\n        name: 'Last 15 minutes'\n      }, {\n        id: 6,\n        name: 'Any 15 minutes within last day'\n      },\n      // { id: 4, name: 'Any hours within last week' },\n      {\n        id: 4,\n        name: 'Any 3 Hours within last week'\n      }];\n      this.FrameSV = [\n      // { id: 1, name: 'Last 7 days' },\n      {\n        id: 2,\n        name: 'Last 24 hours'\n      }, {\n        id: 3,\n        name: 'Last 3 hours'\n      }, {\n        id: 5,\n        name: ' Last 15 minutes'\n      }, {\n        id: 6,\n        name: ' Any 15 minutes within last day'\n      }\n      // { id: 4, name: ' Any hours within last week' },\n      ];\n\n      this.maxDate = new Date();\n      this.minDate = new Date();\n      this.formDate = new Date(this.minDate.setDate(this.minDate.getDate() - 6));\n      this.stepMinuteVal = 0;\n      this.isEndDateDisabled = true;\n      this.isLastDay15minSelected = false;\n      this.minStartTime = new Date();\n      this.maxStartTime = new Date();\n      this.minEndTime = new Date();\n      this.maxEndTime = new Date();\n      this.silderDataAvail = false;\n      this.time = '';\n      let url = this.router.url;\n      if (url.indexOf('/support/') > -1) {\n        this.MODULE = 'support';\n      } else this.MODULE = 'cco';\n      this.qoeCheck();\n      this.getScopes();\n      this.lastdays15MinOfValues();\n    }\n    // OneTimeClick = true;\n    inClick(e) {\n      //Slider bar Prev, Next click events\n      // if (!this.OneTimeClick) return;\n      // this.OneTimeClick = false;\n      // setTimeout(() => {\n      //   this.OneTimeClick = true;\n      // }, 500);\n      let id = e.target.id ? e.target.id : '';\n      if (id == 'slider-click-next' || id == 'slider-click-prev') {\n        e.stopPropagation();\n        let clsList = e.target.className ? e.target.className.split(' ')[0] : '';\n        let tag = e.target.localName;\n        let totalPoints = this.timeIntervals.length - 1;\n        if (id == 'slider-click-next') {\n          let point = parseInt(clsList.split('-')[1]);\n          if (point + 1 <= totalPoints) {\n            this.selectedInterval = point + 1;\n          }\n        }\n        if (id == 'slider-click-prev') {\n          let point = parseInt(clsList.split('-')[1]);\n          if (point - 1 >= 0) {\n            this.selectedInterval = point - 1;\n          }\n        }\n        // console.log(`${this.selectedInterval} selected from range of 0 to ${totalPoints}`);\n        this.handleUserTime();\n      }\n    }\n    ngAfterViewInit() {\n      this.Frame = [{\n        id: 1,\n        name: this.language['Last 7 days']\n      }, {\n        id: 2,\n        name: this.language['Last_hours']\n      }, {\n        id: 3,\n        name: this.language['Last 3 hours']\n      }, {\n        id: 5,\n        name: this.language['Last 15 minutes']\n      }, {\n        id: 6,\n        name: this.language['Any 15 minutes within last day']\n      }, {\n        id: 4,\n        name: this.language['Any 3 Hours within last week']\n      }];\n    }\n    reload() {\n      this.lastdays15MinOfValues();\n      // if (this.TimeFrame == 4) {\n      //   this.dropDownchangeweek()\n      // }\n      // this.dropDownchangeweek()\n      this.loadChart();\n    }\n    handleUserTime() {\n      clearTimeout(this.userClickTimeout);\n      this.userClickTimeout = setTimeout(() => {\n        this.loadChart();\n      }, 2000);\n    }\n    ngOnInit() {\n      var _a, _b;\n      this.weekDate = this.maxDate = new Date();\n      this.endDate = moment(this.startDate).add(15, \"m\").toDate();\n      $('.string-slider .ngx-slider-pointer-min').attr('title', 'Realtime QoE');\n      let devices = JSON.parse(sessionStorage.getItem('calix.deviceData'));\n      this.isDevEnv = this.ssoService.API.includes('dev');\n      let deviceInfo;\n      if ((devices === null || devices === void 0 ? void 0 : devices.length) > 0) {\n        deviceInfo = devices.filter(x => x.opMode == 'RG');\n        if (deviceInfo.length || this.ssoService.acceptGSModel(((_a = deviceInfo[0]) === null || _a === void 0 ? void 0 : _a.modelName) || '')) {\n          this.softwareVersion = (_b = deviceInfo[0].softwareVersion) === null || _b === void 0 ? void 0 : _b.substring(0, 4);\n          this.serialNumberSelected = deviceInfo[0].serialNumber;\n          this.mac = deviceInfo[0].macAddress;\n        } else return;\n      } else return;\n      this.language = this.translateService.defualtLanguage;\n      this.languageSubject = this.translateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n        this.titleService.setTitle(`${this.language['Quality of Experience']} - ${this.language['Overview']} - ${this.language['Service']} - ${this.language['Calix Cloud']}`);\n        this.Frame = [{\n          id: 1,\n          name: this.language['Last 7 days']\n        }, {\n          id: 2,\n          name: this.language['Last_hours']\n        }, {\n          id: 3,\n          name: this.language['Last 3 hours']\n        }, {\n          id: 5,\n          name: this.language['Last 15 minutes']\n        }, {\n          id: 6,\n          name: this.language['Any 15 minutes within last day']\n        }, {\n          id: 4,\n          name: this.language['Any 3 Hours within last week']\n        }];\n        this.loadChart();\n        let keys = Object.keys(this.legendType);\n        for (let key of keys) {\n          this.legendType[key] = true;\n        }\n      });\n      this.titleService.setTitle(`${this.language['Quality of Experience']} - ${this.language['Overview']} - ${this.language['Service']} - ${this.language['Calix Cloud']}`);\n      this.orgId = this.ssoService.getOrgId();\n      this.IssuesService.rebootAndUpgradeEvent(this.orgId, this.serialNumberSelected).subscribe(res => {\n        this.WanShowup = res;\n      });\n      // this.softwareVersion = this.deviceInfo.length ? this.deviceInfo[0]?.softwareVersion?.substring(0, 4) : '';\n      this.loadChart();\n      this.dataChartService.showTopology.subscribe(flag => {\n        this.showTopologyTab = flag;\n      });\n      this.qoeSubscribed = this.dataChartService.showQoe.subscribe(flag => {\n        this.showQoeTab = flag;\n      });\n    }\n    ngOnDestroy() {\n      if (this.qoeSubscribed) this.qoeSubscribed.unsubscribe();\n    }\n    clearFilter() {\n      this.startDate = '';\n      this.endDate = '';\n    }\n    startTimeUpdate() {\n      // if (this.isEndDateDisabled) return\n      this.endDate = moment(this.startDate).add(this.stepMinuteVal, \"m\").toDate();\n      this.isEndDateDisabled = this.isLastDay15minSelected;\n      this.isDateAreEqual = this.start && moment(this.startDate).isSame(this.endDate);\n      // this.isDateAreEqual = moment(this.startDate).isSame(this.endDate)\n      if (this.TimeFrame == 4) this.minEndTime = moment(this.startDate).add(60, \"m\").toDate();\n    }\n    endTimeUpdate() {\n      this.isDateAreEqual = this.start && moment(this.startDate).isSame(this.endDate);\n      // if (this.TimeFrame == 4 && !moment(this.weekDate).isSame(Date.now(), 'day')) {\n      // }\n    }\n\n    onTimeFrameChange(event) {\n      this.isEndDateDisabled = true;\n      this.isLastDay15minSelected = event == 6;\n      if (event == 6) {\n        this.start = true;\n        // this.endDate = moment(this.startDate).add(this.stepMinuteVal, \"m\").toDate()\n        this.stepMinuteVal = 15;\n        var coeff = 1000 * 60 * 15;\n        var date = new Date();\n        //date.setMinutes(0);  //or use any other date\n        this.startDate = this.endDate = new Date(Math.floor(date.getTime() / coeff) * coeff);\n        this.startDate = moment(this.endDate).add(-15, \"m\").toDate();\n        this.showHrs = true;\n        this.setMinMax(6);\n      } else if (event == 4) {\n        this.startDate = this.endDate = '';\n        this.isEndDateDisabled = false;\n        this.start = true;\n        this.stepMinuteVal = 60;\n        var coeff = 1000 * 60 * 5;\n        var date = new Date();\n        date.setMinutes(0); //or use any other date\n        this.startDate = this.endDate = new Date(Math.round(date.getTime() / coeff) * coeff);\n        this.startDate = moment(this.endDate).add(-60, \"m\").toDate();\n        this.setMinMax(4);\n        this.showHrs = true;\n      } else {\n        this.start = false;\n      }\n      //this.loadChart();\n    }\n\n    setMinMax(period) {\n      let selectedDate = this.weekDate;\n      selectedDate.setMinutes(0);\n      if (period == 4) {\n        let isToday = moment(selectedDate).isSame(Date.now(), 'day');\n        var coeff = 1000 * 60 * 5;\n        if (isToday) {\n          var date = new Date();\n          date.setMinutes(0);\n          this.startDate = this.endDate = new Date(Math.round(date.getTime() / coeff) * coeff);\n          this.startDate = moment(this.endDate).add(-60, \"m\").toDate();\n          let startDateOfDay = moment(selectedDate).startOf('day').toDate();\n          this.minStartTime = startDateOfDay; // 12 am of particular date\n          this.minEndTime = moment(this.startDate).add(60, \"m\").toDate(); // 1 hr ahead of start\n          this.maxStartTime = this.startDate;\n          this.maxEndTime = this.endDate;\n        } else {\n          let startDate, endDate;\n          startDate = moment(selectedDate).startOf('day').toDate();\n          endDate = moment(selectedDate).endOf('day').toDate();\n          this.minStartTime = startDate; // 12 am of particular date\n          this.minEndTime = moment(this.startDate).add(60, \"m\").toDate(); // 1hr ahead of start  date\n          this.maxStartTime = moment(endDate).add(-60, \"m\").toDate(); // 11pm of particular date\n          this.maxEndTime = endDate; // 12 am of next day\n        }\n      } else if (period == 6) {\n        let startDateOfDay = moment(new Date()).startOf('day').toDate();\n        this.minStartTime = startDateOfDay; // 12 am of particular date\n        this.minEndTime = moment(this.startDate).add(15, \"m\").toDate(); // 15 min ahead of start\n        this.maxStartTime = moment(this.endDate).add(-15, \"m\").toDate();\n        this.maxEndTime = this.endDate;\n      }\n    }\n    dayUpdate() {\n      this.setMinMax(this.TimeFrame);\n    }\n    sliderEvent() {\n      setTimeout(() => {\n        if (this.TimeFrame == 6 || this.TimeFrame == 4) {\n          this.showIntervalSlider = true;\n        }\n        this.loadChart();\n      }, 500);\n    }\n    dropDownchangeweek() {\n      var x = this.WeekFrame;\n      if (x == 1) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        var startTime1;\n        var lastTime1;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(144, \"hours\");\n        startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n        lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        // console.log('current = ' + new Date(currentTimestamp));\n        // console.log('start = ' + new Date(moment(startTime).toDate()));\n        // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60));\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime1) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(180, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        //console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        // this.lastSeventhDay = moment(this.timeIntervals[0].date).format('dddd');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (x == 2) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        // let startTime1\n        // let lastTime1\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(144, \"hours\");\n        startTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        // console.log('current = ' + new Date(currentTimestamp));\n        // console.log('start = ' + new Date(moment(startTime).toDate()));\n        // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60));\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime1) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(180, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        //console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        // this.lastSixthDay = moment(this.timeIntervals[0].date).format('dddd');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (x == 3) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(144, \"hours\");\n        startTime1 = new Date(startTime['_d'].setHours(48, 0, 0, 0));\n        lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime1) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(180, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).add(15, 'minutes').format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        // console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(15, 'minutes').format('MMM DD hh:mm A');\n        // this.lastfifthDay = moment(this.timeIntervals[0].date).format('dddd');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (x == 4) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(144, \"hours\");\n        startTime1 = new Date(startTime['_d'].setHours(72, 0, 0, 0));\n        lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        // console.log('current = ' + new Date(currentTimestamp));\n        // console.log('start = ' + new Date(moment(startTime).toDate()));\n        // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60));\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime1) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(180, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        //console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        // this.lastFourthDay = moment(this.timeIntervals[0].date).format('dddd');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (x == 5) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(144, \"hours\");\n        startTime1 = new Date(startTime['_d'].setHours(96, 0, 0, 0));\n        lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        // console.log('current = ' + new Date(currentTimestamp));\n        // console.log('start = ' + new Date(moment(startTime).toDate()));\n        // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60));\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime1) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(180, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        //console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        // this.lastThirdDay = moment(this.timeIntervals[0].date).format('dddd');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (x == 6) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(144, \"hours\");\n        startTime1 = new Date(startTime['_d'].setHours(120, 0, 0, 0));\n        lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        // console.log('current = ' + new Date(currentTimestamp));\n        // console.log('start = ' + new Date(moment(startTime).toDate()));\n        // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60));\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime1) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(180, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        //console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        // this.yesterDay = moment(this.timeIntervals[0].date).format('dddd');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (x == 7) {\n        {\n          let date = new Date();\n          let coeff = 1000 * 60;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime;\n          lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(144, 0, 0, 0));\n          // lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0))\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // console.log('current = ' + new Date(currentTimestamp));\n          // console.log('start = ' + new Date(moment(startTime).toDate()));\n          // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n          //   / (1000 * 60 * 60));\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime1).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 60 : 180;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          let lasttime;\n          // this.timeinterrval1 = 180;\n          let now = moment();\n          while (current <= lastTime) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            // current.add(this.timeinterrval1, 'minutes');\n            // if (current['_d'].toString() == now.startOf('day')['_d'].toString()) {\n            // if (current['_d'].toString().substring(16, 18) != lastTime['_d'].getHours() / 3) {\n            lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()) / 3);\n            if (lasttime > 0) {\n              current.add(180, 'minutes');\n            } else {\n              current.add(60, 'minutes');\n            }\n            i++;\n          }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            var start;\n            var end;\n            if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n              start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n            } else {\n              start = pointersTime.subtract(60, 'minutes').format('MMM DD hh:mm A');\n              end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n            }\n            // let start = pointersTime.subtract(180, 'minutes').format('hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.toDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        }\n      }\n      if (this.TimeFrame == 4) {\n        this.showIntervalSlider = false;\n      }\n      this.sliderEvent();\n    }\n    dropDownchange() {\n      this.lastdays15MinOfValues();\n      // if (this.TimeFrame == 4) {\n      //   this.dropDownchangeweek();\n      // }\n      // this.dropDownchangeweek();\n      if (this.TimeFrame == 6 || this.TimeFrame == 4) {\n        this.showIntervalSlider = false;\n      }\n      this.sliderEvent();\n    }\n    loadChart(startTime, endTime) {\n      this.startTime = startTime;\n      this.endTime = endTime;\n      let [start, end] = this.timeForFilter(new Date(), new Date());\n      this.appliedTimeFrame = this.TimeFrame;\n      // if (this.TimeFrame == 4) [start, end] = this.roundOffDate(start, end);\n      if (this.TimeFrame == 4) {\n        // this.lastdays15MinOfValues();\n        // if (current['_d'].toString() == now.startOf('day')['_d'].toString()) {}\n        let startTime;\n        let endTime;\n        let endTime1;\n        if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n          endTime1 = this.timeIntervals[this.selectedInterval].date;\n          // endTime = moment(endTime1).subtract(15, \"minutes\")\n          endTime = moment(endTime1);\n          startTime = moment(endTime1).subtract(180, \"minutes\");\n        } else {\n          endTime1 = this.timeIntervals[this.selectedInterval].date;\n          //endTime = moment(endTime1).subtract(15, \"minutes\")\n          endTime = moment(endTime1);\n          // startTime = moment(endTime1).subtract(60, \"minutes\");\n          startTime = this.timeIntervals[this.selectedInterval - 1].date;\n        }\n        // let endTime = this.timeIntervals[this.selectedInterval].date;\n        // let startTime = moment(endTime).subtract(180, \"minutes\");\n        [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n      }\n      if (this.TimeFrame == 6) {\n        // const last15End = new Date();\n        if (this.startTime) {\n          [start, end] = this.timeForFilter(this.startTime, this.endTime);\n          this.timeForDeviceEfficiency = this.endTime;\n        } else {\n          let endTime = this.timeIntervals[this.selectedInterval].date;\n          let startTime = moment(endTime).subtract(15, \"minutes\");\n          [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n          this.timeForDeviceEfficiency = endTime;\n        }\n      }\n      let params;\n      if (this.TimeFrame == 1) {\n        params = {\n          sn: this.serialNumberSelected,\n          orgId: this.orgId,\n          mac: this.mac,\n          period: this.TimeFrame,\n          start: start,\n          end: end,\n          tz: 0\n        };\n      } else {\n        params = {\n          sn: this.serialNumberSelected,\n          orgId: this.orgId,\n          mac: this.mac,\n          period: this.TimeFrame,\n          start: start,\n          end: end,\n          tz: -(new Date().getTimezoneOffset() / 60)\n        };\n      }\n      this.loader = true;\n      this.IssuesService.getQoeSummary(params).subscribe(res => {\n        this.loader = false;\n        this.summaryData = res || [];\n        if (res.rawData.length && !this.silderDataAvail) {\n          this.value3 = res.rawData[res.rawData.length - 1]['qoeScore'];\n          this.silderDataAvail = true;\n          setTimeout(() => {\n            $('.string-slider .ngx-slider-pointer-min').attr('title', 'Realtime QoE');\n          }, 10);\n        }\n        Highcharts.chart('qoeScoreChart', this.qoeChartOption(res || []));\n        Highcharts.chart('wanServiceChart', this.wanService(res || []));\n        Highcharts.chart('wanContinuityChart', this.wanContinuity(res || [], this.WanShowup));\n        Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(res || []));\n        setTimeout(() => {\n          this.loader = false;\n        }, 4200);\n      }, err => {\n        this.value3 = 0;\n        this.summaryData = [];\n        this.loader = false;\n        this.silderDataAvail = true;\n        setTimeout(() => {\n          $('.string-slider .ngx-slider-pointer-min').attr('title', 'Realtime QoE');\n        }, 10);\n        this.pageErrorHandle(err);\n      });\n    }\n    loadSlider() {\n      let [start, end] = [new Date(), new Date()];\n      end.setMinutes(end.getMinutes() - 1);\n      start.setMinutes(start.getMinutes() - 16);\n      start = start.toISOString().substr(0, 16) + ':00', end = end.toISOString().substr(0, 16) + ':00';\n      let params;\n      if (this.TimeFrame == 1) {\n        params = {\n          sn: this.serialNumberSelected,\n          orgId: this.orgId,\n          mac: this.mac,\n          period: 5,\n          start: start,\n          end: end,\n          tz: 0\n        };\n      } else {\n        params = {\n          sn: this.serialNumberSelected,\n          orgId: this.orgId,\n          mac: this.mac,\n          period: 5,\n          start: start,\n          end: end,\n          tz: -(new Date().getTimezoneOffset() / 60)\n        };\n      }\n      this.loader = true;\n      this.IssuesService.getQoeSummary(params).subscribe(res => {\n        this.loader = false;\n      }, err => {\n        this.value3 = 0;\n        this.loader = false;\n        this.silderDataAvail = true;\n        setTimeout(() => {\n          $('.string-slider .ngx-slider-pointer-min').attr('title', 'Realtime QoE');\n        }, 10);\n        this.pageErrorHandle(err);\n      });\n    }\n    timeForFilter(start, end) {\n      switch (this.TimeFrame) {\n        case 1:\n          start.setDate(start.getDate() - 6);\n          start.setHours(5, 30, 0, 0);\n          // end.setMinutes(end.getMinutes() + 330);\n          end.setMinutes(end.getMinutes());\n          // return [(start.toISOString().substring(0, 16) + ':00'), (end.toISOString().substring(0, 19))];\n          return [start.toISOString().substring(0, 11) + '00' + ':00' + ':00', end.toISOString().substring(0, 19)];\n        // break;\n        case 2:\n          start.setHours(start.getHours() - 24);\n          start.setMinutes(start.getMinutes() + 15);\n          [start, end] = this.minuteAligner(start, end);\n          break;\n        case 3:\n          start.setHours(start.getHours() - 3);\n          [start, end] = this.minuteAligner(start, end);\n          break;\n        case 4:\n          // [start, end] = [this.startDate, this.endDate];\n          // this.setMinMax(4);\n          // [start, end] = [this.startDate, this.endDate];\n          // [start, end] = [this.startDate, this.endDate];\n          // start.setDate(this.weekDate.getDate());\n          // start.setMonth(this.weekDate.getMonth());\n          // start.setFullYear(this.weekDate.getFullYear());\n          // end.setDate(this.weekDate.getDate());\n          // end.setMonth(this.weekDate.getMonth());\n          // end.setFullYear(this.weekDate.getFullYear());\n          // [start, end] = this.minuteAligner(start, end);\n          //if (start.getDate() > end.getDate()) end.setDate(end.getDate() + 2);\n          break;\n        case 5:\n          start.setMinutes(start.getMinutes() - 16);\n          end.setMinutes(end.getMinutes() - 1);\n          break;\n        case 6:\n          // // const currDate = new Date();\n          // // [start, end] = [this.startDate, this.endDate];\n          // // [start, end] = this.minuteAligner(start, end);\n          // // if (start > currDate) start.setDate(start.getDate() - 1);\n          // // if (end > currDate && start.getDate() != currDate.getDate()) end.setDate(end.getDate() - 1);\n          // // const last15End = new Date();\n          // // let endTime = this.timeIntervals[this.selectedInterval].date;\n          // // let startTime = moment(endTime).subtract(15, \"minutes\");\n          // // [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n          // // start.setMinutes(start.getMinutes() - 16);\n          // // end.setMinutes(end.getMinutes() - 1);\n          // start = this.timeIntervals[this.selectedInterval].date;\n          // end = moment(start).subtract(15, \"minutes\");\n          // //  let [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n          break;\n        default:\n          break;\n      }\n      return [start.toISOString().substring(0, 16) + ':00', end.toISOString().substring(0, 16) + ':00'];\n      // return [(start.toISOString().substring(0, 16) + ':00'), (end.toISOString().substring(0, 19))];\n    }\n\n    minuteAligner(start, end) {\n      let [s, e] = [start.getMinutes(), end.getMinutes()];\n      const limit = [45, 30, 15, 0];\n      for (let i = 0; i < limit.length; i++) {\n        //const ind = (i > 0 ? (i - 1) : 0);\n        if (!limit.includes(s) && s > limit[i]) {\n          start.setMinutes(limit[i]);\n          s = limit[i];\n        }\n        if (!limit.includes(e) && e > limit[i]) {\n          end.setMinutes(limit[i]);\n          e = limit[i];\n        }\n      }\n      return [start, end];\n    }\n    averageTimeSetter(start, end, sign = false) {\n      const value = [2, 3, 4].includes(this.TimeFrame) ? sign ? -15 : 15 : sign ? -1 : 1;\n      this.TimeFrame == 1 ? start.setHours(start.getHours() - 24) : start.setMinutes(start.getMinutes() - value);\n      return [start.toISOString().substr(0, 16) + ':00', end.toISOString().substr(0, 16) + ':00'];\n    }\n    // averageTimeSetterNew(start, end, sign = false) {\n    //   const value = ([2, 3, 4 ].includes(this.TimeFrame) ? 1 : 15);\n    //   this.TimeFrame == 1\n    //     ? start.setHours(start.getHours() - 24)\n    //     //: start.setMinutes(start.getMinutes() - value);\n    //     : end.setMinutes(end.getMinutes() + value);\n    //   return [(start.toISOString().substr(0, 16) + ':00'), (end.toISOString().substr(0, 16) + ':00')];\n    // }\n    averageTimeSetterNew(start, end, sign = false) {\n      let value = [5, 6].includes(this.TimeFrame) ? 1 : 15;\n      if (this.TimeFrame == 1) {\n        if (this.clientDates == moment().format('MM/DD/yyyy')) {\n          start.setHours(5, 30, 0, 0);\n          start.setHours(start.getHours());\n          end = new Date();\n          end.setMinutes(end.getMinutes() + 330);\n          return [start.toISOString().substring(0, 11) + '00' + ':00' + ':00', end.toISOString().substring(0, 19)];\n        } else {\n          start.setHours(5, 30, 0, 0);\n          start.setHours(start.getHours());\n          end.setHours(28, 89, 59, 0);\n          return [start.toISOString().substring(0, 11) + '00' + ':00' + ':00', end.toISOString().substring(0, 11) + '23' + ':59' + ':59'];\n        }\n        // start.setHours(5, 30, 0, 0)\n        // start.setHours(start.getHours())\n        // end.setHours(28, 89, 59, 0)\n        // end.getHours(end.getHours() + 24)\n        // end.setMinutes(start.setMinutes() + 1440);//1 hr =>60 in +5.30 add\n        // return [(start.toISOString().substring(0, 11) + '00' + ':00' + ':00'), (end.toISOString().substring(0, 19))]\n      } else {\n        end.setMinutes(end.getMinutes() + value);\n      }\n      // return [(start.toISOString().substr(0, 16) + ':00'), (end.toISOString().substr(0, 19))];\n      return [start.toISOString().substr(0, 16) + ':00', end.toISOString().substr(0, 16) + ':00'];\n    }\n    roundOffDate(start, end) {\n      if (start && end && start > end) {\n        let endSplit = end.split('T');\n        let endDate = endSplit[0].split('-');\n        endDate[2] = (endDate[2] < 9 ? '0' : '') + (parseInt(endDate[2]) + 1);\n        end = endDate.join('-') + 'T' + endSplit[1];\n        return this.roundOffDate(start, end);\n      } else {\n        return [start, end];\n      }\n    }\n    clickToGet15Mins(qoeScore) {\n      var _a;\n      if (this.TimeFrame == 2 || this.TimeFrame == 3) {\n        this.TimeFrame = 6;\n        let arr = qoeScore.category.split(':');\n        let hour = parseInt(arr[0]);\n        let min = parseInt(arr[1]);\n        this.time = arr[1].split(/\\s/)[1];\n        if (this.time == \"PM\" && hour !== 12 || hour === 12 && this.time == \"AM\") {\n          hour += 12;\n        }\n        this.date = new Date();\n        this.date.setHours(hour);\n        this.date.setMinutes(min);\n        this.date.setSeconds(0, 0);\n        if (this.date > new Date()) {\n          this.date.setDate(this.date.getDate() - 1);\n        }\n        let endTime = this.date;\n        let startTime = moment(endTime).subtract(15, \"minutes\");\n        let date = new Date();\n        let date1 = this.date;\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime1 = moment(lastTime).subtract(24, \"hours\");\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime1).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime1 = moment(startTime1).add(minToRoundOf24hr, 'minutes');\n        this.timeIntervals1 = [];\n        this.timeIntervals = [];\n        let current = moment(startTime1);\n        let i = 0;\n        let lastTime1 = moment(new Date(Math.floor(date1.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        while (current <= lastTime1) {\n          this.timeIntervals1.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(15, 'minutes');\n          i++;\n        }\n        current = moment(startTime1);\n        i = 0;\n        while (current <= lastTime) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(15, 'minutes');\n          i++;\n        }\n        len = this.timeIntervals1.length;\n        let len1 = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals1[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A ');\n          let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A ');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(15, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len1 - 1].date).format('MMM DD hh:mm A');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n        this.loadChart(startTime, endTime);\n      }\n      if (this.TimeFrame == 1) {\n        this.TimeFrame = 4;\n        let switchWeekFrame;\n        let arr = qoeScore.category.split('/');\n        let month = arr[0];\n        let day = arr[1];\n        let year = arr[2];\n        let dateData = year + month + day;\n        switchWeekFrame = ((_a = this.summaryData.rawData) === null || _a === void 0 ? void 0 : _a.findIndex(obj => obj.date == dateData)) + 1;\n        this.WeekFrame = switchWeekFrame;\n        if (this.TimeFrame == 4) {\n          var i = this.WeekFrame;\n          if (i == 1) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            var startTime1;\n            var lastTime1;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastSeventhDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 2) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            // let startTime1\n            // let lastTime1\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastSixthDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 3) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(48, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastfifthDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 4) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(72, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastFourthDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 5) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(96, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastThirdDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 6) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(120, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.yesterDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 7) {\n            {\n              let date = new Date();\n              let coeff = 1000 * 60;\n              let timeDuration = -24 * 60;\n              let lastUpdatedTime;\n              let that = this;\n              let len = 0;\n              let lastTime;\n              lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n              let startTime = moment(lastTime).subtract(144, \"hours\");\n              startTime1 = new Date(startTime['_d'].setHours(144, 0, 0, 0));\n              // lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0))\n              let currentTimestamp = new Date().setSeconds(0, 0);\n              // console.log('current = ' + new Date(currentTimestamp));\n              // console.log('start = ' + new Date(moment(startTime).toDate()));\n              // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n              //   / (1000 * 60 * 60));\n              const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime1).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 60 : 180;\n              startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n              this.timeIntervals = [];\n              let current = moment(startTime1);\n              // console.log(this.timeIntervals);\n              let i = 0;\n              let lasttime;\n              // this.timeinterrval1 = 180;\n              let now = moment();\n              while (current <= lastTime) {\n                this.timeIntervals.push({\n                  value: i,\n                  legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                  date: moment(current).toDate()\n                });\n                lastUpdatedTime = moment(current);\n                lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()) / 3);\n                if (lasttime > 0) {\n                  current.add(180, 'minutes');\n                } else {\n                  const minToRoundOf24hr = Math.ceil(lastTime[\"_d\"].getHours() - current['_d'].getHours()) == 2 ? 120 : 60;\n                  current.add(minToRoundOf24hr, 'minutes');\n                }\n                i++;\n              }\n              len = this.timeIntervals.length;\n              this.selectedInterval = this.timeIntervals[len - 1].value;\n              this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n              const translate = (value, label) => {\n                let pointersTime = moment(that.timeIntervals[value]['date']);\n                var start;\n                var end;\n                if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n                  start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n                  end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n                } else {\n                  // start = pointersTime.subtract(minToRoundOf24hr, 'minutes').format('MMM DD hh:mm A');\n                  start = moment(this.timeIntervals[len - 2].date).format('MMM DD hh:mm A');\n                  end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n                }\n                // let start = pointersTime.subtract(180, 'minutes').format('hh:mm A');\n                // let end = moment(that.timeIntervals[value]['date']).format('hh:mm A');\n                return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n              };\n              this.timeIntervalOptions.translate = translate;\n              //console.log(this.timeIntervals);\n              this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n              this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n              // this.toDay = moment(this.timeIntervals[0].date).format('dddd');\n              setTimeout(() => {\n                this.showIntervalSlider = true;\n                setTimeout(() => {\n                  $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n                }, 10);\n              }, 1000);\n            }\n          }\n          this.loadChart(moment(this.time).subtract(180, 'minutes'), moment(this.time));\n          setTimeout(() => {\n            this.WeekFramedata = [{\n              id: 1,\n              name: this.language[this.lastSeventhDay]\n            }, {\n              id: 2,\n              name: this.language[this.lastSixthDay]\n            }, {\n              id: 3,\n              name: this.language[this.lastfifthDay]\n            }, {\n              id: 4,\n              name: this.language[this.lastFourthDay]\n            }, {\n              id: 5,\n              name: this.language[this.lastThirdDay]\n            }, {\n              id: 6,\n              name: this.language[this.yesterDay]\n            }, {\n              id: 7,\n              name: this.language[this.toDay]\n            }];\n          }, 2000);\n        }\n      }\n      let currTime = qoeScore.category.split(' ');\n      let currTime1 = moment(new Date()).format('MM/DD/YY');\n      let coeff = 1000 * 60 * 15;\n      const currentRoundOfTime = moment(new Date(Math.floor(new Date().getTime() / coeff) * coeff)).seconds(0).milliseconds(0).startOf('hour');\n      const selectedTime = moment(qoeScore.category);\n      if (moment.duration(currentRoundOfTime.diff(selectedTime)).asHours() <= 24) {\n        if (this.TimeFrame == 4) {\n          this.TimeFrame = 6;\n          let arr1 = qoeScore.category.split(' ');\n          let arr = arr1[1].split(':');\n          // console.log(\"arr\",qoeScore)\n          let hour = parseInt(arr[0]);\n          let min = parseInt(arr[1]);\n          // this.time = arr[1].split(/\\s/)[1];\n          this.time = arr1[2];\n          if (this.time == \"PM\" && hour !== 12 || hour === 12 && this.time == \"AM\") {\n            hour += 12;\n          }\n          this.date = new Date();\n          this.date.setHours(hour);\n          this.date.setMinutes(min);\n          this.date.setSeconds(0, 0);\n          if (this.date > new Date()) {\n            this.date.setDate(this.date.getDate() - 1);\n          }\n          let endTime = this.date;\n          let startTime = moment(endTime).subtract(15, \"minutes\");\n          let date = new Date();\n          let date1 = this.date;\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime1 = moment(lastTime).subtract(24, \"hours\");\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime1).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(minToRoundOf24hr, 'minutes');\n          this.timeIntervals1 = [];\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          let i = 0;\n          let lastTime1 = moment(new Date(Math.floor(date1.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          this.showIntervalSlider = false;\n          while (current <= lastTime1) {\n            this.timeIntervals1.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(15, 'minutes');\n            i++;\n          }\n          current = moment(startTime1);\n          i = 0;\n          while (current <= lastTime) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(15, 'minutes');\n            i++;\n          }\n          len = this.timeIntervals1.length;\n          let len1 = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals1[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A ');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A ');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.cdRef.detectChanges();\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len1 - 1].date).format('MMM DD hh:mm A');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n          this.loadChart(startTime, endTime);\n        }\n      }\n    }\n    qoeChartOption(chartData) {\n      let thisComponent = this;\n      const qoeCodeMapping = {\n        QOE_HELP_0001: \"Detected WAN down event\",\n        QOE_HELP_0002: \"Detected WAN down event(s)\",\n        QOE_HELP_0003: \"Observed speed test lower than configured rates\",\n        QOE_HELP_0004: \"Observed Low Client(s) Efficiency\",\n        QOE_HELP_0005: \"Observed Poor Client(s) Efficiency\",\n        QOE_HELP_0006: \"Observed latency lower than 50ms\"\n      };\n      let xAxisValue = [],\n        data = [],\n        xZone = [],\n        posVal = 0;\n      let pointColor;\n      const markerColor = ['#C70000', '#C70000', 'rgba(252, 114, 53)', '#82BF00', '#82BF00'];\n      // const DUevel = (testType.includes('Download') || testType.includes('Débit de téléchargement')) ? 'dsLevel' : 'usLevel';\n      let tooltip;\n      const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n      let frame = this.TimeFrame;\n      data = (chartData[mapKey] || []).filter(obj => {\n        if (obj.qoeScore) {\n          pointColor = obj.qoeScore >= 1 ? '#0A77FB' : 'gray';\n          const date = obj.date;\n          // let y = date.substr(0, 4), m = date.substr(4, 2), d = date.substr(6, 2);\n          let y = date.substring(0, 4),\n            m = date.substring(6, 4),\n            d = date.substring(6);\n          let dateWithSlash = m + '/' + d + '/' + y;\n          let year = date.substring(2, 4);\n          let dateWithSlashyear = m + '/' + d + '/' + year;\n          const time = obj.time;\n          // const dt = moment((time.substr(0, 2) + ':' + time.substr(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n          // const dt = moment((time.substring(0, 2) + ':' + time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n          // let fullDate = dt;\n          let fullDateTime;\n          let fullDate = dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4));\n          if (this.TimeFrame == 1) {\n            //daily data\n            fullDate = dateWithSlash;\n          } else if (this.TimeFrame == 4) {\n            fullDateTime = dateWithSlashyear + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n            fullDate = fullDateTime;\n          } else if (this.TimeFrame == 6) {\n            let dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n            dt = dt.split(/\\s/);\n            if (time.toString().slice(0, 2) > 12) {\n              this.time = 'PM';\n            }\n            if (time.toString().slice(0, 2) <= 12) {\n              this.time = 'AM';\n            }\n            dt[1] = this.time;\n            fullDate = dt.join(\" \");\n          } else {\n            let dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n            fullDate = dt;\n          }\n          // let fullDate = (dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4)));\n          xAxisValue.push(fullDate);\n          return obj;\n        }\n      }).map((obj, i) => {\n        if (obj.qoeScore) {\n          posVal = obj.qoeScore > 0 ? obj.qoeScore : posVal;\n          const score = obj.qoeScore > 0 ? obj.qoeScore : posVal > 0 ? -posVal : obj.qoeScore;\n          xZone.push({\n            value: i,\n            dashStyle: score >= 1 ? 'solid' : 'dash',\n            color: score >= 1 ? '#0A77FB' : 'gray'\n          });\n          return {\n            y: typeof score == 'string' ? score.substring(0, 1) : Math.abs(score),\n            color: score >= 1 ? markerColor[score - 1] : 'gray',\n            qoeCode: (obj === null || obj === void 0 ? void 0 : obj.qoeHelpingCode) || []\n            //color: score >= 1 ? '#0A77FB' : 'gray',\n          };\n        }\n      });\n\n      let qoeLabels = [\"Low\", \"Med\", \"High\"];\n      const self = this;\n      return {\n        credits: {\n          enabled: false\n        },\n        legend: {\n          enabled: false\n        },\n        title: {\n          text: ''\n        },\n        xAxis: {\n          categories: xAxisValue,\n          labels: {\n            rotation: -45,\n            style: {\n              fontSize: '10px'\n            }\n          },\n          overflow: false,\n          /* startOnTick: true,\r\n          tickmarkPlacement: 'on', */\n          //padding: '50px',\n          /* labels: {\r\n            //padding: '50px'\r\n            //align: 'left',\r\n            //reserveSpace: true\r\n            //overflow: 'allow'\r\n          }, */\n          /* labels: {\r\n            staggerLines: 2\r\n          }, */\n          tickInterval: function () {\n            let sLength = data.length ? data.length : 0;\n            let f = 1;\n            if (frame === 2) {\n              if (sLength > 90) {\n                f = 4;\n              } else if (sLength > 70) {\n                f = 3;\n              } else if (sLength > 30) {\n                f = 2;\n              }\n            }\n            return f;\n          }()\n        },\n        tooltip: {\n          //pointFormat: ,\n          formatter: function () {\n            var _a;\n            var result = `${self.language.score_table} : <b>${this.point.y}</b>`;\n            result += (((_a = this.point) === null || _a === void 0 ? void 0 : _a.qoeCode) || []).map(obj => `<br>${self.language[obj] ? self.language[obj] : obj}`).join('');\n            return result;\n          }\n        },\n        yAxis: {\n          min: 1,\n          max: 5,\n          tickInterval: 1,\n          title: {\n            text: this.language['QoE Score'],\n            style: {\n              fontSize: '15px'\n            },\n            margin: 40\n          },\n          lineColor: '#ddd'\n        },\n        plotOptions: {\n          series: {\n            cursor: this.TimeFrame != 5 && this.TimeFrame != 6 ? 'pointer' : 'context-menu',\n            point: {\n              events: {\n                click: function () {\n                  thisComponent.clickToGet15Mins(this);\n                  //thisComponent.modalRef = thisComponent.dialogService.open(thisComponent.showProbeStatusModal);\n                }\n              }\n            }\n          }\n        },\n\n        /* yAxis: [{\r\n          title: {\r\n            text: y1title,\r\n            style: {\r\n              fontSize: '15px'\r\n            }\r\n          },\r\n          padding: '50px',\r\n          gridLineWidth: 2,\r\n          tickAmount: 6,\r\n          labels: {\r\n            formatter: function (element) {\r\n              let val = ['', self.language['1'], self.language['2'], self.language['3'], self.language['4'], self.language['5']];\r\n              if (element?.axis?.tickPositions?.length > 0) {\r\n                let index = element.axis.tickPositions.indexOf(this.pos);\r\n                for (let i = 0; i < data?.length; i++) {\r\n                  if (data[i].level == 1) {\r\n                    data[i].y = element.axis?.tickPositions[1];\r\n                  } else if (data[i].level == 2) {\r\n                    data[i].y = element.axis?.tickPositions[2];\r\n                  } else if (data[i].level == 3) {\r\n                    data[i].y = element.axis?.tickPositions[3];\r\n                  } else if (data[i].level == 4) {\r\n                    data[i].y = element.axis?.tickPositions[4];\r\n                  } else if (data[i].level == 5) {\r\n                    data[i].y = element.axis?.tickPositions[5];\r\n                  }\r\n                }\r\n                if (index != -1) {\r\n                  return val[index];\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }, {\r\n          opposite: true,\r\n          tickAmount: 4,\r\n          padding: '50px',\r\n          title: {\r\n            text: y2title\r\n          },\r\n        }], */\n        series: [{\n          type: 'line',\n          min: 1,\n          max: 5,\n          data: data,\n          marker: {\n            //// symbol: 'line',\n            // width: 3,\n            radius: 4 //(data.length == 1 ? 4 : 0),\n          },\n\n          zoneAxis: 'x',\n          zones: xZone,\n          color: '#0A77FB'\n        }]\n      };\n    }\n    wanService(chartData) {\n      let xAxisValue = [],\n        y1title = '',\n        y2title = '',\n        y2AxisValue = [],\n        color = {\n          0: '#C70000',\n          1: '#C70000',\n          2: 'rgba(252, 114, 53)',\n          3: '#82BF00'\n        },\n        data = [],\n        data1 = [];\n      //  color = { 0: '#C70000', 1: '#C70000', 2: 'gary', 3: 'gray' },\n      // const DUevel = testType.includes('Service') ? 'dsLevel' : 'usLevel';\n      let tooltip;\n      const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n      let frame = this.TimeFrame;\n      (chartData[mapKey] || []).filter(obj => (obj === null || obj === void 0 ? void 0 : obj.wanService) == \"GOOD\" || (obj === null || obj === void 0 ? void 0 : obj.wanService) == \"OK\" || (obj === null || obj === void 0 ? void 0 : obj.wanService) == \"BAD\" || (obj === null || obj === void 0 ? void 0 : obj.wanService) == \"BAD(GREY)\").map((obj, i) => {\n        let grey = obj.wanService.toUpperCase().includes('GREY');\n        const wanService = obj.wanService.toUpperCase().includes(\"BAD\") ? 1 : obj.wanService.toUpperCase().includes(\"OK\") ? 2 : 3;\n        const level = wanService;\n        //const DUVAlue = testType.includes('Service') ? 'ds' : 'us';\n        tooltip = `<tr><th>Value:</th><td style=\"padding-left: 3px;\"></td></tr>`;\n        const date = obj.date;\n        let y = date.substring(0, 4),\n          m = date.substring(6, 4),\n          d = date.substring(6);\n        let dateWithSlash = m + '/' + d + '/' + y;\n        let year = date.substring(2, 4);\n        let dateWithSlashyear = m + '/' + d + '/' + year;\n        const time = obj.time;\n        let fullDateTime;\n        let fullDate = dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4));\n        if (this.TimeFrame == 1) {\n          //daily data\n          fullDate = dateWithSlash;\n        } else if (this.TimeFrame == 4) {\n          fullDateTime = dateWithSlashyear + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = fullDateTime;\n        } else if (this.TimeFrame == 6) {\n          let dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          dt = dt.split(/\\s/);\n          if (time.toString().slice(0, 2) > 12) {\n            this.time = 'PM';\n          }\n          if (time.toString().slice(0, 2) <= 12) {\n            this.time = 'AM';\n          }\n          dt[1] = this.time;\n          fullDate = dt.join(\" \");\n        } else {\n          const dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = dt;\n        }\n        xAxisValue.push(fullDate);\n        data.push({\n          x: i,\n          y: level ? 4 : null,\n          color: grey ? 'grey' : color[level],\n          level: level,\n          wanServiceCode: (obj === null || obj === void 0 ? void 0 : obj.wanserviceHelpingCode) || []\n        });\n        /*  data.push({ x: i, y: (level ? 4 : null), color: (grey ? 'grey' : color[level]), level: level }); */\n      });\n      // if (data.length > 0) {\n      //   y1title = y1Title\n      // } else {\n      //   y1title = 'WAN Service';\n      // }\n      y1title = this.language.Health;\n      let that = this;\n      return {\n        credits: {\n          enabled: false\n        },\n        legend: {\n          enabled: false\n        },\n        title: {\n          text: ''\n        },\n        plotOptions: {\n          series: {\n            states: {\n              hover: {\n                enabled: false\n              }\n            }\n          }\n        },\n        xAxis: {\n          categories: xAxisValue,\n          padding: '50px',\n          labels: {\n            rotation: -45,\n            style: {\n              fontSize: '10px'\n            }\n          },\n          overflow: false,\n          tickInterval: function () {\n            let sLength = data.length ? data.length : 0;\n            let f = 1;\n            if (frame === 2) {\n              if (sLength > 90) {\n                f = 4;\n              } else if (sLength > 70) {\n                f = 3;\n              } else if (sLength > 30) {\n                f = 2;\n              }\n            }\n            return f;\n          }()\n        },\n        tooltip: {\n          formatter: function () {\n            var _a;\n            var result = (((_a = this.point) === null || _a === void 0 ? void 0 : _a.wanServiceCode) || []).map(obj => `${that.language[obj] ? that.language[obj] : obj}<br>`).join('');\n            return result ? result : false;\n          }\n        },\n        /* tooltip: {\r\n          useHTML: true,\r\n          headerFormat: '<table>',\r\n          pointFormat: tooltip,\r\n          footerFormat: '</table>',\r\n        }, */\n        yAxis: [{\n          title: {\n            text: y1title,\n            margin: 40,\n            style: {\n              fontSize: '15px'\n            }\n          },\n          padding: '5px',\n          gridLineWidth: 1,\n          tickAmount: 4,\n          labels: {\n            formatter: function (element) {\n              var _a, _b, _c, _e, _f;\n              let val = ['', 'Poor', 'Fair', 'Good'];\n              if (((_b = (_a = element === null || element === void 0 ? void 0 : element.axis) === null || _a === void 0 ? void 0 : _a.tickPositions) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                let index = element.axis.tickPositions.indexOf(this.pos);\n                for (let i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i++) {\n                  if (data[i].level == 1) {\n                    data[i].y = (_c = element.axis) === null || _c === void 0 ? void 0 : _c.tickPositions[1];\n                  } else if (data[i].level == 2) {\n                    data[i].y = (_e = element.axis) === null || _e === void 0 ? void 0 : _e.tickPositions[2];\n                  } else if (data[i].level == 3) {\n                    data[i].y = (_f = element.axis) === null || _f === void 0 ? void 0 : _f.tickPositions[3];\n                  }\n                }\n                if (index != -1) {\n                  return ''; //val[index];\n                }\n              }\n            }\n          }\n        }, {\n          opposite: true,\n          tickAmount: 4,\n          padding: '5px',\n          title: {\n            text: y2title\n          },\n          labels: {\n            format: '{value} Mbps'\n          }\n        }],\n        series: [{\n          type: 'scatter',\n          data: data,\n          name: '',\n          marker: {\n            symbol: 'circle',\n            shadow: false,\n            radius: 8\n          },\n          color: 'black'\n        }, {\n          name: '',\n          data: data1,\n          marker: {\n            symbol: 'circle',\n            shadow: false,\n            radius: 8\n          },\n          color: 'black',\n          states: {\n            hover: {\n              enabled: false\n            }\n          },\n          yAxis: 1\n        }]\n      };\n    }\n    wanContinuity(chartData, wanshow) {\n      let xAxisValue = [],\n        y1title = '',\n        y2title = '',\n        y2AxisValue = [],\n        color = {\n          0: '#C70000',\n          1: '#C70000',\n          2: '#82BF00',\n          3: '#82BF00'\n        },\n        data = [],\n        data1 = [];\n      // const DUevel = testType.includes('Service') ? 'dsLevel' : 'usLevel';\n      let tooltip;\n      const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData',\n        self = this;\n      let frame = this.TimeFrame;\n      (chartData[mapKey] || []).filter(obj => obj.wanContinuity).map((obj, i) => {\n        let grey = obj.wanContinuity.toUpperCase().includes('GREY');\n        const wanContinuity = obj.wanContinuity.toUpperCase().includes(\"GOOD\") ? 2 : 1;\n        let level = wanContinuity;\n        let dl_crttime = new Date(obj.dl_created * 1000);\n        //tooltip = `<tr><th>Value:</th><td style=\"padding-left: 3px;\"></td></tr>`\n        const date = obj.date;\n        let y = date.substr(0, 4),\n          m = date.substr(4, 2),\n          d = date.substr(6, 2);\n        let dateWithSlash = m + '/' + d + '/' + y;\n        let year = date.substring(2, 4);\n        let dateWithSlashyear = m + '/' + d + '/' + year;\n        const time = obj.time;\n        let fullDateTime;\n        let fullDate = dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4));\n        if (this.TimeFrame == 1) {\n          //daily data\n          fullDate = dateWithSlash;\n        } else if (this.TimeFrame == 4) {\n          fullDateTime = dateWithSlashyear + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = fullDateTime;\n        } else if (this.TimeFrame == 6) {\n          let dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          dt = dt.split(/\\s/);\n          if (time.toString().slice(0, 2) > 12) {\n            this.time = 'PM';\n          }\n          if (time.toString().slice(0, 2) <= 12) {\n            this.time = 'AM';\n          }\n          dt[1] = this.time;\n          fullDate = dt.join(\" \");\n        } else {\n          const dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = dt;\n        }\n        xAxisValue.push(fullDate);\n        data.push({\n          x: i,\n          y: level ? 4 : null,\n          color: grey ? 'grey' : color[level],\n          level: level,\n          marker: {\n            lineColor: 'blue',\n            lineWidth: this.downfallCalc(wanshow, chartData, i).length ? 3 : 0\n          }\n        });\n      });\n      // if (data.length > 0) {\n      //   y1title = y1Title\n      // } else {\n      //   y1title = 'WAN Service';\n      // }\n      y1title = this.language.Status;\n      return {\n        credits: {\n          enabled: false\n        },\n        legend: {\n          enabled: false\n        },\n        title: {\n          text: ''\n        },\n        plotOptions: {\n          series: {\n            states: {\n              hover: {\n                enabled: false\n              }\n            }\n          }\n        },\n        xAxis: {\n          categories: xAxisValue,\n          labels: {\n            rotation: -45,\n            style: {\n              fontSize: '10px'\n            }\n          },\n          overflow: false,\n          padding: '50px',\n          tickInterval: function () {\n            let sLength = data.length ? data.length : 0;\n            let f = 1;\n            if (frame === 2) {\n              if (sLength > 90) {\n                f = 4;\n              } else if (sLength > 70) {\n                f = 3;\n              } else if (sLength > 30) {\n                f = 2;\n              }\n            }\n            return f;\n          }()\n        },\n        tooltip: {\n          formatter: function () {\n            var _a;\n            return self.downfallCalc(wanshow, chartData, (_a = this.point) === null || _a === void 0 ? void 0 : _a.x).join('<br>') || false;\n          }\n        },\n        /* tooltip: {\r\n          useHTML: true,\r\n          headerFormat: '<table>',\r\n          pointFormat: tooltip,\r\n          footerFormat: '</table>',\r\n        }, */\n        yAxis: [{\n          title: {\n            text: y1title,\n            margin: 40,\n            style: {\n              fontSize: '15px'\n            }\n          },\n          padding: '5px',\n          gridLineWidth: 1,\n          tickAmount: 3,\n          labels: {\n            formatter: function (element) {\n              var _a, _b, _c, _e;\n              let val = ['', 'Poor', 'Fair', 'Good'];\n              if (((_b = (_a = element === null || element === void 0 ? void 0 : element.axis) === null || _a === void 0 ? void 0 : _a.tickPositions) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                let index = element.axis.tickPositions.indexOf(this.pos);\n                for (let i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i++) {\n                  if (data[i].level == 1) {\n                    data[i].y = (_c = element.axis) === null || _c === void 0 ? void 0 : _c.tickPositions[1];\n                  } else if (data[i].level == 2) {\n                    data[i].y = (_e = element.axis) === null || _e === void 0 ? void 0 : _e.tickPositions[2];\n                  }\n                }\n                if (index != -1) {\n                  return ''; //val[index];\n                }\n              }\n            }\n          }\n        }, {\n          opposite: true,\n          tickAmount: 4,\n          padding: '50px',\n          title: {\n            text: y2title\n          },\n          labels: {\n            format: '{value} Mbps'\n          }\n        }],\n        series: [{\n          type: 'scatter',\n          data: data,\n          name: '',\n          pointWidth: 1000,\n          pointPadding: 0,\n          marker: {\n            enabled: true,\n            symbol: 'circle',\n            shadow: false,\n            radius: 8,\n            states: {\n              hover: {\n                enabled: false\n              }\n            }\n          },\n          color: 'black'\n        }, {\n          name: '',\n          data: data1,\n          marker: {\n            symbol: 'circle',\n            shadow: false,\n            radius: 8\n          },\n          color: 'black',\n          states: {\n            hover: {\n              color: '#a4edba',\n              borderColor: 'gray'\n            }\n          },\n          yAxis: 1\n        }]\n      };\n    }\n    convertDate(date) {\n      var momentDate = moment(date).format(' DD/MM/YYYY, hh:mm A');\n      return momentDate;\n    }\n    downfallCalc(wanshow, chartData, i) {\n      let self = this;\n      let width = [];\n      if ((wanshow === null || wanshow === void 0 ? void 0 : wanshow.length) > 0 && this.TimeFrame != 1) {\n        let dl_indx = i;\n        let dataa1 = chartData.rawData[dl_indx].date;\n        let y = dataa1.slice(0, 4),\n          m = dataa1.slice(4, 6),\n          d = dataa1.slice(6, 8);\n        let orgDate = m + \"/\" + d + \"/\" + y;\n        let dataa2 = chartData.rawData[dl_indx].time;\n        let hrs = dataa2.slice(0, 2),\n          min = dataa2.slice(2, 4);\n        let orgTime = hrs + ':' + min;\n        let datas = orgDate + \" \" + orgTime;\n        let orginal = new Date(datas);\n        orginal.setSeconds(59);\n        orginal.setMilliseconds(0);\n        let orginal15min = new Date(orginal);\n        orginal15min.setSeconds(0);\n        if (![5, 6].includes(this.TimeFrame)) orginal15min.setMinutes(orginal15min.getMinutes() - 14);\n        wanshow.forEach(timedata => {\n          let wanTime = new Date(timedata.timestamp);\n          let occuredTime = wanTime.toISOString();\n          let occuredorgTime = this.convertDate(occuredTime);\n          wanTime.setSeconds(0);\n          wanTime.setMilliseconds(0);\n          if (orginal15min.getTime() <= wanTime.getTime() && wanTime.getTime() <= orginal.getTime()) {\n            if (timedata.type.slice(0, 2) == \"SW\") {\n              timedata.type = 'Software' + timedata.type.slice(2);\n            }\n            width.push(`<b>${occuredorgTime} : </b> ${self.language[timedata.type]}`);\n            return;\n          }\n        });\n      }\n      return width;\n    }\n    wholeHomeEfficiencyOption(data) {\n      let that = this;\n      let xZone = [],\n        posVal = 0;\n      let tooltipvalue = '';\n      const markerColor = ['#C70000', '#C70000', 'rgba(252, 114, 53)', '#82BF00', '#82BF00'];\n      let thisComponent = this;\n      // let [categories, homeefficiency] = this.mapWholeHomeEfficencyChartData(data);\n      // // let average = data?.avgHomeScore ? data?.avgHomeScore : 0;\n      let frame = this.TimeFrame;\n      let categories = [],\n        download = [],\n        upload = [],\n        homeefficiency = [];\n      let tooltip;\n      const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n      homeefficiency = (data[mapKey] || []).map((obj, i) => {\n        const date = obj.date;\n        posVal = obj.homeScore > 0 ? obj.homeScore : posVal;\n        const homescore = obj.homeScore > 0 ? obj.homeScore : posVal > 0 ? -posVal : obj.homeScore;\n        // console.log(\"posVal\", posVal);\n        // console.log(\"homescore\", homescore);\n        tooltipvalue = obj.homeScore > 0 ? ` ${this.language['Efficiency Score']} : <b>{point.y}%</b>` : ` ${this.language['Efficiency Score']} : <b>{point.y}%</b><br>No client activity for Efficiency score`;\n        // tooltipvalue = obj.homeScore > 0 ? 'gretaer 0' : 'lesser';\n        //console.log(\"homescore\",homescore)\n        // if(homescore < 0){\n        //   tooltipvalue = ` ${this.language['Efficiency Score']} : <b>{point.y}%</b><br>No client activity for Efficiency score`;\n        // }\n        // else if(homescore > 0) {tooltipvalue = ` ${this.language['Efficiency Score']} : <b>{point.y}%</b>`;}\n        xZone.push({\n          value: i,\n          dashStyle: obj.homeScore > 0 ? 'solid' : 'dash',\n          color: obj.homeScore > 0 ? '#0a77fb' : 'gray'\n        });\n        let y = date.substring(0, 4),\n          m = date.substring(6, 4),\n          d = date.substring(6);\n        let dateWithSlash = m + '/' + d + '/' + y;\n        const time = obj === null || obj === void 0 ? void 0 : obj.time;\n        let year = date.substring(2, 4);\n        let dateWithSlashyear = m + '/' + d + '/' + year;\n        let fullTime = this.TimeFrame == 1 ? dateWithSlash : moment((time === null || time === void 0 ? void 0 : time.substring(0, 2)) + ':' + (time === null || time === void 0 ? void 0 : time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n        // const dt = moment((time.substring(0, 2) + ':' + time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n        // categories.push(dt);\n        let fullDate = dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4));\n        // let fullDateTime = (dateWithSlash + ' ' + (time.substring(0, 2) + ':' + time.substring(2, 4)));\n        let fullDateTime;\n        if (this.TimeFrame == 1) {\n          //daily data\n          fullDate = dateWithSlash;\n          categories.push(fullDate);\n        } else if (this.TimeFrame == 4) {\n          fullDateTime = dateWithSlashyear + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          categories.push(fullDateTime);\n        } else {\n          const dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDateTime = dateWithSlash + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = dt;\n          categories.push(dt);\n        }\n        // if (obj.homeScore > 0) {\n        return {\n          y: typeof obj.homeScore == 'string' ? parseFloat(homescore.substring(0, 5)) : Math.abs(homescore),\n          color: homescore > 0 ? '#0a77fb' : 'gray',\n          WHECode: parseFloat(obj === null || obj === void 0 ? void 0 : obj.homeScore) || 0,\n          qtime: fullTime,\n          pointDate: fullDate,\n          pointDateTime: fullDateTime\n          //pointFormat: obj.homeScore > 0 ? ` ${this.language['Efficiency Score']} : <b>{point.y}%</b>` : ` ${this.language['Efficiency Score']} : <b>{point.y}%</b><br>No client activity for Efficiency score`\n          //pointFormat: obj.homeScore > 0 ? 'value is grater than 0' : 'value is 0'\n        };\n        // color: homescore  > 0 ? markerColor[(homescore - 1)] : 'gray',\n        // }\n        // } else {\n        //   return { y: null, pointDate: fullDate, pointDateTime: fullDateTime };\n        // }\n      });\n      // console.log(\"xZone\", xZone);\n      // data = (homeefficiency || [])\n      // .map((obj) => {\n      //   if (obj.homeScore) {\n      //     posVal = obj.homeScore > 0 ? obj.homeScore : posVal;\n      //     const homescore = obj.homeScore > 0 ? obj.homeScore : (posVal > 0 ? -(posVal) : obj.homeScore);\n      //     xZone.push({\n      //       // value: i,\n      //       dashStyle: obj.homeScore > 0 ? 'solid' : 'dash',\n      //       color: obj.homeScore > 0 ? '#0a77fb' : 'gray',\n      //     });\n      //     return {\n      //       y: typeof homescore == 'string' ? homescore.substring(0, 1) : Math.abs(homescore),\n      //       color: homescore >= 1 ? markerColor[(homescore - 1)] : 'gray',\n      //       qoeCode: obj?.qoeHelpingCode || []\n      //       //color: score >= 1 ? '#0A77FB' : 'gray',\n      //     }\n      //   }\n      // });\n      let lefficencyScore = this.language.Efficiency_Score;\n      return {\n        title: {\n          text: this.language['Click on the sample to view client efficiency of the selected point.'],\n          style: {\n            fontSize: '14px'\n          },\n          align: 'left'\n        },\n        credits: {\n          enabled: false\n        },\n        chart: {\n          type: 'column'\n          //marginTop: 60\n        },\n\n        tooltip: {\n          //   // headerFormat: '',\n          // pointFormat: `${this.language['Efficiency Score']} : <b>{point.y}%</b>`\n          //pointFormat: tooltipvalue\n          formatter: function () {\n            var result = '<span class=\"f-s-10px\">' + this.point.qtime + '</span><br>' + lefficencyScore + ' : <b>' + (this.point.y == 0 ? this.point.y : this.point.y.toFixed(2)) + '%</b>';\n            //var result = 'value came';\n            if (this.point.WHECode == 0) {\n              result += `</br> ${that.language['No client activity for Efficiency score']}`;\n            }\n            return result;\n          }\n        },\n        xAxis: {\n          categories: categories || [],\n          labels: {\n            rotation: -45,\n            style: {\n              fontSize: '10px'\n            }\n          },\n          overflow: false,\n          tickInterval: function () {\n            let sLength = categories.length ? categories.length : 0;\n            let f = 1;\n            if (frame === 2) {\n              if (sLength > 90) {\n                f = 4;\n              } else if (sLength > 70) {\n                f = 3;\n              } else if (sLength > 30) {\n                f = 2;\n              }\n            }\n            return f;\n          }()\n        },\n        yAxis: {\n          min: 0,\n          max: 100,\n          tickInterval: 20,\n          lineColor: '#ddd',\n          title: {\n            text: this.language.Efficiency_Score + ' (%)',\n            style: {\n              fontSize: '15px'\n            }\n          }\n          //  plotLines: [{\n          //   color: '#5ACFEA',\n          //   value: average, // Insert your average here\n          //   width: '2',\n          //   zIndex: 4, // To not get stuck below the regular plot lines or series\n          //   label: {\n          //     text: ('Avg: ' + average),\n          //     align: 'right'\n          //   },\n          // }],\n        },\n\n        plotOptions: {\n          series: {\n            maxPointWidth: 20,\n            borderRadius: 0,\n            cursor: 'pointer',\n            marker: {\n              enabled: false,\n              states: {\n                hover: {\n                  enabled: true,\n                  radius: 6.5\n                }\n              }\n            },\n            point: {\n              events: {\n                click: function () {\n                  thisComponent.showClientEfficencyChart(this.options);\n                  //thisComponent.modalRef = thisComponent.dialogService.open(thisComponent.showProbeStatusModal);\n                }\n              }\n            }\n          }\n        },\n\n        series: [{\n          type: 'line',\n          name: '',\n          //data: (homeefficiency || []),\n          data: homeefficiency,\n          zoneAxis: 'x',\n          zones: xZone,\n          color: '#0a77fb',\n          showInLegend: false\n        }]\n      };\n    }\n    // mapWholeHomeEfficencyChartData(data) {\n    //   let categories = [], download = [], upload = [], homeefficiency = [];\n    //   let xZone = [];\n    //   let tooltip;\n    //   const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n    //   homeefficiency = (data[mapKey] || [])\n    //     .map(obj => {\n    //       const date = obj.date;\n    //       let y = date.substring(0, 4), m = date.substring(6, 4), d = date.substring(6,);\n    //       let dateWithSlash = m + '/' + d + '/' + y;\n    //       const time = obj.time;\n    //       // const dt = moment((time.substring(0, 2) + ':' + time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n    //       // categories.push(dt);\n    //       let fullDate = (dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4)));\n    //       // let fullDateTime = (dateWithSlash + ' ' + (time.substring(0, 2) + ':' + time.substring(2, 4)));\n    //       let fullDateTime;\n    //       let year = date.substring(2, 4)\n    //       let dateWithSlashyear = m + '/' + d + '/' + year;\n    //       if (this.TimeFrame == 1) { //daily data\n    //         fullDate = dateWithSlash\n    //         categories.push(fullDate);\n    //       } else if (this.TimeFrame == 4) {\n    //         fullDateTime = (dateWithSlashyear + ' ' + moment((time.substring(0, 2) + ':' + time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\"));\n    //         categories.push(fullDateTime);\n    //       }\n    //       else {\n    //         const dt = moment((time.substring(0, 2) + ':' + time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n    //         fullDateTime = (dateWithSlash + ' ' + moment((time.substring(0, 2) + ':' + time.substring(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\"));\n    //         fullDate = dt;\n    //         categories.push(dt);\n    //       }\n    //       obj.homeScore.findindex\n    //       if (obj.homeScore > 0) {\n    //         return typeof obj.homeScore == 'string' ? { y: parseInt(obj.homeScore.toString().substring(0, 5)), pointDate: fullDate, pointDateTime: fullDateTime } : { y: parseInt(obj.homeScore.toString().substring(0, 5)), pointDate: fullDate, pointDateTime: fullDateTime }\n    //       } else {\n    //         return { y: null, pointDate: fullDate, pointDateTime: fullDateTime };\n    //       }\n    //     });\n    //   return [categories, homeefficiency];\n    // }\n    clientEfficiency(value) {\n      let timeFrameOfAverageEff = 6;\n      this.globalObj.latencyCreateTime = '';\n      let s, e;\n      if (this.TimeFrame == 1) {\n        [s, e] = [new Date(value.pointDate.replace('<br>', ' ')), new Date(value.pointDate.replace('<br>', ' '))];\n      } else {\n        [s, e] = [new Date(value.pointDateTime.replace('<br>', ' ')), new Date(value.pointDateTime.replace('<br>', ' '))];\n      }\n      // const [s, e] = [new Date(value.pointDate.replace('<br>', ' ')), new Date(value.pointDate.replace('<br>', ' '))];\n      // var st = moment(value.pointDate.replace('<br>', ' '), [\"hh:mm A\"]).toString();\n      // var et = moment(value.pointDate.replace('<br>', ' '), [\"hh:mm A\"]).toString();\n      // const [s, e] = [new Date(st), new Date(et)];\n      // let [start, end] = value.index == 0 ? this.averageTimeSetter(s, e, true).reverse() : this.averageTimeSetter(s, e);\n      let [start, end] = this.averageTimeSetterNew(s, e); // jeevagan\n      let params;\n      if (this.TimeFrame == 1) {\n        params = {\n          sn: this.serialNumberSelected,\n          orgId: this.orgId,\n          mac: this.mac,\n          // period: timeFrameOfAverageEff,\n          period: this.TimeFrame,\n          start: start,\n          end: end,\n          tz: 0\n        };\n      } else {\n        params = {\n          sn: this.serialNumberSelected,\n          orgId: this.orgId,\n          mac: this.mac,\n          // period: timeFrameOfAverageEff,\n          period: this.TimeFrame,\n          start: start,\n          end: end,\n          tz: -(new Date().getTimezoneOffset() / 60)\n        };\n      }\n      this.avgEff = Object.assign({}, params);\n      this.effLoader = true;\n      this.IssuesService.getAverageScore(params).subscribe(res => {\n        this.effLoader = false;\n        Highcharts.chart('clientEfficiencyChartDiv', this.clientEfficiencyChartPopup(res || [], value.y));\n      }, err => {\n        this.effLoader = false;\n        // const res = {\n        //   'average-effciency-score': [{ client_name: \"Apple iPhone 12\", eff_score: 64.64, router_mac: \"d0:76:8f:dd:c0:2f\", station_mac_addr: \"86:92:b2:8b:5b:96\" },\n        //   { client_name: \"Google Pixel 4a (5G)\", eff_score: 74.95, router_mac: \"d0:76:8f:dd:c0:2f\", station_mac_addr: \"72:7d:61:fc:ca:9e\" }]\n        // };\n        // Highcharts.chart('clientEfficiencyChartDiv', this.clientEfficiencyChartPopup(res || [], value.y));\n        this.pageErrorHandle(err);\n      });\n    }\n    // client_name: \"Apple iPhone 12\"\n    // date: \"20220221\"\n    // dl_created: 1645478640\n    // eff_score: 81.1\n    // fsan_sn: \"CXNK009B44B5\"\n    // router_mac: \"d0:76:8f:dd:c0:2f\"\n    // station_mac_addr: \"86:92:b2:8b:5b:96\"\n    // time: \"1554\"\n    // timestamp_str: \"2022-02-21 10:24:00.000\"\n    getEfficiensyColor(score) {\n      if (score > 45) {\n        return '#82BF00';\n      } else if (score > 15) {\n        return 'rgba(252, 114, 53)';\n      } else {\n        return '#C70000';\n      }\n    }\n    clientEfficiencyChartPopup(chartData, average) {\n      let xAxisValue = [],\n        y1title = '',\n        y2title = '',\n        color = {\n          0: '#C70000',\n          1: '#C70000',\n          2: 'rgba(252, 114, 53)',\n          3: '#82BF00'\n        },\n        data = [],\n        data1 = [];\n      let tooltip;\n      let self = this;\n      const mapKey = 'average-effciency-score';\n      chartData[mapKey].sort((a, b) => a.eff_score - b.eff_score);\n      let value = chartData[mapKey].filter(a => a.client_name !== \"\" || a.client_name == \"\");\n      chartData[mapKey] = value;\n      chartData[mapKey].map((obj, i) => {\n        const level = parseFloat(obj.eff_score.toFixed(2));\n        xAxisValue.push(obj.client_name || obj.mesh_mac || obj.station_mac_addr || '');\n        var temp_is_online_now = false;\n        if (obj['is_online_now']) {\n          temp_is_online_now = obj['is_online_now'];\n        }\n        data.push({\n          x: i,\n          y: level,\n          color: this.getEfficiensyColor(level),\n          level: level,\n          routerMac: obj.router_mac,\n          stationMac: obj.station_mac_addr,\n          client_name: obj.client_name,\n          is_online_now: temp_is_online_now,\n          eff_score: obj.eff_score,\n          mesh_mac: obj.mesh_mac || ''\n        });\n      });\n      let avg = chartData['average-effciency-score'].reduce(function (p, c, i, a) {\n        return p + c.eff_score / a.length;\n      }, 0);\n      avg = parseFloat(avg.toFixed(2));\n      // var avg = chartData.mapKey.reduce(function (p, c, i, a) { return p.eff_score + (c.eff_score / a.length) }, 0);\n      // chartData[mapKey].map((obj) => {\n      //   const sum = obj.eff_score.reduce((acc, cur) => acc + cur);\n      //   const average = sum / obj.eff_score.length;\n      //   return average;\n      // });\n      let period = this.TimeFrame; //[1, 2, 4].includes(this.appliedTimeFrame) ? 2 : ([5, 6].includes(this.appliedTimeFrame) ? 6 : 3);\n      let that = this;\n      return {\n        credits: {\n          enabled: false\n        },\n        legend: {\n          enabled: false\n        },\n        title: {\n          text: ''\n        },\n        xAxis: {\n          categories: xAxisValue,\n          padding: '5px'\n        },\n        tooltip: {\n          //headerFormat: '<b> {point.x} Efficiency',\n          //pointFormat: '{series.name}: {point.y} %</b></br>Click to go to device details',\n          formatter: function () {\n            var s = '<b>' + this.x + ' ' + that.language.Efficiency + ': ' + this.y + ' %</b>';\n            if (this.point.options.client_name || this.point.options.client_name == undefined && this.point.options.is_online_now != true) {\n              s += '</br>' + that.language['Click to go to device details'];\n            }\n            return s;\n          }\n        },\n        yAxis: [{\n          min: 0,\n          max: 100,\n          tickInterval: 20,\n          // top: \"3%\",\n          title: {\n            text: this.language['Device Efficiency'] + ' (%)',\n            style: {\n              fontSize: '15px'\n            }\n          },\n          plotLines: [{\n            color: '#5ACFEA',\n            value: average ? average.toFixed(2) : 0,\n            width: '2',\n            zIndex: 4,\n            label: {\n              text: `${this.language['Whole Home Efficiency']} - ${average ? average.toFixed(2) : 0} % `,\n              align: 'right'\n            }\n          }]\n        }, {\n          opposite: true,\n          tickAmount: 4,\n          padding: '5px',\n          title: {\n            text: y2title\n          },\n          labels: {\n            format: '{value} Mbps'\n          }\n        }],\n        plotOptions: {\n          series: {\n            maxPointWidth: 20,\n            borderRadius: 0,\n            cursor: 'pointer',\n            point: {\n              events: {\n                click: function () {\n                  self.deviceService.efficiencyChart = true;\n                  let link = '/support/device';\n                  // self.router.navigate([link],{ queryParams: { item: 'deviceId' }, });\n                  const inputs = {\n                    routerMac: this.options.routerMac,\n                    stationMac: this.options.stationMac,\n                    is_online_now: this.options.is_online_now,\n                    eff_score: this.options.eff_score,\n                    // period: period,\n                    period: self.periodForFilter(period),\n                    WeekFrame: self.periodForWeekFrame(period),\n                    endTime: self.endForFilter()\n                  };\n                  if (this.options.stationMac && this.options.client_name) {\n                    self.close();\n                    self.router.navigate([link], {\n                      state: inputs\n                    });\n                  }\n                }\n              }\n            }\n          },\n          column: {\n            minPointLength: 3\n          }\n        },\n        series: [{\n          type: 'column',\n          data: data,\n          name: ''\n        }]\n      };\n    }\n    endForFilter() {\n      let [start, end, end2] = [new Date(), new Date(), new Date(), new Date(), new Date(), new Date()];\n      switch (this.TimeFrame) {\n        case 1:\n          // if (this.clientDates == moment().format('MM/DD/yyyy')) {\n          //   start.setHours(5, 30, 0, 0)\n          //   start.setHours(start.getHours())\n          //   end = new Date()\n          //   end.setMinutes(end.getMinutes() + 330);\n          // } else {\n          //   start.setHours(5, 30, 0, 0)\n          //   start.setHours(start.getHours())\n          //   end.setHours(28, 89, 59, 0)\n          // }\n          // let [start, end, startust, endust] = [new Date(), new Date(), new Date(), new Date()];\n          // let startust\n          // let endust\n          if (this.clientDates == moment().format('MM/DD/yyyy')) {\n            end = new Date(this.clientDates);\n            start = new Date(this.clientDates);\n            let date = new Date();\n            let hours = new Date().getHours();\n            let coeff = 1000 * 60;\n            end = new Date(new Date(date.setMinutes(date.getMinutes())).setHours(hours, 0, 0, 0));\n            // startust = new Date(this.clientDates)\n            // startust.setHours(5, 30, 0, 0)\n            // startust.setHours(startust.getHours())\n            // endust = new Date()\n            // endust.setMinutes(endust.getMinutes() + 330);\n          } else {\n            end = new Date(this.clientDates);\n            start = new Date(this.clientDates);\n            end.setHours(end.getHours() + 24);\n            // startust = new Date(this.clientDates)\n            // startust.setHours(5, 30, 0, 0)\n            // startust.setHours(startust.getHours())\n            // endust = new Date(this.clientDates)\n            // endust.setHours(startust.getHours())\n            // endust.setHours(28, 89, 59, 0)\n            // [start, end] = this.minuteAligner(start, end)\n          }\n          //  start = new Date(end.setHours(end.getHours() - 24))\n          // start = end.subtract(60, 'minutes').format('hh:mm A');\n          // return [start, end, startust, endust]\n          break;\n        case 2:\n          end = new Date(this.clientDates);\n          start = new Date(this.clientDates);\n          //   start.setMinutes(end.getMinutes() - 15)\n          // [start, end] = this.minuteAligner(start, end);\n          start.setMinutes(start.getMinutes() - 15);\n          // end.setMinutes(end.getMinutes() - 1);\n          break;\n        case 3:\n          // end = moment((value.pointDate), [\"hh:mm A\"].toString())\n          end = new Date(this.clientDates);\n          start = new Date(this.clientDates);\n          start.setMinutes(start.getMinutes() - 15);\n          // [start, end] = this.minuteAligner(start, end);\n          break;\n        case 4:\n          // let endTime1\n          // if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n          //   endTime1 = this.timeIntervals[this.selectedInterval].date;\n          //   let end = moment(endTime1).subtract(15, \"minutes\")\n          //   let start = moment(endTime1).subtract(180, \"minutes\");\n          // } else {\n          //   endTime1 = this.timeIntervals[this.selectedInterval].date;\n          //   let end = moment(endTime1).subtract(15, \"minutes\")\n          //   // startTime = moment(endTime1).subtract(60, \"minutes\");\n          //   start = this.timeIntervals[this.selectedInterval - 1].date\n          // }\n          /* if (this.WeekFrame == 7) {\r\n            end = new Date(this.clientDates)\r\n            start = new Date(this.clientDates)\r\n            end.setMinutes(end.getMinutes() + 15)\r\n          } else {\r\n            let endTime = this.timeIntervals[this.selectedInterval].date\r\n            endTime = moment(endTime).subtract(15, \"minutes\")\r\n            end = new Date(endTime)\r\n            start = new Date(endTime)\r\n            start.setMinutes(start.getMinutes() - 165)\r\n                    } */\n          if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n            let endTime = this.timeIntervals[this.selectedInterval].date;\n            let endTime2 = this.timeIntervals[this.selectedInterval].date;\n            end2 = new Date(endTime2);\n            endTime = moment(endTime).subtract(15, \"minutes\");\n            end = new Date(endTime);\n            start = new Date(endTime);\n            start.setMinutes(start.getMinutes() - 165);\n          } else {\n            let endTime = this.timeIntervals[this.selectedInterval].date;\n            let endTime2 = this.timeIntervals[this.selectedInterval].date;\n            end2 = new Date(endTime2);\n            endTime = moment(endTime).subtract(15, \"minutes\");\n            end = new Date(endTime);\n            start = this.timeIntervals[this.selectedInterval - 1].date;\n            start.setMinutes(start.getMinutes());\n          }\n          break;\n        case 5:\n          start = new Date();\n          start.setMinutes(start.getMinutes() - 16);\n          end.setMinutes(end.getMinutes() + 1);\n          // start.setMinutes(start.getMinutes() - 15);\n          //  var start = end.setMinutes(end.getMinutes() - 15);\n          // start.setMinutes(start.getMinutes() - 15);\n          //   start.setMinutes(end.getMinutes() - 15)\n          // start.setMinutes(end.getMinutes() - 15)\n          // end.setMinutes(start.getMinutes() - 15);\n          break;\n        case 6:\n          let endTime = this.timeIntervals[this.selectedInterval].date;\n          end = new Date(endTime);\n          start = new Date(endTime);\n          start.setMinutes(start.getMinutes() - 15);\n          // end.setMinutes(end.getMinutes() + 1);\n          //  start = moment(endTime).subtract(15, \"minutes\")\n          // [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n          // start.setMinutes(start.getMinutes());\n          // end.setMinutes(start.getMinutes() - 15);\n          break;\n        default:\n          break;\n      }\n      return [start, end, end2];\n      // return [(start.toISOString().substring(0, 16) + ':00'), (end.toISOString().substring(0, 16) + ':00')];\n    }\n\n    periodForWeekFrame(period) {\n      switch (this.WeekFrame) {\n        case 1:\n          period = 1;\n          break;\n        case 2:\n          period = 2;\n          break;\n        case 3:\n          period = 3;\n          break;\n        case 4:\n          period = 4;\n          break;\n        case 5:\n          period = 5;\n          break;\n        case 6:\n          period = 6;\n          break;\n        case 7:\n          period = 7;\n        default:\n          break;\n      }\n      return period;\n    }\n    periodForFilter(period) {\n      switch (this.TimeFrame) {\n        case 1:\n          period = 7;\n          break;\n        case 2:\n          period = 6;\n          break;\n        case 3:\n          period = 6;\n          break;\n        case 4:\n          period = 4;\n          break;\n        case 5:\n          period = 5;\n          break;\n        case 6:\n          period = 6;\n        default:\n          break;\n      }\n      return period;\n    }\n    // mapClientEfficencyChartData(data, mapObj, isByte = 2) {\n    //   let categories = [], download = [], upload = [], latency = [];\n    //   data.forEach(obj => {\n    //     categories.push(obj[mapObj.time]);\n    //     latency.push(obj[mapObj.latency]);\n    //   });\n    //   return mapObj.hasOwnProperty('latency') ? [categories, latency] : [categories, download, upload];\n    // }\n    showClientEfficencyChart(value) {\n      if (this.TimeFrame == 1) {\n        this.clientDates = moment(new Date(value.pointDate)).format('MM/DD/YYYY');\n      } else if (this.TimeFrame == 4) {\n        this.clientDates = moment(new Date(moment(value.pointDate).toString())).format('MM/DD/YYYY hh:mm A');\n      } else {\n        this.clientDates = moment(new Date(moment(value.pointDateTime).toString())).format('MM/DD/YYYY hh:mm A');\n        // this.clientDates = moment(new Date(moment((value.pointDateTime), [\"hh:mm A\"]).toString())).format('MM/DD/YYYY hh:mm A');\n      }\n\n      this.modalRef = this.dialogService.open(this.clientEfficencyChartTest, {\n        windowClass: 'ce-modal'\n      });\n      this.clientEfficiency(value);\n      //this.QoeCharts();\n      this.modalRef.dismissed.subscribe(() => {\n        setTimeout(() => {\n          window.scrollTo(0, document.body.scrollHeight);\n        }, 100);\n      });\n    }\n    close() {\n      this.modalRef.close();\n      //this.scrollToId('wholeHomeEfficiencyChart');\n      setTimeout(() => {\n        window.scrollTo(0, document.body.scrollHeight);\n      }, 100);\n    }\n    pageErrorHandle(err) {\n      /* if (err.status == 401) {\r\n        this.alertMessage = this.language['Access Denied'];\r\n      } else {\r\n        this.alertMessage = this.dataChartService.pageErrorHandle(err);\r\n      } */\n      this.alertMessage = this.ssoService.pageErrorHandle(err);\n      this.isError = true;\n      this.error = true;\n      $(\"body\").scrollTop(0);\n    }\n    qoeCheck() {\n      let scopes = this.ssoService.getScopes();\n      let validScopes = Object.keys(scopes);\n      if (environment.VALIDATE_SCOPE) {\n        scopes['cloud.rbac.csc.qoe'] = scopes['cloud.rbac.csc.qoe'] ? scopes['cloud.rbac.csc.qoe'] : [];\n        if (scopes && scopes['cloud.rbac.csc.qoe'] && scopes['cloud.rbac.csc.qoe'].length) {\n          if (scopes['cloud.rbac.csc.qoe'].indexOf('read') !== -1) this.scope.qoeRead = true;\n        }\n      } else {\n        this.scope.qoeRead = true;\n      }\n      let modelName = sessionStorage.getItem(\"calix.deviceData\") ? JSON.parse(sessionStorage.getItem(\"calix.deviceData\"))[0].modelName : '';\n      let fduser = sessionStorage.getItem('calix.userFdUser') == 'true' ? true : false;\n      if (this.ssoService.acceptGSModel(modelName)) {\n        this.showQOE = this.ssoService.exosVersionCheck('21.4') && this.scope.qoeRead;\n        return sessionStorage.getItem('qoeCheck');\n      } else {\n        this.showQOE = this.scope.qoeRead;\n        return sessionStorage.getItem('qoeCheck');\n      }\n    }\n    getScopes() {\n      let scopes = this.ssoService.getScopes();\n      let validScopes = Object.keys(scopes);\n      if (environment.VALIDATE_SCOPE) {\n        scopes['cloud.rbac.csc.topology'] = scopes['cloud.rbac.csc.topology'] ? scopes['cloud.rbac.csc.topology'] : [];\n        if (scopes && scopes['cloud.rbac.csc.topology'] && scopes['cloud.rbac.csc.topology'].length) {\n          if (scopes['cloud.rbac.csc.topology'].indexOf('read') !== -1) {\n            this.scope.topologyRead = true;\n            //this.showTopologyTab = true;\n          }\n        }\n      } else {\n        this.scope.topologyRead = true;\n        //this.showTopologyTab = true;\n      }\n    }\n\n    lastdays15MinOfValues() {\n      /* let date = new Date();\r\n      var coeff = 1000 * 60 * 15;\r\n      let timeDuration = -24 * 60;\r\n      let lastUpdatedTime;\r\n      let that = this;\r\n      let len = 0;\r\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\r\n      let startTime = moment(lastTime).subtract(24, \"hours\");\r\n      let currentTimestamp = new Date().setSeconds(0, 0);\r\n      const minToRoundOf24hr = Math.ceil(\r\n        (currentTimestamp - new Date(moment(startTime).toDate()).getTime())\r\n        / (1000 * 60 * 60)\r\n      ) > 24 ? 30 : 15;\r\n      startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute\r\n            this.timeIntervals = [];\r\n      let current = moment(startTime);\r\n      let i = 0;\r\n      while (current <= lastTime) {\r\n        this.timeIntervals.push({\r\n          value: i, legend: moment(current).format('MM/DD/YYYY HH:mm'),\r\n          date: moment(current).toDate()\r\n        });\r\n        lastUpdatedTime = moment(current);\r\n        current.add(15, 'minutes');\r\n        i++;\r\n      }\r\n            //including current time\r\n      // let currentEnd = moment(date).seconds(0).milliseconds(0);\r\n      // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\r\n      //   this.timeIntervals.push({\r\n      //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\r\n      //     date: moment(currentEnd).toDate()\r\n      //   });\r\n      // }\r\n        \r\n      len = this.timeIntervals.length;\r\n      this.selectedInterval = this.timeIntervals[len - 1].value;\r\n      this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\r\n            const translate = (value: number, label: LabelType): string => {\r\n        let pointersTime = moment(that.timeIntervals[value]['date']);\r\n        let start = pointersTime.subtract(15, 'minutes').format('hh:mm A');\r\n        let end = moment(that.timeIntervals[value]['date']).format('hh:mm A');\r\n        return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\r\n      };\r\n      this.timeIntervalOptions.translate = translate; */\n      if (this.TimeFrame == 6) {\n        let date = new Date();\n        let coeff = 1000 * 60 * 15;\n        let timeDuration = -24 * 60;\n        let lastUpdatedTime;\n        let that = this;\n        let len = 0;\n        let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n        let startTime = moment(lastTime).subtract(24, \"hours\");\n        let currentTimestamp = new Date().setSeconds(0, 0);\n        // console.log('current = ' + new Date(currentTimestamp));\n        // console.log('start = ' + new Date(moment(startTime).toDate()));\n        // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60));\n        const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n        startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute\n        this.timeIntervals = [];\n        let current = moment(startTime);\n        // console.log(this.timeIntervals);\n        let i = 0;\n        while (current <= lastTime) {\n          this.timeIntervals.push({\n            value: i,\n            legend: moment(current).format('MM/DD/YYYY HH:mm'),\n            date: moment(current).toDate()\n          });\n          lastUpdatedTime = moment(current);\n          current.add(15, 'minutes');\n          i++;\n        }\n        //including current time\n        // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // console.log(currentEnd);\n        // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        //   console.log('Not same');\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(currentEnd).toDate()\n        //   });\n        // }\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        };\n        this.timeIntervalOptions.translate = translate;\n        //console.log(this.timeIntervals);\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(15, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (this.TimeFrame == 4) {\n        // let date = new Date();\n        // let coeff = 1000 * 60;\n        // // now = moment()\n        // //1000 miliecond //60 seconds\n        // let timeDuration = -24 * 60;\n        // let lastUpdatedTime;\n        // let that = this;\n        // let now = moment()\n        // let len = 0;\n        // var startTime1\n        // let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n        // //  let startOfDayTime = now.startOf('day').toString()\n        // // let startTime = moment(startOfDayTime).subtract(120, \"hours\").startOf('day');\n        // let startTime = moment(lastTime).subtract(144, \"hours\");\n        // startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0))\n        // // startTime1 = new Date(startTime)\n        // let currentTimestamp = new Date().setSeconds(0, 0);\n        // const minToRoundOf24hr = Math.ceil(\n        //   (currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n        //   / (1000 * 60 * 60)\n        // ) > 24 ? 30 : 15;\n        // // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute\n        // this.timeIntervals = [];\n        // let current = moment(startTime1);\n        // // 48\n        // let i = 0;\n        // let timeinterrval1 = 180\n        // while (current <= lastTime) {\n        //   this.timeIntervals.push({\n        //     value: i, legend: moment(current).format('MM/DD/YYYY HH:mm'),\n        //     date: moment(current).toDate()\n        //   });\n        //   lastUpdatedTime = moment(current);\n        //   current.add(timeinterrval1, 'minutes');\n        //   if (current['_d'].toString() == now.startOf('day')['_d'].toString()) {\n        //     //  current.add(60, 'minutes');.\n        //     timeinterrval1 = 60\n        //   }\n        //   // current.add(180, 'minutes');\n        //   i++;\n        // }\n        // //including current time\n        // // let currentEnd = moment(date).seconds(0).milliseconds(0);\n        // // console.log(currentEnd);\n        // // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n        // //   console.log('Not same');\n        // //   this.timeIntervals.push({\n        // //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n        // //     date: moment(currentEnd).toDate()\n        // //   });\n        // // }\n        // len = this.timeIntervals.length;\n        // this.selectedInterval = this.timeIntervals[len - 1].value;\n        // this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        // const translate = (value: number, label: LabelType): string => {\n        //   let pointersTime = moment(that.timeIntervals[value]['date']);\n        //   // var start\n        //   // var end\n        //   // if (this.selectedInterval <= 48) {\n        //   //   start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n        //   //   end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n        //   // }\n        //   // else {\n        //   //   start = pointersTime.subtract(60, 'minutes').format('MMM DD hh:mm A');\n        //   //   end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n        //   // }\n        //   let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n        //   let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n        //   return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n        // };\n        // this.timeIntervalOptions.translate = translate;\n        // //console.log(this.timeIntervals);\n        // // this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n        // this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n        // this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        // setTimeout(() => {\n        //   this.showIntervalSlider = true;\n        //   setTimeout(() => {\n        //     $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n        //   }, 10);\n        // }, 1000)\n        var i = this.WeekFrame;\n        if (i == 1) {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          var startTime1;\n          var lastTime1;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n          lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // console.log('current = ' + new Date(currentTimestamp));\n          // console.log('start = ' + new Date(moment(startTime).toDate()));\n          // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n          //   / (1000 * 60 * 60));\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          while (current <= lastTime1) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(180, 'minutes');\n            i++;\n          }\n          //including current time\n          // let currentEnd = moment(date).seconds(0).milliseconds(0);\n          // console.log(currentEnd);\n          // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n          //   console.log('Not same');\n          //   this.timeIntervals.push({\n          //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n          //     date: moment(currentEnd).toDate()\n          //   });\n          // }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.lastSeventhDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (i == 2) {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          // let startTime1\n          // let lastTime1\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // console.log('current = ' + new Date(currentTimestamp));\n          // console.log('start = ' + new Date(moment(startTime).toDate()));\n          // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n          //   / (1000 * 60 * 60));\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          while (current <= lastTime1) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(180, 'minutes');\n            i++;\n          }\n          //including current time\n          // let currentEnd = moment(date).seconds(0).milliseconds(0);\n          // console.log(currentEnd);\n          // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n          //   console.log('Not same');\n          //   this.timeIntervals.push({\n          //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n          //     date: moment(currentEnd).toDate()\n          //   });\n          // }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.lastSixthDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (i == 3) {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(48, 0, 0, 0));\n          lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          while (current <= lastTime1) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(180, 'minutes');\n            i++;\n          }\n          //including current time\n          // let currentEnd = moment(date).seconds(0).milliseconds(0);\n          // console.log(currentEnd);\n          // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n          //   console.log('Not same');\n          //   this.timeIntervals.push({\n          //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n          //     date: moment(currentEnd).toDate()\n          //   });\n          // }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.lastfifthDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (i == 4) {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(72, 0, 0, 0));\n          lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // console.log('current = ' + new Date(currentTimestamp));\n          // console.log('start = ' + new Date(moment(startTime).toDate()));\n          // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n          //   / (1000 * 60 * 60));\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          while (current <= lastTime1) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(180, 'minutes');\n            i++;\n          }\n          //including current time\n          // let currentEnd = moment(date).seconds(0).milliseconds(0);\n          // console.log(currentEnd);\n          // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n          //   console.log('Not same');\n          //   this.timeIntervals.push({\n          //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n          //     date: moment(currentEnd).toDate()\n          //   });\n          // }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.lastFourthDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (i == 5) {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(96, 0, 0, 0));\n          lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // console.log('current = ' + new Date(currentTimestamp));\n          // console.log('start = ' + new Date(moment(startTime).toDate()));\n          // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n          //   / (1000 * 60 * 60));\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          while (current <= lastTime1) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(180, 'minutes');\n            i++;\n          }\n          //including current time\n          // let currentEnd = moment(date).seconds(0).milliseconds(0);\n          // console.log(currentEnd);\n          // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n          //   console.log('Not same');\n          //   this.timeIntervals.push({\n          //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n          //     date: moment(currentEnd).toDate()\n          //   });\n          // }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.lastThirdDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (i == 6) {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(120, 0, 0, 0));\n          lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // console.log('current = ' + new Date(currentTimestamp));\n          // console.log('start = ' + new Date(moment(startTime).toDate()));\n          // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n          //   / (1000 * 60 * 60));\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n          startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          // console.log(this.timeIntervals);\n          let i = 0;\n          while (current <= lastTime1) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(180, 'minutes');\n            i++;\n          }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.yesterDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (i == 7) {\n          {\n            let date = new Date();\n            let coeff = 1000 * 60;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime;\n            lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(144, 0, 0, 0));\n            // lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0))\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime1).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 60 : 180;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            let lasttime;\n            // this.timeinterrval1 = 180;\n            let now = moment();\n            while (current <= lastTime) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()) / 3);\n              if (lasttime > 0) {\n                current.add(180, 'minutes');\n              } else {\n                const minToRoundOf24hr = Math.ceil(lastTime[\"_d\"].getHours() - current['_d'].getHours()) == 2 ? 120 : 60;\n                current.add(minToRoundOf24hr, 'minutes');\n              }\n              i++;\n            }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              var start;\n              var end;\n              if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n                start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n                end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              } else {\n                // start = pointersTime.subtract(minToRoundOf24hr, 'minutes').format('MMM DD hh:mm A');\n                start = moment(this.timeIntervals[len - 2].date).format('MMM DD hh:mm A');\n                end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n              }\n              // let start = pointersTime.subtract(180, 'minutes').format('hh:mm A');\n              // let end = moment(that.timeIntervals[value]['date']).format('hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.toDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          }\n        }\n        setTimeout(() => {\n          this.WeekFramedata = [{\n            id: 1,\n            name: this.language[this.lastSeventhDay]\n          }, {\n            id: 2,\n            name: this.language[this.lastSixthDay]\n          }, {\n            id: 3,\n            name: this.language[this.lastfifthDay]\n          }, {\n            id: 4,\n            name: this.language[this.lastFourthDay]\n          }, {\n            id: 5,\n            name: this.language[this.lastThirdDay]\n          }, {\n            id: 6,\n            name: this.language[this.yesterDay]\n          }, {\n            id: 7,\n            name: this.language[this.toDay]\n          }];\n        }, 2000);\n      }\n    }\n    // showValue() {\n    // }\n    getISOString(time) {\n      return time.toISOString().substr(0, 16) + ':00';\n    }\n    filterContent(chartType, legend) {\n      var _a;\n      this.legendType[legend] = !this.legendType[legend];\n      // if (chartType == 1) {\n      //   Highcharts.chart('qoeScoreChart', this.qoeChartOption(\n      //     this.legendType['qoeDash'] && this.legendType['qoeSolid']\n      //       ? this.summaryData\n      //       : !this.legendType['qoeDash'] && !this.legendType['qoeSolid']\n      //         ? ({ rawData: [] })\n      //         : ({\n      //           rawData: (this.summaryData?.rawData || [])\n      //             .filter(obj => (this.legendType['qoeDash'] ? (obj.qoeScore > 0) : (obj.qoeScore < 0)))\n      //         })));\n      if (chartType == 1) {\n        const grp = [this.legendType['qoeGood'] ? 5 : '', this.legendType['qoeGood'] ? 4 : '', this.legendType['qoeFair'] ? 3 : '', this.legendType['qoePoor'] ? 2 : '', this.legendType['qoePoor'] ? 1 : '', ...(this.legendType['qoeNoData'] ? [-1] : [''])];\n        const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n        if (this.TimeFrame == 1) {\n          Highcharts.chart('qoeScoreChart', this.qoeChartOption({\n            dailyData: (this.summaryData[mapKey] || []).filter(obj => obj.qoeScore && grp.includes(obj.qoeScore))\n          }));\n        } else {\n          Highcharts.chart('qoeScoreChart', this.qoeChartOption({\n            rawData: (this.summaryData[mapKey] || []).filter(obj => obj.qoeScore && grp.includes(obj.qoeScore))\n          }));\n        }\n      } else if (chartType == 2) {\n        const grp = [this.legendType['serviceGood'] ? 'GOOD' : '', this.legendType['serviceFair'] ? 'OK' : '', this.legendType['servicePoor'] ? 'BAD' : '', ...(this.legendType['serviceNoData'] ? ['GOOD(GREY)', 'BAD(GREY)', 'OK(GREY)'] : [''])];\n        const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n        if (this.TimeFrame == 1) {\n          Highcharts.chart('wanServiceChart', this.wanService({\n            dailyData: (this.summaryData[mapKey] || []).filter(obj => obj.wanService && grp.includes(obj.wanService.toUpperCase()))\n          }));\n        } else {\n          Highcharts.chart('wanServiceChart', this.wanService({\n            rawData: (this.summaryData[mapKey] || []).filter(obj => obj.wanService && grp.includes(obj.wanService.toUpperCase()))\n          }));\n        }\n      } else if (chartType == 3) {\n        const grp = [this.legendType['contGood'] ? 'GOOD' : '', this.legendType['contGood'] ? 'OK' : '', this.legendType['contPoor'] ? 'BAD' : '', ...(this.legendType['contNoData'] ? ['GOOD(GREY)', 'BAD(GREY)', 'OK(GREY)'] : [''])];\n        const mapKey = this.TimeFrame == 1 ? 'dailyData' : 'rawData';\n        if (this.TimeFrame == 1) {\n          Highcharts.chart('wanContinuityChart', this.wanContinuity({\n            dailyData: (this.summaryData[mapKey] || []).filter(obj => obj.wanContinuity && grp.includes(obj.wanContinuity.toUpperCase()))\n          }, this.WanShowup));\n        } else {\n          Highcharts.chart('wanContinuityChart', this.wanContinuity({\n            rawData: (this.summaryData[mapKey] || []).filter(obj => obj.wanContinuity && grp.includes(obj.wanContinuity.toUpperCase()))\n          }, this.WanShowup));\n        }\n      } else if (chartType == 4) {\n        Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(this.legendType['homeData'] && this.legendType['clientData'] ? this.summaryData : !this.legendType['homeData'] && !this.legendType['clientData'] ? {\n          rawData: []\n        } : {\n          rawData: (((_a = this.summaryData) === null || _a === void 0 ? void 0 : _a.rawData) || []).filter(obj => this.legendType['homeData'] ? obj.homeScore : false)\n        }));\n      }\n    }\n  }\n  QualityOfExperienceComponent.ɵfac = function QualityOfExperienceComponent_Factory(t) {\n    return new (t || QualityOfExperienceComponent)(i0.ɵɵdirectiveInject(i1.Router), i0.ɵɵdirectiveInject(i2.NgbModal), i0.ɵɵdirectiveInject(i3.TranslateService), i0.ɵɵdirectiveInject(i4.DataServiceService), i0.ɵɵdirectiveInject(i5.SsoAuthService), i0.ɵɵdirectiveInject(i6.DeviceService), i0.ɵɵdirectiveInject(i7.IssuesService), i0.ɵɵdirectiveInject(i8.Title), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  QualityOfExperienceComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: QualityOfExperienceComponent,\n    selectors: [[\"app-quality-of-experience\"]],\n    viewQuery: function QualityOfExperienceComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clientEfficencyChartTest = _t.first);\n      }\n    },\n    hostBindings: function QualityOfExperienceComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function QualityOfExperienceComponent_click_HostBindingHandler($event) {\n          return ctx.inClick($event);\n        });\n      }\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [1, \"row\"], [1, \"col-md-12\", \"ccl-tabs\"], [\"id\", \"tabs\", 1, \"nav\", \"nav-tabs\"], [\"id\", \"qe-issues-tab\", 1, \"nav-item\"], [\"data-toggle\", \"tab\", \"routerLinkActive\", \"active\", 1, \"nav-link\", \"small\", 3, \"routerLink\", \"Click\"], [1, \"big-text\"], [\"class\", \"nav-item\", \"id\", \"qe-topology-tab\", 4, \"ngIf\"], [\"class\", \"nav-item\", \"id\", \"qe-qoe-tab\", 4, \"ngIf\"], [\"id\", \"tabsContent\", 1, \"tab-content\"], [\"id\", \"issue\", 1, \"tab-pane\", \"fade\", \"active\", \"show\"], [1, \"row\", \"pb-2\"], [\"id\", \"topology\", 1, \"tab-pane\", \"fade\"], [\"class\", \"w-100 alert alert alert-danger fade show\", 4, \"ngIf\"], [1, \"d-flex\", \"align-items-center\", \"my-2\"], [1, \"col-md-12\", \"col-lg-3\", \"col-xl-3\"], [1, \"f-s-14px\", \"mb-0\"], [\"bindLabel\", \"name\", \"bindValue\", \"id\", 3, \"clearable\", \"searchable\", \"items\", \"ngModel\", \"change\", \"ngModelChange\"], [\"class\", \"col-md-12 col-lg-3 col-xl-3\", 4, \"ngIf\"], [\"class\", \"col-md-12 col-lg-2 col-xl-2 cus-select-height-24\", 4, \"ngIf\"], [\"class\", \"cursor-pointer primary mt-4\", 4, \"ngIf\"], [\"class\", \"row mb-3\", 4, \"ngIf\"], [\"class\", \"time-frame-section mb-3\", \"style\", \"min-height: 100px;\", \"id\", \"qoe-chart-timeframe-filter\", 4, \"ngIf\"], [1, \"row\", \"mb-3\", \"loader-wrapper\"], [\"class\", \"loader-wrapper-info\", 4, \"ngIf\"], [1, \"col-md-12\"], [\"id\", \"qoe-score-title\", 1, \"ccl-Secondary-title\", \"border-bottom\", \"mb-4\"], [1, \"\"], [\"id\", \"qoeScoreChart\", 1, \"chart-box\", 2, \"height\", \"300px\"], [1, \"row\", \"d-flex\", \"justify-content-center\"], [1, \"serviceLegend\", \"mr-1\", 2, \"background-color\", \"#82BF00\"], [1, \"cursor-pointer\", \"mr-3\", 3, \"ngClass\", \"click\"], [1, \"serviceLegend\", \"mr-1\", 2, \"background-color\", \"rgba(252, 114, 53)\"], [1, \"serviceLegend\", \"mr-1\", 2, \"background-color\", \"#C70000\"], [1, \"serviceLegend\", \"mr-1\", 2, \"background-color\", \"grey\"], [1, \"cursor-pointer\", 3, \"ngClass\", \"click\"], [\"id\", \"qoe-WAN-service\", 1, \"ccl-Secondary-title\", \"border-bottom\", \"mb-3\"], [\"id\", \"wanServiceChart\", 1, \"chart-box\", 2, \"height\", \"210px\"], [\"id\", \"qoe-wan-continuity\", 1, \"ccl-Secondary-title\", \"border-bottom\", \"mb-3\"], [\"id\", \"wanContinuityChart\", 1, \"chart-box\", 2, \"height\", \"210px\"], [\"id\", \"qoe-home-efficiency\", 1, \"ccl-Secondary-title\", \"border-bottom\", \"mb-4\"], [\"id\", \"wholeHomeEfficiencyChart\", 1, \"chart-box\", 2, \"height\", \"300px\"], [1, \"serviceLegend\", \"mr-1\", 2, \"background-color\", \"#0a77fb\"], [1, \"cursor-pointer\", \"mr-2\", 3, \"ngClass\", \"click\"], [\"clientEfficencyChartTest\", \"\"], [\"id\", \"qe-topology-tab\", 1, \"nav-item\"], [\"data-toggle\", \"tab\", \"routerLinkActive\", \"active\", 1, \"nav-link\", \"small\", 3, \"routerLink\"], [\"id\", \"qe-qoe-tab\", 1, \"nav-item\"], [1, \"w-100\", \"alert\", \"alert\", \"alert-danger\", \"fade\", \"show\"], [1, \"error-img\"], [\"src\", \"./assets/img/ic_error-36px.svg\"], [\"type\", \"button\", 1, \"close\", 3, \"click\"], [1, \"d-inline-flex\", 3, \"innerHtml\"], [1, \"col-md-12\", \"col-lg-2\", \"col-xl-2\", \"cus-select-height-24\"], [\"bindLabel\", \"name\", \"bindValue\", \"id\", 3, \"items\", \"clearable\", \"searchable\", \"ngModel\", \"change\", \"ngModelChange\"], [1, \"cursor-pointer\", \"primary\", \"mt-4\"], [1, \"fas\", \"fa-sync\", 3, \"click\"], [1, \"row\", \"mb-3\"], [1, \"col-md-3\"], [\"bindLabel\", \"name\", \"bindValue\", \"id\", 3, \"items\", \"ngModel\", \"ngModelChange\"], [\"class\", \"col-md-2\", 4, \"ngIf\"], [\"class\", \"col-md-2 form-check\", 4, \"ngIf\"], [1, \"col-md-3\", \"col-lg-3\", \"text-right\", \"btns-con\", \"smy-2\", 2, \"margin-top\", \"40px\"], [1, \"d-inline-flex\", \"mr-3\"], [\"type\", \"button\", 1, \"btn-default\", \"primary\", \"px-3\", 3, \"click\"], [1, \"col-md-2\"], [\"id\", \"week_Date\", \"appendTo\", \"body\", \"placeholder\", \"weekDate\", \"value\", \"#{dateBean.date}\", 1, \"ccl-form\", 3, \"inputStyle\", \"autoZIndex\", \"ngModel\", \"showIcon\", \"ngModelOptions\", \"maxDate\", \"minDate\", \"ngModelChange\", \"onSelect\"], [1, \"col-md-2\", \"form-check\"], [\"id\", \"start_date\", \"appendTo\", \"body\", \"placeholder\", \"Time\", \"hourFormat\", \"12\", 1, \"ccl-form\", 3, \"ngModel\", \"stepMinute\", \"inputStyle\", \"autoZIndex\", \"showIcon\", \"ngModelOptions\", \"timeOnly\", \"panelStyleClass\", \"minDate\", \"maxDate\", \"ngModelChange\", \"onSelect\"], [\"id\", \"end_date\", \"appendTo\", \"body\", \"placeholder\", \"Time\", \"hourFormat\", \"12\", 1, \"ccl-form\", 3, \"stepMinute\", \"inputStyle\", \"autoZIndex\", \"ngModel\", \"showIcon\", \"ngModelOptions\", \"timeOnly\", \"disabled\", \"panelStyleClass\", \"minDate\", \"maxDate\", \"ngModelChange\", \"onSelect\"], [\"id\", \"qoe-chart-timeframe-filter\", 1, \"time-frame-section\", \"mb-3\", 2, \"min-height\", \"100px\"], [\"data-toggle\", \"tooltip\", \"data-placement\", \"top\", 1, \"left-label\", 3, \"title\"], [\"class\", \"multi-point-slider\", 4, \"ngIf\"], [1, \"loader-wrapper-info\"], [1, \"loader\"], [1, \"d-flex\", \"justify-content-center\"], [1, \"spinner-border\", \"text-primary\"], [1, \"sr-only\"], [1, \"multi-point-slider\"], [3, \"value\", \"options\", \"valueChange\", \"userChangeEnd\"], [1, \"left-most-slider-time\"], [1, \"right-most-slider-time\"], [1, \"col-md-3\", \"col-lg-3\", \"text-left\", \"btns-con\", \"smy-2\", 2, \"margin-top\", \"15px\"], [\"class\", \"loader\", 4, \"ngIf\"], [1, \"modal-header\"], [\"id\", \"modal-basic-title\", 1, \"modal-title\"], [\"type\", \"button\", \"aria-label\", \"Close\", 1, \"close\", 3, \"click\"], [\"aria-hidden\", \"true\"], [1, \"modal-body\"], [\"id\", \"qoe-client-efficiency\", 1, \"ccl-Secondary-title\", \"border-bottom\", \"mb-4\"], [\"id\", \"date\"], [\"id\", \"clientEfficiencyChartDiv\", 1, \"chart-box\", 2, \"height\", \"300px\"]],\n    template: function QualityOfExperienceComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, QualityOfExperienceComponent_app_subscriber_menu_0_Template, 1, 0, \"app-subscriber-menu\", 0);\n        i0.ɵɵtemplate(1, QualityOfExperienceComponent_div_1_Template, 102, 72, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.showQOE);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showQOE);\n      }\n    },\n    directives: [i9.NgIf, i10.SubscriberMenuComponent, i1.RouterLinkWithHref, i1.RouterLinkActive, i11.NgSelectComponent, i12.NgControlStatus, i12.NgModel, i9.NgClass, i13.Calendar, i14.ɵa],\n    styles: [\".hideMin .p-minute-picker{color:gray;cursor:not-allowed!important;text-decoration:none}.hideMin .p-minute-picker button{cursor:not-allowed!important;color:gray}.string-slider .ngx-slider-pointer{position:relative}::ng-deep .string-slider{height:88px;margin-bottom:20px}::ng-deep .string-slider .ngx-slider-bubble{display:none!important}::ng-deep .string-slider .ngx-slider-bar{background:linear-gradient(90deg,#FF734F 40%,#F7C343 20%,#82BF00 40%)!important;border-radius:26px!important;height:21px!important}::ng-deep .string-slider .ngx-slider .ngx-slider-pointer{border-radius:100px;width:88px;height:88px;top:-30px;border:1px solid #82BF00;background-color:transparent!important}::ng-deep .string-slider .ngx-slider-pointer:before{content:\\\"\\\";position:absolute;top:2.3px;left:2.3px;width:81.77px;height:81.77px;background:#fff;border-radius:100px;z-index:-1;border:1px solid #82BF00}::ng-deep .string-slider .ngx-slider .ngx-slider-pointer:after{position:absolute;left:0;z-index:999;width:100%!important;height:100%!important;color:#000!important;background-color:transparent!important;text-align:center;line-height:56px;font-size:16px}::ng-deep .string-slider [aria-valuetext=\\\"1\\\"]:after,::ng-deep .string-slider [aria-valuetext=\\\"2\\\"]:after{content:\\\"Low\\\"!important}::ng-deep .string-slider [aria-valuetext=\\\"3\\\"]:after{content:\\\"Medium\\\"!important}::ng-deep .string-slider [aria-valuetext=\\\"4\\\"]:after,::ng-deep .string-slider [aria-valuetext=\\\"5\\\"]:after{content:\\\"High\\\"!important}::ng-deep .string-slider [aria-valuetext=\\\"0\\\"]:after{content:\\\"No Data\\\"!important}.modal.fade .modal-dialog .modal-content .modal-header{padding:10px!important;border-bottom:transparent}.loader-wrapper{position:relative}.time-frame-section{padding:2px 0 1px 140px;position:relative;overflow:hidden}.time-frame-section .left-label{position:absolute;left:0;top:25px;font-size:16px}.time-frame-section .left-label label{margin-bottom:-8px!important;display:block;overflow:hidden;text-overflow:ellipsis;width:136px;white-space:nowrap}.time-frame-section .left-label span{color:#9e9e9e;font-size:12px}.legendDash{width:20px;height:3px;border-top:2px dashed grey;margin-top:.8rem!important}.legendSolid{width:20px;height:3px;border-top:2px solid #0a77fb;margin-top:.8rem!important}.serviceLegend{width:13px;height:13px;margin-top:.4rem!important;border-radius:50%}.opac{opacity:.5}.no-realtime-data{position:absolute}#clientEfficiencyChartDiv .highcharts-root{min-height:310px}.f-s-10px{font-size:10px}\\n\"],\n    encapsulation: 2\n  });\n  return QualityOfExperienceComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}