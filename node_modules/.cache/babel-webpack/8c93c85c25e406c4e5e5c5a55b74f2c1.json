{"ast":null,"code":"import { assign, filter, groupBy, isObject } from 'min-dash';\nvar LOW_PRIORITY = 500,\n  MEDIUM_PRIORITY = 1250,\n  HIGH_PRIORITY = 1500;\nimport { getOriginal as getOriginalEvent } from '../../util/Event';\nimport { isPrimaryButton } from '../../util/Mouse';\nvar round = Math.round;\nfunction mid(element) {\n  return {\n    x: element.x + round(element.width / 2),\n    y: element.y + round(element.height / 2)\n  };\n}\n\n/**\n * A plugin that makes shapes draggable / droppable.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Modeling} modeling\n * @param {Selection} selection\n * @param {Rules} rules\n */\nexport default function MoveEvents(eventBus, dragging, modeling, selection, rules) {\n  // rules\n\n  function canMove(shapes, delta, position, target) {\n    return rules.allowed('elements.move', {\n      shapes: shapes,\n      delta: delta,\n      position: position,\n      target: target\n    });\n  }\n\n  // move events\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment.\n  //\n  // This sets up the context with\n  //\n  // * shape: the primary shape being moved\n  // * shapes: a list of shapes to be moved\n  // * validatedShapes: a list of shapes that are being checked\n  //                    against the rules before and during move\n  //\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      shape = event.shape,\n      shapes = selection.get().slice();\n\n    // move only single shape if the dragged element\n    // is not part of the current selection\n    if (shapes.indexOf(shape) === -1) {\n      shapes = [shape];\n    }\n\n    // ensure we remove nested elements in the collection\n    // and add attachers for a proper dragger\n    shapes = removeNested(shapes);\n\n    // attach shapes to drag context\n    assign(context, {\n      shapes: shapes,\n      validatedShapes: shapes,\n      shape: shape\n    });\n  });\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment\n  //\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {\n    var context = event.context,\n      validatedShapes = context.validatedShapes,\n      canExecute;\n    canExecute = context.canExecute = canMove(validatedShapes);\n\n    // check if we can move the elements\n    if (!canExecute) {\n      return false;\n    }\n  });\n\n  // assign a low priority to this handler\n  // to let others modify the move event before we update\n  // the context\n  //\n  eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {\n    var context = event.context,\n      validatedShapes = context.validatedShapes,\n      hover = event.hover,\n      delta = {\n        x: event.dx,\n        y: event.dy\n      },\n      position = {\n        x: event.x,\n        y: event.y\n      },\n      canExecute;\n\n    // check if we can move the elements\n    canExecute = canMove(validatedShapes, delta, position, hover);\n    context.delta = delta;\n    context.canExecute = canExecute;\n\n    // simply ignore move over\n    if (canExecute === null) {\n      context.target = null;\n      return;\n    }\n    context.target = hover;\n  });\n  eventBus.on('shape.move.end', function (event) {\n    var context = event.context;\n    var delta = context.delta,\n      canExecute = context.canExecute,\n      isAttach = canExecute === 'attach',\n      shapes = context.shapes;\n    if (canExecute === false) {\n      return false;\n    }\n\n    // ensure we have actual pixel values deltas\n    // (important when zoom level was > 1 during move)\n    delta.x = round(delta.x);\n    delta.y = round(delta.y);\n    if (delta.x === 0 && delta.y === 0) {\n      // didn't move\n      return;\n    }\n    modeling.moveElements(shapes, delta, context.target, {\n      primaryShape: context.shape,\n      attach: isAttach\n    });\n  });\n\n  // move activation\n\n  eventBus.on('element.mousedown', function (event) {\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n    var originalEvent = getOriginalEvent(event);\n    if (!originalEvent) {\n      throw new Error('must supply DOM mousedown event');\n    }\n    return start(originalEvent, event.element);\n  });\n\n  /**\n   * Start move.\n   *\n   * @param {MouseEvent} event\n   * @param {djs.model.Shape} shape\n   * @param {boolean} [activate]\n   * @param {Object} [context]\n   */\n  function start(event, element, activate, context) {\n    if (isObject(activate)) {\n      context = activate;\n      activate = false;\n    }\n\n    // do not move connections or the root element\n    if (element.waypoints || !element.parent) {\n      return;\n    }\n    var referencePoint = mid(element);\n    dragging.init(event, referencePoint, 'shape.move', {\n      cursor: 'grabbing',\n      autoActivate: activate,\n      data: {\n        shape: element,\n        context: context || {}\n      }\n    });\n\n    // we've handled the event\n    return true;\n  }\n\n  // API\n\n  this.start = start;\n}\nMoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];\n\n/**\n * Return a filtered list of elements that do not contain\n * those nested into others.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeNested(elements) {\n  var ids = groupBy(elements, 'id');\n  return filter(elements, function (element) {\n    while (element = element.parent) {\n      // parent in selection\n      if (ids[element.id]) {\n        return false;\n      }\n    }\n    return true;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}