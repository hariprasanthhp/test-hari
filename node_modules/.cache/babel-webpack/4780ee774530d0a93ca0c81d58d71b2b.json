{"ast":null,"code":"import { environment } from '../../../environments/environment';\nimport { EventSourcePolyfill } from 'event-source-polyfill';\nimport { BehaviorSubject } from 'rxjs';\nimport * as Highcharts from \"highcharts/highstock\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../shared/services/sso-auth.service\";\nimport * as i2 from \"@angular/common/http\";\nexport let SupportRealtimeService = /*#__PURE__*/(() => {\n  class SupportRealtimeService {\n    constructor(sso, http) {\n      this.sso = sso;\n      this.http = http;\n      this.data = {\n        graphType: 'TRF',\n        sendTime: new Date().getTime(),\n        usage: [0, 0],\n        maxRate: [0, 0],\n        packet: [0, 0]\n      };\n      this.rtData$ = new BehaviorSubject(this.data);\n      this.ratePacketStreamData$ = new BehaviorSubject(this.data);\n      this.delay$ = new BehaviorSubject(false);\n      this.chartData = [0, 0];\n      this.lastData = [0, 0];\n      this.yAxixTitle = 'bps';\n      this.chartDataPacket = [0, 0];\n      this.lastDataPacket = [0, 0];\n      this.yAxixTitlePacket = 'pps';\n      this.cacheRateRTDataObj = {};\n      this.cachePacketRTDataObj = {};\n      this.inc = 0;\n      /***begin-aswin-29-04-2021-poc-realtime-data-render */\n      this.previousUrlData = {};\n      this.restoreChartObj = {};\n    }\n    getData() {\n      let orgId = this.sso.getOrgId();\n      let moniterType = 'EP';\n      let moniterId = this.sso.getSubscriberEndpointId();\n      if (!moniterId) {\n        console.log(\"subscriber endpoint id not set\");\n        return;\n      }\n      if (this.source) {\n        this.source.close();\n        this.source = null;\n      }\n      let url = `${environment.SUPPORT_URL}/rt/sse/${orgId}/${moniterType}/${moniterId}/TAPP,TEP,TRF`;\n      this.source = new EventSourcePolyfill(url, {\n        headers: {\n          'X-Calix-ClientID': environment.X_CALIX_CLIENTID,\n          'X-Calix-AccessToken': this.sso.getAccessToken()\n        }\n      });\n      this.source.addEventListener('open', message => {\n        console.log(JSON.stringify(message));\n        console.log(message);\n        console.log(new Date());\n      });\n      this.source.addEventListener('state', message => {\n        console.log(JSON.stringify(message));\n        console.log('state', message);\n        console.log(new Date());\n        let data = JSON.parse(message.data);\n        if (data['status'].toLowerCase() === 's300') {\n          let data = {\n            graphType: 'TRF',\n            sendTime: new Date().getTime(),\n            usage: [0, 0],\n            maxRate: [0, 0],\n            packet: [0, 0]\n          };\n          this.rtData$.next(data);\n        }\n      });\n      this.source.addEventListener('message', message => {\n        let path = window.location.pathname;\n        if (path.indexOf('/traffic-reports/') === -1) {\n          console.log('force closed');\n          this.source.close();\n        }\n        let data = JSON.parse(message.data);\n        if (data.graphType === 'TRF') {\n          this.ratePacketStreamData$.next(data);\n          //console.log(JSON.parse(message.data));\n          this.data = JSON.parse(message.data);\n          clearInterval(this.cacheInterval);\n          clearInterval(this.cachePacketInterval);\n          this.cacheRTData('rate');\n          this.cacheRTData('packet');\n        } else {\n          this.rtData$.next(data);\n        }\n        console.log(JSON.parse(message.data));\n      });\n      this.source.addEventListener('error', message => {\n        //console.log(JSON.parse(message));\n        window.location.reload();\n        this.source.close();\n        this.source = null;\n      });\n    }\n    cacheRTData(type) {\n      if (type === 'rate') {\n        if (this.currentData) {\n          this.lastData = this.currentData;\n        } else {\n          this.chartData = [0, 0];\n        }\n        this.currentData = this.data.maxRate;\n        this.yAxixTitle = type === 'rate' ? 'bps' : 'pps';\n        let loadTime = new Date().getTime();\n        let inc = 0;\n        this.cacheInterval = setInterval(() => {\n          inc++;\n          var time = loadTime + inc * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cacheRateRTDataObj[key] = this.generateRTforCache(this.currentData, this.lastData, this.chartData, type);\n          this.removeOldKeys(this.cacheRateRTDataObj, type);\n          //window.localStorage.setItem('calix.rate_rt_data', JSON.stringify(this.cacheRateRTDataObj));\n        }, 1000);\n        //console.log(\"cache rate realtime data\", this.cacheRateRTDataObj);\n      } else {\n        if (this.currentDataPacket) {\n          this.lastDataPacket = this.currentDataPacket;\n        } else {\n          this.chartDataPacket = [0, 0];\n        }\n        this.currentDataPacket = this.data.packet;\n        this.yAxixTitlePacket = type === 'rate' ? 'bps' : 'pps';\n        let loadTime = new Date().getTime();\n        let inc = 0;\n        this.cachePacketInterval = setInterval(() => {\n          inc++;\n          var time = loadTime + inc * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cachePacketRTDataObj[key] = this.generateRTforCache(this.currentDataPacket, this.lastDataPacket, this.chartDataPacket, type);\n          this.removeOldKeys(this.cachePacketRTDataObj, type);\n          //window.localStorage.setItem('calix.packet_rt_data', JSON.stringify(this.cachePacketRTDataObj));\n        }, 1000);\n        //console.log(\"cache packet realtime data\", this.cachePacketRTDataObj);\n      }\n    }\n\n    generateRTforCache(currentData, lastData, chartData, chartName) {\n      let data = this.transformData(currentData, lastData, chartData, chartName);\n      if (chartName === 'rate') {\n        this.chartData = data;\n      } else {\n        this.chartDataPacket = data;\n      }\n      if (!data[0]) {\n        data[0] = 0;\n      }\n      if (!data[1]) {\n        data[1] = 0;\n      }\n      let upRate = this.bitsToSize(data[0], chartName);\n      let downRate = this.bitsToSize(data[1], chartName);\n      let vArr1 = upRate.split(\" \");\n      let vArr2 = downRate.split(\" \");\n      let upRateUnit = vArr1[1] ? vArr1[1] : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      let downRateUnit = vArr2[1] ? vArr2[1] : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      let maxUnit = '';\n      if (data[0] || data[1]) {\n        if (data[0] > data[1]) {\n          maxUnit = vArr1[1];\n        } else {\n          maxUnit = vArr2[1];\n        }\n      } else {\n        if (chartName.toLowerCase() === 'rate') {\n          maxUnit = this.yAxixTitle ? this.yAxixTitle : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        } else {\n          maxUnit = this.yAxixTitlePacket ? this.yAxixTitlePacket : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        }\n      }\n      if (maxUnit == 'undefined') {\n        //maxUnit = this.yAxixTitle ? this.yAxixTitle : (chartName.toLowerCase() === 'rate') ? 'bps' : 'pps';\n        if (chartName.toLowerCase() === 'rate') {\n          maxUnit = this.yAxixTitle ? this.yAxixTitle : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        } else {\n          maxUnit = this.yAxixTitlePacket ? this.yAxixTitlePacket : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        }\n      }\n      if (typeof maxUnit === 'string') {\n        //this.yAxixTitle = maxUnit;\n        if (chartName.toLowerCase() === 'rate') {\n          this.yAxixTitle = maxUnit;\n        } else {\n          this.yAxixTitlePacket = maxUnit;\n        }\n      }\n      if (data) {\n        if (chartName.toLowerCase() === 'rate') {\n          return [data[0], data[1], this.yAxixTitle, upRateUnit, downRateUnit];\n        } else {\n          return [data[0], data[1], this.yAxixTitlePacket, upRateUnit, downRateUnit];\n        }\n      }\n    }\n    transformData(currentData, lastData, data, chartName) {\n      if (chartName.toLowerCase() === 'rate') {\n        // console.log(\"current api value\", currentData);\n        // console.log(\"last api value\", lastData);\n        // console.log(\"last chart value\", data);\n      }\n      let chartData = [];\n      for (let i = 0; i < currentData.length; i++) {\n        let delta = parseFloat(currentData[i]) - parseFloat(lastData[i]);\n        //delta = Math.abs(delta);\n        if (!parseFloat(currentData[i]) && !parseFloat(lastData[i])) {\n          data[i] = 0;\n        }\n        let deltaRate = delta / 15;\n        let value = Math.abs(parseFloat(data[i]) + deltaRate);\n        chartData.push(value);\n      }\n      return chartData;\n    }\n    bitsToSize(bits, chartName) {\n      let bytes = parseFloat(bits);\n      let sizes = chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2) + ' ' + sizes[i];\n    }\n    removeLast3Chars(str) {\n      str = str.toString();\n      str = str.slice(0, -3);\n      str = parseInt(str);\n      return str;\n    }\n    removeOldKeys(lastChartDataObj, chartName) {\n      let keys = Object.keys(lastChartDataObj);\n      let len = keys.length;\n      if (len > 300) {\n        let obj = lastChartDataObj;\n        let removeLen = len - 300;\n        for (let i = 0; i < removeLen; i++) {\n          delete obj[keys[i]];\n        }\n        if (chartName === 'rate') {\n          this.cacheRateRTDataObj = obj;\n        } else {\n          this.cachePacketRTDataObj = obj;\n        }\n        //console.log(\"removal of old chart length\", Object.keys(lastChartDataObj).length);\n      }\n    }\n\n    getCachedata(chartName) {\n      if (chartName === 'rate') {\n        return this.cacheRateRTDataObj;\n      } else {\n        return this.cachePacketRTDataObj;\n      }\n    }\n    getCurrrentUnit(chartName) {\n      let length = Object.keys(this.cachePacketRTDataObj).length;\n      if (chartName.toLowerCase() === 'rate') {\n        return this.yAxixTitle ? this.yAxixTitle : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      } else {\n        return this.yAxixTitlePacket ? this.yAxixTitlePacket : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      }\n    }\n    clearData() {\n      this.yAxixTitle = '';\n      this.yAxixTitlePacket = '';\n      this.cachePacketRTDataObj = {};\n      this.cacheRateRTDataObj = {};\n      if (this.source) {\n        this.source.close();\n        this.source = null;\n      }\n      if (this.cacheInterval) {\n        clearInterval(this.cacheInterval);\n      }\n      if (this.cachePacketInterval) {\n        clearInterval(this.cachePacketInterval);\n      }\n    }\n    getLastData() {\n      return this.data;\n    }\n    closeEventSource() {\n      if (this.source) {\n        this.source.close();\n      }\n      this.source = null;\n      console.log(\"close event source\");\n    }\n    getRealtimeDelay() {\n      let orgId = this.sso.getOrgId();\n      let url = `${environment.API_BASE_URL}fa/config/organization?org-id=${orgId}`;\n      this.http.get(`${url}`).subscribe(res => {\n        if (res && res !== null) {\n          let timeDelay = -1 * (res.realtimeLateflowDelay ? res.realtimeLateflowDelay : 0) * 1000;\n          this.sso.setRealtimeDelay(timeDelay);\n        } else {\n          this.sso.setRealtimeDelay(0);\n        }\n        this.delay$.next(true);\n      }, error => {\n        this.sso.setRealtimeDelay(0);\n        this.delay$.next(true);\n      });\n    }\n    getPreviousUrlData(previousurl) {\n      return this.previousUrlData.hasOwnProperty(previousurl) ? this.previousUrlData[previousurl] : false;\n    }\n    setPreviousUrlData(previousurl, previousUrlData, reset) {\n      reset ? this.previousUrlData = {} : this.previousUrlData[previousurl] = previousUrlData;\n    }\n    getRestoreChartData(key) {\n      return this.restoreChartObj.hasOwnProperty(key) ? this.restoreChartObj[key] : false;\n    }\n    setRestoreChartData(key, restoreChartObj, reset) {\n      reset ? this.restoreChartObj = {} : this.restoreChartObj[key] = restoreChartObj;\n    }\n  }\n  SupportRealtimeService.ɵfac = function SupportRealtimeService_Factory(t) {\n    return new (t || SupportRealtimeService)(i0.ɵɵinject(i1.SsoAuthService), i0.ɵɵinject(i2.HttpClient));\n  };\n  SupportRealtimeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SupportRealtimeService,\n    factory: SupportRealtimeService.ɵfac,\n    providedIn: 'root'\n  });\n  return SupportRealtimeService;\n})();","map":null,"metadata":{},"sourceType":"module"}