{"ast":null,"code":"import { pointsAligned, pointsOnLine } from '../../util/Geometry';\nimport { addSegmentDragger, getConnectionIntersection } from './BendpointUtil';\nimport { getMid, getOrientation } from '../../layout/LayoutUtil';\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n  MARKER_CONNECT_UPDATING = 'djs-updating';\nimport { classes as svgClasses, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\nfunction axisSet(point, axis, value) {\n  return {\n    x: axis === 'x' ? value : point.x,\n    y: axis === 'y' ? value : point.y\n  };\n}\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n    minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n  var padding = 20;\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n  return axisSet(segmentStart, axis, fencedValue);\n}\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param  {Point} point\n * @param  {djs.model.Shape} referenceElement\n * @param  {string} moveAxis (x|y)\n *\n * @return {Point}\n */\nfunction getDocking(point, referenceElement, moveAxis) {\n  var referenceMid, inverseAxis;\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n\n/**\n * A component that implements moving of bendpoints\n */\nexport default function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n  // API\n\n  this.start = function (event, connection, idx) {\n    var context,\n      gfx = canvas.getGraphics(connection),\n      segmentStartIndex = idx - 1,\n      segmentEndIndex = idx,\n      waypoints = connection.waypoints,\n      segmentStart = waypoints[segmentStartIndex],\n      segmentEnd = waypoints[segmentEndIndex],\n      intersection = getConnectionIntersection(canvas, waypoints, event),\n      direction,\n      axis,\n      dragPosition;\n    direction = pointsAligned(segmentStart, segmentEnd);\n\n    // do not move diagonal connection\n    if (!direction) {\n      return;\n    }\n\n    // the axis where we are going to move things\n    axis = direction === 'v' ? 'x' : 'y';\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n    if (intersection) {\n      dragPosition = intersection.point;\n    } else {\n      // set to segment center as default\n      dragPosition = {\n        x: (segmentStart.x + segmentEnd.x) / 2,\n        y: (segmentStart.y + segmentEnd.y) / 2\n      };\n    }\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis,\n      dragPosition: dragPosition\n    };\n    dragging.init(event, dragPosition, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Array<Point>} newWaypoints\n   *\n   * @return {Array<Point>} cropped connection waypoints\n   */\n  function cropConnection(connection, newWaypoints) {\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n    var oldWaypoints = connection.waypoints,\n      croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n    return croppedWaypoints;\n  }\n\n  // DRAGGING IMPLEMENTATION\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n  function updateDragger(context, segmentOffset, event) {\n    var newWaypoints = context.newWaypoints,\n      segmentStartIndex = context.segmentStartIndex + segmentOffset,\n      segmentStart = newWaypoints[segmentStartIndex],\n      segmentEndIndex = context.segmentEndIndex + segmentOffset,\n      segmentEnd = newWaypoints[segmentEndIndex],\n      axis = flipAxis(context.axis);\n\n    // make sure the dragger does not move\n    // outside the connection\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\n\n    // update dragger\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Array<Point>} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n    var segmentOffset = 0;\n    var filteredWaypoints = waypoints.filter(function (r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      }\n\n      // dont remove point\n      return true;\n    });\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n  eventBus.on('connectionSegment.move.start', function (event) {\n    var context = event.context,\n      connection = event.connection,\n      layer = canvas.getLayer('overlays');\n    context.originalWaypoints = connection.waypoints.slice();\n\n    // add dragger gfx\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on('connectionSegment.move.move', function (event) {\n    var context = event.context,\n      connection = context.connection,\n      segmentStartIndex = context.segmentStartIndex,\n      segmentEndIndex = context.segmentEndIndex,\n      segmentStart = context.segmentStart,\n      segmentEnd = context.segmentEnd,\n      axis = context.axis;\n    var newWaypoints = context.originalWaypoints.slice(),\n      newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),\n      newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);\n\n    // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n    var waypointCount = newWaypoints.length,\n      segmentOffset = 0;\n\n    // move segment start / end by axis delta\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n    var sourceToSegmentOrientation, targetToSegmentOrientation;\n\n    // handle first segment\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);\n\n      // first bendpoint, remove first segment if intersecting\n      if (segmentStartIndex === 1) {\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      }\n\n      // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    }\n\n    // handle last segment\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);\n\n      // last bendpoint, remove last segment if intersecting\n      if (segmentEndIndex === waypointCount - 2) {\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      }\n\n      // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    }\n\n    // update connection waypoints\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\n\n    // update dragger position\n    updateDragger(context, segmentOffset, event);\n\n    // save segmentOffset in context\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\n\n    // redraw connection\n    redrawConnection(event);\n  });\n  eventBus.on('connectionSegment.move.hover', function (event) {\n    event.context.hover = event.hover;\n    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);\n  });\n  eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (event) {\n    // remove connect marker\n    // if it was added\n    var hover = event.context.hover;\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n  eventBus.on('connectionSegment.move.cleanup', function (event) {\n    var context = event.context,\n      connection = context.connection;\n\n    // remove dragger gfx\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (event) {\n    var context = event.context,\n      connection = context.connection;\n    connection.waypoints = context.originalWaypoints;\n    redrawConnection(event);\n  });\n  eventBus.on('connectionSegment.move.end', function (event) {\n    var context = event.context,\n      connection = context.connection,\n      newWaypoints = context.newWaypoints,\n      newSegmentStartIndex = context.newSegmentStartIndex;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    newWaypoints = newWaypoints.map(function (p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    });\n\n    // apply filter redunant waypoints\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\n\n    // get filtered waypoints\n    var filteredWaypoints = filtered.waypoints,\n      croppedWaypoints = cropConnection(connection, filteredWaypoints),\n      segmentOffset = filtered.segmentOffset;\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\nConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'modeling'];","map":null,"metadata":{},"sourceType":"module"}