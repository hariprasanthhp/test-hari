{"ast":null,"code":"import inherits from 'inherits';\nimport CommandInterceptor from '../../../command/CommandInterceptor';\nimport { assign, isString } from 'min-dash';\n\n/**\r\n * Integrates resizing with grid snapping.\r\n */\nexport default function ResizeBehavior(eventBus, gridSnapping) {\n  CommandInterceptor.call(this, eventBus);\n  this._gridSnapping = gridSnapping;\n  var self = this;\n  this.preExecute('shape.resize', function (event) {\n    var context = event.context,\n      hints = context.hints || {},\n      autoResize = hints.autoResize;\n    if (!autoResize) {\n      return;\n    }\n    var shape = context.shape,\n      newBounds = context.newBounds;\n    if (isString(autoResize)) {\n      context.newBounds = self.snapComplex(newBounds, autoResize);\n    } else {\n      context.newBounds = self.snapSimple(shape, newBounds);\n    }\n  });\n}\nResizeBehavior.$inject = ['eventBus', 'gridSnapping', 'modeling'];\ninherits(ResizeBehavior, CommandInterceptor);\n\n/**\r\n * Snap width and height in relation to center.\r\n *\r\n * @param {djs.model.shape} shape\r\n * @param {Bounds} newBounds\r\n *\r\n * @returns {Bounds} Snapped bounds.\r\n */\nResizeBehavior.prototype.snapSimple = function (shape, newBounds) {\n  var gridSnapping = this._gridSnapping;\n  newBounds.width = gridSnapping.snapValue(newBounds.width, {\n    min: newBounds.width\n  });\n  newBounds.height = gridSnapping.snapValue(newBounds.height, {\n    min: newBounds.height\n  });\n  newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;\n  newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;\n  return newBounds;\n};\n\n/**\r\n * Snap x, y, width and height according to given directions.\r\n *\r\n * @param {Bounds} newBounds\r\n * @param {string} directions - Directions as {n|w|s|e}.\r\n *\r\n * @returns {Bounds} Snapped bounds.\r\n */\nResizeBehavior.prototype.snapComplex = function (newBounds, directions) {\n  if (/w|e/.test(directions)) {\n    newBounds = this.snapHorizontally(newBounds, directions);\n  }\n  if (/n|s/.test(directions)) {\n    newBounds = this.snapVertically(newBounds, directions);\n  }\n  return newBounds;\n};\n\n/**\r\n * Snap in one or both directions horizontally.\r\n *\r\n * @param {Bounds} newBounds\r\n * @param {string} directions - Directions as {n|w|s|e}.\r\n *\r\n * @returns {Bounds} Snapped bounds.\r\n */\nResizeBehavior.prototype.snapHorizontally = function (newBounds, directions) {\n  var gridSnapping = this._gridSnapping,\n    west = /w/.test(directions),\n    east = /e/.test(directions);\n  var snappedNewBounds = {};\n  snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {\n    min: newBounds.width\n  });\n  if (east) {\n    // handle <we>\n    if (west) {\n      snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {\n        max: newBounds.x\n      });\n      snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {\n        min: newBounds.x - snappedNewBounds.x\n      });\n    }\n\n    // handle <e>\n    else {\n      newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;\n    }\n  }\n\n  // assign snapped x and width\n  assign(newBounds, snappedNewBounds);\n  return newBounds;\n};\n\n/**\r\n * Snap in one or both directions vertically.\r\n *\r\n * @param {Bounds} newBounds\r\n * @param {string} directions - Directions as {n|w|s|e}.\r\n *\r\n * @returns {Bounds} Snapped bounds.\r\n */\nResizeBehavior.prototype.snapVertically = function (newBounds, directions) {\n  var gridSnapping = this._gridSnapping,\n    north = /n/.test(directions),\n    south = /s/.test(directions);\n  var snappedNewBounds = {};\n  snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {\n    min: newBounds.height\n  });\n  if (north) {\n    // handle <ns>\n    if (south) {\n      snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {\n        max: newBounds.y\n      });\n      snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {\n        min: newBounds.y - snappedNewBounds.y\n      });\n    }\n\n    // handle <n>\n    else {\n      newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;\n    }\n  }\n\n  // assign snapped y and height\n  assign(newBounds, snappedNewBounds);\n  return newBounds;\n};","map":null,"metadata":{},"sourceType":"module"}