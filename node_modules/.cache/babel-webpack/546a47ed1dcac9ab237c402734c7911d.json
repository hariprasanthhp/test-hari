{"ast":null,"code":"const CONSTRAINTS = [[0, 59], [0, 59], [0, 23], [1, 31], [0, 11], [0, 6]];\nconst MONTH_CONSTRAINTS = [31, 29,\n// support leap year...not perfect\n31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst PARSE_DEFAULTS = ['0', '*', '*', '*', '*', '*'];\nconst ALIASES = {\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  may: 4,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11,\n  sun: 0,\n  mon: 1,\n  tue: 2,\n  wed: 3,\n  thu: 4,\n  fri: 5,\n  sat: 6\n};\nconst TIME_UNITS = ['second', 'minute', 'hour', 'dayOfMonth', 'month', 'dayOfWeek'];\nconst TIME_UNITS_LEN = TIME_UNITS.length;\nconst PRESETS = {\n  '@yearly': '0 0 0 1 0 *',\n  '@monthly': '0 0 0 1 * *',\n  '@weekly': '0 0 0 * * 0',\n  '@daily': '0 0 0 * * *',\n  '@hourly': '0 0 * * * *',\n  '@minutely': '0 * * * * *',\n  '@secondly': '* * * * * *',\n  '@weekdays': '0 0 0 * * 1-5',\n  '@weekends': '0 0 0 * * 0,6'\n};\nconst RE_WILDCARDS = /\\*/g;\nconst RE_RANGE = /^(\\d+)(?:-(\\d+))?(?:\\/(\\d+))?$/g;\nfunction CronTime(luxon) {\n  function CT(source, zone, utcOffset) {\n    this.source = source;\n    if (zone) {\n      const dt = luxon.DateTime.fromObject({}, {\n        zone\n      });\n      if (dt.invalid) {\n        throw new Error('Invalid timezone.');\n      }\n      this.zone = zone;\n    }\n    if (typeof utcOffset !== 'undefined') {\n      this.utcOffset = utcOffset;\n    }\n    const that = this;\n    TIME_UNITS.forEach(timeUnit => {\n      that[timeUnit] = {};\n    });\n    if (this.source instanceof Date || this.source instanceof luxon.DateTime) {\n      if (this.source instanceof Date) {\n        this.source = luxon.DateTime.fromJSDate(this.source);\n      }\n      this.realDate = true;\n    } else {\n      this._parse(this.source);\n      this._verifyParse();\n    }\n  }\n  CT.prototype = {\n    /*\n     * Ensure that the syntax parsed correctly and correct the specified values if needed.\n     */\n    _verifyParse: function () {\n      const months = Object.keys(this.month);\n      const dom = Object.keys(this.dayOfMonth);\n      let ok = false;\n\n      /* if a dayOfMonth is not found in all months, we only need to fix the last\n                    wrong month  to prevent infinite loop */\n      let lastWrongMonth = NaN;\n      for (let i = 0; i < months.length; i++) {\n        const m = months[i];\n        const con = MONTH_CONSTRAINTS[parseInt(m, 10)];\n        for (let j = 0; j < dom.length; j++) {\n          const day = dom[j];\n          if (day <= con) {\n            ok = true;\n          }\n        }\n        if (!ok) {\n          // save the month in order to be fixed if all months fails (infinite loop)\n          lastWrongMonth = m;\n          console.warn(`Month '${m}' is limited to '${con}' days.`);\n        }\n      }\n\n      // infinite loop detected (dayOfMonth is not found in all months)\n      if (!ok) {\n        const notOkCon = MONTH_CONSTRAINTS[parseInt(lastWrongMonth, 10)];\n        for (let k = 0; k < dom.length; k++) {\n          const notOkDay = dom[k];\n          if (notOkDay > notOkCon) {\n            delete this.dayOfMonth[notOkDay];\n            const fixedDay = Number(notOkDay) % notOkCon;\n            this.dayOfMonth[fixedDay] = true;\n          }\n        }\n      }\n    },\n    /**\n     * Calculate the \"next\" scheduled time\n     */\n    sendAt: function (i) {\n      let date = this.realDate ? this.source : luxon.DateTime.local();\n      if (this.zone) {\n        date = date.setZone(this.zone);\n      }\n      if (typeof this.utcOffset !== 'undefined') {\n        let offset = this.utcOffset >= 60 || this.utcOffset <= -60 ? this.utcOffset / 60 : this.utcOffset;\n        offset = parseInt(offset);\n        let utcZone = 'UTC';\n        if (offset < 0) {\n          utcZone += offset;\n        } else if (offset > 0) {\n          utcZone += `+${offset}`;\n        }\n        date = date.setZone(utcZone);\n        if (date.invalid) {\n          throw new Error('ERROR: You specified an invalid UTC offset.');\n        }\n      }\n      if (this.realDate) {\n        if (luxon.DateTime.local() > date) {\n          throw new Error('WARNING: Date in past. Will never be fired.');\n        }\n        return date;\n      }\n      if (isNaN(i) || i < 0) {\n        // just get the next scheduled time\n        return this._getNextDateFrom(date);\n      } else {\n        // return the next schedule times\n        const dates = [];\n        for (; i > 0; i--) {\n          date = this._getNextDateFrom(date);\n          dates.push(date);\n        }\n        return dates;\n      }\n    },\n    /**\n     * Get the number of milliseconds in the future at which to fire our callbacks.\n     */\n    getTimeout: function () {\n      return Math.max(-1, this.sendAt() - luxon.DateTime.local());\n    },\n    /**\n     * writes out a cron string\n     */\n    toString: function () {\n      return this.toJSON().join(' ');\n    },\n    /**\n     * Json representation of the parsed cron syntax.\n     */\n    toJSON: function () {\n      const self = this;\n      return TIME_UNITS.map(function (timeName) {\n        return self._wcOrAll(timeName);\n      });\n    },\n    getNextDateFrom: function (start, zone) {\n      return this._getNextDateFrom(start, zone);\n    },\n    /**\n     * Get next date matching the specified cron time.\n     *\n     * Algorithm:\n     * - Start with a start date and a parsed crontime.\n     * - Loop until 5 seconds have passed, or we found the next date.\n     * - Within the loop:\n     *   - If it took longer than 5 seconds to select a date, throw an exception.\n     *   - Find the next month to run at.\n     *   - Find the next day of the month to run at.\n     *   - Find the next day of the week to run at.\n     *   - Find the next hour to run at.\n     *   - Find the next minute to run at.\n     *   - Find the next second to run at.\n     *   - Check that the chosen time does not equal the current execution.\n     * - Return the selected date object.\n     */\n    _getNextDateFrom: function (start, zone) {\n      if (start instanceof Date) {\n        start = luxon.DateTime.fromJSDate(start);\n      }\n      let date = start;\n      const firstDate = start.toMillis();\n      if (zone) {\n        date = date.setZone(zone);\n      }\n      if (!this.realDate) {\n        if (date.millisecond > 0) {\n          date = date.set({\n            millisecond: 0,\n            second: date.second + 1\n          });\n        }\n      }\n      if (date.invalid) {\n        throw new Error('ERROR: You specified an invalid date.');\n      }\n\n      /**\n       * maximum match interval is 8 years:\n       * crontab has '* * 29 2 *' and we are on 1 March 2096:\n       * next matching time will be 29 February 2104\n       * source: https://github.com/cronie-crond/cronie/blob/0d669551680f733a4bdd6bab082a0b3d6d7f089c/src/cronnext.c#L401-L403\n       */\n      const maxMatch = luxon.DateTime.now().plus({\n        years: 8\n      });\n\n      // determine next date\n      while (true) {\n        const diff = date - start;\n\n        // hard stop if the current date is after the maximum match interval\n        if (date > maxMatch) {\n          throw new Error(`Something went wrong. No execution date was found in the next 8 years.\n\t\t\t\t\t\t\tPlease provide the following string if you would like to help debug:\n\t\t\t\t\t\t\tTime Zone: ${zone || '\"\"'} - Cron String: ${this} - UTC offset: ${date.offset}\n\t\t\t\t\t\t\t- current Date: ${luxon.DateTime.local().toString()}`);\n        }\n        if (!(date.month - 1 in this.month) && Object.keys(this.month).length !== 12) {\n          date = date.plus({\n            months: 1\n          });\n          date = date.set({\n            day: 1,\n            hour: 0,\n            minute: 0,\n            second: 0\n          });\n          if (this._forwardDSTJump(0, 0, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          continue;\n        }\n        if (!(date.day in this.dayOfMonth) && Object.keys(this.dayOfMonth).length !== 31 && !(date.getWeekDay() in this.dayOfWeek && Object.keys(this.dayOfWeek).length !== 7)) {\n          date = date.plus({\n            days: 1\n          });\n          date = date.set({\n            hour: 0,\n            minute: 0,\n            second: 0\n          });\n          if (this._forwardDSTJump(0, 0, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          continue;\n        }\n        if (!(date.getWeekDay() in this.dayOfWeek) && Object.keys(this.dayOfWeek).length !== 7 && !(date.day in this.dayOfMonth && Object.keys(this.dayOfMonth).length !== 31)) {\n          date = date.plus({\n            days: 1\n          });\n          date = date.set({\n            hour: 0,\n            minute: 0,\n            second: 0\n          });\n          if (this._forwardDSTJump(0, 0, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          continue;\n        }\n        if (!(date.hour in this.hour) && Object.keys(this.hour).length !== 24) {\n          const expectedHour = date.hour === 23 && diff > 86400000 ? 0 : date.hour + 1;\n          const expectedMinute = date.minute; // expect no change.\n\n          date = date.set({\n            hour: expectedHour\n          });\n          date = date.set({\n            minute: 0,\n            second: 0\n          });\n\n          // When this is the case, Asking luxon to go forward by 1 hour actually made us go forward by more hours...\n          // This indicates that somewhere between these two time points, a forward DST adjustment has happened.\n          // When this happens, the job should be scheduled to execute as though the time has come when the jump is made.\n          // Therefore, the job should be scheduled on the first tick after the forward jump.\n          if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          // backwards jumps do not seem to have any problems (i.e. double activations),\n          // so they need not be handled in a similar way.\n\n          continue;\n        }\n        if (!(date.minute in this.minute) && Object.keys(this.minute).length !== 60) {\n          const expectedMinute = date.minute === 59 && diff > 3600000 ? 0 : date.minute + 1;\n          const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n          date = date.set({\n            minute: expectedMinute\n          });\n          date = date.set({\n            second: 0\n          });\n\n          // Same case as with hours: DST forward jump.\n          // This must be accounted for if a minute increment pushed us to a jumping point.\n          if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          continue;\n        }\n        if (!(date.second in this.second) && Object.keys(this.second).length !== 60) {\n          const expectedSecond = date.second === 59 && diff > 60000 ? 0 : date.second + 1;\n          const expectedMinute = date.minute + (expectedSecond === 60);\n          const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n          date = date.set({\n            second: expectedSecond\n          });\n\n          // Seconds can cause it too, imagine 21:59:59 -> 23:00:00.\n          if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          continue;\n        }\n        if (date.toMillis() === firstDate) {\n          const expectedSecond = date.second + 1;\n          const expectedMinute = date.minute + (expectedSecond === 60);\n          const expectedHour = date.hour + (expectedMinute === 60 ? 1 : 0);\n          date = date.set({\n            second: expectedSecond\n          });\n\n          // Same as always.\n          if (this._forwardDSTJump(expectedHour, expectedMinute, date)) {\n            const [done, newDate] = this._findPreviousDSTJump(date);\n            date = newDate;\n            if (done) break;\n          }\n          continue;\n        }\n        break;\n      }\n      return date;\n    },\n    /**\n     * Search backwards in time 1 minute at a time, to detect a DST forward jump.\n     * When the jump is found, the range of the jump is investigated to check for acceptable cron times.\n     *\n     * A pair is returned, whose first is a boolean representing if an acceptable time was found inside the jump,\n     * and whose second is a DateTime representing the first millisecond after the jump.\n     *\n     * The input date is expected to be decently close to a DST jump.\n     * Up to a day in the past is checked before an error is thrown.\n     * @param date\n     * @return [boolean, DateTime]\n     */\n    _findPreviousDSTJump: function (date) {\n      /** @type number */\n      let expectedMinute, expectedHour, actualMinute, actualHour;\n      /** @type DateTime */\n      let maybeJumpingPoint = date;\n\n      // representing one day of backwards checking. If this is hit, the input must be wrong.\n      const iterationLimit = 60 * 24;\n      let iteration = 0;\n      do {\n        if (++iteration > iterationLimit) {\n          throw new Error(`ERROR: This DST checking related function assumes the input DateTime (${date.toISO()}) is within 24 hours of a DST jump.`);\n        }\n        expectedMinute = maybeJumpingPoint.minute - 1;\n        expectedHour = maybeJumpingPoint.hour;\n        if (expectedMinute < 0) {\n          expectedMinute += 60;\n          expectedHour = (expectedHour + 24 - 1) % 24; // Subtract 1 hour, but we must account for the -1 case.\n        }\n\n        maybeJumpingPoint = maybeJumpingPoint.minus({\n          minute: 1\n        });\n        actualMinute = maybeJumpingPoint.minute;\n        actualHour = maybeJumpingPoint.hour;\n      } while (expectedMinute === actualMinute && expectedHour === actualHour);\n\n      // Setting the seconds and milliseconds to zero is necessary for two reasons:\n      // Firstly, the range checking function needs the earliest moment after the jump.\n      // Secondly, this DateTime may be used for scheduling jobs, if there existed a job in the skipped range.\n      const afterJumpingPoint = maybeJumpingPoint.plus({\n        minute: 1\n      }) // back to the first minute _after_ the jump\n      .set({\n        seconds: 0,\n        millisecond: 0\n      });\n\n      // Get the lower bound of the range to check as well. This only has to be accurate down to minutes.\n      const beforeJumpingPoint = afterJumpingPoint.minus({\n        second: 1\n      });\n      if (date.month in this.month && date.day in this.dayOfMonth && date.getWeekDay() in this.dayOfWeek) {\n        return [this._checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint), afterJumpingPoint];\n      }\n\n      // no valid time in the range for sure, units that didn't change from the skip mismatch.\n      return [false, afterJumpingPoint];\n    },\n    /**\n     * Given 2 DateTimes, which represent 1 second before and immediately after a DST forward jump,\n     * checks if a time in the skipped range would have been a valid CronJob time.\n     *\n     * Could technically work with just one of these values, extracting the other by adding or subtracting seconds.\n     * However, this couples the input DateTime to actually being tied to a DST jump,\n     * which would make the function harder to test.\n     * This way the logic just tests a range of minutes and hours, regardless if there are skipped time points underneath.\n     *\n     * Assumes the DST jump started no earlier than 0:00 and jumped forward by at least 1 minute, to at most 23:59.\n     * i.e. The day is assumed constant, but the jump is not assumed to be an hour long.\n     * Empirically, it is almost always one hour, but very, very rarely 30 minutes.\n     *\n     * Assumes dayOfWeek, dayOfMonth and month match all match, so only the hours, minutes and seconds are to be checked.\n     * @param {DateTime} beforeJumpingPoint\n     * @param {DateTime} afterJumpingPoint\n     * @returns {boolean}\n     */\n    _checkTimeInSkippedRange: function (beforeJumpingPoint, afterJumpingPoint) {\n      // start by getting the first minute & hour inside the skipped range.\n      const startingMinute = (beforeJumpingPoint.minute + 1) % 60;\n      const startingHour = (beforeJumpingPoint.hour + (startingMinute === 0)) % 24;\n      const hourRangeSize = afterJumpingPoint.hour - startingHour + 1;\n      const isHourJump = startingMinute === 0 && afterJumpingPoint.minute === 0;\n\n      // There exist DST jumps other than 1 hour long, and the function is built to deal with it.\n      // It may be overkill to assume some cases, but it shouldn't cost much at runtime.\n      // https://en.wikipedia.org/wiki/Daylight_saving_time_by_country\n      if (hourRangeSize === 2 && isHourJump) {\n        // Exact 1 hour jump, most common real-world case.\n        // There is no need to check minutes and seconds, as any value would suffice.\n        return startingHour in this.hour;\n      } else if (hourRangeSize === 1) {\n        // less than 1 hour jump, rare but does exist.\n        return startingHour in this.hour && this._checkTimeInSkippedRangeSingleHour(startingMinute, afterJumpingPoint.minute);\n      } else {\n        // non-round or multi-hour jump. (does not exist in the real world at the time of writing)\n        return this._checkTimeInSkippedRangeMultiHour(startingHour, startingMinute, afterJumpingPoint.hour, afterJumpingPoint.minute);\n      }\n    },\n    /**\n     * Component of checking if a CronJob time existed in a DateTime range skipped by DST.\n     * This subroutine makes a further assumption that the skipped range is fully contained in one hour,\n     * and that all other larger units are valid for the job.\n     *\n     * for example a jump from 02:00:00 to 02:30:00, but not from 02:00:00 to 03:00:00.\n     * @see _checkTimeInSkippedRange\n     *\n     * This is done by checking if any minute in startMinute - endMinute is valid, excluding endMinute.\n     * For endMinute, there is only a match if the 0th second is a valid time.\n     */\n    _checkTimeInSkippedRangeSingleHour: function (startMinute, endMinute) {\n      for (let minute = startMinute; minute < endMinute; ++minute) {\n        if (minute in this.minute) return true;\n      }\n\n      // Unless the very last second of the jump matched, there is no match.\n      return endMinute in this.minute && 0 in this.second;\n    },\n    /**\n     * Component of checking if a CronJob time existed in a DateTime range skipped by DST.\n     * This subroutine assumes the jump touches at least 2 hours, but the jump does not necessarily fully contain these hours.\n     *\n     * @see _checkTimeInSkippedRange\n     *\n     * This is done by defining the minutes to check for the first and last hour,\n     * and checking all 60 minutes for any hours in between them.\n     *\n     * If any hour x minute combination is a valid time, true is returned.\n     * The endMinute x endHour combination is only checked with the 0th second, since the rest would be out of the range.\n     *\n     * @param startHour {number}\n     * @param startMinute {number}\n     * @param endHour {number}\n     * @param endMinute {number}\n     */\n    _checkTimeInSkippedRangeMultiHour: function (startHour, startMinute, endHour, endMinute) {\n      if (startHour >= endHour) {\n        throw new Error(`ERROR: This DST checking related function assumes the forward jump starting hour (${startHour}) is less than the end hour (${endHour})`);\n      }\n\n      /** @type number[] */\n      const firstHourMinuteRange = Array.from({\n        length: 60 - startMinute\n      }, (_, k) => startMinute + k);\n      /** @type {number[]} The final minute is not contained on purpose. Every minute in this range represents one for which any second is valid. */\n      const lastHourMinuteRange = Array.from({\n        length: endMinute\n      }, (_, k) => k);\n      /** @type number[] */\n      const middleHourMinuteRange = Array.from({\n        length: 60\n      }, (_, k) => k);\n\n      /** @type (number) => number[] */\n      const selectRange = forHour => {\n        if (forHour === startHour) {\n          return firstHourMinuteRange;\n        } else if (forHour === endHour) {\n          return lastHourMinuteRange;\n        } else {\n          return middleHourMinuteRange;\n        }\n      };\n\n      // Include the endHour: Selecting the right range still ensures no values outside the skip are checked.\n      for (let hour = startHour; hour <= endHour; ++hour) {\n        if (!(hour in this.hour)) continue;\n\n        // The hour matches, so if the minute is in the range, we have a match!\n        const usingRange = selectRange(hour);\n        for (const minute of usingRange) {\n          // All minutes in any of the selected ranges represent minutes which are fully contained in the jump,\n          // So we need not check the seconds. If the minute is in there, it is a match.\n          if (minute in this.minute) return true;\n        }\n      }\n\n      // The endMinute of the endHour was not checked in the loop, because only the 0th second of it is in the range.\n      // Arriving here means no match was found yet, but this final check may turn up as a match.\n      return endHour in this.hour && endMinute in this.minute && 0 in this.second;\n    },\n    /**\n     * Given expected and actual hours and minutes, report if a DST forward jump occurred.\n     *\n     * This is the case when the expected is smaller than the acutal.\n     *\n     * It is not sufficient to check only hours, because some parts of the world apply DST by shifting in minutes.\n     * Better to account for it by checking minutes too, before an Australian of Lord Howe Island call us.\n     * @param expectedHour\n     * @param expectedMinute\n     * @param {DateTime} actualDate\n     */\n    _forwardDSTJump: function (expectedHour, expectedMinute, actualDate) {\n      const actualHour = actualDate.hour;\n      const actualMinute = actualDate.minute;\n      const hoursJumped = expectedHour % 24 < actualHour;\n      const minutesJumped = expectedMinute % 60 < actualMinute;\n      return hoursJumped || minutesJumped;\n    },\n    /**\n     * wildcard, or all params in array (for to string)\n     */\n    _wcOrAll: function (type) {\n      if (this._hasAll(type)) {\n        return '*';\n      }\n      const all = [];\n      for (const time in this[type]) {\n        all.push(time);\n      }\n      return all.join(',');\n    },\n    _hasAll: function (type) {\n      const constraints = CONSTRAINTS[TIME_UNITS.indexOf(type)];\n      for (let i = constraints[0], n = constraints[1]; i < n; i++) {\n        if (!(i in this[type])) {\n          return false;\n        }\n      }\n      return true;\n    },\n    /*\n     * Parse the cron syntax into something useful for selecting the next execution time.\n     *\n     * Algorithm:\n     * - Replace preset\n     * - Replace aliases in the source.\n     * - Trim string and split for processing.\n     * - Loop over split options (ms -> month):\n     *   - Get the value (or default) in the current position.\n     *   - Parse the value.\n     */\n    _parse: function (source) {\n      source = source.toLowerCase();\n      if (source in PRESETS) {\n        source = PRESETS[source];\n      }\n      source = source.replace(/[a-z]{1,3}/gi, alias => {\n        if (alias in ALIASES) {\n          return ALIASES[alias];\n        }\n        throw new Error(`Unknown alias: ${alias}`);\n      });\n      const units = source.trim().split(/\\s+/);\n\n      // seconds are optional\n      if (units.length < TIME_UNITS_LEN - 1) {\n        throw new Error('Too few fields');\n      }\n      if (units.length > TIME_UNITS_LEN) {\n        throw new Error('Too many fields');\n      }\n      const unitsLen = units.length;\n      for (let i = 0; i < TIME_UNITS_LEN; i++) {\n        // If the split source string doesn't contain all digits,\n        // assume defaults for first n missing digits.\n        // This adds support for 5-digit standard cron syntax\n        const cur = units[i - (TIME_UNITS_LEN - unitsLen)] || PARSE_DEFAULTS[i];\n        this._parseField(cur, TIME_UNITS[i], CONSTRAINTS[i]);\n      }\n    },\n    /*\n     * Parse individual field from the cron syntax provided.\n     *\n     * Algorithm:\n     * - Split field by commas aand check for wildcards to ensure proper user.\n     * - Replace wildcard values with <low>-<high> boundaries.\n     * - Split field by commas and then iterate over ranges inside field.\n     *   - If range matches pattern then map over matches using replace (to parse the range by the regex pattern)\n     *   - Starting with the lower bounds of the range iterate by step up to the upper bounds and toggle the CronTime field value flag on.\n     */\n    _parseField: function (value, type, constraints) {\n      const typeObj = this[type];\n      let pointer;\n      const low = constraints[0];\n      const high = constraints[1];\n      const fields = value.split(',');\n      fields.forEach(field => {\n        const wildcardIndex = field.indexOf('*');\n        if (wildcardIndex !== -1 && wildcardIndex !== 0) {\n          throw new Error(`Field (${field}) has an invalid wildcard expression`);\n        }\n      });\n\n      // * is a shortcut to [low-high] range for the field\n      value = value.replace(RE_WILDCARDS, `${low}-${high}`);\n\n      // commas separate information, so split based on those\n      const allRanges = value.split(',');\n      for (let i = 0; i < allRanges.length; i++) {\n        if (allRanges[i].match(RE_RANGE)) {\n          allRanges[i].replace(RE_RANGE, ($0, lower, upper, step) => {\n            lower = parseInt(lower, 10);\n            upper = upper !== undefined ? parseInt(upper, 10) : undefined;\n            const wasStepDefined = !isNaN(parseInt(step, 10));\n            if (step === '0') {\n              throw new Error(`Field (${type}) has a step of zero`);\n            }\n            step = parseInt(step, 10) || 1;\n            if (upper !== undefined && lower > upper) {\n              throw new Error(`Field (${type}) has an invalid range`);\n            }\n            const outOfRangeError = lower < low || upper !== undefined && upper > high || upper === undefined && lower > high;\n            if (outOfRangeError) {\n              throw new Error(`Field value (${value}) is out of range`);\n            }\n\n            // Positive integer higher than constraints[0]\n            lower = Math.min(Math.max(low, ~~Math.abs(lower)), high);\n\n            // Positive integer lower than constraints[1]\n            if (upper !== undefined) {\n              upper = Math.min(high, ~~Math.abs(upper));\n            } else {\n              // If step is provided, the default upper range is the highest value\n              upper = wasStepDefined ? high : lower;\n            }\n\n            // Count from the lower barrier to the upper\n            pointer = lower;\n            do {\n              typeObj[pointer] = true; // mutates the field objects values inside CronTime\n              pointer += step;\n            } while (pointer <= upper);\n          });\n        } else {\n          throw new Error(`Field (${type}) cannot be parsed`);\n        }\n      }\n    }\n  };\n  return CT;\n}\nmodule.exports = CronTime;","map":null,"metadata":{},"sourceType":"script"}