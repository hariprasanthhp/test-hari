{"ast":null,"code":"import { forEach, assign, find, filter, has, isString, map } from 'min-dash';\nimport { Parser } from 'saxen';\nimport { coerceType, parseNameNS, isSimpleType, Moddle } from 'moddle';\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\nvar XSI_TYPE = 'xsi:type';\nfunction serializeFormat(element) {\n  return element.xml && element.xml.serialize;\n}\nfunction serializeAsType(element) {\n  return serializeFormat(element) === XSI_TYPE;\n}\nfunction serializeAsProperty(element) {\n  return serializeFormat(element) === 'property';\n}\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction aliasToName(aliasNs, pkg) {\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\nfunction prefixedToName(nameNs, pkg) {\n  var name = nameNs.name,\n    localName = nameNs.localName;\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\nfunction normalizeXsiTypeName(name, model) {\n  var nameNs = parseNameNS(name);\n  var pkg = model.getPackage(nameNs.prefix);\n  return prefixedToName(nameNs, pkg);\n}\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function (reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function (element) {\n    if (!element) {\n      throw error('expected element');\n    }\n    var elementsById = this.elementsById;\n    var descriptor = getModdleDescriptor(element);\n    var idProperty = descriptor.idProperty,\n      id;\n    if (idProperty) {\n      id = element.get(idProperty.name);\n      if (id) {\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function (warning) {\n    this.warnings.push(warning);\n  };\n}\nfunction BaseHandler() {}\nBaseHandler.prototype.handleEnd = function () {};\nBaseHandler.prototype.handleText = function () {};\nBaseHandler.prototype.handleNode = function () {};\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() {}\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\nNoopHandler.prototype.handleNode = function () {\n  return this;\n};\nfunction BodyHandler() {}\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\nBodyHandler.prototype.handleText = function (text) {\n  this.body = (this.body || '') + text;\n};\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\nReferenceHandler.prototype.handleNode = function (node) {\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n  return this;\n};\nReferenceHandler.prototype.handleEnd = function () {\n  this.element.id = this.body;\n};\nReferenceHandler.prototype.createReference = function (node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\nValueHandler.prototype = Object.create(BodyHandler.prototype);\nValueHandler.prototype.handleEnd = function () {\n  var value = this.body || '',\n    element = this.element,\n    propertyDesc = this.propertyDesc;\n  value = coerceType(propertyDesc.type, value);\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\nfunction BaseElementHandler() {}\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\nBaseElementHandler.prototype.handleNode = function (node) {\n  var parser = this,\n    element = this.element;\n  if (!element) {\n    element = this.element = this.createElement(node);\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\nElementHandler.prototype.addReference = function (reference) {\n  this.context.addReference(reference);\n};\nElementHandler.prototype.handleText = function (text) {\n  var element = this.element,\n    descriptor = getModdleDescriptor(element),\n    bodyProperty = descriptor.bodyProperty;\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n  BodyHandler.prototype.handleText.call(this, text);\n};\nElementHandler.prototype.handleEnd = function () {\n  var value = this.body,\n    element = this.element,\n    descriptor = getModdleDescriptor(element),\n    bodyProperty = descriptor.bodyProperty;\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function (node) {\n  var attributes = node.attributes,\n    Type = this.type,\n    descriptor = getModdleDescriptor(Type),\n    context = this.context,\n    instance = new Type({}),\n    model = this.model,\n    propNameNs;\n  forEach(attributes, function (value, name) {\n    var prop = descriptor.propertiesByName[name],\n      values;\n    if (prop && prop.isReference) {\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n        forEach(values, function (v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name !== 'xmlns') {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n      instance.set(name, value);\n    }\n  });\n  return instance;\n};\nElementHandler.prototype.getPropertyForNode = function (node) {\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n  var type = this.type,\n    model = this.model,\n    descriptor = getModdleDescriptor(type);\n  var propertyName = nameNs.name,\n    property = descriptor.propertiesByName[propertyName],\n    elementTypeName,\n    elementType;\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n    if (serializeAsType(property)) {\n      elementTypeName = node.attributes[XSI_TYPE];\n\n      // xsi type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n        elementType = model.getType(elementTypeName);\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n  var pkg = model.getPackage(nameNs.prefix);\n  if (pkg) {\n    elementTypeName = aliasToName(nameNs, pkg);\n    elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function (p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function (p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n    if (property) {\n      return property;\n    }\n  }\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\nElementHandler.prototype.toString = function () {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\nElementHandler.prototype.valueHandler = function (propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\nElementHandler.prototype.referenceHandler = function (propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\nElementHandler.prototype.handler = function (type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function (node) {\n  var propertyDesc, type, element, childHandler;\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n  type = propertyDesc.effectiveType || propertyDesc.type;\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\nRootElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n    nameNs = parseNameNS(name),\n    model = this.model,\n    type = this.type,\n    pkg = model.getPackage(nameNs.prefix),\n    typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n  return ElementHandler.prototype.createElement.call(this, node);\n};\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\nGenericElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n    ns = parseNameNS(name),\n    prefix = ns.prefix,\n    uri = node.ns[prefix + '$uri'],\n    attributes = node.attributes;\n  return this.model.createAny(name, uri, attributes);\n};\nGenericElementHandler.prototype.handleChild = function (node) {\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n    element = this.element;\n  var newElement = handler.element,\n    children;\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n  return handler;\n};\nGenericElementHandler.prototype.handleEnd = function () {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction Reader(options) {\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n  assign(this, {\n    lax: false\n  }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function (xml, options, done) {\n  var rootHandler = options.rootHandler;\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n  var model = this.model,\n    lax = this.lax;\n  var context = new Context(assign({}, options, {\n      rootHandler: rootHandler\n    })),\n    parser = new Parser({\n      proxy: true\n    }),\n    stack = createStack();\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n    var ctx = getContext();\n    var line = ctx.line,\n      column = ctx.column,\n      data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n    var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' + 'line: ' + line + '\\n\\t' + 'column: ' + column + '\\n\\t' + 'nested error: ' + err.message;\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n  function handleWarning(err, getContext) {\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n    var elementsById = context.elementsById;\n    var references = context.references;\n    var i, r;\n    for (i = 0; r = references[i]; i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n      if (property.isMany) {\n        var collection = element.get(property.name),\n          idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n  var UTF_8_PATTERN = /^utf-8$/i;\n  function handleQuestion(question) {\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n    context.addWarning({\n      message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'\n    });\n  }\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n  function handleCData(text, getContext) {\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n  function handleText(text, getContext) {\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n    text = text.trim();\n    if (!text) {\n      return;\n    }\n    handleCData(text, getContext);\n  }\n  var uriMap = model.getPackages().reduce(function (uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n    return uriMap;\n  }, {\n    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns\n  });\n\n  parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {\n    // gracefully handle unparsable attributes (attrs=false)\n    var attrs = obj.attrs || {};\n    var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {\n      var value = decodeStr(attrs[key]);\n      d[key] = value;\n      return d;\n    }, {});\n    var node = {\n      name: obj.name,\n      originalName: obj.originalName,\n      attributes: decodedAttrs,\n      ns: obj.ns\n    };\n    handleOpen(node, getContext);\n  }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {\n    handleText(decodeEntities(text), getContext);\n  }).on('error', handleError).on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function (resolve, reject) {\n    var err;\n    try {\n      parser.parse(xml);\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n    var rootElement = rootHandler.element;\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n    if (err) {\n      err.warnings = warnings;\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\nReader.prototype.handler = function (name) {\n  return new RootElementHandler(this.model, name);\n};\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n  Object.defineProperty(stack, 'peek', {\n    value: function () {\n      return this[this.length - 1];\n    }\n  });\n  return stack;\n}\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\nfunction Namespaces(parent) {\n  var prefixMap = {};\n  var uriMap = {};\n  var used = {};\n  var wellknown = [];\n  var custom = [];\n\n  // API\n\n  this.byUri = function (uri) {\n    return uriMap[uri] || parent && parent.byUri(uri);\n  };\n  this.add = function (ns, isWellknown) {\n    uriMap[ns.uri] = ns;\n    if (isWellknown) {\n      wellknown.push(ns);\n    } else {\n      custom.push(ns);\n    }\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n  this.uriByPrefix = function (prefix) {\n    return prefixMap[prefix || 'xmlns'];\n  };\n  this.mapPrefix = function (prefix, uri) {\n    prefixMap[prefix || 'xmlns'] = uri;\n  };\n  this.getNSKey = function (ns) {\n    return ns.prefix !== undefined ? ns.uri + '|' + ns.prefix : ns.uri;\n  };\n  this.logUsed = function (ns) {\n    var uri = ns.uri;\n    var nsKey = this.getNSKey(ns);\n    used[nsKey] = this.byUri(uri);\n\n    // Inform parent recursively about the usage of this NS\n    if (parent) {\n      parent.logUsed(ns);\n    }\n  };\n  this.getUsed = function (ns) {\n    function isUsed(ns) {\n      var nsKey = self.getNSKey(ns);\n      return used[nsKey];\n    }\n    var self = this;\n    var allNs = [].concat(wellknown, custom);\n    return allNs.filter(isUsed);\n  };\n}\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\nfunction getNsAttrs(namespaces) {\n  return map(namespaces.getUsed(), function (ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return {\n      name: name,\n      value: ns.uri\n    };\n  });\n}\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({\n      localName: descriptor.ns.localName\n    }, ns);\n  } else {\n    return assign({\n      localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)\n    }, ns);\n  }\n}\nfunction getPropertyNs(ns, descriptor) {\n  return assign({\n    localName: descriptor.ns.localName\n  }, ns);\n}\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n  return filter(descriptor.properties, function (p) {\n    var name = p.name;\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!has(element, name)) {\n      return false;\n    }\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n    return p.isMany ? value.length : true;\n  });\n}\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\nfunction escape(str, charPattern, replaceMap) {\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n  return str.replace(charPattern, function (s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\nfunction filterAttributes(props) {\n  return filter(props, function (p) {\n    return p.isAttr;\n  });\n}\nfunction filterContained(props) {\n  return filter(props, function (p) {\n    return !p.isAttr;\n  });\n}\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\nReferenceSerializer.prototype.build = function (element) {\n  this.element = element;\n  return this;\n};\nReferenceSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();\n};\nfunction BodySerializer() {}\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {\n  writer.append(this.escape ? escapeBody(this.value) : this.value);\n};\nBodySerializer.prototype.build = function (prop, value) {\n  this.value = value;\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n  return this;\n};\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\ninherits(ValueSerializer, BodySerializer);\nValueSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>');\n  this.serializeValue(writer);\n  writer.append('</' + this.tagName + '>').appendNewLine();\n};\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\nElementSerializer.prototype.build = function (element) {\n  this.element = element;\n  var elementDescriptor = element.$descriptor,\n    propertyDescriptor = this.propertyDescriptor;\n  var otherAttrs, properties;\n  var isGeneric = elementDescriptor.isGeneric;\n  if (isGeneric) {\n    otherAttrs = this.parseGeneric(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n  if (!isGeneric) {\n    properties = getSerializableProperties(element);\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n  this.parseGenericAttributes(element, otherAttrs);\n  return this;\n};\nElementSerializer.prototype.nsTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\nElementSerializer.prototype.nsPropertyTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\nElementSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function (element) {\n  var ns;\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return {\n      localName: ns.localName\n    };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return {\n      localName: ns.localName\n    };\n  } else {\n    return assign({\n      localName: ns.localName\n    }, effectiveNs);\n  }\n};\nElementSerializer.prototype.parseGeneric = function (element) {\n  var self = this,\n    body = this.body;\n  var attributes = [];\n  forEach(element, function (val, key) {\n    var nonNsAttr;\n    if (key === '$body') {\n      body.push(new BodySerializer().build({\n        type: 'String'\n      }, val));\n    } else if (key === '$children') {\n      forEach(val, function (child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else if (key.indexOf('$') !== 0) {\n      nonNsAttr = self.parseNsAttribute(element, key, val);\n      if (nonNsAttr) {\n        attributes.push({\n          name: key,\n          value: val\n        });\n      }\n    }\n  });\n  return attributes;\n};\nElementSerializer.prototype.parseNsAttribute = function (element, name, value) {\n  var model = element.$model;\n  var nameNs = parseNameNS(name);\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = {\n      prefix: nameNs.localName,\n      uri: value\n    };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = {\n      uri: value\n    };\n  }\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n  if (model && model.getPackage(value)) {\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function (element, attrs) {\n  var self = this;\n  var genericAttrs = element.$attrs;\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function (value, name) {\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n  return attributes;\n};\nElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {\n  var self = this;\n  forEach(attributes, function (attr) {\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn('missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);\n    }\n  });\n};\nElementSerializer.prototype.parseContainments = function (properties) {\n  var self = this,\n    body = this.body,\n    element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name),\n      isReference = p.isReference,\n      isMany = p.isMany;\n    if (!isMany) {\n      value = [value];\n    }\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function (v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function (v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n        asProperty = serializeAsProperty(p);\n      forEach(value, function (v) {\n        var serializer;\n        if (asType) {\n          serializer = new TypeSerializer(self, p);\n        } else if (asProperty) {\n          serializer = new ElementSerializer(self, p);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\nElementSerializer.prototype.getNamespaces = function (local) {\n  var namespaces = this.namespaces,\n    parent = this.parent,\n    parentNamespaces;\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n  return namespaces;\n};\nElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n  var nsUri = ns.uri,\n    nsPrefix = ns.prefix;\n  var existing = namespaces.byUri(nsUri);\n  if (nsPrefix !== 'xml' && (!existing || local)) {\n    namespaces.add(ns, wellknown);\n  }\n  namespaces.mapPrefix(nsPrefix, nsUri);\n  return ns;\n};\nElementSerializer.prototype.logNamespaceUsed = function (ns, local) {\n  var element = this.element,\n    model = element.$model,\n    namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n    uri = ns.uri,\n    newPrefix,\n    idx,\n    wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return {\n      localName: ns.localName\n    };\n  }\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n  ns = namespaces.byUri(uri);\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n    ns = this.logNamespace({\n      prefix: newPrefix,\n      uri: uri\n    }, wellknownUri === uri);\n  }\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n  return ns;\n};\nElementSerializer.prototype.parseAttributes = function (properties) {\n  var self = this,\n    element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name);\n    if (p.isReference) {\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function (v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n    }\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\nElementSerializer.prototype.addTagName = function (nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n  this.getNamespaces().logUsed(actualNs);\n  return nsName(nsTagName);\n};\nElementSerializer.prototype.addAttribute = function (name, value) {\n  var attrs = this.attrs;\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n  attrs.push({\n    name: name,\n    value: value\n  });\n};\nElementSerializer.prototype.serializeAttributes = function (writer) {\n  var attrs = this.attrs,\n    namespaces = this.namespaces;\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n  forEach(attrs, function (a) {\n    writer.append(' ').append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\nElementSerializer.prototype.serializeTo = function (writer) {\n  var firstBody = this.body[0],\n    indent = firstBody && firstBody.constructor !== BodySerializer;\n  writer.appendIndent().append('<' + this.tagName);\n  this.serializeAttributes(writer);\n  writer.append(firstBody ? '>' : ' />');\n  if (firstBody) {\n    if (indent) {\n      writer.appendNewLine().indent();\n    }\n    forEach(this.body, function (b) {\n      b.serializeTo(writer);\n    });\n    if (indent) {\n      writer.unindent().appendIndent();\n    }\n    writer.append('</' + this.tagName + '>');\n  }\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n}\ninherits(TypeSerializer, ElementSerializer);\nTypeSerializer.prototype.parseNsAttributes = function (element) {\n  // extracted attributes\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n  var descriptor = element.$descriptor;\n\n  // only serialize xsi:type if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n    typePrefix = pkg.xml && pkg.xml.typePrefix || '';\n  this.addAttribute(this.nsAttributeName(XSI_TYPE), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);\n  return attributes;\n};\nTypeSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\nfunction SavingWriter() {\n  this.value = '';\n  this.write = function (str) {\n    this.value += str;\n  };\n}\nfunction FormatingWriter(out, format) {\n  var indent = [''];\n  this.append = function (str) {\n    out.write(str);\n    return this;\n  };\n  this.appendNewLine = function () {\n    if (format) {\n      out.write('\\n');\n    }\n    return this;\n  };\n  this.appendIndent = function () {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n    return this;\n  };\n  this.indent = function () {\n    indent.push('');\n    return this;\n  };\n  this.unindent = function () {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction Writer(options) {\n  options = assign({\n    format: false,\n    preamble: true\n  }, options || {});\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n  return {\n    toXML: toXML\n  };\n}\nexport { Reader, Writer };","map":null,"metadata":{},"sourceType":"module"}