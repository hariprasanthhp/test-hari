{"ast":null,"code":"'use strict';\n\nvar createDropdown = require('./Utils').createDropdown,\n  escapeHTML = require('./Utils').escapeHTML;\nvar domify = require('min-dom').domify,\n  domQuery = require('min-dom').query,\n  domQueryAll = require('min-dom').queryAll,\n  domRemove = require('min-dom').remove,\n  domClasses = require('min-dom').classes,\n  domClosest = require('min-dom').closest,\n  domAttr = require('min-dom').attr,\n  domDelegate = require('min-dom').delegate,\n  domMatches = require('min-dom').matches;\nvar forEach = require('lodash/forEach'),\n  filter = require('lodash/filter'),\n  get = require('lodash/get'),\n  keys = require('lodash/keys'),\n  isEmpty = require('lodash/isEmpty'),\n  isArray = require('lodash/isArray'),\n  isFunction = require('lodash/isFunction'),\n  isObject = require('lodash/isObject'),\n  xor = require('lodash/xor'),\n  debounce = require('lodash/debounce'),\n  flattenDeep = require('lodash/flattenDeep'),\n  keyBy = require('lodash/keyBy'),\n  map = require('lodash/map'),\n  reduce = require('lodash/reduce');\nvar updateSelection = require('selection-update');\nvar scrollTabs = require('scroll-tabs').default;\nvar getBusinessObject = require('bpmn-js/lib/util/ModelUtil').getBusinessObject;\nvar HIDE_CLASS = 'bpp-hidden';\nvar DEBOUNCE_DELAY = 300;\nvar DEFAULT_PRIORITY = 1000;\nfunction isToggle(node) {\n  return node.type === 'checkbox' || node.type === 'radio';\n}\nfunction isSelect(node) {\n  return node.type === 'select-one';\n}\nfunction isContentEditable(node) {\n  return domAttr(node, 'contenteditable');\n}\nfunction getPropertyPlaceholders(node) {\n  var selector = 'input[name], textarea[name], [data-value], [contenteditable]';\n  var placeholders = domQueryAll(selector, node);\n  if ((!placeholders || !placeholders.length) && domMatches(node, selector)) {\n    placeholders = [node];\n  }\n  return placeholders;\n}\n\n/**\n * Return all active form controls.\n * This excludes the invisible controls unless all is true\n *\n * @param {Element} node\n * @param {Boolean} [all=false]\n */\nfunction getFormControls(node, all) {\n  var controls = domQueryAll('input[name], textarea[name], select[name], [contenteditable]', node);\n  if (!controls || !controls.length) {\n    controls = domMatches(node, 'option') ? [node] : controls;\n  }\n  if (!all) {\n    controls = filter(controls, function (node) {\n      return !domClosest(node, '.' + HIDE_CLASS);\n    });\n  }\n  return controls;\n}\nfunction getFormControlValuesInScope(entryNode) {\n  var values = {};\n  var controlNodes = getFormControls(entryNode);\n  forEach(controlNodes, function (controlNode) {\n    var value = controlNode.value;\n    var name = domAttr(controlNode, 'name') || domAttr(controlNode, 'data-name');\n\n    // take toggle state into account for radio / checkboxes\n    if (isToggle(controlNode)) {\n      if (controlNode.checked) {\n        if (!domAttr(controlNode, 'value')) {\n          value = true;\n        } else {\n          value = controlNode.value;\n        }\n      } else {\n        value = null;\n      }\n    } else if (isContentEditable(controlNode)) {\n      value = controlNode.innerText;\n    }\n    if (value !== null) {\n      // return the actual value\n      // handle serialization in entry provider\n      // (ie. if empty string should be serialized or not)\n      values[name] = value;\n    }\n  });\n  return values;\n}\n\n/**\n * Extract input values from entry node\n *\n * @param  {DOMElement} entryNode\n * @returns {Object}\n */\nfunction getFormControlValues(entryNode) {\n  var values;\n  var listContainer = domQuery('[data-list-entry-container]', entryNode);\n  if (listContainer) {\n    values = [];\n    var listNodes = listContainer.children || [];\n    forEach(listNodes, function (listNode) {\n      values.push(getFormControlValuesInScope(listNode));\n    });\n  } else {\n    values = getFormControlValuesInScope(entryNode);\n  }\n  return values;\n}\n\n/**\n * Return true if the given form extracted value equals\n * to an old cached version.\n *\n * @param {Object} value\n * @param {Object} oldValue\n * @return {Boolean}\n */\nfunction valueEqual(value, oldValue) {\n  if (value && !oldValue) {\n    return false;\n  }\n  var allKeys = keys(value).concat(keys(oldValue));\n  return allKeys.every(function (key) {\n    return value[key] === oldValue[key];\n  });\n}\n\n/**\n * Return true if the given form extracted value(s)\n * equal an old cached version.\n *\n * @param {Array<Object>|Object} values\n * @param {Array<Object>|Object} oldValues\n * @return {Boolean}\n */\nfunction valuesEqual(values, oldValues) {\n  if (isArray(values)) {\n    if (values.length !== oldValues.length) {\n      return false;\n    }\n    return values.every(function (v, idx) {\n      return valueEqual(v, oldValues[idx]);\n    });\n  }\n  return valueEqual(values, oldValues);\n}\n\n/**\n * Return a mapping of { id: entry } for all entries in the given groups in the given tabs.\n *\n * @param {Object} tabs\n * @return {Object}\n */\nfunction extractEntries(tabs) {\n  return keyBy(flattenDeep(map(flattenDeep(map(tabs, 'groups')), 'entries')), 'id');\n}\n\n/**\n * Return a mapping of { id: group } for all groups in the given tabs.\n *\n * @param {Object} tabs\n * @return {Object}\n */\nfunction extractGroups(tabs) {\n  return keyBy(flattenDeep(map(tabs, 'groups')), 'id');\n}\n\n/**\n * A properties panel implementation.\n *\n * To use it provide a `propertiesProvider` component that knows\n * about which properties to display.\n *\n * Properties edit state / visibility can be intercepted\n * via a custom {@link PropertiesActivator}.\n *\n * @class\n * @constructor\n *\n * @param {Object} config\n * @param {didi.Injector} injector\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Canvas} canvas\n * @param {CommandStack} commandStack\n */\nfunction PropertiesPanel(config, injector, eventBus, modeling, commandStack, canvas) {\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._commandStack = commandStack;\n  this._canvas = canvas;\n  var propertiesProvider = injector.get('propertiesProvider', false);\n  if (propertiesProvider) {\n    this.registerProvider(propertiesProvider);\n  }\n  this._init(config);\n}\nPropertiesPanel.$inject = ['config.propertiesPanel', 'injector', 'eventBus', 'modeling', 'commandStack', 'canvas'];\nmodule.exports = PropertiesPanel;\n\n/**\n * @param {number} [priority]\n * @param { { getTabs: any[] | (any) => (any[]) => any[]) } } provider\n */\nPropertiesPanel.prototype.registerProvider = function (priority, provider) {\n  if (!provider) {\n    provider = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n  this._eventBus.on('propertiesPanel.getProviders', priority, function (event) {\n    event.providers.push(provider);\n  });\n  this._eventBus.fire('propertiesPanel.providersChanged');\n};\nPropertiesPanel.prototype._init = function (config) {\n  var canvas = this._canvas,\n    eventBus = this._eventBus;\n  var self = this;\n\n  /**\n   * Select the root element once it is added to the canvas\n   */\n  eventBus.on('root.added', function (e) {\n    var element = e.element;\n    if (isImplicitRoot(element)) {\n      return;\n    }\n    self.update(element);\n  });\n  eventBus.on('selection.changed', function (e) {\n    var newElement = e.newSelection[0];\n    var rootElement = canvas.getRootElement();\n    if (isImplicitRoot(rootElement)) {\n      return;\n    }\n    self.update(newElement);\n  });\n\n  // add / update tab-bar scrolling\n  eventBus.on(['propertiesPanel.changed', 'propertiesPanel.resized'], function (event) {\n    var tabBarNode = domQuery('.bpp-properties-tab-bar', self._container);\n    if (!tabBarNode) {\n      return;\n    }\n    var scroller = scrollTabs.get(tabBarNode);\n    if (!scroller) {\n      // we did not initialize yet, do that\n      // now and make sure we select the active\n      // tab on scroll update\n      scroller = scrollTabs(tabBarNode, {\n        selectors: {\n          tabsContainer: '.bpp-properties-tabs-links',\n          tab: '.bpp-properties-tabs-links li',\n          ignore: '.bpp-hidden',\n          active: '.bpp-active'\n        }\n      });\n      scroller.on('scroll', function (newActiveNode, oldActiveNode, direction) {\n        var linkNode = domQuery('[data-tab-target]', newActiveNode);\n        var tabId = domAttr(linkNode, 'data-tab-target');\n        self.activateTab(tabId);\n      });\n    }\n\n    // react on tab changes and or tabContainer resize\n    // and make sure the active tab is shown completely\n    scroller.update();\n  });\n  eventBus.on('elements.changed', function (e) {\n    var current = self._current;\n    var element = current && current.element;\n    if (element) {\n      if (e.elements.indexOf(element) !== -1) {\n        self.update(element);\n      }\n    }\n  });\n  eventBus.on(['elementTemplates.changed', 'propertiesPanel.providersChanged'], function () {\n    var current = self._current;\n    var element = current && current.element;\n    if (element) {\n      self.update(element);\n    }\n  });\n  eventBus.on('diagram.destroy', function () {\n    self.detach();\n  });\n  this._container = domify('<div class=\"bpp-properties-panel\"></div>');\n  this._bindListeners(this._container);\n  if (config && config.parent) {\n    this.attachTo(config.parent);\n  }\n};\nPropertiesPanel.prototype.attachTo = function (parentNode) {\n  if (!parentNode) {\n    throw new Error('parentNode required');\n  }\n\n  // ensure we detach from the\n  // previous, old parent\n  this.detach();\n\n  // unwrap jQuery if provided\n  if (parentNode.get && parentNode.constructor.prototype.jquery) {\n    parentNode = parentNode.get(0);\n  }\n  if (typeof parentNode === 'string') {\n    parentNode = domQuery(parentNode);\n  }\n  var container = this._container;\n  parentNode.appendChild(container);\n  this._emit('attach');\n};\nPropertiesPanel.prototype.detach = function () {\n  var container = this._container,\n    parentNode = container.parentNode;\n  if (!parentNode) {\n    return;\n  }\n  this._emit('detach');\n  parentNode.removeChild(container);\n};\n\n/**\n * Activate tab. Fall back to first visible tab.\n *\n * @param {Object|string} tabId\n */\nPropertiesPanel.prototype.activateTab = function (tabId) {\n  if (isObject(tabId)) {\n    tabId = tabId.id;\n  }\n  var tabs = domQueryAll('.bpp-properties-tab', this._current.panel),\n    tabLinks = domQueryAll('.bpp-properties-tab-link', this._current.panel);\n\n  // (1) Deactivate all tabs\n  forEach(tabs, function (tab) {\n    domClasses(tab).remove('bpp-active');\n  });\n  forEach(tabLinks, function (tabLink) {\n    domClasses(tabLink).remove('bpp-active');\n  });\n\n  // (2) Activate tab, fall back to first visible tab\n  var visibleTabs = filter(tabs, function (tab) {\n    return !domClasses(tab).has(HIDE_CLASS);\n  });\n  var activeTab = reduce(visibleTabs, function (activeTab, tab) {\n    if (domAttr(tab, 'data-tab') === tabId) {\n      return tab;\n    }\n    return activeTab;\n  }, visibleTabs[0]);\n  if (activeTab) {\n    domClasses(activeTab).add('bpp-active');\n  }\n  var visibleTabLinks = filter(tabLinks, function (tabLink) {\n    return !domClasses(tabLink).has(HIDE_CLASS);\n  });\n  var activeTabLink = reduce(visibleTabLinks, function (activeTabLink, tabLink) {\n    if (domAttr(domQuery('a[data-tab-target]', tabLink), 'data-tab-target') === tabId) {\n      return tabLink;\n    }\n    return activeTabLink;\n  }, visibleTabLinks[0]);\n  if (activeTabLink) {\n    domClasses(activeTabLink).add('bpp-active');\n  }\n};\nPropertiesPanel.prototype._getProviders = function () {\n  var event = this._eventBus.createEvent({\n    type: 'propertiesPanel.getProviders',\n    providers: []\n  });\n  this._eventBus.fire(event);\n  return event.providers;\n};\nPropertiesPanel.prototype._getTabs = function (element) {\n  var providers = this._getProviders();\n\n  // loop through all providers and their entries.\n  // group entries by id so that overriding an entry is possible\n  return reduce(providers, function (tabs, provider) {\n    var tabsOrUpdater = provider.getTabs(element);\n    if (isFunction(tabsOrUpdater)) {\n      return tabsOrUpdater(tabs);\n    } else {\n      return tabsOrUpdater;\n    }\n  }, []);\n};\n\n/**\n * Update properties panel to show properties of element. Create new properties panel if no previous\n * properties panel, element has changed or element has not changed but entries have.\n *\n * @param {ModdleElement|undefined} element\n */\nPropertiesPanel.prototype.update = function (element) {\n  // (1) Fall back to root element\n  if (!element) {\n    element = this._canvas.getRootElement();\n  }\n\n  // (2) Get tabs\n  var tabs = this._getTabs(element);\n  var activeTabId, activeTabNode;\n  if (this._current) {\n    activeTabNode = domQuery('.bpp-properties-tab.bpp-active', this._current.panel);\n    if (activeTabNode) {\n      activeTabId = domAttr(activeTabNode, 'data-tab');\n    }\n  }\n\n  // (3) Create new properties panel if necessary\n  if (!this._current || this._current.element !== element || this._entriesChanged(this._current.entries, extractEntries(tabs))) {\n    if (this._current) {\n      domRemove(this._current.panel);\n    }\n    this._current = this._create(element, tabs);\n  }\n\n  // (4) Update visibility of tabs, groups and entries\n  this._updateActivation(this._current);\n\n  // (5) Update active tab\n  if (activeTabId) {\n    this.activateTab(activeTabId);\n  } else {\n    this.activateTab(this._current.tabs[0]);\n  }\n  this._emit('changed');\n};\n\n/**\n * Check whether entries have changes.\n *\n * @param  {Array} prevEntries\n * @param  {Array} entries\n *\n * @returns {Boolean}\n */\nPropertiesPanel.prototype._entriesChanged = function (prevEntries, entries) {\n  var prevEntryIds = keys(prevEntries),\n    entryIds = keys(entries);\n  return !isEmpty(xor(prevEntryIds, entryIds));\n};\nPropertiesPanel.prototype._emit = function (event) {\n  this._eventBus.fire('propertiesPanel.' + event, {\n    panel: this,\n    current: this._current\n  });\n};\nPropertiesPanel.prototype._bindListeners = function (container) {\n  var self = this;\n\n  // handles a change for a given event\n  var handleChange = function handleChange(event) {\n    // see if we handle a change inside a [data-entry] element.\n    // if not, drop out\n    var inputNode = event.delegateTarget,\n      entryNode = domClosest(inputNode, '[data-entry]'),\n      entryId,\n      entry;\n\n    // change from outside a [data-entry] element, simply ignore\n    if (!entryNode) {\n      return;\n    }\n    entryId = domAttr(entryNode, 'data-entry');\n    entry = self.getEntry(entryId);\n    var values = getFormControlValues(entryNode);\n    if (event.type === 'change') {\n      // - if the \"data-on-change\" attribute is present and a value is changed,\n      //   then the associated action is performed.\n      // - if the associated action returns \"true\" then an update to the business\n      //   object is done\n      // - if it does not return \"true\", then only the DOM content is updated\n      var onChangeAction = domAttr(inputNode, 'data-on-change');\n      if (onChangeAction) {\n        var isEntryDirty = self.executeAction(entry, entryNode, onChangeAction, event);\n        if (!isEntryDirty) {\n          return self.update(self._current.element);\n        }\n      }\n    }\n    self.applyChanges(entry, values, entryNode);\n    self.updateState(entry, entryNode);\n  };\n\n  // debounce update only elements that are target of key events,\n  // i.e. INPUT and TEXTAREA. SELECTs will trigger an immediate update anyway.\n  domDelegate.bind(container, 'input, textarea, [contenteditable]', 'input', debounce(handleChange, DEBOUNCE_DELAY));\n  domDelegate.bind(container, 'input, textarea, select, [contenteditable]', 'change', handleChange);\n\n  // paste as plain text only\n  domDelegate.bind(container, '[contenteditable]', 'paste', handlePaste);\n  function handlePaste(event) {\n    var text = (event.clipboardData || window.clipboardData).getData('text');\n    document.execCommand('insertText', false, text);\n    event.preventDefault();\n  }\n\n  // handle key events\n  domDelegate.bind(container, 'select', 'keydown', function (e) {\n    // DEL\n    if (e.keyCode === 46) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  });\n  function handleSuggestItems(event) {\n    // triggers on all inputs\n    var inputNode = event.delegateTarget;\n    var entryNode = domClosest(inputNode, '[data-entry]');\n\n    // only work on data entries\n    if (!entryNode) {\n      return;\n    }\n    var action = domAttr(inputNode, 'data-auto-suggest'),\n      entryId = domAttr(entryNode, 'data-entry');\n    var entry = self.getEntry(entryId);\n    self.executeAction(entry, entryNode, action, event);\n  }\n  domDelegate.bind(container, '[data-auto-suggest]', 'input', handleSuggestItems, true);\n  domDelegate.bind(container, '[data-action]', 'click', function onClick(event) {\n    // triggers on all inputs\n    var inputNode = event.delegateTarget,\n      entryNode = domClosest(inputNode, '[data-entry]');\n    var actionId = domAttr(inputNode, 'data-action'),\n      entryId = domAttr(entryNode, 'data-entry');\n    var entry = self.getEntry(entryId);\n    var isEntryDirty = self.executeAction(entry, entryNode, actionId, event);\n    if (!isEntryDirty) {\n      return self.update(self._current.element);\n    }\n    var values = getFormControlValues(entryNode);\n    self.applyChanges(entry, values, entryNode);\n    self.updateState(entry, entryNode);\n  });\n  function handleInput(event, element) {\n    // triggers on all inputs\n    var inputNode = event.delegateTarget;\n    var entryNode = domClosest(inputNode, '[data-entry]');\n\n    // only work on data entries\n    if (!entryNode) {\n      return;\n    }\n    var eventHandlerId = domAttr(inputNode, 'data-blur'),\n      entryId = domAttr(entryNode, 'data-entry');\n    var entry = self.getEntry(entryId);\n    var isEntryDirty = self.executeAction(entry, entryNode, eventHandlerId, event);\n    if (isEntryDirty) {\n      var values = getFormControlValues(entryNode);\n      self.applyChanges(entry, values, entryNode);\n    }\n    self.updateState(entry, entryNode);\n  }\n  domDelegate.bind(container, '[data-blur]', 'blur', handleInput, true);\n\n  // make tab links interactive\n  domDelegate.bind(container, '.bpp-properties-tabs-links [data-tab-target]', 'click', function (event) {\n    event.preventDefault();\n    var delegateTarget = event.delegateTarget;\n    var tabId = domAttr(delegateTarget, 'data-tab-target');\n\n    // activate tab on link click\n    self.activateTab(tabId);\n  });\n};\nPropertiesPanel.prototype.updateState = function (entry, entryNode) {\n  this.updateShow(entry, entryNode);\n  this.updateDisable(entry, entryNode);\n};\n\n/**\n * Update the visibility of the entry node in the DOM\n */\nPropertiesPanel.prototype.updateShow = function (entry, node) {\n  var current = this._current;\n  if (!current) {\n    return;\n  }\n  var showNodes = domQueryAll('[data-show]', node) || [];\n  forEach(showNodes, function (showNode) {\n    var expr = domAttr(showNode, 'data-show');\n    var fn = get(entry, expr);\n    if (fn) {\n      var scope = domClosest(showNode, '[data-scope]') || node;\n      var shouldShow = fn(current.element, node, showNode, scope) || false;\n      if (shouldShow) {\n        domClasses(showNode).remove(HIDE_CLASS);\n      } else {\n        domClasses(showNode).add(HIDE_CLASS);\n      }\n    }\n  });\n};\n\n/**\n * Evaluates a given function. If it returns true, then the\n * node is marked as \"disabled\".\n */\nPropertiesPanel.prototype.updateDisable = function (entry, node) {\n  var current = this._current;\n  if (!current) {\n    return;\n  }\n  var nodes = domQueryAll('[data-disable]', node) || [];\n  forEach(nodes, function (currentNode) {\n    var expr = domAttr(currentNode, 'data-disable');\n    var fn = get(entry, expr);\n    if (fn) {\n      var scope = domClosest(currentNode, '[data-scope]') || node;\n      var shouldDisable = fn(current.element, node, currentNode, scope) || false;\n      domAttr(currentNode, 'disabled', shouldDisable ? '' : null);\n    }\n  });\n};\nPropertiesPanel.prototype.executeAction = function (entry, entryNode, actionId, event) {\n  var current = this._current;\n  if (!current) {\n    return;\n  }\n  var fn = get(entry, actionId);\n  if (fn) {\n    var scopeNode = domClosest(event.target, '[data-scope]') || entryNode;\n    return fn.apply(entry, [current.element, entryNode, event, scopeNode]);\n  }\n};\n\n/**\n * Apply changes to the business object by executing a command\n */\nPropertiesPanel.prototype.applyChanges = function (entry, values, containerElement) {\n  var element = this._current.element;\n\n  // ensure we only update the model if we got dirty changes\n  if (valuesEqual(values, entry.oldValues)) {\n    return;\n  }\n  var command = entry.set(element, values, containerElement);\n  var commandToExecute;\n  if (isArray(command)) {\n    if (command.length) {\n      commandToExecute = {\n        cmd: 'properties-panel.multi-command-executor',\n        context: flattenDeep(command)\n      };\n    }\n  } else {\n    commandToExecute = command;\n  }\n  if (commandToExecute) {\n    this._commandStack.execute(commandToExecute.cmd, commandToExecute.context || {\n      element: element\n    });\n  } else {\n    this.update(element);\n  }\n};\n\n/**\n * apply validation errors in the DOM and show or remove an error message near the entry node.\n */\nPropertiesPanel.prototype.applyValidationErrors = function (validationErrors, entryNode) {\n  var valid = true;\n  var controlNodes = getFormControls(entryNode, true);\n  forEach(controlNodes, function (controlNode) {\n    var name = domAttr(controlNode, 'name') || domAttr(controlNode, 'data-name');\n    var error = validationErrors && validationErrors[name];\n    var errorMessageNode = domQuery('.bpp-error-message', controlNode.parentNode);\n    if (error) {\n      valid = false;\n      if (!errorMessageNode) {\n        errorMessageNode = domify('<div></div>');\n        domClasses(errorMessageNode).add('bpp-error-message');\n\n        // insert errorMessageNode after controlNode\n        controlNode.parentNode.insertBefore(errorMessageNode, controlNode.nextSibling);\n      }\n      errorMessageNode.textContent = error;\n      domClasses(controlNode).add('invalid');\n    } else {\n      domClasses(controlNode).remove('invalid');\n      if (errorMessageNode) {\n        controlNode.parentNode.removeChild(errorMessageNode);\n      }\n    }\n  });\n  return valid;\n};\n\n/**\n * Check if the entry contains valid input\n */\nPropertiesPanel.prototype.validate = function (entry, values, entryNode) {\n  var self = this;\n  var current = this._current;\n  var valid = true;\n  entryNode = entryNode || domQuery('[data-entry=\"' + entry.id + '\"]', current.panel);\n  if (values instanceof Array) {\n    var listContainer = domQuery('[data-list-entry-container]', entryNode),\n      listEntryNodes = listContainer.children || [];\n\n    // create new elements\n    for (var i = 0; i < values.length; i++) {\n      var listValue = values[i];\n      if (entry.validateListItem) {\n        var validationErrors = entry.validateListItem(current.element, listValue, entryNode, i),\n          listEntryNode = listEntryNodes[i];\n        valid = self.applyValidationErrors(validationErrors, listEntryNode) && valid;\n      }\n    }\n  } else {\n    if (entry.validate) {\n      this.validationErrors = entry.validate(current.element, values, entryNode);\n      valid = self.applyValidationErrors(this.validationErrors, entryNode) && valid;\n    }\n  }\n  return valid;\n};\nPropertiesPanel.prototype.getEntry = function (id) {\n  return this._current && this._current.entries[id];\n};\nPropertiesPanel.prototype._create = function (element, tabs) {\n  if (!element) {\n    return null;\n  }\n  var containerNode = this._container;\n  var panelNode = this._createPanel(element, tabs);\n  containerNode.appendChild(panelNode);\n  var entries = extractEntries(tabs);\n  var groups = extractGroups(tabs);\n  return {\n    tabs: tabs,\n    groups: groups,\n    entries: entries,\n    element: element,\n    panel: panelNode\n  };\n};\n\n/**\n * Update variable parts of the entry node on element changes.\n *\n * @param {djs.model.Base} element\n * @param {EntryDescriptor} entry\n * @param {Object} values\n * @param {HTMLElement} entryNode\n * @param {Number} idx\n */\nPropertiesPanel.prototype._bindTemplate = function (element, entry, values, entryNode, idx) {\n  var eventBus = this._eventBus;\n  function isPropertyEditable(entry, propertyName) {\n    return eventBus.fire('propertiesPanel.isPropertyEditable', {\n      entry: entry,\n      propertyName: propertyName,\n      element: element\n    });\n  }\n  var inputNodes = getPropertyPlaceholders(entryNode);\n  forEach(inputNodes, function (node) {\n    var name, newValue, editable;\n\n    // we deal with an input element\n    if ('value' in node || isContentEditable(node) === 'true') {\n      name = domAttr(node, 'name') || domAttr(node, 'data-name');\n      newValue = values[name];\n      editable = isPropertyEditable(entry, name);\n      if (editable && entry.editable) {\n        editable = entry.editable(element, entryNode, node, name, newValue, idx);\n      }\n      domAttr(node, 'readonly', editable ? null : '');\n      domAttr(node, 'disabled', editable ? null : '');\n\n      // take full control over setting the value\n      // and possibly updating the input in entry#setControlValue\n      if (entry.setControlValue) {\n        entry.setControlValue(element, entryNode, node, name, newValue, idx);\n      } else if (isToggle(node)) {\n        setToggleValue(node, newValue);\n      } else if (isSelect(node)) {\n        setSelectValue(node, newValue);\n      } else {\n        setInputValue(node, newValue);\n      }\n    }\n\n    // we deal with some non-editable html element\n    else {\n      name = domAttr(node, 'data-value');\n      newValue = values[name];\n      if (entry.setControlValue) {\n        entry.setControlValue(element, entryNode, node, name, newValue, idx);\n      } else {\n        setTextValue(node, newValue);\n      }\n    }\n  });\n};\n\n// TODO(nikku): WTF freaking name? Change / clarify.\nPropertiesPanel.prototype._updateActivation = function (current) {\n  var self = this;\n  var eventBus = this._eventBus;\n  var element = current.element;\n  function isEntryVisible(entry, group, tab) {\n    return eventBus.fire('propertiesPanel.isEntryVisible', {\n      element: element,\n      entry: entry,\n      group: group,\n      tab: tab\n    });\n  }\n  function isGroupVisible(group, element, groupNode) {\n    if (isFunction(group.enabled)) {\n      return group.enabled(element, groupNode);\n    } else {\n      return true;\n    }\n  }\n  function isTabVisible(tab, element) {\n    if (isFunction(tab.enabled)) {\n      return tab.enabled(element);\n    } else {\n      return true;\n    }\n  }\n  function toggleVisible(node, visible) {\n    domClasses(node).toggle(HIDE_CLASS, !visible);\n  }\n  function updateLabel(element, selector, text) {\n    var labelNode = domQuery(selector, element);\n    if (!labelNode) {\n      return;\n    }\n    labelNode.textContent = text;\n  }\n  var panelNode = current.panel;\n  forEach(current.tabs, function (tab) {\n    var tabNode = domQuery('[data-tab=' + tab.id + ']', panelNode);\n    var tabLinkNode = domQuery('[data-tab-target=' + tab.id + ']', panelNode).parentNode;\n    var tabVisible = false;\n    forEach(tab.groups, function (group) {\n      var groupVisible = false;\n      var groupNode = domQuery('[data-group=' + group.id + ']', tabNode);\n      forEach(group.entries, function (entry) {\n        var entryNode = domQuery('[data-entry=\"' + entry.id + '\"]', groupNode);\n        var entryVisible = isEntryVisible(entry, group, tab);\n        groupVisible = groupVisible || entryVisible;\n        toggleVisible(entryNode, entryVisible);\n        var values = 'get' in entry ? entry.get(element, entryNode) : {};\n        if (values instanceof Array) {\n          var listEntryContainer = domQuery('[data-list-entry-container]', entryNode);\n          var existingElements = listEntryContainer.children || [];\n          for (var i = 0; i < values.length; i++) {\n            var listValue = values[i];\n            var listItemNode = existingElements[i];\n            if (!listItemNode) {\n              listItemNode = domify(entry.createListEntryTemplate(listValue, i, listEntryContainer));\n              listEntryContainer.appendChild(listItemNode);\n            }\n            domAttr(listItemNode, 'data-index', i);\n            self._bindTemplate(element, entry, listValue, listItemNode, i);\n          }\n          var entriesToRemove = existingElements.length - values.length;\n          for (var j = 0; j < entriesToRemove; j++) {\n            // remove orphaned element\n            listEntryContainer.removeChild(listEntryContainer.lastChild);\n          }\n        } else {\n          self._bindTemplate(element, entry, values, entryNode);\n        }\n\n        // update conditionally visible elements\n        self.updateState(entry, entryNode);\n        self.validate(entry, values, entryNode);\n\n        // remember initial state for later dirty checking\n        entry.oldValues = getFormControlValues(entryNode);\n      });\n      if (typeof group.label === 'function') {\n        updateLabel(groupNode, '.group-label', group.label(element, groupNode));\n      }\n      groupVisible = groupVisible && isGroupVisible(group, element, groupNode);\n      tabVisible = tabVisible || groupVisible;\n      toggleVisible(groupNode, groupVisible);\n    });\n    tabVisible = tabVisible && isTabVisible(tab, element);\n    toggleVisible(tabNode, tabVisible);\n    toggleVisible(tabLinkNode, tabVisible);\n  });\n\n  // inject elements id into header\n  updateLabel(panelNode, '[data-label-id]', getBusinessObject(element).id || '');\n};\nPropertiesPanel.prototype._createPanel = function (element, tabs) {\n  var self = this;\n  var panelNode = domify('<div class=\"bpp-properties\"></div>'),\n    headerNode = domify('<div class=\"bpp-properties-header\">' + '<div class=\"label\" data-label-id></div>' + '</div>'),\n    tabBarNode = domify('<div class=\"bpp-properties-tab-bar\"></div>'),\n    tabLinksNode = domify('<ul class=\"bpp-properties-tabs-links\"></ul>'),\n    tabContainerNode = domify('<div class=\"bpp-properties-tabs-container\"></div>');\n  panelNode.appendChild(headerNode);\n  forEach(tabs, function (tab, tabIndex) {\n    if (!tab.id) {\n      throw new Error('tab must have an id');\n    }\n    var tabNode = domify('<div class=\"bpp-properties-tab\" data-tab=\"' + escapeHTML(tab.id) + '\"></div>'),\n      tabLinkNode = domify('<li class=\"bpp-properties-tab-link\">' + '<a href data-tab-target=\"' + escapeHTML(tab.id) + '\">' + escapeHTML(tab.label) + '</a>' + '</li>');\n    var groups = tab.groups;\n    forEach(groups, function (group) {\n      if (!group.id) {\n        throw new Error('group must have an id');\n      }\n      var groupNode = domify('<div class=\"bpp-properties-group\" data-group=\"' + escapeHTML(group.id) + '\">' + '<span class=\"group-toggle\"></span>' + '<div class=\"group-header\">' + '<span class=\"group-label\">' + escapeHTML(group.label) + '</span>' + '</div>' + '</div>');\n      if (group.dropdown) {\n        domQuery('.group-header', groupNode).appendChild(createDropdown(group.dropdown));\n      }\n\n      // TODO(nre): use event delegation to handle that...\n      groupNode.querySelector('.group-toggle').addEventListener('click', function (evt) {\n        domClasses(groupNode).toggle('group-closed');\n        evt.preventDefault();\n        evt.stopPropagation();\n      });\n      groupNode.addEventListener('click', function (evt) {\n        if (!evt.defaultPrevented && domClasses(groupNode).has('group-closed')) {\n          domClasses(groupNode).remove('group-closed');\n        }\n      });\n      forEach(group.entries, function (entry) {\n        if (!entry.id) {\n          throw new Error('entry must have an id');\n        }\n        var html = entry.html;\n        if (typeof html === 'string') {\n          html = domify(html);\n        }\n\n        // unwrap jquery\n        if (html.get && html.constructor.prototype.jquery) {\n          html = html.get(0);\n        }\n        var entryNode = domify('<div class=\"bpp-properties-entry\" data-entry=\"' + escapeHTML(entry.id) + '\"></div>');\n        forEach(entry.cssClasses || [], function (cssClass) {\n          domClasses(entryNode).add(cssClass);\n        });\n        entryNode.appendChild(html);\n        groupNode.appendChild(entryNode);\n\n        // update conditionally visible elements\n        self.updateState(entry, entryNode);\n      });\n      tabNode.appendChild(groupNode);\n    });\n    tabLinksNode.appendChild(tabLinkNode);\n    tabContainerNode.appendChild(tabNode);\n  });\n  tabBarNode.appendChild(tabLinksNode);\n  panelNode.appendChild(tabBarNode);\n  panelNode.appendChild(tabContainerNode);\n  return panelNode;\n};\nfunction setInputValue(node, value) {\n  var contentEditable = isContentEditable(node);\n  var oldValue = contentEditable ? node.innerText : node.value;\n  var selection;\n\n  // prevents input fields from having the value 'undefined'\n  if (value === undefined) {\n    value = '';\n  }\n  if (oldValue === value) {\n    return;\n  }\n\n  // update selection on undo/redo\n  if (document.activeElement === node) {\n    selection = updateSelection(getSelection(node), oldValue, value);\n  }\n  if (contentEditable) {\n    node.innerText = value;\n  } else {\n    node.value = value;\n  }\n  if (selection) {\n    setSelection(node, selection);\n  }\n}\nfunction setSelectValue(node, value) {\n  if (value !== undefined) {\n    node.value = value;\n  }\n}\nfunction setToggleValue(node, value) {\n  var nodeValue = node.value;\n  node.checked = value === nodeValue || !domAttr(node, 'value') && value;\n}\nfunction setTextValue(node, value) {\n  node.textContent = value;\n}\nfunction getSelection(node) {\n  return isContentEditable(node) ? getContentEditableSelection(node) : {\n    start: node.selectionStart,\n    end: node.selectionEnd\n  };\n}\nfunction getContentEditableSelection(node) {\n  var selection = window.getSelection();\n  var focusNode = selection.focusNode,\n    focusOffset = selection.focusOffset,\n    anchorOffset = selection.anchorOffset;\n  if (!focusNode) {\n    throw new Error('not selected');\n  }\n\n  // verify we have selection on the current element\n  if (!node.contains(focusNode)) {\n    throw new Error('not selected');\n  }\n  return {\n    start: Math.min(focusOffset, anchorOffset),\n    end: Math.max(focusOffset, anchorOffset)\n  };\n}\nfunction setSelection(node, selection) {\n  if (isContentEditable(node)) {\n    setContentEditableSelection(node, selection);\n  } else {\n    node.selectionStart = selection.start;\n    node.selectionEnd = selection.end;\n  }\n}\nfunction setContentEditableSelection(node, selection) {\n  var focusNode, domRange, domSelection;\n  focusNode = node.firstChild || node, domRange = document.createRange();\n  domRange.setStart(focusNode, selection.start);\n  domRange.setEnd(focusNode, selection.end);\n  domSelection = window.getSelection();\n  domSelection.removeAllRanges();\n  domSelection.addRange(domRange);\n}\nfunction isImplicitRoot(element) {\n  return element.id === '__implicitroot';\n}","map":null,"metadata":{},"sourceType":"script"}