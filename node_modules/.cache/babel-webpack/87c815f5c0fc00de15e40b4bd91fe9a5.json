{"ast":null,"code":"import { is } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { getMid, asTRBL, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { findFreePosition, generateGetNextPosition, getConnectedDistance } from 'diagram-js/lib/features/auto-place/AutoPlaceUtil';\n\n/**\n * Find the new position for the target element to\n * connect to source.\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Point}\n */\nexport function getNewShapePosition(source, element) {\n  if (is(element, 'bpmn:TextAnnotation')) {\n    return getTextAnnotationPosition(source, element);\n  }\n  if (isAny(element, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {\n    return getDataElementPosition(source, element);\n  }\n  if (is(element, 'bpmn:FlowNode')) {\n    return getFlowNodePosition(source, element);\n  }\n}\n\n/**\n * Always try to place element right of source;\n * compute actual distance from previous nodes in flow.\n */\nexport function getFlowNodePosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n  var horizontalDistance = getConnectedDistance(source, {\n    filter: function (connection) {\n      return is(connection, 'bpmn:SequenceFlow');\n    }\n  });\n  var margin = 30,\n    minDistance = 80,\n    orientation = 'left';\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n    if (orientation.indexOf('top') !== -1) {\n      margin *= -1;\n    }\n  }\n  var position = {\n    x: sourceTrbl.right + horizontalDistance + element.width / 2,\n    y: sourceMid.y + getVerticalDistance(orientation, minDistance)\n  };\n  var nextPositionDirection = {\n    y: {\n      margin: margin,\n      minDistance: minDistance\n    }\n  };\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}\nfunction getVerticalDistance(orientation, minDistance) {\n  if (orientation.indexOf('top') != -1) {\n    return -1 * minDistance;\n  } else if (orientation.indexOf('bottom') != -1) {\n    return minDistance;\n  } else {\n    return 0;\n  }\n}\n\n/**\n * Always try to place text annotations top right of source.\n */\nexport function getTextAnnotationPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var position = {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  };\n  var nextPositionDirection = {\n    y: {\n      margin: -30,\n      minDistance: 20\n    }\n  };\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}\n\n/**\n * Always put element bottom right of source.\n */\nexport function getDataElementPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var position = {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  };\n  var nextPositionDirection = {\n    x: {\n      margin: 30,\n      minDistance: 30\n    }\n  };\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}","map":null,"metadata":{},"sourceType":"module"}