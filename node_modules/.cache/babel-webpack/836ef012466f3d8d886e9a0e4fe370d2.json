{"ast":null,"code":"import { assign, forEach, isObject } from 'min-dash';\nimport inherits from 'inherits';\nimport { is } from '../../util/ModelUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport BaseElementFactory from 'diagram-js/lib/core/ElementFactory';\nimport { DEFAULT_LABEL_SIZE } from '../../util/LabelUtil';\n\n/**\n * A bpmn-aware factory for diagram-js shapes\n */\nexport default function ElementFactory(bpmnFactory, moddle, translate) {\n  BaseElementFactory.call(this);\n  this._bpmnFactory = bpmnFactory;\n  this._moddle = moddle;\n  this._translate = translate;\n}\ninherits(ElementFactory, BaseElementFactory);\nElementFactory.$inject = ['bpmnFactory', 'moddle', 'translate'];\nElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;\nElementFactory.prototype.create = function (elementType, attrs) {\n  // no special magic for labels,\n  // we assume their businessObjects have already been created\n  // and wired via attrs\n  if (elementType === 'label') {\n    return this.baseCreate(elementType, assign({\n      type: 'label'\n    }, DEFAULT_LABEL_SIZE, attrs));\n  }\n  return this.createBpmnElement(elementType, attrs);\n};\nElementFactory.prototype.createBpmnElement = function (elementType, attrs) {\n  var size,\n    translate = this._translate;\n  attrs = attrs || {};\n  var businessObject = attrs.businessObject;\n  if (!businessObject) {\n    if (!attrs.type) {\n      throw new Error(translate('no shape type specified'));\n    }\n    businessObject = this._bpmnFactory.create(attrs.type);\n  }\n  if (!businessObject.di) {\n    if (elementType === 'root') {\n      businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else if (elementType === 'connection') {\n      businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else {\n      businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {\n        id: businessObject.id + '_di'\n      });\n    }\n  }\n  if (is(businessObject, 'bpmn:Group')) {\n    attrs = assign({\n      isFrame: true\n    }, attrs);\n  }\n  if (attrs.di) {\n    assign(businessObject.di, attrs.di);\n    delete attrs.di;\n  }\n  applyAttributes(businessObject, attrs, ['processRef', 'isInterrupting', 'associationDirection', 'isForCompensation']);\n  if (attrs.isExpanded) {\n    applyAttribute(businessObject.di, attrs, 'isExpanded');\n  }\n  if (is(businessObject, 'bpmn:ExclusiveGateway')) {\n    businessObject.di.isMarkerVisible = true;\n  }\n  var eventDefinitions, newEventDefinition;\n  if (attrs.eventDefinitionType) {\n    eventDefinitions = businessObject.get('eventDefinitions') || [];\n    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);\n    if (attrs.eventDefinitionType === 'bpmn:ConditionalEventDefinition') {\n      newEventDefinition.condition = this._bpmnFactory.create('bpmn:FormalExpression');\n    }\n    eventDefinitions.push(newEventDefinition);\n    newEventDefinition.$parent = businessObject;\n    businessObject.eventDefinitions = eventDefinitions;\n    delete attrs.eventDefinitionType;\n  }\n  size = this._getDefaultSize(businessObject);\n  attrs = assign({\n    businessObject: businessObject,\n    id: businessObject.id\n  }, size, attrs);\n  return this.baseCreate(elementType, attrs);\n};\nElementFactory.prototype._getDefaultSize = function (semantic) {\n  if (is(semantic, 'bpmn:SubProcess')) {\n    if (isExpanded(semantic)) {\n      return {\n        width: 350,\n        height: 200\n      };\n    } else {\n      return {\n        width: 100,\n        height: 80\n      };\n    }\n  }\n  if (is(semantic, 'bpmn:Task')) {\n    return {\n      width: 100,\n      height: 80\n    };\n  }\n  if (is(semantic, 'bpmn:Gateway')) {\n    return {\n      width: 50,\n      height: 50\n    };\n  }\n  if (is(semantic, 'bpmn:Event')) {\n    return {\n      width: 36,\n      height: 36\n    };\n  }\n  if (is(semantic, 'bpmn:Participant')) {\n    if (isExpanded(semantic)) {\n      return {\n        width: 600,\n        height: 250\n      };\n    } else {\n      return {\n        width: 400,\n        height: 60\n      };\n    }\n  }\n  if (is(semantic, 'bpmn:Lane')) {\n    return {\n      width: 400,\n      height: 100\n    };\n  }\n  if (is(semantic, 'bpmn:DataObjectReference')) {\n    return {\n      width: 36,\n      height: 50\n    };\n  }\n  if (is(semantic, 'bpmn:DataStoreReference')) {\n    return {\n      width: 50,\n      height: 50\n    };\n  }\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return {\n      width: 100,\n      height: 30\n    };\n  }\n  if (is(semantic, 'bpmn:Group')) {\n    return {\n      width: 300,\n      height: 300\n    };\n  }\n  return {\n    width: 100,\n    height: 80\n  };\n};\n\n/**\n * Create participant.\n *\n * @param {boolean|Object} [attrs] attrs\n *\n * @returns {djs.model.Shape}\n */\nElementFactory.prototype.createParticipantShape = function (attrs) {\n  if (!isObject(attrs)) {\n    attrs = {\n      isExpanded: attrs\n    };\n  }\n  attrs = assign({\n    type: 'bpmn:Participant'\n  }, attrs || {});\n\n  // participants are expanded by default\n  if (attrs.isExpanded !== false) {\n    attrs.processRef = this._bpmnFactory.create('bpmn:Process');\n  }\n  return this.createShape(attrs);\n};\n\n// helpers //////////////////////\n\n/**\n * Apply attributes from a map to the given element,\n * remove attribute from the map on application.\n *\n * @param {Base} element\n * @param {Object} attrs (in/out map of attributes)\n * @param {Array<string>} attributeNames name of attributes to apply\n */\nfunction applyAttributes(element, attrs, attributeNames) {\n  forEach(attributeNames, function (property) {\n    if (attrs[property] !== undefined) {\n      applyAttribute(element, attrs, property);\n    }\n  });\n}\n\n/**\n * Apply named property to element and drain it from the attrs\n * collection.\n *\n * @param {Base} element\n * @param {Object} attrs (in/out map of attributes)\n * @param {string} attributeName to apply\n */\nfunction applyAttribute(element, attrs, attributeName) {\n  element[attributeName] = attrs[attributeName];\n  delete attrs[attributeName];\n}","map":null,"metadata":{},"sourceType":"module"}