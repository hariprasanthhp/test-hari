{"ast":null,"code":"import * as constants from \"../../../../shared/constants/marketing.constants\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../marketing-subscrib-chart/marketing-explore-data-subscriberapi.service\";\nimport * as i2 from \"./explore-data-common.service\";\nimport * as i3 from \"src/app-services/translate.service\";\nexport let MarketingExploreDataAssignerService = /*#__PURE__*/(() => {\n  class MarketingExploreDataAssignerService {\n    constructor(marketingExploreDataSubscriberApiService, marketingExploreCommonService, translateService) {\n      this.marketingExploreDataSubscriberApiService = marketingExploreDataSubscriberApiService;\n      this.marketingExploreCommonService = marketingExploreCommonService;\n      this.translateService = translateService;\n      this.language = this.translateService.defualtLanguage;\n      this.languageSubject = this.translateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n    }\n    //  CATEGORIES ASSIGNER\n    assignCategoriesFunction(arrayOrObj) {\n      let series = Object.values(arrayOrObj);\n      let categories = Object.values(series);\n      let categoriesArray = [];\n      categories.forEach(el => {\n        categoriesArray.push(...Object.keys(el));\n      });\n      return categoriesArray;\n    }\n    //  SERIES ASSIGNER\n    assignSeriesFunction(arrayOrObj) {\n      let series = Object.values(arrayOrObj);\n      let categories = Object.values(series);\n      let seriesArray = [];\n      categories.forEach(el => {\n        if (Object.values(el).length >= 1) {\n          let newArray = Object.values(el);\n          seriesArray.push(...Object.values(newArray));\n        } else {\n          seriesArray.push(...Object.values(el));\n        }\n      });\n      return seriesArray;\n    }\n    // ARRAY & OBJECT SUM\n    getArraySum(value) {\n      let arrayData = value;\n      if (typeof arrayData == 'object') {\n        arrayData = Object.values(value);\n      }\n      let sum = value.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n      return sum;\n    }\n    // GET OBJECT LENGTH\n    keyLength(data) {\n      let keys = [];\n      for (const key in data) {\n        if (data.hasOwnProperty(key)) {\n          keys.push(key);\n        }\n        return keys.length;\n      }\n    }\n    // ARRAY ELEMENT SPLICE\n    elementRemover(array, arrayElement) {\n      let returnArray = [];\n      array.forEach(el => {\n        if (el != arrayElement) {\n          returnArray.push(el);\n        }\n      });\n      return returnArray;\n    }\n    //DATA ASSIGNERS\n    // SUBSCRIBERS DATA USAGE\n    subscriberDataUsageDataFormatter(data) {\n      let results = {};\n      results['series'] = this.assignSeriesFunction(data);\n      var categories = this.assignCategoriesFunction(data);\n      results['totalSubs'] = +this.marketingExploreDataSubscriberApiService.getActiveSubscribersCount();\n      var resultcategory = [];\n      for (var i = 0; i < categories.length; i++) {\n        var key = categories[i];\n        const sizes = ['GB', 'TB'];\n        var size1 = \"\";\n        var size2 = \"\";\n        var value1 = \"\";\n        var value2 = \"\";\n        var conversion1 = \"\";\n        var conversion2 = \"\";\n        var keydata = key.split(\"-\");\n        if (keydata[0] != null && keydata[0] != undefined && keydata.length == 2) {\n          if (Number(keydata[0]) >= 1000) {\n            size1 = sizes[1];\n            if (keydata[0].includes('001')) {\n              let value = keydata[0];\n              value1 = ((Number(value) + 9) / 1000).toFixed(2);\n            } else {\n              value1 = (keydata[0] / 1000).toFixed(2);\n            }\n          } else if (Number(keydata[0]) < 1000) {\n            size1 = sizes[0];\n            value1 = keydata[0];\n            // if(Number(keydata[0] == 501)) {\n            //     size1 = sizes[0];\n            //   }\n          }\n\n          conversion1 = value1 + size1;\n        }\n        if (keydata[1] != null && keydata[1] != undefined && keydata.length == 2) {\n          if (Number(keydata[1]) >= 1000) {\n            size2 = sizes[1];\n            if (keydata[1].includes('001')) {\n              let value = keydata[1];\n              value2 = ((Number(value) + 9) / 1000).toFixed(2);\n            } else {\n              value2 = (keydata[1] / 1000).toFixed(2);\n            }\n            // value2 = ((keydata[1] + 9) / 1000).toFixed(2);\n          } else if (Number(keydata[1]) < 1000) {\n            size2 = sizes[0];\n            value2 = keydata[1];\n          }\n          conversion2 = \"-\" + value2 + size2;\n        } else {\n          var keydata = key.split(\"+\");\n          if (Number(keydata[0]) >= 1000) {\n            size1 = sizes[1];\n            if (keydata[0].includes('001')) {\n              let value = keydata[0];\n              value1 = ((Number(value) + 9) / 1000).toFixed(2);\n            } else {\n              value1 = (keydata[0] / 1000).toFixed(2);\n            }\n            // value1 = ((keydata[0] + 9) / 1000).toFixed(2);\n          } else if (Number(keydata[0]) < 1000) {\n            size1 = sizes[0];\n            value1 = keydata[0];\n          }\n          conversion1 = value1 + size1 + \"+\";\n        }\n        resultcategory.push(conversion1 + conversion2);\n      }\n      results['categories'] = resultcategory;\n      return results;\n    }\n    // STREAMING,GAMING,WFH SUBSCRIBERS\n    streamGameWFHsubscribersDataFormatter(data, seriesNames) {\n      let map = {};\n      let series = [];\n      let categories = [];\n      let totals = {};\n      for (let i = 0; i < seriesNames.length; i++) {\n        for (let j in data) {\n          if (data.hasOwnProperty(j)) {\n            if (!map[seriesNames[i]]) {\n              map[seriesNames[i]] = [];\n            }\n            for (let k in data[j]) {\n              // single item object\n              if (data[j].hasOwnProperty(k)) {\n                if (i == 0) {\n                  // only save the categories during first outer-outer loop\n                  categories.push(k);\n                }\n                map[seriesNames[i]].push(data[j][k][i]);\n                if (totals[k]) {\n                  totals[k] += data[j][k][i];\n                } else {\n                  totals[k] = data[j][k][i];\n                }\n              }\n            }\n          }\n        }\n      }\n      for (let i = 0; i < seriesNames.length; i++) {\n        if (seriesNames.hasOwnProperty(i)) {\n          series.push({\n            name: seriesNames[i],\n            data: map[seriesNames[i]] != undefined ? map[seriesNames[i]] : []\n          });\n        }\n      }\n      return {\n        categories: categories,\n        series: series,\n        totals: totals\n      };\n    }\n    // DATA USAGE TRENDS\n    dataUsageTrendsDataFormater(data) {\n      let returnDataObject = {};\n      let categories = [];\n      let series = [];\n      let streamingSeriesObject = {\n        name: 'Streaming Usage (TB)',\n        data: []\n      };\n      let totalSeriesObject = {\n        name: 'Total Usage (TB)',\n        data: []\n      };\n      data.streaming.forEach(el => {\n        for (const key in el) {\n          if (Object.prototype.hasOwnProperty.call(el, key)) {\n            categories.push(key);\n            streamingSeriesObject.data.push(el[key] != 0 ? Math.floor(el[key] / 1024) : 0);\n          }\n        }\n      });\n      data.total.forEach(el => {\n        for (const key in el) {\n          if (Object.prototype.hasOwnProperty.call(el, key)) {\n            totalSeriesObject.data.push(el[key] != 0 ? Math.floor(el[key] / 1024) : 0);\n          }\n        }\n      });\n      series.push(totalSeriesObject, streamingSeriesObject);\n      returnDataObject['categories'] = categories;\n      returnDataObject['series'] = series;\n      return returnDataObject;\n    }\n    // SUBSCRIBER ACTIVITY TRENDS\n    subscriberActivityTrendsDataForming(data) {\n      let returnDataObject = {};\n      let categories = [];\n      let series = [];\n      let gamingSeriesObject = {\n        name: this.language['Gaming_Title'],\n        data: []\n      };\n      let streamingSeriesObject = {\n        name: this.language['Streaming_Title'],\n        data: []\n      };\n      let wfhSeriesObject = {\n        name: this.language['Work From Home Subscribers'],\n        data: []\n      };\n      // let gamingSeriesObject;\n      // let streamingSeriesObject;\n      // let wfhSeriesObject;\n      // if (sessionStorage.getItem('defaultLanguage') == 'fr') {\n      //     gamingSeriesObject = { name: \"Abonnés joueurs\", data: [] }\n      //     streamingSeriesObject = { name: 'Abonnés vidéo', data: [] };\n      //     wfhSeriesObject = { name: 'Abonnés travaillant à la maison', data: [] };\n      // } else {\n      //     gamingSeriesObject = { name: \"Gaming Subscribers\", data: [] }\n      //     streamingSeriesObject = { name: 'Streaming Subscribers', data: [] };\n      //     wfhSeriesObject = { name: 'Work From Home Subscribers', data: [] };\n      // }\n      data.streaming.forEach(el => {\n        for (const key in el) {\n          if (Object.prototype.hasOwnProperty.call(el, key)) {\n            categories.push(key);\n            streamingSeriesObject.data.push(el[key]);\n          }\n        }\n      });\n      data['work from home'].forEach(el => {\n        for (const key in el) {\n          if (Object.prototype.hasOwnProperty.call(el, key)) {\n            wfhSeriesObject.data.push(el[key]);\n          }\n        }\n      });\n      data.gaming.forEach(el => {\n        for (const key in el) {\n          if (Object.prototype.hasOwnProperty.call(el, key)) {\n            gamingSeriesObject.data.push(el[key]);\n          }\n        }\n      });\n      series.push(streamingSeriesObject, wfhSeriesObject, gamingSeriesObject);\n      returnDataObject['categories'] = categories;\n      returnDataObject['series'] = series;\n      return returnDataObject;\n    }\n    // DEVICE PER HOUSEHOLD\n    devicePerHouseHoldDataFormater(data) {\n      let results = {};\n      results['series'] = this.assignSeriesFunction(data);\n      results['categories'] = this.assignCategoriesFunction(data);\n      results['totalSubs'] = this.getArraySum(results['series']);\n      return results;\n    }\n    // HOUSEHOLD DEVICES TRENDS\n    houseHoldDataForming(data) {\n      let returnObject = {};\n      returnObject['categories'] = data.numberOfDevices.map(el => {\n        return Object.keys(el);\n      });\n      returnObject[\"numberOfDevices\"] = data.numberOfDevices.map(el => {\n        el = Object.values(el)[0];\n        return el == null || el == 'null' ? [0] : [el];\n      });\n      returnObject['wifiScore'] = data.wifiScore.map(el => {\n        el = Object.values(el)[0];\n        return el == null || el == 'null' ? [0] : [el];\n      });\n      return returnObject;\n    }\n    // SERVICE MODULE ADOPTION  & WIFI DEVICE CATEGORY TRENDS\n    commonDataFormatter(results, dataFormatFunc = undefined) {\n      let categories = [];\n      let series = [];\n      let index = 0;\n      for (let i in results) {\n        if (results.hasOwnProperty(i)) {\n          let name = i;\n          let data = [];\n          for (let j in results[i]) {\n            if (results[i].hasOwnProperty(j)) {\n              let item = results[i][j];\n              for (let k in item) {\n                // expecting only one\n                if (item.hasOwnProperty(k)) {\n                  if (index == 0) {\n                    // assumes symertical categories\n                    categories.push(k);\n                  }\n                  item[k] = item[k] == null ? 0 : item[k];\n                  data.push(dataFormatFunc ? dataFormatFunc(item[k]) : item[k]);\n                }\n              }\n            }\n          }\n          series.push({\n            name: name,\n            data: data\n          });\n        }\n        index++;\n      }\n      return {\n        categories: categories,\n        series: series\n      };\n    }\n    // BLOCKED THREATS INSIGHTS\n    blockThreatsInsightsDataFormatter(results) {\n      var rearrange = []; // reformat for Highcharts pie data series\n      var longline = -1;\n      for (var i = 0; i < results.length; i++) {\n        for (var j in results[i]) {\n          if (results[i].hasOwnProperty(j)) {\n            rearrange.push([j, results[i][j]]);\n            // look for a name that has commas\n            if (j.indexOf(\",\") != -1) {\n              longline = i;\n            }\n          }\n        }\n      }\n      if (longline >= 0 && longline < rearrange.length) {\n        var temp = rearrange[1];\n        rearrange[1] = rearrange[longline];\n        rearrange[longline] = temp;\n      }\n      return rearrange;\n    }\n    // USAGE BY APPLICATION && AQUISITION INLINE CHART \n    usageByApplicationDataFormatter(data) {\n      let returnData = [];\n      for (const item of data) {\n        for (var key in item) {\n          returnData.push({\n            \"name\": key,\n            \"originalValue\": item[key],\n            \"y\": item[key]\n          });\n        }\n      }\n      return returnData;\n    }\n    // SOCIAL CHANNEL HEAT MAP\n    socialChannelDataFormatter(data) {\n      let results = {};\n      results[\"xcategories\"] = constants.HeatMap.XCategories;\n      results[\"ycategories\"] = [this.language.Sunday, this.language.Monday, this.language.Tuesday, this.language.Wednesday, this.language.Thursday, this.language.Friday, this.language.Saturday];\n      results[\"heatmapdata\"] = data.data ? data.data : [];\n      return results;\n    }\n    // USAGE BY APP DRILL DOWN\n    usageByAppDrillDownDataFormatter(data) {\n      let returnArray = [];\n      data.forEach(el => {\n        let obj = {\n          appName: Object.keys(el).toString(),\n          totalUsage: '',\n          pctUsage: '',\n          avgSubs: '',\n          avgPctSubs: ''\n        };\n        Object.values(el).forEach(el => {\n          obj.totalUsage = el[0].toFixed(1);\n          obj.pctUsage = (el[1] * 100).toFixed(1);\n          obj.avgSubs = el[2];\n          obj.avgPctSubs = (el[3] * 100).toFixed(1);\n        });\n        returnArray.push(obj);\n      });\n      console.log(returnArray, 'returnArray');\n      return returnArray;\n    }\n    // TOP APP & TOP GAMING APP\n    topAppData(data) {\n      let topapps = [];\n      for (const item of data) {\n        for (var key in item) {\n          topapps.push({\n            \"application\": key,\n            'application1': key,\n            \"average\": item[key][0],\n            \"percentage\": (item[key][1] * 100).toFixed(1)\n          });\n        }\n      }\n      return topapps;\n    }\n    topGamingAppData(data) {\n      let topapps = [];\n      for (const item of data) {\n        for (var key in item) {\n          topapps.push({\n            \"application\": key,\n            'application1': this.marketingExploreCommonService.gamingReplacer(key),\n            \"average\": item[key][0],\n            \"percentage\": (item[key][1] * 100).toFixed(1)\n          });\n        }\n      }\n      return topapps;\n    }\n    topAppDrillDownDataFormatter(data) {\n      let retuenArray = [];\n      for (const item of data) {\n        for (var key in item) {\n          retuenArray.push({\n            \"date\": key,\n            \"userCount\": item[key][0],\n            \"userPercentage\": (item[key][1] * 100).toFixed(1)\n          });\n        }\n      }\n      return retuenArray;\n    }\n    // SOCIAL CHANNEL APP LIST\n    socialChannelsListDataFormatter(data) {\n      let returnArray = [];\n      if (data.length > 0) {\n        data.forEach(el => {\n          for (const key in el) {\n            if (Object.prototype.hasOwnProperty.call(el, key)) {\n              returnArray.push({\n                count: el[key],\n                name: key,\n                value: key\n              });\n            }\n          }\n        });\n      }\n      return returnArray;\n    }\n    // CHURN RATE INSIGHTS\n    churnRateInsightsDataFormatter(results) {\n      let returnObject = {};\n      var categories = [];\n      var seriesObj = {};\n      var totalObj = {};\n      var total = 0;\n      var categoryFeatureTotal = [];\n      var categoryExistingTotal = [];\n      let ndata = {};\n      let types = {};\n      results.forEach(element => {\n        if (typeof element === 'object') {\n          Object.keys(element).forEach(monthKey => {\n            ndata[monthKey] = {};\n            if (element[monthKey]) {\n              element[monthKey].forEach(dataObj => {\n                if (typeof dataObj === 'object') {\n                  Object.keys(dataObj).forEach(typeKey => {\n                    if (dataObj[typeKey]) {\n                      ndata[monthKey][typeKey] = dataObj[typeKey];\n                    }\n                    types[typeKey] = typeKey;\n                  });\n                }\n              });\n            }\n          });\n        }\n      });\n      //  console.log(ndata);\n      Object.keys(ndata).forEach(monthKey => {\n        var monthlyNewTotal = 0;\n        var monthlyExistingTotal = 0;\n        for (const key in types) {\n          if (types.hasOwnProperty(key)) {\n            let newSubsExistingSubs = [];\n            if (ndata[monthKey][key]) {\n              newSubsExistingSubs = ndata[monthKey][key];\n            } else {\n              newSubsExistingSubs = [null, null];\n            }\n            let tier = key;\n            if (!seriesObj[tier]) {\n              seriesObj[tier] = [];\n            }\n            seriesObj[tier].push(newSubsExistingSubs[0]);\n            monthlyNewTotal += Number(newSubsExistingSubs[0]);\n            total += Number(newSubsExistingSubs[0]);\n            if (!totalObj[tier]) {\n              totalObj[tier] = [];\n            }\n            totalObj[tier].push(newSubsExistingSubs[1]);\n            monthlyExistingTotal += Number(newSubsExistingSubs[1]);\n          }\n        }\n        categories.push(String(monthKey));\n        categoryFeatureTotal.push(monthlyNewTotal);\n        categoryExistingTotal.push(monthlyExistingTotal);\n      });\n      let series = [];\n      for (const item in seriesObj) {\n        let value, key;\n        if (seriesObj.hasOwnProperty(item)) {\n          value = seriesObj[item];\n          key = item;\n        }\n        series.push({\n          name: key,\n          data: value\n        });\n      }\n      ;\n      returnObject[\"categories\"] = categories;\n      returnObject[\"categoryFeatureTotal\"] = categoryFeatureTotal;\n      returnObject[\"series\"] = series;\n      returnObject['totalObj'] = totalObj;\n      returnObject['categoryExistingTotal'] = categoryExistingTotal;\n      returnObject['total'] = total;\n      //  console.log(returnObject);\n      return returnObject;\n    }\n    // churnRateInsightsDataFormatter(results) {\n    //     let returnObject = {};\n    //     var categories = [];\n    //     var seriesObj = {};\n    //     var totalObj = {};\n    //     var total = 0;\n    //     var categoryFeatureTotal = [];\n    //     var categoryExistingTotal = [];\n    //     let ndata = {};\n    //     let types = {};\n    //     results.forEach((element: any) => {\n    //         if (typeof element === 'object') {\n    //             Object.keys(element).forEach((monthKey: any) => {\n    //                 ndata[monthKey] = {};\n    //                 if (element[monthKey]) {\n    //                     element[monthKey].forEach((dataObj: any) => {\n    //                         if (typeof dataObj === 'object') {\n    //                             Object.keys(dataObj).forEach((typeKey: any) => {\n    //                                 if (dataObj[typeKey]) {\n    //                                     ndata[monthKey][typeKey] = dataObj[typeKey];\n    //                                 }\n    //                                 types[typeKey] = typeKey;\n    //                             });\n    //                         }\n    //                     });\n    //                 }\n    //             });\n    //         }\n    //     });\n    //     console.log(ndata);\n    //     Object.keys(ndata).forEach(monthKey => {\n    //         var monthlyNewTotal = 0;\n    //         var monthlyExistingTotal = 0;\n    //         for (const key in types) {\n    //             if (types.hasOwnProperty(key)) {\n    //                 let newSubsExistingSubs = [];\n    //                 if (ndata[monthKey][key]) {\n    //                     newSubsExistingSubs = ndata[monthKey][key];\n    //                 } else {\n    //                     newSubsExistingSubs = [null, null];\n    //                 }\n    //                 let tier = key;\n    //                 if (!seriesObj[tier]) {\n    //                     seriesObj[tier] = [];\n    //                 }\n    //                 seriesObj[tier].push(newSubsExistingSubs[0]);\n    //                 monthlyNewTotal += Number(newSubsExistingSubs[0]);\n    //                 total += Number(newSubsExistingSubs[0]);\n    //                 if (!totalObj[tier]) {\n    //                     totalObj[tier] = [];\n    //                 }\n    //                 totalObj[tier].push(newSubsExistingSubs[1]);\n    //                 monthlyExistingTotal += Number(newSubsExistingSubs[1]);\n    //             }\n    //         }\n    //         categories.push(String(monthKey));\n    //         categoryFeatureTotal.push(monthlyNewTotal);\n    //         categoryExistingTotal.push(monthlyExistingTotal);\n    //     });\n    //     let series = [];\n    //     for (const item in seriesObj) {\n    //         let value, key;\n    //         if (seriesObj.hasOwnProperty(item)) {\n    //             value = seriesObj[item]\n    //             key = item;\n    //         }\n    //         series.push({\n    //             name: key,\n    //             data: value,\n    //         });\n    //     };\n    //     returnObject[\"categories\"] = categories;\n    //     returnObject[\"categoryFeatureTotal\"] = categoryFeatureTotal;\n    //     returnObject[\"series\"] = series;\n    //     returnObject['totalObj'] = totalObj;\n    //     returnObject['categoryExistingTotal'] = categoryExistingTotal;\n    //     returnObject['total'] = total;\n    //     console.log(returnObject);\n    //     return returnObject;\n    // }\n    // CHURN RATE INSIGHTS INLINE CHART DATA \n    churnRateInsightsInlineChartDataFormatter(data) {\n      let returnObject = {\n        competitor: {},\n        deviceTrend: {},\n        serviceTier: {},\n        serviceUsage: {},\n        serviceLimit: {}\n      };\n      let categories = data.map(el => el.month);\n      //  Competitor\n      let competitor = {\n        name: 'Competitor Visit',\n        data: []\n      };\n      let speedTest = {\n        name: 'Speed Test',\n        data: []\n      };\n      returnObject.competitor['categories'] = categories;\n      competitor.data = data.map(el => el.competitor == null ? 0 : el.competitor);\n      speedTest.data = data.map(el => el.speedTest == null ? 0 : el.speedTest);\n      returnObject.competitor['totals'] = +this.getArraySum(speedTest.data) + +this.getArraySum(competitor.data);\n      returnObject.competitor['series'] = [competitor, speedTest];\n      // Device Trends\n      returnObject.deviceTrend = this.acquisitionInnerTableDeviceTrendsDataFormatter(data);\n      returnObject.serviceUsage = this.aquisitionInnerTableSubscriberUsageDataFormatter(data);\n      returnObject.serviceLimit = this.aquisitionInnerTableServiceLimitDataFormatter(data);\n      if (data[0].serviceChangeDesc == null || !undefined) {\n        // serviceTier        \n        let serviceTierScatterData = {\n          name: \"Service Tier Change\",\n          data: data.map(el => el.serviceChangeTier == null ? '' : el.serviceChangeTier),\n          tierDesc: data.map(el => el.serviceChangeDesc == null ? '' : el.serviceChangeDesc),\n          tierDate: data.map(el => el.serviceChangeDate == null ? '' : el.serviceChangeDate)\n        };\n        returnObject.serviceTier['categories'] = categories;\n        returnObject.serviceTier['series'] = [serviceTierScatterData];\n      }\n      return returnObject;\n    }\n    // ACQUISITION REVENUE INSIGHTS\n    aquisitionRevenueDataFormater(results) {\n      let returnObject = {};\n      var axisIndex = 1;\n      var colorIndex = 0;\n      var categories = [];\n      var seriesObj = {};\n      var totalObj = {};\n      var countObj = {};\n      var total = 0;\n      var categoryCurrentRevenueTotal = [];\n      var categoryPotentialRevenueTotal = [];\n      var categoryMissedRevenueTotal = [];\n      var categoryMissedData = [],\n        categoryCurrentData = [];\n      var categoryUserCountTotal = [];\n      var totalMissedRevenue = 0,\n        totalCurrentRevenue = 0;\n      var drilldownObj = {};\n      results.forEach(month => {\n        for (var key in month) {\n          if (month.hasOwnProperty(key)) {\n            var emptyCategory = false;\n            var monthlyCurrentRevenueTotal = 0;\n            var monthlyPotentialRevenueTotal = 0;\n            var monthlyUserCountTotal = 0;\n            colorIndex = 0;\n            if (typeof month[key] === 'object') {\n              month[key].forEach(wrapper => {\n                for (const key in wrapper) {\n                  if (wrapper.hasOwnProperty(key)) {\n                    let currentAndPotentialRevenue = wrapper[key];\n                    let tier = key;\n                    if (!seriesObj[tier]) {\n                      seriesObj[tier] = [];\n                    }\n                    seriesObj[tier].push(currentAndPotentialRevenue[0]);\n                    monthlyCurrentRevenueTotal += Number(currentAndPotentialRevenue[0]);\n                    total += Number(currentAndPotentialRevenue[0]);\n                    if (!totalObj[tier]) {\n                      totalObj[tier] = [];\n                    }\n                    totalObj[tier].push(currentAndPotentialRevenue[1]);\n                    monthlyPotentialRevenueTotal += Number(currentAndPotentialRevenue[1]);\n                    if (!countObj[tier]) {\n                      countObj[tier] = [];\n                    }\n                    countObj[tier].push(currentAndPotentialRevenue[2]);\n                    monthlyUserCountTotal += Number(currentAndPotentialRevenue[2]);\n                    if (!drilldownObj[key]) {\n                      drilldownObj[key] = [];\n                    }\n                    drilldownObj[key].push({\n                      name: tier,\n                      data: [{\n                        name: String(key) + ' Current',\n                        y: currentAndPotentialRevenue[0]\n                      }, {\n                        y: currentAndPotentialRevenue[1] - currentAndPotentialRevenue[0],\n                        name: String(key) + ' Potential'\n                      }],\n                      tooltip: {\n                        valuePrefix: '$'\n                      }\n                    });\n                  }\n                  ;\n                }\n              });\n            }\n            ;\n            if (!emptyCategory || this.keyLength(seriesObj) > 0) {\n              categories.push(String(key));\n            }\n            categoryMissedData.push(Number(monthlyPotentialRevenueTotal) - Number(monthlyCurrentRevenueTotal));\n            categoryCurrentData.push(Number(monthlyCurrentRevenueTotal));\n            axisIndex++;\n            categoryCurrentRevenueTotal.push(monthlyCurrentRevenueTotal);\n            categoryPotentialRevenueTotal.push(monthlyPotentialRevenueTotal);\n            categoryMissedRevenueTotal.push(monthlyPotentialRevenueTotal - monthlyCurrentRevenueTotal);\n            categoryUserCountTotal.push(monthlyUserCountTotal);\n            totalMissedRevenue = totalMissedRevenue + monthlyPotentialRevenueTotal - monthlyCurrentRevenueTotal;\n            totalCurrentRevenue += monthlyCurrentRevenueTotal;\n          }\n        }\n      });\n      var series = [];\n      colorIndex = 0;\n      series.push({\n        name: this.language['currentrevenue'],\n        data: categoryCurrentData\n      });\n      series.push({\n        name: this.language['POTENTIAL REVENUE'],\n        data: categoryMissedData\n      });\n      returnObject[\"series\"] = series;\n      returnObject[\"categories\"] = categories;\n      returnObject['maxPotentialRevenue'] = +totalCurrentRevenue + +totalMissedRevenue;\n      returnObject['actualRevenue'] = totalCurrentRevenue;\n      return returnObject;\n    }\n    // ACQUISITION RATE INSIGHTS   \n    // aquisitionRateInsightsFormatData(results) {\n    //     let returnObject = {};\n    //     var categories = [];\n    //     var seriesObj = {};\n    //     var totalObj = {};\n    //     var total = 0;\n    //     var categoryFeatureTotal = [];\n    //     var categoryExistingTotal = [];\n    //     results.forEach(month => {\n    //         for (var key in month) {\n    //             if (month.hasOwnProperty(key)) {\n    //                 var monthlyNewTotal = 0;\n    //                 var monthlyExistingTotal = 0;\n    //                 if (typeof month[key] === 'object') {\n    //                     month[key].forEach(wrapper => {\n    //                         for (const key in wrapper) {\n    //                             if (wrapper.hasOwnProperty(key)) {\n    //                                 let newSubsExistingSubs = wrapper[key]\n    //                                 let tier = key;\n    //                                 if (!seriesObj[tier]) {\n    //                                     seriesObj[tier] = [];\n    //                                 }\n    //                                 seriesObj[tier].push(newSubsExistingSubs[0]);\n    //                                 monthlyNewTotal += Number(newSubsExistingSubs[0]);\n    //                                 total += Number(newSubsExistingSubs[0]);\n    //                                 if (!totalObj[tier]) {\n    //                                     totalObj[tier] = [];\n    //                                 }\n    //                                 totalObj[tier].push(newSubsExistingSubs[1]);\n    //                                 monthlyExistingTotal += Number(newSubsExistingSubs[1]);\n    //                             }\n    //                         }\n    //                     });\n    //                 }\n    //                 if (this.keyLength(seriesObj) > 0) {\n    //                     categories.push(String(key));\n    //                 }\n    //                 categoryFeatureTotal.push(monthlyNewTotal);\n    //                 categoryExistingTotal.push(monthlyExistingTotal);\n    //             }\n    //         }\n    //     });\n    //     let series = [];\n    //     for (const item in seriesObj) {\n    //         let value, key;\n    //         if (seriesObj.hasOwnProperty(item)) {\n    //             value = seriesObj[item]\n    //             key = item;\n    //         }\n    //         series.push({\n    //             name: key,\n    //             data: value,\n    //         });\n    //     };\n    //     returnObject[\"categories\"] = categories;\n    //     returnObject[\"categoryExistingTotal\"] = categoryExistingTotal;\n    //     returnObject[\"categoryFeatureTotal\"] = categoryFeatureTotal;\n    //     returnObject[\"series\"] = series;\n    //     returnObject['totalObj'] = totalObj;\n    //     returnObject['total'] = total;\n    //     return returnObject\n    // }\n    aquisitionRateInsightsFormatData(results) {\n      let returnObject = {};\n      var categories = [];\n      var seriesObj = {};\n      var totalObj = {};\n      var total = 0;\n      var categoryFeatureTotal = [];\n      var categoryExistingTotal = [];\n      let ndata = {};\n      let types = {};\n      results.forEach(element => {\n        if (typeof element === 'object') {\n          Object.keys(element).forEach(monthKey => {\n            ndata[monthKey] = {};\n            if (element[monthKey]) {\n              element[monthKey].forEach(dataObj => {\n                if (typeof dataObj === 'object') {\n                  Object.keys(dataObj).forEach(typeKey => {\n                    if (dataObj[typeKey]) {\n                      ndata[monthKey][typeKey] = dataObj[typeKey];\n                    }\n                    types[typeKey] = typeKey;\n                  });\n                }\n              });\n            }\n          });\n        }\n      });\n      //   console.log(ndata);\n      Object.keys(ndata).forEach(monthKey => {\n        var monthlyNewTotal = 0;\n        var monthlyExistingTotal = 0;\n        for (const key in types) {\n          if (types.hasOwnProperty(key)) {\n            let newSubsExistingSubs = [];\n            if (ndata[monthKey][key]) {\n              newSubsExistingSubs = ndata[monthKey][key];\n            } else {\n              newSubsExistingSubs = [null, null];\n            }\n            let tier = key;\n            if (!seriesObj[tier]) {\n              seriesObj[tier] = [];\n            }\n            seriesObj[tier].push(newSubsExistingSubs[0]);\n            monthlyNewTotal += Number(newSubsExistingSubs[0]);\n            total += Number(newSubsExistingSubs[0]);\n            if (!totalObj[tier]) {\n              totalObj[tier] = [];\n            }\n            totalObj[tier].push(newSubsExistingSubs[1]);\n            monthlyExistingTotal += Number(newSubsExistingSubs[1]);\n          }\n        }\n        categories.push(String(monthKey));\n        categoryFeatureTotal.push(monthlyNewTotal);\n        categoryExistingTotal.push(monthlyExistingTotal);\n      });\n      let series = [];\n      for (const item in seriesObj) {\n        let value, key;\n        if (seriesObj.hasOwnProperty(item)) {\n          value = seriesObj[item];\n          key = item;\n        }\n        series.push({\n          name: key,\n          data: value\n        });\n      }\n      ;\n      returnObject[\"categories\"] = categories;\n      returnObject[\"categoryFeatureTotal\"] = categoryFeatureTotal;\n      returnObject[\"series\"] = series;\n      returnObject['totalObj'] = totalObj;\n      returnObject['categoryExistingTotal'] = categoryExistingTotal;\n      returnObject['total'] = total;\n      //  console.log(returnObject);\n      return returnObject;\n    }\n    acquisitionInnerTabletopAppData(data) {\n      let topapps = [];\n      for (const item of data) {\n        for (var key in item) {\n          topapps.push({\n            \"application\": key,\n            \"application1\": key,\n            \"usage\": item[key].toFixed(2)\n          });\n        }\n      }\n      return topapps;\n    }\n    // ACQUISITION & CHURN RATE INSIGHTS\n    aquisitionInnerTableSubscriberUsageDataFormatter(data, chartID) {\n      let returnObject = {};\n      let name = chartID == 'churn-rate-insights' ? '' : ' Usage';\n      let gaming = {\n        name: 'Gaming' + name,\n        data: []\n      };\n      let streaming = {\n        name: 'Streaming' + name,\n        data: []\n      };\n      let other = {\n        name: 'Other' + name,\n        data: []\n      };\n      returnObject['categories'] = data.map(el => el.month);\n      gaming.data = data.map(el => el.gamingUsage == null ? 0 : el.gamingUsage);\n      streaming.data = data.map(el => el.streamingUsage == null ? 0 : el.streamingUsage);\n      other.data = data.map(el => el.totalUsage == null ? 0 : el.totalUsage - (el.streamingUsage + el.gamingUsage));\n      let totalValues = data.map(el => el.totalUsage);\n      returnObject['totals'] = (+this.getArraySum(totalValues)).toFixed(2);\n      returnObject['gamingTotals'] = (+this.getArraySum(gaming.data)).toFixed(2);\n      returnObject['streamingTotals'] = (+this.getArraySum(streaming.data)).toFixed(2);\n      returnObject['series'] = [streaming, gaming, other];\n      return returnObject;\n    }\n    aquisitionInnerTableServiceLimitDataFormatter(data) {\n      let returnObject = {};\n      let downStream = {\n        name: `Downstream Limit Hits`,\n        data: []\n      };\n      let upStream = {\n        name: `Upstream Limit Hits`,\n        data: []\n      };\n      returnObject['categories'] = data.map(el => el.month);\n      downStream.data = data.map(el => el.downstreamServiceLimit == null ? 0 : el.downstreamServiceLimit);\n      upStream.data = data.map(el => el.upstreamServiceLimit == null ? 0 : el.upstreamServiceLimit);\n      returnObject['series'] = [upStream, downStream];\n      returnObject['downstreamTotals'] = (+this.getArraySum(downStream.data)).toFixed(0);\n      returnObject['upStreamTotals'] = (+this.getArraySum(upStream.data)).toFixed(0);\n      return returnObject;\n    }\n    acquisitionInnerTableDeviceTrendsDataFormatter(data, page) {\n      let returnObject = {};\n      let type = page ? 'line' : 'column';\n      let wifi = {\n        type: type,\n        name: 'Wi-Fi Score',\n        data: []\n      };\n      let devices = {\n        type: 'line',\n        name: 'Devices',\n        data: []\n      };\n      returnObject['categories'] = data.map(el => el.month);\n      wifi.data = data.map(el => el.wifiScore == null ? 0 : el.wifiScore);\n      if (page) {\n        devices.data = data.map(el => el.connectDevicesCount == null ? 0 : el.connectDevicesCount);\n      } else {\n        devices.data = data.map(el => el.numOfDevices == null ? 0 : el.numOfDevices);\n      }\n      returnObject['series'] = [wifi, devices];\n      let wifiScoreCount = this.elementRemover(wifi.data, 0).length;\n      let deviceCount = this.elementRemover(devices.data, 0).length;\n      // returnObject['wifiScore'] = Math.round((+this.getArraySum(wifi.data)) / (wifiScoreCount != 0 ? wifiScoreCount : 1))\n      // returnObject['connectDevicesCount'] = Math.round((+this.getArraySum(devices.data)) / (deviceCount != 0 ? deviceCount : 1))\n      returnObject['wifiScore'] = (+this.getArraySum(wifi.data)).toFixed(0);\n      returnObject['connectDevicesCount'] = (+this.getArraySum(devices.data)).toFixed(0);\n      return returnObject;\n    }\n    //insight lens formatter\n    deviceWifiTrendDataAssign(data, page) {\n      // let returnObject = {}\n      // let type = page ? 'line' : 'column';\n      // let wifi = { type: 'line', name: this.language.Wi_Fi_Score, data: [] }\n      // let devices = { type: 'line', name: this.language.Devices_1, data: [] }\n      // returnObject['categories'] = data.map(el => el.month);\n      // wifi.data = data.map(el => el.wifiScore == null ? 0 : el.wifiScore)\n      // if (page) {\n      //     devices.data = data.map(el => el.connectDevicesCount == null ? 0 : el.connectDevicesCount)\n      // } else {\n      //     devices.data = data.map(el => el.numOfDevices == null ? 0 : el.numOfDevices)\n      // }\n      // returnObject['series'] = [wifi, devices];\n      // let wifiScoreCount = this.elementRemover(wifi.data, 0).length;\n      // let deviceCount = this.elementRemover(devices.data, 0).length;\n      // returnObject['wifiScore'] = Math.round((+this.getArraySum(wifi.data)) / (wifiScoreCount != 0 ? wifiScoreCount : 1))\n      // returnObject['connectDevicesCount'] = Math.round((+this.getArraySum(devices.data)) / (deviceCount != 0 ? deviceCount : 1))\n      // return returnObject;\n      let returnObject = {};\n      let wifi = {\n        name: this.language.Wi_Fi_Score,\n        data: []\n      };\n      let devices = {\n        name: this.language.Devices_1,\n        data: []\n      };\n      let count;\n      returnObject['categories'] = data.map(el => el.month);\n      wifi.data = data.map(el => el.wifiScore == null ? 0 : el.wifiScore);\n      devices.data = data.map(el => el.connectDevicesCount == null ? 0 : el.connectDevicesCount);\n      //  count.data = data.length\n      //   console.log(devices.data, '***** devices.data*****', wifi.data, count)\n      returnObject['series'] = [wifi, devices];\n      returnObject['wifiScore'] = (+this.getArraySum(wifi.data)).toFixed(0);\n      returnObject['connectDevicesCount'] = (+this.getArraySum(devices.data)).toFixed(0);\n      returnObject['datacount'] = data.length;\n      return returnObject;\n    }\n    competitorDataAssign(data, isSubscriber) {\n      let returnObject = {};\n      let competitor = {\n        name: this.language.Competitor_Visits_1,\n        data: []\n      };\n      let speedTest = {\n        name: this.language.Speed_Tests_1,\n        data: []\n      };\n      returnObject['categories'] = data.map(el => el.month);\n      speedTest.data = data.map(el => el.speedTest == null ? 0 : el.speedTest);\n      if (!isSubscriber) {\n        competitor.data = data.map(el => el.competitor == null ? 0 : el.competitor);\n        returnObject['totals'] = +this.getArraySum(speedTest.data) + +this.getArraySum(competitor.data);\n        returnObject['series'] = [competitor, speedTest];\n        returnObject['speedTest'] = +this.getArraySum(speedTest.data);\n        returnObject['competitor'] = +this.getArraySum(competitor.data);\n      } else {\n        returnObject['totals'] = +this.getArraySum(speedTest.data);\n        returnObject['series'] = [speedTest];\n        returnObject['speedTest'] = +this.getArraySum(speedTest.data);\n      }\n      return returnObject;\n    }\n    serviceLimitDataAssign(data) {\n      let returnObject = {};\n      let downStream = {\n        name: this.language.Downstream_Limit_Hits,\n        data: []\n      };\n      let upStream = {\n        name: this.language.Upstream_Limit_Hits,\n        data: []\n      };\n      returnObject['categories'] = data.map(el => el.month);\n      downStream.data = data.map(el => el.downstreamServiceLimit == null ? 0 : el.downstreamServiceLimit);\n      upStream.data = data.map(el => el.upstreamServiceLimit == null ? 0 : el.upstreamServiceLimit);\n      returnObject['series'] = [downStream, upStream];\n      returnObject['downstreamTotals'] = (+this.getArraySum(downStream.data)).toFixed(0);\n      returnObject['upStreamTotals'] = (+this.getArraySum(upStream.data)).toFixed(0);\n      return returnObject;\n    }\n    subscriberUsageDataAssign(data) {\n      let returnObject = {};\n      let gaming = {\n        name: this.language.Gaming_Usage,\n        data: []\n      };\n      let streaming = {\n        name: this.language.Streaming_Usage,\n        data: []\n      };\n      let other = {\n        name: this.language.Other_Usage,\n        data: []\n      };\n      returnObject['categories'] = data.map(el => el.month);\n      gaming.data = data.map(el => el.gamingUsage == null ? 0 : el.gamingUsage);\n      streaming.data = data.map(el => el.streamingUsage == null ? 0 : el.streamingUsage);\n      other.data = data.map(el => el.totalUsage == null ? 0 : el.totalUsage - (el.streamingUsage + el.gamingUsage));\n      let totalValues = data.map(el => el.totalUsage);\n      returnObject['totals'] = (+this.getArraySum(totalValues)).toFixed(2);\n      returnObject['gamingTotals'] = (+this.getArraySum(gaming.data)).toFixed(2);\n      returnObject['streamingTotals'] = (+this.getArraySum(streaming.data)).toFixed(2);\n      returnObject['series'] = [streaming, gaming, other];\n      return returnObject;\n    }\n    topAppDataFormater(array) {\n      let returnArray = [];\n      array.forEach(el => {\n        returnArray.push({\n          application1: Object.keys(el).toString(),\n          usage: Object.values(el).toString()\n        });\n      });\n      return returnArray;\n    }\n  }\n  MarketingExploreDataAssignerService.ɵfac = function MarketingExploreDataAssignerService_Factory(t) {\n    return new (t || MarketingExploreDataAssignerService)(i0.ɵɵinject(i1.MarketingExploreDataSubscriberApiService), i0.ɵɵinject(i2.MarketingExploreCommonService), i0.ɵɵinject(i3.TranslateService));\n  };\n  MarketingExploreDataAssignerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MarketingExploreDataAssignerService,\n    factory: MarketingExploreDataAssignerService.ɵfac,\n    providedIn: 'root'\n  });\n  return MarketingExploreDataAssignerService;\n})();","map":null,"metadata":{},"sourceType":"module"}