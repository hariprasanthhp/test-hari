{"ast":null,"code":"import { assign, forEach, map } from 'min-dash';\nimport { getWaypointsUpdatingConnections, resizeBounds } from '../../space-tool/SpaceUtil';\nimport { getMovedSourceAnchor, getMovedTargetAnchor, getResizedSourceAnchor, getResizedTargetAnchor } from './helper/AnchorsHelper';\n\n/**\n * Add or remove space by moving and resizing shapes and updating connection waypoints.\n */\nexport default function SpaceToolHandler(modeling) {\n  this._modeling = modeling;\n}\nSpaceToolHandler.$inject = ['modeling'];\nSpaceToolHandler.prototype.preExecute = function (context) {\n  var delta = context.delta,\n    direction = context.direction,\n    movingShapes = context.movingShapes,\n    resizingShapes = context.resizingShapes,\n    start = context.start,\n    oldBounds = {};\n\n  // (1) move shapes\n  this.moveShapes(movingShapes, delta);\n\n  // (2a) save old bounds of resized shapes\n  forEach(resizingShapes, function (shape) {\n    oldBounds[shape.id] = getBounds(shape);\n  });\n\n  // (2b) resize shapes\n  this.resizeShapes(resizingShapes, delta, direction);\n\n  // (3) update connection waypoints\n  this.updateConnectionWaypoints(getWaypointsUpdatingConnections(movingShapes, resizingShapes), delta, direction, start, movingShapes, resizingShapes, oldBounds);\n};\nSpaceToolHandler.prototype.execute = function () {};\nSpaceToolHandler.prototype.revert = function () {};\nSpaceToolHandler.prototype.moveShapes = function (shapes, delta) {\n  var self = this;\n  forEach(shapes, function (element) {\n    self._modeling.moveShape(element, delta, null, {\n      autoResize: false,\n      layout: false,\n      recurse: false\n    });\n  });\n};\nSpaceToolHandler.prototype.resizeShapes = function (shapes, delta, direction) {\n  var self = this;\n  forEach(shapes, function (shape) {\n    var newBounds = resizeBounds(shape, direction, delta);\n    self._modeling.resizeShape(shape, newBounds, null, {\n      attachSupport: false,\n      autoResize: false,\n      layout: false\n    });\n  });\n};\n\n/**\n * Update connections waypoints according to the rules:\n *   1. Both source and target are moved/resized => move waypoints by the delta\n *   2. Only one of source and target is moved/resized => re-layout connection with moved start/end\n */\nSpaceToolHandler.prototype.updateConnectionWaypoints = function (connections, delta, direction, start, movingShapes, resizingShapes, oldBounds) {\n  var self = this,\n    affectedShapes = movingShapes.concat(resizingShapes);\n  forEach(connections, function (connection) {\n    var source = connection.source,\n      target = connection.target,\n      waypoints = copyWaypoints(connection),\n      axis = getAxisFromDirection(direction),\n      layoutHints = {\n        labelBehavior: false\n      };\n    if (includes(affectedShapes, source) && includes(affectedShapes, target)) {\n      // move waypoints\n      waypoints = map(waypoints, function (waypoint) {\n        if (shouldMoveWaypoint(waypoint, start, direction)) {\n          // move waypoint\n          waypoint[axis] = waypoint[axis] + delta[axis];\n        }\n        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {\n          // move waypoint original\n          waypoint.original[axis] = waypoint.original[axis] + delta[axis];\n        }\n        return waypoint;\n      });\n      self._modeling.updateWaypoints(connection, waypoints, {\n        labelBehavior: false\n      });\n    } else if (includes(affectedShapes, source) || includes(affectedShapes, target)) {\n      // re-layout connection with moved start/end\n      if (includes(movingShapes, source)) {\n        layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta);\n      } else if (includes(movingShapes, target)) {\n        layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta);\n      } else if (includes(resizingShapes, source)) {\n        layoutHints.connectionStart = getResizedSourceAnchor(connection, source, oldBounds[source.id]);\n      } else if (includes(resizingShapes, target)) {\n        layoutHints.connectionEnd = getResizedTargetAnchor(connection, target, oldBounds[target.id]);\n      }\n      self._modeling.layoutConnection(connection, layoutHints);\n    }\n  });\n};\n\n// helpers //////////\n\nfunction copyWaypoint(waypoint) {\n  return assign({}, waypoint);\n}\nfunction copyWaypoints(connection) {\n  return map(connection.waypoints, function (waypoint) {\n    waypoint = copyWaypoint(waypoint);\n    if (waypoint.original) {\n      waypoint.original = copyWaypoint(waypoint.original);\n    }\n    return waypoint;\n  });\n}\nfunction getAxisFromDirection(direction) {\n  switch (direction) {\n    case 'n':\n      return 'y';\n    case 'w':\n      return 'x';\n    case 's':\n      return 'y';\n    case 'e':\n      return 'x';\n  }\n}\nfunction shouldMoveWaypoint(waypoint, start, direction) {\n  var relevantAxis = getAxisFromDirection(direction);\n  if (/e|s/.test(direction)) {\n    return waypoint[relevantAxis] > start;\n  } else if (/n|w/.test(direction)) {\n    return waypoint[relevantAxis] < start;\n  }\n}\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}\nfunction getBounds(shape) {\n  return {\n    x: shape.x,\n    y: shape.y,\n    height: shape.height,\n    width: shape.width\n  };\n}","map":null,"metadata":{},"sourceType":"module"}