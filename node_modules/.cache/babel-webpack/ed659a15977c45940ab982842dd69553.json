{"ast":null,"code":"import { sortBy, forEach, filter } from 'min-dash';\nvar AXIS_DIMENSIONS = {\n  horizontal: ['x', 'width'],\n  vertical: ['y', 'height']\n};\nvar THRESHOLD = 5;\n\n/**\n * Groups and filters elements and then trigger even distribution.\n */\nexport default function DistributeElements(modeling) {\n  this._modeling = modeling;\n  this._filters = [];\n\n  // register filter for filtering big elements\n  this.registerFilter(function (elements, axis, dimension) {\n    var elementsSize = 0,\n      numOfShapes = 0,\n      avgDimension;\n    forEach(elements, function (element) {\n      if (element.waypoints || element.labelTarget) {\n        return;\n      }\n      elementsSize += element[dimension];\n      numOfShapes += 1;\n    });\n    avgDimension = Math.round(elementsSize / numOfShapes);\n    return filter(elements, function (element) {\n      return element[dimension] < avgDimension + 50;\n    });\n  });\n}\nDistributeElements.$inject = ['modeling'];\n\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param  {Function} filterFn\n */\nDistributeElements.prototype.registerFilter = function (filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n  this._filters.push(filterFn);\n};\n\n/**\n * Distributes the elements with a given orientation\n *\n * @param  {Array} elements    [description]\n * @param  {string} orientation [description]\n */\nDistributeElements.prototype.trigger = function (elements, orientation) {\n  var modeling = this._modeling;\n  var groups, distributableElements;\n  if (elements.length < 3) {\n    return;\n  }\n  this._setOrientation(orientation);\n  distributableElements = this._filterElements(elements);\n  groups = this._createGroups(distributableElements);\n\n  // nothing to distribute\n  if (groups.length <= 2) {\n    return;\n  }\n  modeling.distributeElements(groups, this._axis, this._dimension);\n  return groups;\n};\n\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param  {Array[Elements]} elements\n *\n * @return {Array[Elements]}\n */\nDistributeElements.prototype._filterElements = function (elements) {\n  var filters = this._filters,\n    axis = this._axis,\n    dimension = this._dimension,\n    distributableElements = [].concat(elements);\n  if (!filters.length) {\n    return elements;\n  }\n  forEach(filters, function (filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n  return distributableElements;\n};\n\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n * \tvar distributableElements = [\n * \t\t{\n * \t\t\trange: {\n * \t\t\t\tmin: 100,\n * \t\t\t\tmax: 200\n * \t\t\t},\n * \t\t\telements: [ { id: 'shape1', .. }]\n * \t\t}\n * \t]\n *\n * @param  {Array} elements\n *\n * @return {Array[Objects]}\n */\nDistributeElements.prototype._createGroups = function (elements) {\n  var rangeGroups = [],\n    self = this,\n    axis = this._axis,\n    dimension = this._dimension;\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  }\n\n  // sort by 'left->right' or 'top->bottom'\n  var sortedElements = sortBy(elements, axis);\n  forEach(sortedElements, function (element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n      range;\n    var previous = rangeGroups[rangeGroups.length - 1];\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = {\n        range: elementRange,\n        elements: [element]\n      };\n      rangeGroups.push(range);\n    }\n  });\n  return rangeGroups;\n};\n\n/**\n * Maps a direction to the according axis and dimension\n *\n * @param  {string} direction 'horizontal' or 'vertical'\n */\nDistributeElements.prototype._setOrientation = function (direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n\n/**\n * Checks if the two ranges intercept each other\n *\n * @param  {Object} rangeA {min, max}\n * @param  {Object} rangeB {min, max}\n *\n * @return {boolean}\n */\nDistributeElements.prototype._hasIntersection = function (rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n\n/**\n * Returns the min and max values for an element\n *\n * @param  {[type]} element   [description]\n * @param  {[type]} axis      [description]\n * @param  {[type]} dimension [description]\n *\n * @return {[type]}           [description]\n */\nDistributeElements.prototype._findRange = function (element) {\n  var axis = element[this._axis],\n    dimension = element[this._dimension];\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};","map":null,"metadata":{},"sourceType":"module"}