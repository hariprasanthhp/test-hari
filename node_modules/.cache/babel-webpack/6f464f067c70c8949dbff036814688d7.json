{"ast":null,"code":"import { closest as domClosest } from 'min-dom';\nimport { toPoint } from '../../util/Event';\nvar HIGH_PRIORITY = 1500;\n\n/**\n * Browsers may swallow certain events (hover, out ...) if users are to\n * fast with the mouse.\n *\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\n *\n * The fix implemented in this component ensure that we\n *\n * 1) have a hover state after a successful drag.move event\n * 2) have an out event when dragging leaves an element\n *\n * @param {ElementRegistry} elementRegistry\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function HoverFix(elementRegistry, eventBus, injector) {\n  var self = this;\n  var dragging = injector.get('dragging', false);\n\n  /**\n   * Make sure we are god damn hovering!\n   *\n   * @param {Event} dragging event\n   */\n  function ensureHover(event) {\n    if (event.hover) {\n      return;\n    }\n    var originalEvent = event.originalEvent;\n    var gfx = self._findTargetGfx(originalEvent);\n    var element = gfx && elementRegistry.get(gfx);\n    if (gfx && element) {\n      // 1) cancel current mousemove\n      event.stopPropagation();\n\n      // 2) emit fake hover for new target\n      dragging.hover({\n        element: element,\n        gfx: gfx\n      });\n\n      // 3) re-trigger move event\n      dragging.move(originalEvent);\n    }\n  }\n  if (dragging) {\n    /**\n     * We wait for a specific sequence of events before\n     * emitting a fake drag.hover event.\n     *\n     * Event Sequence:\n     *\n     * drag.start\n     * drag.move >> ensure we are hovering\n     */\n    eventBus.on('drag.start', function (event) {\n      eventBus.once('drag.move', HIGH_PRIORITY, function (event) {\n        ensureHover(event);\n      });\n    });\n  }\n\n  /**\n   * We make sure that element.out is always fired, even if the\n   * browser swallows an element.out event.\n   *\n   * Event sequence:\n   *\n   * element.hover\n   * (element.out >> sometimes swallowed)\n   * element.hover >> ensure we fired element.out\n   */\n  (function () {\n    var hoverGfx;\n    var hover;\n    eventBus.on('element.hover', function (event) {\n      // (1) remember current hover element\n      hoverGfx = event.gfx;\n      hover = event.element;\n    });\n    eventBus.on('element.hover', HIGH_PRIORITY, function (event) {\n      // (3) am I on an element still?\n      if (hover) {\n        // (4) that is a problem, gotta \"simulate the out\"\n        eventBus.fire('element.out', {\n          element: hover,\n          gfx: hoverGfx\n        });\n      }\n    });\n    eventBus.on('element.out', function () {\n      // (2) unset hover state if we correctly outed us *GG*\n      hoverGfx = null;\n      hover = null;\n    });\n  })();\n  this._findTargetGfx = function (event) {\n    var position, target;\n    if (!(event instanceof MouseEvent)) {\n      return;\n    }\n    position = toPoint(event);\n\n    // damn expensive operation, ouch!\n    target = document.elementFromPoint(position.x, position.y);\n    return getGfx(target);\n  };\n}\nHoverFix.$inject = ['elementRegistry', 'eventBus', 'injector'];\n\n// helpers /////////////////////\n\nfunction getGfx(target) {\n  return domClosest(target, 'svg, .djs-element', true);\n}","map":null,"metadata":{},"sourceType":"module"}