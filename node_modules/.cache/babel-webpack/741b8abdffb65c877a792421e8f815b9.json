{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let IpSubnetCalculatorService = /*#__PURE__*/(() => {\n  class IpSubnetCalculatorService {\n    constructor() {}\n    /**\r\n     * Calculates an optimal set of IP masks for the given IP address range\r\n     *\r\n     * @param {string} ipStart Lowest IP in the range to be calculated in string format (\"123.123.123.123\")\r\n     * @param {string} ipEnd Highest IP (inclusive) in the range to be calculated in string format (\"123.123.123.123\")\r\n     *\r\n     * @return The function returns null in case of an error. Otherwise, an array containing one or more subnet\r\n     *         masks is returned:\r\n     *\r\n     * <code>var result = [\r\n     *      {\r\n     *          ipLow              : 2071689984,\r\n     *          ipLowStr           : \"123.123.123.0\",\r\n     *          ipHigh             : 2071690239,\r\n     *          ipHighStr          : \"123.123.123.255\",\r\n     *          prefixMask         : 4294967040,\r\n     *          prefixMaskStr      : \"255.255.255.0\",\r\n     *          prefixSize         : 24,\r\n     *          invertedMask       : 255,\r\n     *          invertedMaskStr    : \"0.0.0.255\",\r\n     *          invertedMaskSize   : 8\r\n     *      },\r\n     *\r\n     *      ...\r\n     *  ];\r\n     * </code>\r\n     * @public\r\n     */\n    calculate(ipStart, ipEnd) {\n      var ipStartNum, ipEndNum, ipCurNum;\n      var rangeCollection = [];\n      if (ipStart === '' || ipStart === null || ipStart === false || ipEnd === '' || ipEnd === null || ipEnd === false) {\n        return null;\n      }\n      ipStartNum = this.toDecimal(ipStart);\n      ipEndNum = this.toDecimal(ipEnd);\n      if (ipEndNum < ipStartNum) {\n        return null;\n      }\n      ipCurNum = ipStartNum;\n      while (ipCurNum <= ipEndNum) {\n        var optimalRange = this.getOptimalRange(ipCurNum, ipEndNum);\n        if (optimalRange === null) {\n          return null;\n        }\n        rangeCollection.push(optimalRange);\n        ipCurNum = optimalRange.ipHigh + 1;\n      }\n      return rangeCollection;\n    }\n    /**\r\n     * Calculates a subnet mask from CIDR prefix.\r\n     *\r\n     * @param {string} ip IP address in string format\r\n     * @param {int} prefixSize Number of relevant bits in the subnet mask\r\n     * @return {object|null} Returns null in case of an error, and a subnet data object otherwise.\r\n     *         For details about the subnet data object, see documentation of\r\n     *         getMaskRange()\r\n     * @public\r\n     */\n    calculateSubnetMask(ip, prefixSize) {\n      if (ip === '' || ip === null || ip === false || prefixSize === '' || prefixSize === null || prefixSize === false) {\n        return null;\n      }\n      var ipNum = this.toDecimal(ip);\n      return this.getMaskRange(ipNum, prefixSize);\n    }\n    /**\r\n     * Calculates a CIDR prefix from subnet mask.\r\n     *\r\n     * @param {string} ip IP address in string format\r\n     * @param {string} subnetMask IP subnet mask in string format (\"255.255.255.0\")\r\n     * @return {object|null} Returns null in case of an error, and a subnet data object otherwise.\r\n     *         For details about the subnet data object, see documentation of\r\n     *         getMaskRange()\r\n     * @public\r\n     */\n    calculateCIDRPrefix(ip, subnetMask) {\n      if (ip === '' || ip === null || ip === false || subnetMask === '' || subnetMask === null || subnetMask === false) {\n        return null;\n      }\n      var ipNum = this.toDecimal(ip);\n      var subnetMaskNum = this.toDecimal(subnetMask);\n      var prefix = 0;\n      var newPrefix = 0;\n      var prefixSize;\n      for (prefixSize = 0; prefixSize < 32; prefixSize++) {\n        newPrefix = prefix + (1 << 32 - (prefixSize + 1)) >>> 0;\n        if ((subnetMaskNum & newPrefix) >>> 0 !== newPrefix) {\n          break;\n        }\n        prefix = newPrefix;\n      }\n      return this.getMaskRange(ipNum, prefixSize);\n    }\n    /**\r\n     * Finds the largest subnet mask that begins from ipNum and does not\r\n     * exceed ipEndNum.\r\n     *\r\n     * @param {int} ipNum IP start point\r\n     * @param {int} ipEndNum IP end point\r\n     * @return {object|null} Returns null on failure, otherwise an object with the following fields:\r\n     *\r\n     * ipLow - Decimal representation of the lowest IP address in the subnet\r\n     * ipLowStr - String representation of the lowest IP address in the subnet\r\n     * ipHigh - Decimal representation of the highest IP address in the subnet\r\n     * ipHighStr - String representation of the highest IP address in the subnet\r\n     * prefixMask - Bitmask matching prefixSize\r\n     * prefixMaskStr - String / IP representation of the bitmask\r\n     * prefixSize - Size of the prefix\r\n     * invertedMask - Bitmask matching the inverted subnet mask\r\n     * invertedMaskStr - String / IP representation of the inverted mask\r\n     * invertedSize - Number of relevant bits in the inverted mask\r\n     *\r\n     */\n    getOptimalRange(ipNum, ipEndNum) {\n      var prefixSize;\n      var optimalRange = null;\n      for (prefixSize = 32; prefixSize >= 0; prefixSize--) {\n        var maskRange = this.getMaskRange(ipNum, prefixSize);\n        if (maskRange.ipLow === ipNum && maskRange.ipHigh <= ipEndNum) {\n          optimalRange = maskRange;\n        } else {\n          break;\n        }\n      }\n      return optimalRange;\n    }\n    /**\r\n     * Calculates details of a CIDR subnet\r\n     *\r\n     * @param {int} ipNum Decimal IP address\r\n     * @param {int} prefixSize Subnet mask size in bits\r\n     * @return {object} Returns an object with the following fields:\r\n     *\r\n     * ipLow - Decimal representation of the lowest IP address in the subnet\r\n     * ipLowStr - String representation of the lowest IP address in the subnet\r\n     * ipHigh - Decimal representation of the highest IP address in the subnet\r\n     * ipHighStr - String representation of the highest IP address in the subnet\r\n     * prefixMask - Bitmask matching prefixSize\r\n     * prefixMaskStr - String / IP representation of the bitmask\r\n     * prefixSize - Size of the prefix\r\n     * invertedMask - Bitmask matching the inverted subnet mask\r\n     * invertedMaskStr - String / IP representation of the inverted mask\r\n     * invertedSize - Number of relevant bits in the inverted mask\r\n     *\r\n     */\n    getMaskRange(ipNum, prefixSize) {\n      var prefixMask = this.getPrefixMask(prefixSize);\n      var lowMask = this.getMask(32 - prefixSize);\n      var ipLow = (ipNum & prefixMask) >>> 0;\n      var ipHigh = ((ipNum & prefixMask) >>> 0) + lowMask >>> 0;\n      return {\n        'ipLow': ipLow,\n        'ipLowStr': this.toString(ipLow),\n        'ipHigh': ipHigh,\n        'ipHighStr': this.toString(ipHigh),\n        'prefixMask': prefixMask,\n        'prefixMaskStr': this.toString(prefixMask),\n        'prefixSize': prefixSize,\n        'invertedMask': lowMask,\n        'invertedMaskStr': this.toString(lowMask),\n        'invertedSize': 32 - prefixSize\n      };\n    }\n    /**\r\n     * Creates a bitmask with maskSize leftmost bits set to one\r\n     *\r\n     * @param {int} prefixSize Number of bits to be set\r\n     * @return {int} Returns the bitmask\r\n     *\r\n     */\n    getPrefixMask(prefixSize) {\n      var mask = 0;\n      var i;\n      for (i = 0; i < prefixSize; i++) {\n        mask += 1 << 32 - (i + 1) >>> 0;\n      }\n      return mask;\n    }\n    /**\r\n     * Creates a bitmask with maskSize rightmost bits set to one\r\n     *\r\n     * @param {int} maskSize Number of bits to be set\r\n     * @return {int} Returns the bitmask\r\n     *\r\n     */\n    getMask(maskSize) {\n      var mask = 0;\n      var i;\n      for (i = 0; i < maskSize; i++) {\n        mask += 1 << i >>> 0;\n      }\n      return mask;\n    }\n    /**\r\n     * Converts string formatted IPs to decimal representation\r\n     *\r\n     * @link http://javascript.about.com/library/blipconvert.htm\r\n     * @param {string} ipString IP address in string format\r\n     * @return {int} Returns the IP address in decimal format\r\n     *\r\n     */\n    toDecimal(ipString) {\n      var d = ipString.split('.');\n      return ((+d[0] * 256 + +d[1]) * 256 + +d[2]) * 256 + +d[3];\n    }\n    /**\r\n     * Converts decimal IPs to string representation\r\n     *\r\n     * @link http://javascript.about.com/library/blipconvert.htm\r\n     * @param {int} ipNum IP address in decimal format\r\n     * @return {string} Returns the IP address in string format\r\n     *\r\n     */\n    toString(ipNum) {\n      var d = ipNum % 256;\n      for (var i = 3; i > 0; i--) {\n        ipNum = Math.floor(ipNum / 256);\n        d = ipNum % 256 + '.' + d;\n      }\n      return d;\n    }\n  }\n  IpSubnetCalculatorService.ɵfac = function IpSubnetCalculatorService_Factory(t) {\n    return new (t || IpSubnetCalculatorService)();\n  };\n  IpSubnetCalculatorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: IpSubnetCalculatorService,\n    factory: IpSubnetCalculatorService.ɵfac,\n    providedIn: 'root'\n  });\n  return IpSubnetCalculatorService;\n})();","map":null,"metadata":{},"sourceType":"module"}