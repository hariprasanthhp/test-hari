{"ast":null,"code":"import inherits from 'inherits';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { is } from '../../../util/ModelUtil';\nimport { isLabel } from '../../../util/LabelUtil';\nimport { getBBox } from 'diagram-js/lib/util/Elements';\nimport { assign, find } from 'min-dash';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nvar HORIZONTAL_PARTICIPANT_PADDING = 20,\n  VERTICAL_PARTICIPANT_PADDING = 20;\nexport var PARTICIPANT_BORDER_WIDTH = 30;\nvar HIGH_PRIORITY = 2000;\n\n/**\n * BPMN-specific behavior for creating participants.\n */\nexport default function CreateParticipantBehavior(canvas, eventBus, modeling) {\n  CommandInterceptor.call(this, eventBus);\n\n  // fit participant\n  eventBus.on(['create.start', 'shape.move.start'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      shape = context.shape,\n      rootElement = canvas.getRootElement();\n    if (!is(shape, 'bpmn:Participant') || !is(rootElement, 'bpmn:Process') || !rootElement.children.length) {\n      return;\n    }\n\n    // ignore connections, groups and labels\n    var children = rootElement.children.filter(function (element) {\n      return !is(element, 'bpmn:Group') && !isLabel(element) && !isConnection(element);\n    });\n\n    // ensure for available children to calculate bounds\n    if (!children.length) {\n      return;\n    }\n    var childrenBBox = getBBox(children);\n    var participantBounds = getParticipantBounds(shape, childrenBBox);\n\n    // assign width and height\n    assign(shape, participantBounds);\n\n    // assign create constraints\n    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);\n  });\n\n  // force hovering process when creating first participant\n  eventBus.on('create.start', HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      shape = context.shape,\n      rootElement = canvas.getRootElement(),\n      rootElementGfx = canvas.getGraphics(rootElement);\n    function ensureHoveringProcess(event) {\n      event.element = rootElement;\n      event.gfx = rootElementGfx;\n    }\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      eventBus.on('element.hover', HIGH_PRIORITY, ensureHoveringProcess);\n      eventBus.once('create.cleanup', function () {\n        eventBus.off('element.hover', ensureHoveringProcess);\n      });\n    }\n  });\n  function ensureCollaboration(context) {\n    var parent = context.parent,\n      collaboration;\n    var rootElement = canvas.getRootElement();\n    if (is(rootElement, 'bpmn:Collaboration')) {\n      collaboration = rootElement;\n    } else {\n      // update root element by making collaboration\n      collaboration = modeling.makeCollaboration();\n\n      // re-use process when creating first participant\n      context.process = parent;\n    }\n    context.parent = collaboration;\n  }\n\n  // turn process into collaboration before adding participant\n  this.preExecute('shape.create', function (context) {\n    var parent = context.parent,\n      shape = context.shape;\n    if (is(shape, 'bpmn:Participant') && is(parent, 'bpmn:Process')) {\n      ensureCollaboration(context);\n    }\n  }, true);\n  this.execute('shape.create', function (context) {\n    var process = context.process,\n      shape = context.shape;\n    if (process) {\n      context.oldProcessRef = shape.businessObject.processRef;\n\n      // re-use process when creating first participant\n      shape.businessObject.processRef = process.businessObject;\n    }\n  }, true);\n  this.revert('shape.create', function (context) {\n    var process = context.process,\n      shape = context.shape;\n    if (process) {\n      // re-use process when creating first participant\n      shape.businessObject.processRef = context.oldProcessRef;\n    }\n  }, true);\n  this.postExecute('shape.create', function (context) {\n    var process = context.process,\n      shape = context.shape;\n    if (process) {\n      // move children from process to participant\n      var processChildren = process.children.slice();\n      modeling.moveElements(processChildren, {\n        x: 0,\n        y: 0\n      }, shape);\n    }\n  }, true);\n\n  // turn process into collaboration when creating participants\n  this.preExecute('elements.create', HIGH_PRIORITY, function (context) {\n    var elements = context.elements,\n      parent = context.parent,\n      participant;\n    var hasParticipants = findParticipant(elements);\n    if (hasParticipants && is(parent, 'bpmn:Process')) {\n      ensureCollaboration(context);\n      participant = findParticipant(elements);\n      context.oldProcessRef = participant.businessObject.processRef;\n\n      // re-use process when creating first participant\n      participant.businessObject.processRef = parent.businessObject;\n    }\n  }, true);\n  this.revert('elements.create', function (context) {\n    var elements = context.elements,\n      process = context.process,\n      participant;\n    if (process) {\n      participant = findParticipant(elements);\n\n      // re-use process when creating first participant\n      participant.businessObject.processRef = context.oldProcessRef;\n    }\n  }, true);\n  this.postExecute('elements.create', function (context) {\n    var elements = context.elements,\n      process = context.process,\n      participant;\n    if (process) {\n      participant = findParticipant(elements);\n\n      // move children from process to first participant\n      var processChildren = process.children.slice();\n      modeling.moveElements(processChildren, {\n        x: 0,\n        y: 0\n      }, participant);\n    }\n  }, true);\n}\nCreateParticipantBehavior.$inject = ['canvas', 'eventBus', 'modeling'];\ninherits(CreateParticipantBehavior, CommandInterceptor);\n\n// helpers //////////\n\nfunction getParticipantBounds(shape, childrenBBox) {\n  childrenBBox = {\n    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,\n    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2\n  };\n  var width = Math.max(shape.width, childrenBBox.width),\n    height = Math.max(shape.height, childrenBBox.height);\n  return {\n    x: -width / 2,\n    y: -height / 2,\n    width: width,\n    height: height\n  };\n}\nfunction getParticipantCreateConstraints(shape, childrenBBox) {\n  childrenBBox = asTRBL(childrenBBox);\n  return {\n    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,\n    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,\n    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,\n    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH\n  };\n}\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\nfunction findParticipant(elements) {\n  return find(elements, function (element) {\n    return is(element, 'bpmn:Participant');\n  });\n}","map":null,"metadata":{},"sourceType":"module"}