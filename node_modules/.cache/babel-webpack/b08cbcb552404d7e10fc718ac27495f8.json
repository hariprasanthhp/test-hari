{"ast":null,"code":"import { forEach } from 'min-dash';\nvar MARKER_DRAGGING = 'djs-dragging',\n  MARKER_RESIZING = 'djs-resizing';\nvar LOW_PRIORITY = 250;\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\nvar max = Math.max;\n\n/**\n * Provides previews for selecting/moving/resizing shapes when creating/removing space.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Canvas} canvas\n * @param {Styles} styles\n */\nexport default function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\n  function addPreviewGfx(collection, dragGroup) {\n    forEach(collection, function (element) {\n      previewSupport.addDragger(element, dragGroup);\n      canvas.addMarker(element, MARKER_DRAGGING);\n    });\n  }\n\n  // add crosshair\n  eventBus.on('spaceTool.selection.start', function (event) {\n    var space = canvas.getLayer('space'),\n      context = event.context;\n    var orientation = {\n      x: 'M 0,-10000 L 0,10000',\n      y: 'M -10000,0 L 10000,0'\n    };\n    var crosshairGroup = svgCreate('g');\n    svgAttr(crosshairGroup, styles.cls('djs-crosshair-group', ['no-events']));\n    svgAppend(space, crosshairGroup);\n\n    // horizontal path\n    var pathX = svgCreate('path');\n    svgAttr(pathX, 'd', orientation.x);\n    svgClasses(pathX).add('djs-crosshair');\n    svgAppend(crosshairGroup, pathX);\n\n    // vertical path\n    var pathY = svgCreate('path');\n    svgAttr(pathY, 'd', orientation.y);\n    svgClasses(pathY).add('djs-crosshair');\n    svgAppend(crosshairGroup, pathY);\n    context.crosshairGroup = crosshairGroup;\n  });\n\n  // update crosshair\n  eventBus.on('spaceTool.selection.move', function (event) {\n    var crosshairGroup = event.context.crosshairGroup;\n    translate(crosshairGroup, event.x, event.y);\n  });\n\n  // remove crosshair\n  eventBus.on('spaceTool.selection.cleanup', function (event) {\n    var context = event.context,\n      crosshairGroup = context.crosshairGroup;\n    if (crosshairGroup) {\n      svgRemove(crosshairGroup);\n    }\n  });\n\n  // add and update move/resize previews\n  eventBus.on('spaceTool.move', LOW_PRIORITY, function (event) {\n    var context = event.context,\n      line = context.line,\n      axis = context.axis,\n      movingShapes = context.movingShapes,\n      resizingShapes = context.resizingShapes;\n    if (!context.initialized) {\n      return;\n    }\n    if (!context.dragGroup) {\n      var spaceLayer = canvas.getLayer('space');\n      line = svgCreate('path');\n      svgAttr(line, 'd', 'M0,0 L0,0');\n      svgClasses(line).add('djs-crosshair');\n      svgAppend(spaceLayer, line);\n      context.line = line;\n      var dragGroup = svgCreate('g');\n      svgAttr(dragGroup, styles.cls('djs-drag-group', ['no-events']));\n      svgAppend(canvas.getDefaultLayer(), dragGroup);\n\n      // shapes\n      addPreviewGfx(movingShapes, dragGroup);\n\n      // connections\n      var movingConnections = context.movingConnections = elementRegistry.filter(function (element) {\n        var sourceIsMoving = false;\n        forEach(movingShapes, function (shape) {\n          forEach(shape.outgoing, function (connection) {\n            if (element === connection) {\n              sourceIsMoving = true;\n            }\n          });\n        });\n        var targetIsMoving = false;\n        forEach(movingShapes, function (shape) {\n          forEach(shape.incoming, function (connection) {\n            if (element === connection) {\n              targetIsMoving = true;\n            }\n          });\n        });\n        var sourceIsResizing = false;\n        forEach(resizingShapes, function (shape) {\n          forEach(shape.outgoing, function (connection) {\n            if (element === connection) {\n              sourceIsResizing = true;\n            }\n          });\n        });\n        var targetIsResizing = false;\n        forEach(resizingShapes, function (shape) {\n          forEach(shape.incoming, function (connection) {\n            if (element === connection) {\n              targetIsResizing = true;\n            }\n          });\n        });\n        return isConnection(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);\n      });\n      addPreviewGfx(movingConnections, dragGroup);\n      context.dragGroup = dragGroup;\n    }\n    if (!context.frameGroup) {\n      var frameGroup = svgCreate('g');\n      svgAttr(frameGroup, styles.cls('djs-frame-group', ['no-events']));\n      svgAppend(canvas.getDefaultLayer(), frameGroup);\n      var frames = [];\n      forEach(resizingShapes, function (shape) {\n        var frame = previewSupport.addFrame(shape, frameGroup);\n        var initialBounds = frame.getBBox();\n        frames.push({\n          element: frame,\n          initialBounds: initialBounds\n        });\n        canvas.addMarker(shape, MARKER_RESIZING);\n      });\n      context.frameGroup = frameGroup;\n      context.frames = frames;\n    }\n    var orientation = {\n      x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',\n      y: 'M -10000, ' + event.y + ' L 10000, ' + event.y\n    };\n    svgAttr(line, {\n      d: orientation[axis]\n    });\n    var opposite = {\n      x: 'y',\n      y: 'x'\n    };\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n    delta[opposite[context.axis]] = 0;\n\n    // update move previews\n    translate(context.dragGroup, delta.x, delta.y);\n\n    // update resize previews\n    forEach(context.frames, function (frame) {\n      var element = frame.element,\n        initialBounds = frame.initialBounds,\n        width,\n        height;\n      if (context.direction === 'e') {\n        svgAttr(element, {\n          width: max(initialBounds.width + delta.x, 5)\n        });\n      } else {\n        width = max(initialBounds.width - delta.x, 5);\n        svgAttr(element, {\n          width: width,\n          x: initialBounds.x + initialBounds.width - width\n        });\n      }\n      if (context.direction === 's') {\n        svgAttr(element, {\n          height: max(initialBounds.height + delta.y, 5)\n        });\n      } else {\n        height = max(initialBounds.height - delta.y, 5);\n        svgAttr(element, {\n          height: height,\n          y: initialBounds.y + initialBounds.height - height\n        });\n      }\n    });\n  });\n\n  // remove move/resize previews\n  eventBus.on('spaceTool.cleanup', function (event) {\n    var context = event.context,\n      movingShapes = context.movingShapes,\n      movingConnections = context.movingConnections,\n      resizingShapes = context.resizingShapes,\n      line = context.line,\n      dragGroup = context.dragGroup,\n      frameGroup = context.frameGroup;\n\n    // moving shapes\n    forEach(movingShapes, function (shape) {\n      canvas.removeMarker(shape, MARKER_DRAGGING);\n    });\n\n    // moving connections\n    forEach(movingConnections, function (connection) {\n      canvas.removeMarker(connection, MARKER_DRAGGING);\n    });\n    if (dragGroup) {\n      svgRemove(line);\n      svgRemove(dragGroup);\n    }\n    forEach(resizingShapes, function (shape) {\n      canvas.removeMarker(shape, MARKER_RESIZING);\n    });\n    if (frameGroup) {\n      svgRemove(frameGroup);\n    }\n  });\n}\nSpaceToolPreview.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];\n\n// helpers //////////////////////\n\n/**\n * Checks if an element is a connection.\n */\nfunction isConnection(element) {\n  return element.waypoints;\n}","map":null,"metadata":{},"sourceType":"module"}