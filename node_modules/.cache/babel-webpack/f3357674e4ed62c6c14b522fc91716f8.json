{"ast":null,"code":"/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the fractions option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport DygraphDataHandler from './datahandler';\nimport DefaultHandler from './default';\n\n/**\n * @extends DefaultHandler\n * @constructor\n */\nvar DefaultFractionHandler = function () {};\nDefaultFractionHandler.prototype = new DefaultHandler();\nDefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value;\n  var mult = 100.0;\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([x, y, [num, den]]);\n      } else {\n        series.push([x, num, [num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null]]);\n    }\n  }\n  return series;\n};\nDefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var i;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][0];\n    den += originalData[i][2][1];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][0];\n      den -= originalData[i - rollPeriod][2][1];\n    }\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    rollingData[i] = [date, mult * value];\n  }\n  return rollingData;\n};\nexport default DefaultFractionHandler;","map":null,"metadata":{},"sourceType":"module"}