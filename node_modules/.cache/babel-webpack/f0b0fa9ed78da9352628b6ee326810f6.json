{"ast":null,"code":"import inherits from 'inherits';\nimport { getBBox as getBoundingBox } from '../../util/Elements';\nimport { asTRBL, asBounds } from '../../layout/LayoutUtil';\nimport { assign, flatten, find, forEach, groupBy, isArray, matchPattern, pick, values } from 'min-dash';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n  CommandInterceptor.call(this, eventBus);\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n  var self = this;\n  this.postExecuted(['shape.create'], function (event) {\n    var context = event.context,\n      hints = context.hints || {},\n      shape = context.shape,\n      parent = context.parent || context.newParent;\n    if (hints.autoResize === false) {\n      return;\n    }\n    self._expand([shape], parent);\n  });\n  this.postExecuted(['elements.move'], function (event) {\n    var context = event.context,\n      elements = flatten(values(context.closure.topLevel)),\n      hints = context.hints;\n    var autoResize = hints ? hints.autoResize : true;\n    if (autoResize === false) {\n      return;\n    }\n    var expandings = groupBy(elements, function (element) {\n      return element.parent.id;\n    });\n    forEach(expandings, function (elements, parentId) {\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function (element) {\n          return find(autoResize, matchPattern({\n            id: element.id\n          }));\n        });\n      }\n      self._expand(elements, parentId);\n    });\n  });\n  this.postExecuted(['shape.toggleCollapse'], function (event) {\n    var context = event.context,\n      hints = context.hints,\n      shape = context.shape;\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n    if (shape.collapsed) {\n      return;\n    }\n    self._expand(shape.children || [], shape);\n  });\n  this.postExecuted(['shape.resize'], function (event) {\n    var context = event.context,\n      hints = context.hints,\n      shape = context.shape,\n      parent = shape.parent;\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n    if (parent) {\n      self._expand([shape], parent);\n    }\n  });\n}\nAutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];\ninherits(AutoResize, CommandInterceptor);\n\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape} target\n */\nAutoResize.prototype._getOptimalBounds = function (elements, target) {\n  var offset = this.getOffset(target),\n    padding = this.getPadding(target);\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n    targetTrbl = asTRBL(target);\n  var newTrbl = {};\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape|string} target|targetId\n */\nAutoResize.prototype._expand = function (elements, target) {\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n  if (!allowed) {\n    return;\n  }\n\n  // calculate the new bounds\n  var newBounds = this._getOptimalBounds(elements, target);\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  }\n  var resizeDirections = getResizeDirections(pick(target, ['x', 'y', 'width', 'height']), newBounds);\n\n  // resize the parent shape\n  this.resize(target, newBounds, {\n    autoResize: resizeDirections\n  });\n  var parent = target.parent;\n\n  // recursively expand parent elements\n  if (parent) {\n    this._expand([target], parent);\n  }\n};\n\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {TRBL}\n */\nAutoResize.prototype.getOffset = function (shape) {\n  return {\n    top: 60,\n    bottom: 60,\n    left: 100,\n    right: 100\n  };\n};\n\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {TRBL}\n */\nAutoResize.prototype.getPadding = function (shape) {\n  return {\n    top: 2,\n    bottom: 2,\n    left: 15,\n    right: 15\n  };\n};\n\n/**\n * Perform the actual resize operation.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n * @param {Object} [hints]\n * @param {string} [hints.autoResize]\n */\nAutoResize.prototype.resize = function (shape, newBounds, hints) {\n  this._modeling.resizeShape(shape, newBounds, null, hints);\n};\nfunction boundsChanged(newBounds, oldBounds) {\n  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;\n}\n\n/**\n * Get directions of resize as {n|w|s|e} e.g. \"nw\".\n *\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @returns {string} Resize directions as {n|w|s|e}.\n */\nfunction getResizeDirections(oldBounds, newBounds) {\n  var directions = '';\n  oldBounds = asTRBL(oldBounds);\n  newBounds = asTRBL(newBounds);\n  if (oldBounds.top > newBounds.top) {\n    directions = directions.concat('n');\n  }\n  if (oldBounds.right < newBounds.right) {\n    directions = directions.concat('w');\n  }\n  if (oldBounds.bottom < newBounds.bottom) {\n    directions = directions.concat('s');\n  }\n  if (oldBounds.left > newBounds.left) {\n    directions = directions.concat('e');\n  }\n  return directions;\n}","map":null,"metadata":{},"sourceType":"module"}