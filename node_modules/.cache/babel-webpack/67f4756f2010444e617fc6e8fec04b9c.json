{"ast":null,"code":"import { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Subject, Observable, throwError } from 'rxjs';\nimport { catchError, switchMap, tap } from 'rxjs/operators';\nimport { environment } from \"../../../environments/environment\";\nimport { ActivationEnd } from '@angular/router';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"./sso-auth.service\";\nexport let HttpConfigInterceptor = /*#__PURE__*/(() => {\n  class HttpConfigInterceptor {\n    constructor(router, injector, sso) {\n      this.router = router;\n      this.injector = injector;\n      this.sso = sso;\n      this.refreshTokenInProgress = false;\n      this.tokenRefreshedSource = new Subject();\n      this.pendingHTTPRequests$ = new Subject();\n      this.tokenRefreshed$ = this.tokenRefreshedSource.asObservable();\n      this.router.events.subscribe(event => {\n        // An event triggered at the end of the activation part of the Resolve phase of routing.\n        if (event instanceof ActivationEnd) {\n          // Cancel pending calls\n          this.refreshTokenInProgress = false;\n          this.cancelPendingRequests();\n        }\n      });\n      this.sso.refreshTokenNew$.subscribe(res => {\n        //console.log('set refreshTokenInProgress to false')\n        this.refreshTokenInProgress = false;\n      });\n    }\n    // Cancel Pending HTTP calls\n    cancelPendingRequests() {\n      this.pendingHTTPRequests$.next();\n    }\n    onCancelPendingRequests() {\n      return this.pendingHTTPRequests$.asObservable();\n    }\n    addAuthHeader(request) {\n      let rqstUrl = request.url;\n      let hostName = window.location.host;\n      if (hostName.includes('cloud-dev')) {\n        this.isDev = true;\n      } else {\n        this.isDev = false;\n      }\n      const token = this.sso.getAccessToken() ? this.sso.getAccessToken() : 'token';\n      if (rqstUrl.indexOf('login.mailchimp.com') !== -1) {} else if (rqstUrl.indexOf('gcs-dev') !== -1) {} else if (rqstUrl.indexOf('dev.virtualearth.net') !== -1) {} else if (rqstUrl.indexOf('/authentication/token') !== -1) {\n        let headers = {\n          'X-Calix-ClientID': environment.X_CALIX_CLIENTID\n          //'X-Calix-AccessToken': token\n        };\n        // if (environment['IS_PRE_PRODUCTION']) {\n        //   let body = request.body;\n        //   if (body && body.indexOf(\"grant_type=secure_access\") !== -1 || this.sso.isSecureAccess()) {\n        //     // do not send 'X-Calix-PreProduction' header\n        //   } else {\n        //     headers['X-Calix-PreProduction'] = \"yes\";\n        //   }\n        // }\n        request = request.clone({\n          setHeaders: headers\n        });\n      } else if (rqstUrl.indexOf('/fa/') !== -1) {\n        request = request.clone({\n          setHeaders: {\n            'X-Calix-ClientID': environment.X_CALIX_CLIENTID,\n            'X-Calix-AccessToken': token\n          }\n        });\n      } else if (rqstUrl.indexOf('authentication/usertype') === -1 && token && !rqstUrl.includes('dashboards-dev.calix.com')) {\n        if (this.isDev) {\n          request = request.clone({\n            setHeaders: {\n              'X-Calix-ClientID': environment.X_CALIX_CLIENTID,\n              'X-Calix-AccessToken': token\n            }\n          });\n        } else {\n          request = request.clone({\n            setHeaders: {\n              'X-Calix-ClientID': environment.X_CALIX_CLIENTID,\n              'X-Calix-AccessToken': token\n            }\n          });\n        }\n      } else if (rqstUrl.indexOf('authentication/usertype') !== -1) {\n        request = request.clone({\n          setHeaders: {\n            'X-Calix-ClientID': environment.X_CALIX_CLIENTID,\n            'X-Calix-AccessToken': token\n          }\n        });\n      } else {\n        // request = request.clone({\n        //   setHeaders: {\n        //     Cookie: 'custom=ramu'\n        //   }\n        // });\n      }\n      /****************** Space Removing Code Temporarily Commented ******************/\n      // if (request.body) {\n      //   if (typeof request.body == 'object' && request.body !== null && !Array.isArray(request.body)) {\n      //     request.body = this.removeSpaceFromObjects(request.body);\n      //   } else if (typeof request.body == 'object' && Array.isArray(request.body)) {\n      //     request.body = this.removeSpaceFromArrayElements(request.body);\n      //   } else if (typeof request.body == 'string') {\n      //     request.body = request.body\n      //       .replace(/^[\\s]+/, '')\n      //       .replace(/[\\s]+$/, '')\n      //   .replace(/[\\=][\\w\\s\\-\\%\\*\\$\\#\\@\\!\\^\\<\\>\\,\\.\\?\\/]+[\\&]?/g,(word)=>{\n      //   return `=${word.replace(/[=&]/g,'').replace(/^[\\s]+/, '')\n      //   .replace(/[\\s]+$/, '')\n      //   }${(word[word.length-1] == '&'?'&':'')}`\n      // })\n      //   }\n      // }\n      // if(request.urlWithParams && request.urlWithParams.includes('?')){\n      //   let params = decodeURIComponent(request.urlWithParams).split('?');\n      //   params[1] = params[1].replace(/[\\=][\\w\\s\\-\\%\\*\\$\\#\\@\\!\\^\\<\\>\\,\\.\\?\\/]+[\\&]?/g,(word)=>{\n      //     return `=${word.replace(/[=&]/g,'').replace(/^[\\s]+/, '')\n      //     .replace(/[\\s]+$/, '')\n      //     }${(word[word.length-1] == '&'?'&':'')}`\n      //   });\n      //   request.urlWithParams = encodeURI(params.join('?'));\n      // }\n      return request;\n    }\n    /****************** Space Removing Code Temporarily Commented ******************/\n    // removeSpaceFromObjects(obj) {\n    //   for (let key in obj) {\n    //     if (typeof obj[key] == 'object' && obj[key] !== null && !Array.isArray(obj[key])) {\n    //       obj[key] = this.removeSpaceFromObjects(obj[key]);\n    //     } else if (typeof obj[key] == 'object' && Array.isArray(obj[key])) {\n    //       obj[key] = this.removeSpaceFromArrayElements(obj[key]);\n    //     } else if (typeof obj[key] == 'string') {\n    //       try {\n    //         const descriptors1 = Object.getOwnPropertyDescriptors(obj);\n    //         console.log(descriptors1[key]?.writable)\n    //         console.log(descriptors1[key]?.configurable)\n    //         obj[key] = obj[key]\n    //         .replace(/^[\\s]+/, '')\n    //         .replace(/[\\s]+$/, '')\n    //         ;\n    //       }catch(err){\n    //         console.clear();\n    //         console.log(err)\n    //       }\n    //     }\n    //   }\n    //   return obj;\n    // }\n    // removeSpaceFromArrayElements(arr) {\n    //   return arr.map((element) => {\n    //     if (typeof element == 'object' && typeof element !== null && !Array.isArray(element)) {\n    //       return this.removeSpaceFromObjects(element);\n    //     } else if (typeof element == 'object' && Array.isArray(element)) {\n    //       return this.removeSpaceFromArrayElements(element);\n    //     } else if (typeof element == 'string') {\n    //      return element = element\n    //         .replace(/^[\\s]+/, '')\n    //         .replace(/[\\s]+$/, '')\n    //         ;\n    //     }\n    //   });\n    // }\n    refreshToken() {\n      if (this.refreshTokenInProgress) {\n        return new Observable(observer => {\n          this.tokenRefreshed$.subscribe(() => {\n            observer.next();\n            observer.complete();\n          });\n        });\n      } else {\n        this.refreshTokenInProgress = true;\n        return this.sso.getAuthTokenByRT().pipe(tap(res => {\n          this.sso.manageScopes(res.scopes);\n          this.sso.manageEntitlements(res.entitlements);\n          this.sso.setAccessToken(res['access_token']);\n          this.sso.setRefreshToken(res['refresh_token']);\n          this.sso.setShadToken(res['access_token']);\n          this.sso.setSpid(res['SpId']);\n          this.sso.setUserInfo(res);\n          this.sso.setLoginInfo(res);\n          if (!this.sso.isSecureAccess() && !this.sso.isFederatedLogin()) {\n            this.sso.setLoginData(res);\n          }\n          this.refreshTokenInProgress = false;\n          this.tokenRefreshedSource.next();\n        }, err => {\n          this.refreshTokenInProgress = false;\n        }));\n      }\n    }\n    intercept(request, next) {\n      request = this.addAuthHeader(request);\n      // next.handle(request).pipe(takeUntil(this.onCancelPendingRequests()))\n      return next.handle(request).pipe(catchError(error => {\n        return this.handleResponseError(error, request, next);\n      }));\n    }\n    handleResponseError(error, request, next) {\n      // Business error\n      if (error.status === 404) {\n        // Show message\n        console.log(error);\n        if (typeof error.error == 'object') {\n          let err = error.error;\n          if (err && err.fault && err.fault.faultstring && err.fault.faultstring.toLowerCase() == 'invalid access token') {\n            console.log(\"Received invalid access token from apigee\");\n            //this.router.navigate(['logout'], { queryParams: { error: err.fault.faultstring } });\n          }\n        }\n      } else if (error.status === 403) {\n        const isAcl = error.statusText && error.statusText.toLowerCase().includes(\"acl error\");\n        if (error.statusText === 'Forbidden' || !isAcl) {\n          return throwError(error);\n        }\n        if (this.sso.isSecureAccess()) {\n          this.sso.doExitSecureAccess();\n          return;\n        } else {\n          this.sso.doLogoutCSC();\n          this.sso.doLogout();\n          localStorage.removeItem('calix.login_data');\n          localStorage.removeItem('calix.userInfo');\n          this.clearCalixAdminSessionData();\n          if (typeof error.error === 'string') {\n            this.router.navigate(['login'], {\n              queryParams: {\n                error: error.error\n              }\n            });\n          } else {\n            this.router.navigate(['login'], {\n              queryParams: {\n                error: 'ACL Check Failed'\n              }\n            });\n          }\n        }\n      }\n      // Invalid token error\n      else if (error.status === 401) {\n        if (error.url && error.url.includes('dashboards-dev.calix.com/')) {\n          return throwError(error);\n        }\n        if (typeof error.error == 'object') {\n          let err = error.error;\n          if (err && err.fault && err.fault.faultstring && err.fault.faultstring.toLowerCase() == 'apikey not approved') {\n            console.log(\"Received invalid access token from apigee api\");\n            //this.router.navigate(['logout'], { queryParams: { error: err.fault.faultstring } });\n            this.sso.setApigeeError(true);\n            return throwError(error);\n          }\n        }\n        if (error.statusText && error.statusText === 'User Unauthorized' || error['statusText'].toLowerCase() === 'user unauthorized') {\n          if (this.sso.isSecureAccess()) {\n            this.sso.doExitSecureAccess();\n          }\n          this.sso.doLogoutCSC();\n          this.sso.doLogout();\n          localStorage.removeItem('calix.login_data');\n          localStorage.removeItem('calix.userInfo');\n          this.clearCalixAdminSessionData();\n          this.router.navigate(['login']);\n        }\n        let rqstUrl = request === null || request === void 0 ? void 0 : request.url;\n        let path = this.router.url;\n        let validErrorCodesForRT = [\"Invalid Access Token\", \"Expired Access Token\", \"Invalid or expired Access Token\"];\n        if (request && rqstUrl.indexOf('authentication/token') !== -1 && path.indexOf('login') !== -1 || typeof error.error == 'object' && error.error.errorMessage && validErrorCodesForRT.indexOf(error.error.errorMessage) === -1) {\n          //console.log(\"something went wrong , received 401 from refresh token api\");\n          //window.location.reload();\n          return throwError(error);\n        }\n        if (error.statusText && path.indexOf('/organization-admin/csccfg/acs-settings') !== 1 && (error.statusText === 'Unauthorized User' || error['statusText'].toLowerCase() === 'unauthorized user')) {\n          return throwError(error);\n        }\n        if (((error === null || error === void 0 ? void 0 : error.url) || \"\").indexOf(\"calloutcome/extrefconfig/nisc/test\") != -1) {\n          return throwError(error);\n        }\n        if (request && rqstUrl.indexOf('/rt/sse/') !== -1) {\n          //console.log(\"something went wrong , received 401 from refresh token api\");\n          window.location.reload();\n          //return throwError(error);\n        }\n        //this.refreshTokenInProgress = false;\n        if (request) {\n          return this.refreshToken().pipe(switchMap(() => {\n            var _a, _b;\n            request = this.addAuthHeader(request);\n            if (((_a = request === null || request === void 0 ? void 0 : request.url) === null || _a === void 0 ? void 0 : _a.indexOf('/authentication/token')) !== -1) {\n              console.log(this.sso.queryStringToJSON(request.body));\n              let formData = this.sso.queryStringToJSON(request.body);\n              if ((formData === null || formData === void 0 ? void 0 : formData.grant_type) === 'secure_access') {\n                formData.access_token = this.sso.getAccessToken();\n                let formDataStr = this.sso.jsonToQueryString(formData);\n                request = request.clone({\n                  body: formDataStr\n                });\n              }\n            } else if (((_b = request === null || request === void 0 ? void 0 : request.url) === null || _b === void 0 ? void 0 : _b.indexOf('/grantor/changeorg')) !== -1 && this.router.url.includes(\"federated-dashboard\")) {\n              console.log(this.sso.queryStringToJSON(request.body));\n              let formData = this.sso.queryStringToJSON(request.body);\n              formData.access_token = this.sso.getAccessToken();\n              let formDataStr = this.sso.jsonToQueryString(formData);\n              request = request.clone({\n                body: formDataStr\n              });\n            }\n            return next.handle(request).pipe(catchError(error => {\n              return throwError(error);\n            }));\n          }), catchError(e => {\n            this.refreshTokenInProgress = false;\n            return this.handleResponseError(e);\n            // if (e.status !== 401) {\n            //   return this.handleResponseError(e);\n            // } else {\n            //   return throwError(error);\n            //   //this.logout();\n            // }\n          }));\n        }\n      }\n      // Server error\n      else if (error.status === 500) {\n        if (typeof error.error == 'object') {\n          let err = error.error;\n          if (err && err.fault && err.fault.faultstring && err.fault.faultstring.toLowerCase() == 'consumer key not approved') {\n            console.log(\"Received Consumer Key not approved from apigee api\");\n            this.sso.setApigeeError(true);\n            return throwError(error);\n          }\n        }\n        this.sso.setApiError(\"Internal Server Error\");\n        let rqstUrl = request.url;\n        if (rqstUrl.indexOf('authentication/token') !== -1) {\n          console.log(\"something went wrong , received 500 from apigee api\");\n          if (!this.router.url.includes(\"login\")) {\n            this.router.navigate(['/logout']);\n          }\n          //window.location.reload();\n          if (!this.router.url.includes(\"login\")) {\n            this.router.navigate(['/logout']);\n          }\n          return throwError(error);\n        }\n        // Show message\n      } else if (error.status === 502) {\n        this.sso.setApiError(error);\n      } else if (error.status === 503) {\n        // Show message\n        // Redirect to the maintenance page\n        this.sso.setApiError(error);\n      } else if (error.status === 504) {\n        //this.sso.setApiError(error);\n        this.sso.setApiError(\"Gateway Timeout\");\n      } else if (error.status === 599) {\n        this.sso.setApiError(error);\n      }\n      return throwError(error);\n    }\n    clearCalixAdminSessionData() {\n      sessionStorage.removeItem('calixAdminOrgDetail');\n      sessionStorage.removeItem('calixAdminOrgID');\n      sessionStorage.removeItem('calixAdminUserDetail');\n      sessionStorage.removeItem('calixAdminAddRole');\n      sessionStorage.removeItem('calixAdminAddRoleId');\n      sessionStorage.removeItem('SecuredAccessUser');\n    }\n  }\n  HttpConfigInterceptor.ɵfac = function HttpConfigInterceptor_Factory(t) {\n    return new (t || HttpConfigInterceptor)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i2.SsoAuthService));\n  };\n  HttpConfigInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: HttpConfigInterceptor,\n    factory: HttpConfigInterceptor.ɵfac\n  });\n  return HttpConfigInterceptor;\n})();\nexport const AuthInterceptorProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: HttpConfigInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module"}