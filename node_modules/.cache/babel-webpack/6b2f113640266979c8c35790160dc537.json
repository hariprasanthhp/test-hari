{"ast":null,"code":"/*\n Highmaps JS v9.3.3 (2022-02-01)\n\n Highmaps as a plugin for Highcharts or Highcharts Stock.\n\n (c) 2011-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (c) {\n  \"object\" === typeof module && module.exports ? (c[\"default\"] = c, module.exports = c) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/map\", [\"highcharts\"], function (y) {\n    c(y);\n    c.Highcharts = y;\n    return c;\n  }) : c(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (c) {\n  function y(c, f, p, r) {\n    c.hasOwnProperty(f) || (c[f] = r.apply(null, p));\n  }\n  c = c ? c._modules : {};\n  y(c, \"Core/Axis/Color/ColorAxisComposition.js\", [c[\"Core/Color/Color.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    var p = c.parse,\n      r = f.addEvent,\n      n = f.extend,\n      u = f.merge,\n      e = f.pick,\n      b = f.splat,\n      v;\n    (function (m) {\n      function k() {\n        var h = this,\n          l = this.options;\n        this.colorAxis = [];\n        l.colorAxis && (l.colorAxis = b(l.colorAxis), l.colorAxis.forEach(function (l, d) {\n          l.index = d;\n          new B(h, l);\n        }));\n      }\n      function a(h) {\n        var l = this,\n          d = function (a) {\n            a = h.allItems.indexOf(a);\n            -1 !== a && (l.destroyItem(h.allItems[a]), h.allItems.splice(a, 1));\n          },\n          a = [],\n          g,\n          w;\n        (this.chart.colorAxis || []).forEach(function (h) {\n          (g = h.options) && g.showInLegend && (g.dataClasses && g.visible ? a = a.concat(h.getDataClassLegendSymbols()) : g.visible && a.push(h), h.series.forEach(function (h) {\n            if (!h.options.showInLegend || g.dataClasses) \"point\" === h.options.legendType ? h.points.forEach(function (h) {\n              d(h);\n            }) : d(h);\n          }));\n        });\n        for (w = a.length; w--;) h.allItems.unshift(a[w]);\n      }\n      function d(h) {\n        h.visible && h.item.legendColor && h.item.legendSymbol.attr({\n          fill: h.item.legendColor\n        });\n      }\n      function g() {\n        var h = this.chart.colorAxis;\n        h && h.forEach(function (h, l, a) {\n          h.update({}, a);\n        });\n      }\n      function t() {\n        (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();\n      }\n      function x() {\n        var h = this.axisTypes;\n        h ? -1 === h.indexOf(\"colorAxis\") && h.push(\"colorAxis\") : this.axisTypes = [\"colorAxis\"];\n      }\n      function v(h) {\n        var l = this,\n          a = h ? \"show\" : \"hide\";\n        l.visible = l.options.visible = !!h;\n        [\"graphic\", \"dataLabel\"].forEach(function (h) {\n          if (l[h]) l[h][a]();\n        });\n        this.series.buildKDTree();\n      }\n      function q() {\n        var h = this,\n          l = this.options.nullColor,\n          a = this.colorAxis,\n          d = this.colorKey;\n        (this.data.length ? this.data : this.points).forEach(function (g) {\n          var w = g.getNestedProperty(d);\n          (w = g.options.color || (g.isNull || null === g.value ? l : a && \"undefined\" !== typeof w ? a.toColor(w, g) : g.color || h.color)) && g.color !== w && (g.color = w, \"point\" === h.options.legendType && g.legendItem && h.chart.legend.colorizeItem(g, g.visible));\n        });\n      }\n      function w(h) {\n        var l = h.prototype.createAxis;\n        h.prototype.createAxis = function (h, a) {\n          if (\"colorAxis\" !== h) return l.apply(this, arguments);\n          var d = new B(this, u(a.axis, {\n            index: this[h].length,\n            isX: !1\n          }));\n          this.isDirtyLegend = !0;\n          this.axes.forEach(function (h) {\n            h.series = [];\n          });\n          this.series.forEach(function (h) {\n            h.bindAxes();\n            h.isDirtyData = !0;\n          });\n          e(a.redraw, !0) && this.redraw(a.animation);\n          return d;\n        };\n      }\n      function A() {\n        this.elem.attr(\"fill\", p(this.start).tweenTo(p(this.end), this.pos), void 0, !0);\n      }\n      function h() {\n        this.elem.attr(\"stroke\", p(this.start).tweenTo(p(this.end), this.pos), void 0, !0);\n      }\n      var l = [],\n        B;\n      m.compose = function (b, e, m, u, c) {\n        B || (B = b);\n        -1 === l.indexOf(e) && (l.push(e), b = e.prototype, b.collectionsWithUpdate.push(\"colorAxis\"), b.collectionsWithInit.colorAxis = [b.addColorAxis], r(e, \"afterGetAxes\", k), w(e));\n        -1 === l.indexOf(m) && (l.push(m), e = m.prototype, e.fillSetter = A, e.strokeSetter = h);\n        -1 === l.indexOf(u) && (l.push(u), r(u, \"afterGetAllItems\", a), r(u, \"afterColorizeItem\", d), r(u, \"afterUpdate\", g));\n        -1 === l.indexOf(c) && (l.push(c), n(c.prototype, {\n          optionalAxis: \"colorAxis\",\n          translateColors: q\n        }), n(c.prototype.pointClass.prototype, {\n          setVisible: v\n        }), r(c, \"afterTranslate\", t), r(c, \"bindAxes\", x));\n      };\n      m.pointSetVisible = v;\n    })(v || (v = {}));\n    return v;\n  });\n  y(c, \"Core/Axis/Color/ColorAxisDefaults.js\", [], function () {\n    return {\n      lineWidth: 0,\n      minPadding: 0,\n      maxPadding: 0,\n      gridLineWidth: 1,\n      tickPixelInterval: 72,\n      startOnTick: !0,\n      endOnTick: !0,\n      offset: 0,\n      marker: {\n        animation: {\n          duration: 50\n        },\n        width: .01,\n        color: \"#999999\"\n      },\n      labels: {\n        overflow: \"justify\",\n        rotation: 0\n      },\n      minColor: \"#e6ebf5\",\n      maxColor: \"#003399\",\n      tickLength: 5,\n      showInLegend: !0\n    };\n  });\n  y(c, \"Core/Axis/Color/ColorAxis.js\", [c[\"Core/Axis/Axis.js\"], c[\"Core/Color/Color.js\"], c[\"Core/Axis/Color/ColorAxisComposition.js\"], c[\"Core/Axis/Color/ColorAxisDefaults.js\"], c[\"Core/Globals.js\"], c[\"Core/Legend/LegendSymbol.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r, n, u, e, b) {\n    var v = this && this.__extends || function () {\n        var a = function (d, g) {\n          a = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, h) {\n            a.__proto__ = h;\n          } || function (a, h) {\n            for (var l in h) h.hasOwnProperty(l) && (a[l] = h[l]);\n          };\n          return a(d, g);\n        };\n        return function (d, g) {\n          function b() {\n            this.constructor = d;\n          }\n          a(d, g);\n          d.prototype = null === g ? Object.create(g) : (b.prototype = g.prototype, new b());\n        };\n      }(),\n      m = f.parse,\n      k = n.noop,\n      a = e.series,\n      d = b.extend,\n      g = b.isNumber,\n      t = b.merge,\n      x = b.pick;\n    f = function (b) {\n      function q(a, d) {\n        var h = b.call(this, a, d) || this;\n        h.beforePadding = !1;\n        h.chart = void 0;\n        h.coll = \"colorAxis\";\n        h.dataClasses = void 0;\n        h.legendItem = void 0;\n        h.legendItems = void 0;\n        h.name = \"\";\n        h.options = void 0;\n        h.stops = void 0;\n        h.visible = !0;\n        h.init(a, d);\n        return h;\n      }\n      v(q, b);\n      q.compose = function (a, d, h, l) {\n        p.compose(q, a, d, h, l);\n      };\n      q.prototype.init = function (a, d) {\n        var h = a.options.legend || {},\n          l = d.layout ? \"vertical\" !== d.layout : \"vertical\" !== h.layout,\n          g = d.visible;\n        h = t(q.defaultColorAxisOptions, d, {\n          showEmpty: !1,\n          title: null,\n          visible: h.enabled && !1 !== g\n        });\n        this.coll = \"colorAxis\";\n        this.side = d.side || l ? 2 : 1;\n        this.reversed = d.reversed || !l;\n        this.opposite = !l;\n        b.prototype.init.call(this, a, h);\n        this.userOptions.visible = g;\n        d.dataClasses && this.initDataClasses(d);\n        this.initStops();\n        this.horiz = l;\n        this.zoomEnabled = !1;\n      };\n      q.prototype.initDataClasses = function (a) {\n        var d = this.chart,\n          h = this.options,\n          l = a.dataClasses.length,\n          g,\n          b = 0,\n          w = d.options.chart.colorCount;\n        this.dataClasses = g = [];\n        this.legendItems = [];\n        (a.dataClasses || []).forEach(function (a, q) {\n          a = t(a);\n          g.push(a);\n          if (d.styledMode || !a.color) \"category\" === h.dataClassColor ? (d.styledMode || (q = d.options.colors, w = q.length, a.color = q[b]), a.colorIndex = b, b++, b === w && (b = 0)) : a.color = m(h.minColor).tweenTo(m(h.maxColor), 2 > l ? .5 : q / (l - 1));\n        });\n      };\n      q.prototype.hasData = function () {\n        return !!(this.tickPositions || []).length;\n      };\n      q.prototype.setTickPositions = function () {\n        if (!this.dataClasses) return b.prototype.setTickPositions.call(this);\n      };\n      q.prototype.initStops = function () {\n        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];\n        this.stops.forEach(function (a) {\n          a.color = m(a[1]);\n        });\n      };\n      q.prototype.setOptions = function (a) {\n        b.prototype.setOptions.call(this, a);\n        this.options.crosshair = this.options.marker;\n      };\n      q.prototype.setAxisSize = function () {\n        var a = this.legendSymbol,\n          d = this.chart,\n          h = d.options.legend || {},\n          l,\n          g;\n        a ? (this.left = h = a.attr(\"x\"), this.top = l = a.attr(\"y\"), this.width = g = a.attr(\"width\"), this.height = a = a.attr(\"height\"), this.right = d.chartWidth - h - g, this.bottom = d.chartHeight - l - a, this.len = this.horiz ? g : a, this.pos = this.horiz ? h : l) : this.len = (this.horiz ? h.symbolWidth : h.symbolHeight) || q.defaultLegendLength;\n      };\n      q.prototype.normalizedValue = function (a) {\n        this.logarithmic && (a = this.logarithmic.log2lin(a));\n        return 1 - (this.max - a) / (this.max - this.min || 1);\n      };\n      q.prototype.toColor = function (a, d) {\n        var h = this.dataClasses,\n          l = this.stops,\n          g;\n        if (h) for (g = h.length; g--;) {\n          var b = h[g];\n          var w = b.from;\n          l = b.to;\n          if ((\"undefined\" === typeof w || a >= w) && (\"undefined\" === typeof l || a <= l)) {\n            var t = b.color;\n            d && (d.dataClass = g, d.colorIndex = b.colorIndex);\n            break;\n          }\n        } else {\n          a = this.normalizedValue(a);\n          for (g = l.length; g-- && !(a > l[g][0]););\n          w = l[g] || l[g + 1];\n          l = l[g + 1] || w;\n          a = 1 - (l[0] - a) / (l[0] - w[0] || 1);\n          t = w.color.tweenTo(l.color, a);\n        }\n        return t;\n      };\n      q.prototype.getOffset = function () {\n        var a = this.legendGroup,\n          d = this.chart.axisOffset[this.side];\n        a && (this.axisParent = a, b.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = d);\n      };\n      q.prototype.setLegendColor = function () {\n        var a = this.reversed,\n          d = a ? 1 : 0;\n        a = a ? 0 : 1;\n        d = this.horiz ? [d, 0, a, 0] : [0, a, 0, d];\n        this.legendColor = {\n          linearGradient: {\n            x1: d[0],\n            y1: d[1],\n            x2: d[2],\n            y2: d[3]\n          },\n          stops: this.stops\n        };\n      };\n      q.prototype.drawLegendSymbol = function (a, d) {\n        var h = a.padding,\n          g = a.options,\n          b = this.horiz,\n          t = x(g.symbolWidth, b ? q.defaultLegendLength : 12),\n          w = x(g.symbolHeight, b ? 12 : q.defaultLegendLength),\n          k = x(g.labelPadding, b ? 16 : 30);\n        g = x(g.itemDistance, 10);\n        this.setLegendColor();\n        d.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, t, w).attr({\n          zIndex: 1\n        }).add(d.legendGroup);\n        this.legendItemWidth = t + h + (b ? g : k);\n        this.legendItemHeight = w + h + (b ? k : 0);\n      };\n      q.prototype.setState = function (a) {\n        this.series.forEach(function (d) {\n          d.setState(a);\n        });\n      };\n      q.prototype.setVisible = function () {};\n      q.prototype.getSeriesExtremes = function () {\n        var d = this.series,\n          g = d.length,\n          h;\n        this.dataMin = Infinity;\n        for (this.dataMax = -Infinity; g--;) {\n          var l = d[g];\n          var b = l.colorKey = x(l.options.colorKey, l.colorKey, l.pointValKey, l.zoneAxis, \"y\");\n          var t = l.pointArrayMap;\n          var q = l[b + \"Min\"] && l[b + \"Max\"];\n          if (l[b + \"Data\"]) var k = l[b + \"Data\"];else if (t) {\n            k = [];\n            t = t.indexOf(b);\n            var e = l.yData;\n            if (0 <= t && e) for (h = 0; h < e.length; h++) k.push(x(e[h][t], e[h]));\n          } else k = l.yData;\n          q ? (l.minColorValue = l[b + \"Min\"], l.maxColorValue = l[b + \"Max\"]) : (k = a.prototype.getExtremes.call(l, k), l.minColorValue = k.dataMin, l.maxColorValue = k.dataMax);\n          \"undefined\" !== typeof l.minColorValue && (this.dataMin = Math.min(this.dataMin, l.minColorValue), this.dataMax = Math.max(this.dataMax, l.maxColorValue));\n          q || a.prototype.applyExtremes.call(l);\n        }\n      };\n      q.prototype.drawCrosshair = function (a, d) {\n        var h = d && d.plotX,\n          g = d && d.plotY,\n          t = this.pos,\n          q = this.len;\n        if (d) {\n          var k = this.toPixels(d.getNestedProperty(d.series.colorKey));\n          k < t ? k = t - 2 : k > t + q && (k = t + q + 2);\n          d.plotX = k;\n          d.plotY = this.len - k;\n          b.prototype.drawCrosshair.call(this, a, d);\n          d.plotX = h;\n          d.plotY = g;\n          this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass(\"highcharts-coloraxis-marker\").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || \"object\" !== typeof this.crosshair || this.cross.attr({\n            fill: this.crosshair.color\n          }));\n        }\n      };\n      q.prototype.getPlotLinePath = function (a) {\n        var d = this.left,\n          h = a.translatedValue,\n          l = this.top;\n        return g(h) ? this.horiz ? [[\"M\", h - 4, l - 6], [\"L\", h + 4, l - 6], [\"L\", h, l], [\"Z\"]] : [[\"M\", d, h], [\"L\", d - 6, h + 6], [\"L\", d - 6, h - 6], [\"Z\"]] : b.prototype.getPlotLinePath.call(this, a);\n      };\n      q.prototype.update = function (a, d) {\n        var h = this.chart.legend;\n        this.series.forEach(function (a) {\n          a.isDirtyData = !0;\n        });\n        (a.dataClasses && h.allItems || this.dataClasses) && this.destroyItems();\n        b.prototype.update.call(this, a, d);\n        this.legendItem && (this.setLegendColor(), h.colorizeItem(this, !0));\n      };\n      q.prototype.destroyItems = function () {\n        var a = this.chart;\n        this.legendItem ? a.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (d) {\n          a.legend.destroyItem(d);\n        });\n        a.isDirtyLegend = !0;\n      };\n      q.prototype.destroy = function () {\n        this.chart.isDirtyLegend = !0;\n        this.destroyItems();\n        b.prototype.destroy.apply(this, [].slice.call(arguments));\n      };\n      q.prototype.remove = function (a) {\n        this.destroyItems();\n        b.prototype.remove.call(this, a);\n      };\n      q.prototype.getDataClassLegendSymbols = function () {\n        var a = this,\n          g = a.chart,\n          h = a.legendItems,\n          b = g.options.legend,\n          t = b.valueDecimals,\n          q = b.valueSuffix || \"\",\n          e;\n        h.length || a.dataClasses.forEach(function (b, l) {\n          var w = b.from,\n            x = b.to,\n            m = g.numberFormatter,\n            v = !0;\n          e = \"\";\n          \"undefined\" === typeof w ? e = \"< \" : \"undefined\" === typeof x && (e = \"> \");\n          \"undefined\" !== typeof w && (e += m(w, t) + q);\n          \"undefined\" !== typeof w && \"undefined\" !== typeof x && (e += \" - \");\n          \"undefined\" !== typeof x && (e += m(x, t) + q);\n          h.push(d({\n            chart: g,\n            name: e,\n            options: {},\n            drawLegendSymbol: u.drawRectangle,\n            visible: !0,\n            setState: k,\n            isDataClass: !0,\n            setVisible: function () {\n              v = a.visible = !v;\n              a.series.forEach(function (a) {\n                a.points.forEach(function (a) {\n                  a.dataClass === l && a.setVisible(v);\n                });\n              });\n              g.legend.colorizeItem(this, v);\n            }\n          }, b));\n        });\n        return h;\n      };\n      q.defaultColorAxisOptions = r;\n      q.defaultLegendLength = 200;\n      q.keepProps = [\"legendGroup\", \"legendItemHeight\", \"legendItemWidth\", \"legendItem\", \"legendSymbol\"];\n      return q;\n    }(c);\n    Array.prototype.push.apply(c.keepProps, f.keepProps);\n    \"\";\n    return f;\n  });\n  y(c, \"Maps/MapNavigationOptionsDefault.js\", [c[\"Core/DefaultOptions.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    f = f.extend;\n    var p = {\n      buttonOptions: {\n        alignTo: \"plotBox\",\n        align: \"left\",\n        verticalAlign: \"top\",\n        x: 0,\n        width: 18,\n        height: 18,\n        padding: 5,\n        style: {\n          fontSize: \"15px\",\n          fontWeight: \"bold\"\n        },\n        theme: {\n          \"stroke-width\": 1,\n          \"text-align\": \"center\"\n        }\n      },\n      buttons: {\n        zoomIn: {\n          onclick: function () {\n            this.mapZoom(.5);\n          },\n          text: \"+\",\n          y: 0\n        },\n        zoomOut: {\n          onclick: function () {\n            this.mapZoom(2);\n          },\n          text: \"-\",\n          y: 28\n        }\n      },\n      mouseWheelSensitivity: 1.1\n    };\n    f(c.defaultOptions.lang, {\n      zoomIn: \"Zoom in\",\n      zoomOut: \"Zoom out\"\n    });\n    return c.defaultOptions.mapNavigation = p;\n  });\n  y(c, \"Maps/MapNavigation.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, f, p) {\n    function r(a) {\n      a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);\n    }\n    function n(a) {\n      this.init(a);\n    }\n    var u = f.doc,\n      e = p.addEvent,\n      b = p.extend,\n      v = p.isNumber,\n      m = p.merge,\n      k = p.objectEach,\n      a = p.pick;\n    n.prototype.init = function (a) {\n      this.chart = a;\n      a.mapNavButtons = [];\n    };\n    n.prototype.update = function (d) {\n      var g = this.chart,\n        t = g.options.mapNavigation,\n        x,\n        v,\n        q,\n        w,\n        c = function (a) {\n          this.handler.call(g, a);\n          r(a);\n        },\n        h = g.mapNavButtons;\n      d && (t = g.options.mapNavigation = m(g.options.mapNavigation, d));\n      for (; h.length;) h.pop().destroy();\n      a(t.enableButtons, t.enabled) && !g.renderer.forExport && k(t.buttons, function (a, d) {\n        a = m(t.buttonOptions, a);\n        !g.styledMode && a.theme && (x = a.theme, x.style = m(a.theme.style, a.style), q = (v = x.states) && v.hover, w = v && v.select, delete x.states);\n        var l = g.renderer.button(a.text || \"\", 0, 0, c, x, q, w, void 0, \"zoomIn\" === d ? \"topbutton\" : \"bottombutton\").addClass(\"highcharts-map-navigation highcharts-\" + {\n          zoomIn: \"zoom-in\",\n          zoomOut: \"zoom-out\"\n        }[d]).attr({\n          width: a.width,\n          height: a.height,\n          title: g.options.lang[d],\n          padding: a.padding,\n          zIndex: 5\n        }).add();\n        l.handler = a.onclick;\n        e(l.element, \"dblclick\", r);\n        h.push(l);\n        b(a, {\n          width: l.width,\n          height: 2 * l.height\n        });\n        if (g.hasLoaded) l.align(a, !1, a.alignTo);else var k = e(g, \"load\", function () {\n          l.element && l.align(a, !1, a.alignTo);\n          k();\n        });\n      });\n      this.updateEvents(t);\n    };\n    n.prototype.updateEvents = function (d) {\n      var g = this.chart;\n      a(d.enableDoubleClickZoom, d.enabled) || d.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || e(g.container, \"dblclick\", function (a) {\n        g.pointer.onContainerDblClick(a);\n      }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());\n      a(d.enableMouseWheelZoom, d.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || e(g.container, void 0 !== u.onwheel ? \"wheel\" : void 0 !== u.onmousewheel ? \"mousewheel\" : \"DOMMouseScroll\", function (a) {\n        g.pointer.inClass(a.target, \"highcharts-no-mousewheel\") || (g.pointer.onContainerMouseWheel(a), r(a));\n        return !1;\n      }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());\n    };\n    b(c.prototype, {\n      fitToBox: function (a, g) {\n        [[\"x\", \"width\"], [\"y\", \"height\"]].forEach(function (d) {\n          var b = d[0];\n          d = d[1];\n          a[b] + a[d] > g[b] + g[d] && (a[d] > g[d] ? (a[d] = g[d], a[b] = g[b]) : a[b] = g[b] + g[d] - a[d]);\n          a[d] > g[d] && (a[d] = g[d]);\n          a[b] < g[b] && (a[b] = g[b]);\n        });\n        return a;\n      },\n      mapZoom: function (a, g, b, k, e) {\n        this.mapView && (v(a) && (a = Math.log(a) / Math.log(.5)), this.mapView.zoomBy(a, v(g) && v(b) ? this.mapView.projection.inverse([g, b]) : void 0, v(k) && v(e) ? [k, e] : void 0));\n      }\n    });\n    e(c, \"beforeRender\", function () {\n      this.mapNavigation = new n(this);\n      this.mapNavigation.update();\n    });\n    f.MapNavigation = n;\n  });\n  y(c, \"Maps/MapPointer.js\", [c[\"Core/Pointer.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    var p = f.defined,\n      r = f.extend,\n      n = f.pick;\n    f = f.wrap;\n    var u = 0,\n      e;\n    r(c.prototype, {\n      onContainerDblClick: function (b) {\n        var e = this.chart;\n        b = this.normalize(b);\n        e.options.mapNavigation.enableDoubleClickZoomTo ? e.pointer.inClass(b.target, \"highcharts-tracker\") && e.hoverPoint && e.hoverPoint.zoomTo() : e.isInsidePlot(b.chartX - e.plotLeft, b.chartY - e.plotTop) && e.mapZoom(.5, void 0, void 0, b.chartX, b.chartY);\n      },\n      onContainerMouseWheel: function (b) {\n        var v = this.chart;\n        b = this.normalize(b);\n        var m = p(b.wheelDelta) && -b.wheelDelta / 120 || b.deltaY || b.detail;\n        1 <= Math.abs(m) && (u += Math.abs(m), e && clearTimeout(e), e = setTimeout(function () {\n          u = 0;\n        }, 50));\n        10 > u && v.isInsidePlot(b.chartX - v.plotLeft, b.chartY - v.plotTop) && v.mapView && v.mapView.zoomBy((v.options.mapNavigation.mouseWheelSensitivity - 1) * -m, void 0, [b.chartX, b.chartY], 1 > Math.abs(m) ? !1 : void 0);\n      }\n    });\n    f(c.prototype, \"zoomOption\", function (b) {\n      var e = this.chart.options.mapNavigation;\n      n(e.enableTouchZoom, e.enabled) && (this.chart.options.chart.pinchType = \"xy\");\n      b.apply(this, [].slice.call(arguments, 1));\n    });\n    f(c.prototype, \"pinchTranslate\", function (b, e, m, k, a, d, g) {\n      b.call(this, e, m, k, a, d, g);\n      \"map\" === this.chart.options.chart.type && this.hasZoom && (b = k.scaleX > k.scaleY, this.pinchTranslateDirection(!b, e, m, k, a, d, g, b ? k.scaleX : k.scaleY));\n    });\n  });\n  y(c, \"Series/ColorMapMixin.js\", [c[\"Core/Globals.js\"], c[\"Core/Series/Point.js\"], c[\"Core/Utilities.js\"]], function (c, f, p) {\n    var r = c.noop;\n    c = c.seriesTypes;\n    var n = p.defined;\n    p = p.addEvent;\n    p(f, \"afterSetState\", function (c) {\n      this.moveToTopOnHover && this.graphic && this.graphic.attr({\n        zIndex: c && \"hover\" === c.state ? 1 : 0\n      });\n    });\n    return {\n      PointMixin: {\n        dataLabelOnNull: !0,\n        moveToTopOnHover: !0,\n        isValid: function () {\n          return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n        }\n      },\n      SeriesMixin: {\n        pointArrayMap: [\"value\"],\n        axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n        trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n        getSymbol: r,\n        parallelArrays: [\"x\", \"y\", \"value\"],\n        colorKey: \"value\",\n        pointAttribs: c.column.prototype.pointAttribs,\n        colorAttribs: function (c) {\n          var e = {};\n          !n(c.color) || c.state && \"normal\" !== c.state || (e[this.colorProp || \"fill\"] = c.color);\n          return e;\n        }\n      }\n    };\n  });\n  y(c, \"Maps/MapViewOptionsDefault.js\", [], function () {\n    return {\n      center: [0, 0],\n      maxZoom: void 0,\n      padding: 0,\n      projection: void 0,\n      zoom: void 0\n    };\n  });\n  y(c, \"Maps/Projections/LambertConformalConic.js\", [], function () {\n    var c = Math.sign || function (c) {\n        return 0 === c ? 0 : 0 < c ? 1 : -1;\n      },\n      f = Math.PI / 180,\n      p = Math.PI / 2,\n      r = 0,\n      n = 0;\n    return {\n      init: function (u) {\n        var e = (u.parallels || []).map(function (b) {\n          return b * f;\n        });\n        u = e[0] || 0;\n        e = e[1] || u;\n        var b = Math.cos(u);\n        r = u === e ? Math.sin(u) : Math.log(b / Math.cos(e)) / Math.log(Math.tan((p + e) / 2) / Math.tan((p + u) / 2));\n        1e-10 > Math.abs(r) && (r = 1e-10 * (c(r) || 1));\n        n = b * Math.pow(Math.tan((p + u) / 2), r) / r;\n      },\n      forward: function (c) {\n        var e = c[0] * f;\n        c = c[1] * f;\n        0 < n ? c < -p + .000001 && (c = -p + .000001) : c > p - .000001 && (c = p - .000001);\n        c = n / Math.pow(Math.tan((p + c) / 2), r);\n        return [c * Math.sin(r * e) * 63.78137, 63.78137 * (n - c * Math.cos(r * e))];\n      },\n      inverse: function (u) {\n        var e = u[0] / 63.78137;\n        u = n - u[1] / 63.78137;\n        var b = c(r) * Math.sqrt(e * e + u * u),\n          v = Math.atan2(e, Math.abs(u)) * c(u);\n        0 > u * r && (v -= Math.PI * c(e) * c(u));\n        return [v / r / f, (2 * Math.atan(Math.pow(n / b, 1 / r)) - p) / f];\n      }\n    };\n  });\n  y(c, \"Maps/Projections/EqualEarth.js\", [], function () {\n    var c = Math.sqrt(3) / 2;\n    return {\n      forward: function (f) {\n        var p = Math.PI / 180,\n          r = Math.asin(c * Math.sin(f[1] * p)),\n          n = r * r,\n          u = n * n * n;\n        return [f[0] * p * Math.cos(r) * 74.03120656864502 / (c * (1.340264 + 3 * -.081106 * n + u * (7 * .000893 + .034164 * n))), 74.03120656864502 * r * (1.340264 + -.081106 * n + u * (.000893 + .003796 * n))];\n      },\n      inverse: function (f) {\n        var p = f[0] / 74.03120656864502;\n        f = f[1] / 74.03120656864502;\n        var r = 180 / Math.PI,\n          n = f,\n          u;\n        for (u = 0; 12 > u; ++u) {\n          var e = n * n;\n          var b = e * e * e;\n          var v = n * (1.340264 + -.081106 * e + b * (.000893 + .003796 * e)) - f;\n          e = 1.340264 + 3 * -.081106 * e + b * (7 * .000893 + .034164 * e);\n          n -= v /= e;\n          if (1e-9 > Math.abs(v)) break;\n        }\n        e = n * n;\n        return [r * c * p * (1.340264 + 3 * -.081106 * e + e * e * e * (7 * .000893 + .034164 * e)) / Math.cos(n), r * Math.asin(Math.sin(n) / c)];\n      }\n    };\n  });\n  y(c, \"Maps/Projections/Miller.js\", [], function () {\n    var c = Math.PI / 4,\n      f = Math.PI / 180;\n    return {\n      forward: function (p) {\n        return [p[0] * f * 63.78137, 79.7267125 * Math.log(Math.tan(c + .4 * p[1] * f))];\n      },\n      inverse: function (p) {\n        return [p[0] / 63.78137 / f, 2.5 * (Math.atan(Math.exp(p[1] / 63.78137 * .8)) - c) / f];\n      }\n    };\n  });\n  y(c, \"Maps/Projections/Orthographic.js\", [], function () {\n    var c = Math.PI / 180;\n    return {\n      forward: function (f) {\n        var p = f[0];\n        if (-90 > p || 90 < p) return [NaN, NaN];\n        f = f[1] * c;\n        return [Math.cos(f) * Math.sin(p * c) * 63.78460826781007, 63.78460826781007 * Math.sin(f)];\n      },\n      inverse: function (f) {\n        var p = f[0] / 63.78460826781007;\n        f = f[1] / 63.78460826781007;\n        var r = Math.sqrt(p * p + f * f),\n          n = Math.asin(r),\n          u = Math.sin(n);\n        return [Math.atan2(p * u, r * Math.cos(n)) / c, Math.asin(r && f * u / r) / c];\n      }\n    };\n  });\n  y(c, \"Maps/Projections/WebMercator.js\", [], function () {\n    var c = Math.PI / 180;\n    return {\n      forward: function (f) {\n        if (85.0511287798 < Math.abs(f[1])) return [NaN, NaN];\n        var p = Math.sin(f[1] * c);\n        return [63.78137 * f[0] * c, 63.78137 * Math.log((1 + p) / (1 - p)) / 2];\n      },\n      inverse: function (f) {\n        return [f[0] / (63.78137 * c), (2 * Math.atan(Math.exp(f[1] / 63.78137)) - Math.PI / 2) / c];\n      },\n      maxLatitude: 85.0511287798\n    };\n  });\n  y(c, \"Maps/Projections/ProjectionRegistry.js\", [c[\"Maps/Projections/LambertConformalConic.js\"], c[\"Maps/Projections/EqualEarth.js\"], c[\"Maps/Projections/Miller.js\"], c[\"Maps/Projections/Orthographic.js\"], c[\"Maps/Projections/WebMercator.js\"]], function (c, f, p, r, n) {\n    return {\n      EqualEarth: f,\n      LambertConformalConic: c,\n      Miller: p,\n      Orthographic: r,\n      WebMercator: n\n    };\n  });\n  y(c, \"Maps/Projection.js\", [c[\"Maps/Projections/ProjectionRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    var p = this && this.__spreadArrays || function () {\n        for (var c = 0, b = 0, v = arguments.length; b < v; b++) c += arguments[b].length;\n        c = Array(c);\n        var m = 0;\n        for (b = 0; b < v; b++) for (var k = arguments[b], a = 0, d = k.length; a < d; a++, m++) c[m] = k[a];\n        return c;\n      },\n      r = f.erase,\n      n = 2 * Math.PI / 360,\n      u = function (c) {\n        -180 > c && (c += 360);\n        180 < c && (c -= 360);\n        return c;\n      };\n    return function () {\n      function e(b) {\n        void 0 === b && (b = {});\n        this.hasGeoProjection = this.hasCoordinates = !1;\n        this.maxLatitude = 90;\n        this.options = b;\n        var c = b.name,\n          m = b.rotation;\n        this.rotator = m ? this.getRotator(m) : void 0;\n        var k = this.def = c ? e.registry[c] : void 0,\n          a = this.rotator;\n        k && (k.init && k.init(b), this.maxLatitude = k.maxLatitude || 90, this.hasGeoProjection = !0);\n        a && k ? (this.forward = function (d) {\n          d = a.forward(d);\n          return k.forward(d);\n        }, this.inverse = function (d) {\n          d = k.inverse(d);\n          return a.inverse(d);\n        }) : k ? (this.forward = k.forward, this.inverse = k.inverse) : a && (this.forward = a.forward, this.inverse = a.inverse);\n      }\n      e.add = function (b, c) {\n        e.registry[b] = c;\n      };\n      e.greatCircle = function (b, c, e) {\n        var k = Math.atan2,\n          a = Math.cos,\n          d = Math.sin,\n          g = Math.sqrt,\n          t = b[1] * n,\n          m = b[0] * n,\n          v = c[1] * n,\n          q = c[0] * n,\n          w = v - t,\n          A = q - m;\n        w = d(w / 2) * d(w / 2) + a(t) * a(v) * d(A / 2) * d(A / 2);\n        w = 2 * k(g(w), g(1 - w));\n        var h = Math.round(6371E3 * w / 5E5);\n        A = [];\n        e && A.push(b);\n        if (1 < h) for (h = b = 1 / h; .999 > h; h += b) {\n          var l = d((1 - h) * w) / d(w),\n            u = d(h * w) / d(w),\n            f = l * a(t) * a(m) + u * a(v) * a(q),\n            p = l * a(t) * d(m) + u * a(v) * d(q);\n          l = l * d(t) + u * d(v);\n          l = k(l, g(f * f + p * p));\n          f = k(p, f);\n          A.push([f / n, l / n]);\n        }\n        e && A.push(c);\n        return A;\n      };\n      e.insertGreatCircles = function (b) {\n        for (var c = b.length - 1; c--;) if (10 < Math.max(Math.abs(b[c][0] - b[c + 1][0]), Math.abs(b[c][1] - b[c + 1][1]))) {\n          var m = e.greatCircle(b[c], b[c + 1]);\n          m.length && b.splice.apply(b, p([c + 1, 0], m));\n        }\n      };\n      e.toString = function (b) {\n        b = b || {};\n        var c = b.rotation;\n        return [b.name, c && c.join(\",\")].join(\";\");\n      };\n      e.prototype.getRotator = function (b) {\n        var c = b[0] * n,\n          e = (b[1] || 0) * n;\n        b = (b[2] || 0) * n;\n        var k = Math.cos(e),\n          a = Math.sin(e),\n          d = Math.cos(b),\n          g = Math.sin(b);\n        if (0 !== c || 0 !== e || 0 !== b) return {\n          forward: function (b) {\n            var e = b[0] * n + c,\n              t = b[1] * n,\n              q = Math.cos(t);\n            b = Math.cos(e) * q;\n            e = Math.sin(e) * q;\n            t = Math.sin(t);\n            q = t * k + b * a;\n            return [Math.atan2(e * d - q * g, b * k - t * a) / n, Math.asin(q * d + e * g) / n];\n          },\n          inverse: function (b) {\n            var e = b[0] * n,\n              t = b[1] * n,\n              q = Math.cos(t);\n            b = Math.cos(e) * q;\n            e = Math.sin(e) * q;\n            t = Math.sin(t);\n            q = t * d - e * g;\n            return [(Math.atan2(e * d + t * g, b * k + q * a) - c) / n, Math.asin(q * k - b * a) / n];\n          }\n        };\n      };\n      e.prototype.forward = function (b) {\n        return b;\n      };\n      e.prototype.inverse = function (b) {\n        return b;\n      };\n      e.prototype.clipOnAntimeridian = function (b, c) {\n        var m = [],\n          k = [b];\n        b.forEach(function (a, d) {\n          var g = b[d - 1];\n          if (!d) {\n            if (!c) return;\n            g = b[b.length - 1];\n          }\n          var h = g[0],\n            l = a[0];\n          (-90 > h || 90 < h) && (-90 > l || 90 < l) && 0 < h !== 0 < l && m.push({\n            i: d,\n            lat: g[1] + (180 - g[0]) / (a[0] - g[0]) * (a[1] - g[1]),\n            direction: 0 > h ? 1 : -1,\n            previousLonLat: g,\n            lonLat: a\n          });\n        });\n        if (m.length) if (c) {\n          if (1 === m.length % 2) {\n            var a = m.slice().sort(function (a, d) {\n              return Math.abs(d.lat) - Math.abs(a.lat);\n            })[0];\n            r(m, a);\n          }\n          for (var d = m.length - 2; 0 <= d;) {\n            var g = m[d].i,\n              t = u(180 + .000001 * m[d].direction),\n              x = u(180 - .000001 * m[d].direction);\n            g = b.splice.apply(b, p([g, m[d + 1].i - g], e.greatCircle([t, m[d].lat], [t, m[d + 1].lat], !0)));\n            g.push.apply(g, e.greatCircle([x, m[d + 1].lat], [x, m[d].lat], !0));\n            k.push(g);\n            d -= 2;\n          }\n          if (a) for (g = 0; g < k.length; g++) if (d = k[g], x = d.indexOf(a.lonLat), -1 < x) {\n            g = (0 > a.lat ? -1 : 1) * this.maxLatitude;\n            t = u(180 + .000001 * a.direction);\n            var v = u(180 - .000001 * a.direction);\n            a = e.greatCircle([t, a.lat], [t, g], !0).concat(e.greatCircle([v, g], [v, a.lat], !0));\n            d.splice.apply(d, p([x, 0], a));\n            break;\n          }\n        } else for (d = m.length; d--;) g = m[d].i, g = b.splice(g, b.length, [u(180 + .000001 * m[d].direction), m[d].lat]), g.unshift([u(180 - .000001 * m[d].direction), m[d].lat]), k.push(g);\n        return k;\n      };\n      e.prototype.path = function (b) {\n        var c = this,\n          m = this.def,\n          k = this.rotator,\n          a = [],\n          d = \"Polygon\" === b.type || \"MultiPolygon\" === b.type,\n          g = this.hasGeoProjection,\n          t = \"Orthographic\" !== this.options.name,\n          x = t ? k : void 0,\n          u = t ? m || this : this,\n          q = function (b) {\n            b = b.map(function (a) {\n              if (t) {\n                x && (a = x.forward(a));\n                var d = a[0];\n                .000001 > Math.abs(d - 180) && (d = 180 > d ? 179.999999 : 180.000001);\n                a = [d, a[1]];\n              }\n              return a;\n            });\n            var k = [b];\n            g && (e.insertGreatCircles(b), t && (k = c.clipOnAntimeridian(b, d)));\n            k.forEach(function (h) {\n              if (!(2 > h.length)) for (var b = !1, k, q, t = !1, m = function (d) {\n                  b ? a.push([\"L\", d[0], d[1]]) : (a.push([\"M\", d[0], d[1]]), b = !0);\n                }, w = 0; w < h.length; w++) {\n                var x = h[w],\n                  v = u.forward(x);\n                isNaN(v[0]) || isNaN(v[1]) || g && !(x[1] <= c.maxLatitude && x[1] >= -c.maxLatitude) ? t = !0 : (d && !k && (k = x, h.push(x)), t && q && (d && g ? e.greatCircle(q, x).forEach(function (a) {\n                  return m(u.forward(a));\n                }) : b = !1), m(v), q = x, t = !1);\n              }\n            });\n          };\n        \"LineString\" === b.type ? q(b.coordinates) : \"MultiLineString\" === b.type ? b.coordinates.forEach(function (a) {\n          return q(a);\n        }) : \"Polygon\" === b.type ? (b.coordinates.forEach(function (a) {\n          return q(a);\n        }), a.length && a.push([\"Z\"])) : \"MultiPolygon\" === b.type && (b.coordinates.forEach(function (a) {\n          a.forEach(function (a) {\n            return q(a);\n          });\n        }), a.length && a.push([\"Z\"]));\n        return a;\n      };\n      e.registry = c;\n      return e;\n    }();\n  });\n  y(c, \"Maps/MapView.js\", [c[\"Maps/MapViewOptionsDefault.js\"], c[\"Maps/Projection.js\"], c[\"Core/Utilities.js\"]], function (c, f, p) {\n    var r = p.addEvent,\n      n = p.clamp,\n      u = p.fireEvent,\n      e = p.isNumber,\n      b = p.merge,\n      v = p.pick,\n      m = p.relativeLength;\n    return function () {\n      function k(a, d) {\n        var g = this;\n        this.userOptions = d || {};\n        d = b(c, d);\n        this.chart = a;\n        this.center = d.center;\n        this.options = d;\n        this.projection = new f(d.projection);\n        this.zoom = d.zoom || 0;\n        r(a, \"afterSetChartSize\", function () {\n          if (void 0 === g.minZoom || g.minZoom === g.zoom) g.fitToBounds(void 0, void 0, !1), e(g.userOptions.zoom) && (g.zoom = g.userOptions.zoom), g.userOptions.center && b(!0, g.center, g.userOptions.center);\n        });\n        var k, m, v;\n        d = function (d) {\n          var b = a.pointer.pinchDown,\n            c = a.mouseDownX,\n            h = a.mouseDownY;\n          1 === b.length && (c = b[0].chartX, h = b[0].chartY);\n          if (\"number\" === typeof c && \"number\" === typeof h) {\n            var l = c + \",\" + h,\n              e = d.originalEvent;\n            b = e.chartX;\n            e = e.chartY;\n            l !== m && (m = l, k = g.projection.forward(g.center), v = (g.projection.options.rotation || [0, 0]).slice());\n            \"Orthographic\" === g.projection.options.name && 3 > (g.minZoom || Infinity) ? (l = 440 / (g.getScale() * Math.min(a.plotWidth, a.plotHeight)), v && (c = (c - b) * l - v[0], h = n(-v[1] - (h - e) * l, -80, 80), g.update({\n              projection: {\n                rotation: [-c, -h]\n              },\n              center: [c, h],\n              zoom: g.zoom\n            }, !0, !1))) : (l = g.getScale(), h = g.projection.inverse([k[0] + (c - b) / l, k[1] - (h - e) / l]), g.setView(h, void 0, !0, !1));\n            d.preventDefault();\n          }\n        };\n        r(a, \"pan\", d);\n        r(a, \"touchpan\", d);\n        r(a, \"selection\", function (d) {\n          if (d.resetSelection) g.zoomBy();else {\n            var b = d.x - a.plotLeft,\n              c = d.y - a.plotTop,\n              h = g.pixelsToProjectedUnits({\n                x: b,\n                y: c\n              }),\n              l = h.y;\n            h = h.x;\n            b = g.pixelsToProjectedUnits({\n              x: b + d.width,\n              y: c + d.height\n            });\n            g.fitToBounds({\n              x1: h,\n              y1: l,\n              x2: b.x,\n              y2: b.y\n            }, void 0, !0, d.originalEvent.touches ? !1 : void 0);\n            /^touch/.test(d.originalEvent.type) || a.showResetZoom();\n            d.preventDefault();\n          }\n        });\n      }\n      k.prototype.fitToBounds = function (a, d, b, c) {\n        void 0 === b && (b = !0);\n        var g = a || this.getProjectedBounds();\n        if (g) {\n          var e = this.chart,\n            k = e.plotWidth;\n          e = e.plotHeight;\n          var t = v(d, a ? 0 : this.options.padding);\n          d = m(t, k);\n          t = m(t, e);\n          k = Math.log(400.979322 / Math.max((g.x2 - g.x1) / ((k - d) / 256), (g.y2 - g.y1) / ((e - t) / 256))) / Math.log(2);\n          a || (this.minZoom = k);\n          a = this.projection.inverse([(g.x2 + g.x1) / 2, (g.y2 + g.y1) / 2]);\n          this.setView(a, k, b, c);\n        }\n      };\n      k.prototype.getProjectedBounds = function () {\n        var a = this.chart.series.reduce(function (a, b) {\n          (b = b.getProjectedBounds && b.getProjectedBounds()) && a.push(b);\n          return a;\n        }, []);\n        return k.compositeBounds(a);\n      };\n      k.prototype.getScale = function () {\n        return 256 / 400.979322 * Math.pow(2, this.zoom);\n      };\n      k.prototype.redraw = function (a) {\n        this.chart.series.forEach(function (a) {\n          a.useMapGeometry && (a.isDirty = !0);\n        });\n        this.chart.redraw(a);\n      };\n      k.prototype.setView = function (a, d, b, c) {\n        void 0 === b && (b = !0);\n        var g = !1;\n        a && (this.center = a);\n        \"number\" === typeof d && (\"number\" === typeof this.minZoom && (d = Math.max(d, this.minZoom)), \"number\" === typeof this.options.maxZoom && (d = Math.min(d, this.options.maxZoom)), g = d > this.zoom, this.zoom = d);\n        var e = this.getProjectedBounds();\n        if (e && !g) {\n          g = this.projection.forward(this.center);\n          d = this.chart;\n          a = d.plotWidth;\n          d = d.plotHeight;\n          var k = this.getScale(),\n            t = this.projectedUnitsToPixels({\n              x: e.x1,\n              y: e.y1\n            }),\n            m = this.projectedUnitsToPixels({\n              x: e.x2,\n              y: e.y2\n            });\n          e = [(e.x1 + e.x2) / 2, (e.y1 + e.y2) / 2];\n          var h = t.x,\n            l = m.y;\n          m = m.x;\n          t = t.y;\n          m - h < a ? g[0] = e[0] : 0 > h && m < a ? g[0] += Math.max(h, m - a) / k : m > a && 0 < h && (g[0] += Math.min(m - a, h) / k);\n          t - l < d ? g[1] = e[1] : 0 > l && t < d ? g[1] -= Math.max(l, t - d) / k : t > d && 0 < l && (g[1] -= Math.min(t - d, l) / k);\n          this.center = this.projection.inverse(g);\n        }\n        u(this, \"afterSetView\");\n        b && this.redraw(c);\n      };\n      k.prototype.projectedUnitsToPixels = function (a) {\n        var d = this.getScale(),\n          b = this.projection.forward(this.center);\n        return {\n          x: this.chart.plotWidth / 2 - d * (b[0] - a.x),\n          y: this.chart.plotHeight / 2 + d * (b[1] - a.y)\n        };\n      };\n      k.prototype.pixelsToProjectedUnits = function (a) {\n        var d = a.x;\n        a = a.y;\n        var b = this.getScale(),\n          c = this.projection.forward(this.center);\n        return {\n          x: c[0] + (d - this.chart.plotWidth / 2) / b,\n          y: c[1] - (a - this.chart.plotHeight / 2) / b\n        };\n      };\n      k.prototype.update = function (a, d, g) {\n        void 0 === d && (d = !0);\n        var c = a.projection;\n        c = c && f.toString(c) !== f.toString(this.options.projection);\n        b(!0, this.userOptions, a);\n        b(!0, this.options, a);\n        c && (this.chart.series.forEach(function (a) {\n          a.clearBounds && a.clearBounds();\n          a.isDirty = !0;\n          a.isDirtyData = !0;\n        }), this.projection = new f(this.options.projection), a.center || e(a.zoom) || this.fitToBounds(void 0, void 0, !1));\n        (a.center || e(a.zoom)) && this.setView(this.options.center, a.zoom, !1);\n        d && this.chart.redraw(g);\n      };\n      k.prototype.zoomBy = function (a, b, g, c) {\n        var d = this.chart,\n          e = this.projection.forward(this.center);\n        b = b ? this.projection.forward(b) : [];\n        var k = b[0],\n          t = b[1];\n        \"number\" === typeof a ? (a = this.zoom + a, b = void 0, g && (k = g[0], t = g[1], g = this.getScale(), k = k - d.plotLeft - d.plotWidth / 2, d = t - d.plotTop - d.plotHeight / 2, k = e[0] + k / g, t = e[1] + d / g), \"number\" === typeof k && \"number\" === typeof t && (g = 1 - Math.pow(2, this.zoom) / Math.pow(2, a), k = e[0] - k, d = e[1] - t, e[0] -= k * g, e[1] += d * g, b = this.projection.inverse(e)), this.setView(b, a, void 0, c)) : this.fitToBounds(void 0, void 0, void 0, c);\n      };\n      k.compositeBounds = function (a) {\n        if (a.length) return a.slice(1).reduce(function (a, b) {\n          a.x1 = Math.min(a.x1, b.x1);\n          a.y1 = Math.min(a.y1, b.y1);\n          a.x2 = Math.max(a.x2, b.x2);\n          a.y2 = Math.max(a.y2, b.y2);\n          return a;\n        }, b(a[0]));\n      };\n      return k;\n    }();\n  });\n  y(c, \"Maps/MapSymbols.js\", [c[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (c) {\n    function f(c, f, n, u, e, b, v, m) {\n      return [[\"M\", c + e, f], [\"L\", c + n - b, f], [\"C\", c + n - b / 2, f, c + n, f + b / 2, c + n, f + b], [\"L\", c + n, f + u - v], [\"C\", c + n, f + u - v / 2, c + n - v / 2, f + u, c + n - v, f + u], [\"L\", c + m, f + u], [\"C\", c + m / 2, f + u, c, f + u - m / 2, c, f + u - m], [\"L\", c, f + e], [\"C\", c, f + e / 2, c + e / 2, f, c + e, f], [\"Z\"]];\n    }\n    c = c.prototype.symbols;\n    c.bottombutton = function (c, r, n, u, e) {\n      e = e && e.r || 0;\n      return f(c - 1, r - 1, n, u, 0, 0, e, e);\n    };\n    c.topbutton = function (c, r, n, u, e) {\n      e = e && e.r || 0;\n      return f(c - 1, r - 1, n, u, e, e, 0, 0);\n    };\n    return c;\n  });\n  y(c, \"Core/Chart/MapChart.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/DefaultOptions.js\"], c[\"Maps/MapView.js\"], c[\"Core/Renderer/SVG/SVGRenderer.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r, n) {\n    var u = this && this.__extends || function () {\n        var b = function (a, d) {\n          b = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);\n          };\n          return b(a, d);\n        };\n        return function (a, d) {\n          function c() {\n            this.constructor = a;\n          }\n          b(a, d);\n          a.prototype = null === d ? Object.create(d) : (c.prototype = d.prototype, new c());\n        };\n      }(),\n      e = f.getOptions,\n      b = n.addEvent,\n      v = n.merge,\n      m = n.pick;\n    c = function (c) {\n      function a() {\n        return null !== c && c.apply(this, arguments) || this;\n      }\n      u(a, c);\n      a.prototype.init = function (a, g) {\n        b(this, \"afterInit\", function () {\n          this.mapView = new p(this, this.options.mapView);\n        });\n        var d = e().credits;\n        a = v({\n          chart: {\n            panning: {\n              enabled: !0,\n              type: \"xy\"\n            },\n            type: \"map\"\n          },\n          credits: {\n            mapText: m(d.mapText, ' \\u00a9 <a href=\"{geojson.copyrightUrl}\">{geojson.copyrightShort}</a>'),\n            mapTextFull: m(d.mapTextFull, \"{geojson.copyright}\")\n          },\n          mapView: {},\n          tooltip: {\n            followTouchMove: !1\n          }\n        }, a);\n        c.prototype.init.call(this, a, g);\n      };\n      return a;\n    }(c);\n    (function (b) {\n      b.maps = {};\n      b.mapChart = function (a, d, c) {\n        return new b(a, d, c);\n      };\n      b.splitPath = function (a) {\n        \"string\" === typeof a && (a = a.replace(/([A-Za-z])/g, \" $1 \").replace(/^\\s*/, \"\").replace(/\\s*$/, \"\"), a = a.split(/[ ,;]+/).map(function (a) {\n          return /[A-za-z]/.test(a) ? a : parseFloat(a);\n        }));\n        return r.prototype.pathToSegments(a);\n      };\n    })(c || (c = {}));\n    return c;\n  });\n  y(c, \"Series/Map/MapPoint.js\", [c[\"Series/ColorMapMixin.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p) {\n    var r = this && this.__extends || function () {\n        var c = function (e, b) {\n          c = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (b, c) {\n            b.__proto__ = c;\n          } || function (b, c) {\n            for (var e in c) c.hasOwnProperty(e) && (b[e] = c[e]);\n          };\n          return c(e, b);\n        };\n        return function (e, b) {\n          function f() {\n            this.constructor = e;\n          }\n          c(e, b);\n          e.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n        };\n      }(),\n      n = p.extend;\n    f = function (c) {\n      function e() {\n        var b = null !== c && c.apply(this, arguments) || this;\n        b.options = void 0;\n        b.path = void 0;\n        b.series = void 0;\n        return b;\n      }\n      r(e, c);\n      e.getProjectedPath = function (b, c) {\n        b.projectedPath || (c && b.geometry ? (c.hasCoordinates = !0, b.projectedPath = c.path(b.geometry)) : b.projectedPath = b.path);\n        return b.projectedPath || [];\n      };\n      e.prototype.applyOptions = function (b, e) {\n        var m = this.series;\n        b = c.prototype.applyOptions.call(this, b, e);\n        e = m.joinBy;\n        m.mapData && m.mapMap && (e = c.prototype.getNestedProperty.call(b, e[1]), (m = \"undefined\" !== typeof e && m.mapMap[e]) ? n(b, m) : b.value = b.value || null);\n        return b;\n      };\n      e.prototype.onMouseOver = function (b) {\n        p.clearTimeout(this.colorInterval);\n        if (null !== this.value || this.series.options.nullInteraction) c.prototype.onMouseOver.call(this, b);else this.series.onMouseOut(b);\n      };\n      e.prototype.zoomTo = function () {\n        var b = this.series.chart;\n        b.mapView && this.bounds && (b.mapView.fitToBounds(this.bounds, void 0, !1), this.series.isDirty = !0, b.redraw());\n      };\n      return e;\n    }(f.seriesTypes.scatter.prototype.pointClass);\n    n(f.prototype, {\n      dataLabelOnNull: c.PointMixin.dataLabelOnNull,\n      isValid: c.PointMixin.isValid,\n      moveToTopOnHover: c.PointMixin.moveToTopOnHover\n    });\n    return f;\n  });\n  y(c, \"Series/Map/MapSeries.js\", [c[\"Core/Animation/AnimationUtilities.js\"], c[\"Series/ColorMapMixin.js\"], c[\"Series/CenteredUtilities.js\"], c[\"Core/Globals.js\"], c[\"Core/Legend/LegendSymbol.js\"], c[\"Core/Chart/MapChart.js\"], c[\"Series/Map/MapPoint.js\"], c[\"Maps/MapView.js\"], c[\"Core/Series/Series.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Renderer/SVG/SVGRenderer.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r, n, u, e, b, v, m, k, a) {\n    var d = this && this.__extends || function () {\n        var a = function (b, c) {\n          a = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n          };\n          return a(b, c);\n        };\n        return function (b, c) {\n          function d() {\n            this.constructor = b;\n          }\n          a(b, c);\n          b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n        };\n      }(),\n      g = c.animObject;\n    c = r.noop;\n    var t = u.maps,\n      x = u.splitPath;\n    u = m.seriesTypes;\n    var z = u.column,\n      q = u.scatter;\n    u = a.extend;\n    var w = a.fireEvent,\n      A = a.getNestedProperty,\n      h = a.isArray,\n      l = a.isNumber,\n      B = a.merge,\n      E = a.objectEach,\n      C = a.pick,\n      F = a.splat;\n    a = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.group = void 0;\n        b.joinBy = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.transformGroup = void 0;\n        return b;\n      }\n      d(c, a);\n      c.prototype.animate = function (a) {\n        var b = this.chart,\n          c = this.group,\n          d = g(this.options.animation);\n        b.renderer.isSVG && (a ? c.attr({\n          translateX: b.plotLeft + b.plotWidth / 2,\n          translateY: b.plotTop + b.plotHeight / 2,\n          scaleX: .001,\n          scaleY: .001\n        }) : c.animate({\n          translateX: b.plotLeft,\n          translateY: b.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        }, d));\n      };\n      c.prototype.animateDrilldown = function (a) {\n        var b = this.chart,\n          c = this.group;\n        b.renderer.isSVG && (a ? c.attr({\n          translateX: b.plotLeft + b.plotWidth / 2,\n          translateY: b.plotTop + b.plotHeight / 2,\n          scaleX: .1,\n          scaleY: .1,\n          opacity: .01\n        }) : c.animate({\n          translateX: b.plotLeft,\n          translateY: b.plotTop,\n          scaleX: 1,\n          scaleY: 1,\n          opacity: 1\n        }));\n      };\n      c.prototype.animateDrillupFrom = function () {\n        var a = this.chart;\n        a.renderer.isSVG && this.group.animate({\n          translateX: a.plotLeft + a.plotWidth / 2,\n          translateY: a.plotTop + a.plotHeight / 2,\n          scaleX: .1,\n          scaleY: .1,\n          opacity: .01\n        });\n      };\n      c.prototype.animateDrillupTo = function (a) {\n        z.prototype.animateDrillupTo.call(this, a);\n      };\n      c.prototype.clearBounds = function () {\n        this.points.forEach(function (a) {\n          delete a.bounds;\n          delete a.projectedPath;\n        });\n        delete this.bounds;\n      };\n      c.prototype.doFullTranslate = function () {\n        return !(!(this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML) && this.hasRendered);\n      };\n      c.prototype.drawMapDataLabels = function () {\n        v.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      };\n      c.prototype.drawPoints = function () {\n        var a = this,\n          b = this.chart,\n          c = this.group,\n          d = this.svgTransform,\n          h = b.mapView,\n          g = b.renderer;\n        this.transformGroup || (this.transformGroup = g.g().add(c), this.transformGroup.survive = !0);\n        this.doFullTranslate() && (b.hasRendered && !b.styledMode && this.points.forEach(function (b) {\n          b.shapeArgs && (b.shapeArgs.fill = a.pointAttribs(b, b.state).fill);\n        }), this.group = this.transformGroup, z.prototype.drawPoints.apply(this), this.group = c, this.points.forEach(function (c) {\n          if (c.graphic) {\n            var d = \"\";\n            c.name && (d += \"highcharts-name-\" + c.name.replace(/ /g, \"-\").toLowerCase());\n            c.properties && c.properties[\"hc-key\"] && (d += \" highcharts-key-\" + c.properties[\"hc-key\"].toLowerCase());\n            d && c.graphic.addClass(d);\n            b.styledMode && c.graphic.css(a.pointAttribs(c, c.selected && \"select\" || void 0));\n          }\n        }));\n        if (h && d) {\n          var e = C(this.options[this.pointAttrToOptions && this.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], 1),\n            l = d.scaleX,\n            k = 0 < d.scaleY ? 1 : -1,\n            t = this.transformGroup;\n          if (g.globalAnimation && b.hasRendered) {\n            var m = Number(t.attr(\"translateX\")),\n              q = Number(t.attr(\"translateY\")),\n              f = Number(t.attr(\"scaleX\"));\n            t.attr({\n              animator: 0\n            }).animate({\n              animator: 1\n            }, {\n              step: function (a, b) {\n                a = f + (l - f) * b.pos;\n                t.attr({\n                  translateX: m + (d.translateX - m) * b.pos,\n                  translateY: q + (d.translateY - q) * b.pos,\n                  scaleX: a,\n                  scaleY: a * k\n                });\n                c.element.setAttribute(\"stroke-width\", e / a);\n              }\n            });\n          } else t.attr(d), c.element.setAttribute(\"stroke-width\", e / l);\n        }\n        this.drawMapDataLabels();\n      };\n      c.prototype.getProjectedBounds = function () {\n        if (!this.bounds) {\n          var a = Number.MAX_VALUE,\n            c = this.chart.mapView && this.chart.mapView.projection,\n            d = [];\n          (this.points || []).forEach(function (b) {\n            if (b.path || b.geometry) {\n              \"string\" === typeof b.path ? b.path = x(b.path) : h(b.path) && \"M\" === b.path[0] && (b.path = k.prototype.pathToSegments(b.path));\n              if (!b.bounds) {\n                var g = e.getProjectedPath(b, c),\n                  t = b.properties,\n                  m = -a,\n                  q = a,\n                  f = -a,\n                  w = a,\n                  v;\n                g.forEach(function (a) {\n                  var b = a[a.length - 2];\n                  a = a[a.length - 1];\n                  \"number\" === typeof b && \"number\" === typeof a && (q = Math.min(q, b), m = Math.max(m, b), w = Math.min(w, a), f = Math.max(f, a), v = !0);\n                });\n                v && (g = t && t[\"hc-middle-x\"], g = q + (m - q) * C(b.middleX, l(g) ? g : .5), t = t && t[\"hc-middle-y\"], t = C(b.middleY, l(t) ? t : .5), b.geometry || (t = 1 - t), b.bounds = {\n                  midX: g,\n                  midY: f - (f - w) * t,\n                  x1: q,\n                  y1: w,\n                  x2: m,\n                  y2: f\n                }, b.labelrank = C(b.labelrank, (m - q) * (f - w)));\n              }\n              b.bounds && d.push(b.bounds);\n            }\n          });\n          this.bounds = b.compositeBounds(d);\n        }\n        return this.bounds;\n      };\n      c.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n      c.prototype.pointAttribs = function (a, b) {\n        var c = a.series.chart,\n          d = c.mapView;\n        b = c.styledMode ? this.colorAttribs(a) : z.prototype.pointAttribs.call(this, a, b);\n        (a = a.options[this.pointAttrToOptions && this.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"]) && d && (a /= d.getScale());\n        b.dashstyle && d && this.options.borderWidth && (a = this.options.borderWidth / d.getScale());\n        b[\"stroke-width\"] = C(a, \"inherit\");\n        return b;\n      };\n      c.prototype.setData = function (a, b, c, d) {\n        var g = this.options,\n          k = this.chart.options.chart,\n          m = k && k.map,\n          q = g.mapData,\n          f = this.joinBy,\n          w = g.keys || this.pointArrayMap,\n          u = [],\n          x = {},\n          n = this.chart.mapTransforms;\n        !q && m && (q = \"string\" === typeof m ? t[m] : m);\n        a && a.forEach(function (b, c) {\n          var d = 0;\n          if (l(b)) a[c] = {\n            value: b\n          };else if (h(b)) {\n            a[c] = {};\n            !g.keys && b.length > w.length && \"string\" === typeof b[0] && (a[c][\"hc-key\"] = b[0], ++d);\n            for (var k = 0; k < w.length; ++k, ++d) w[k] && \"undefined\" !== typeof b[d] && (0 < w[k].indexOf(\".\") ? e.prototype.setNestedProperty(a[c], b[d], w[k]) : a[c][w[k]] = b[d]);\n          }\n          f && \"_i\" === f[0] && (a[c]._i = c);\n        });\n        (this.chart.mapTransforms = n = k.mapTransforms || q && q[\"hc-transform\"] || n) && E(n, function (a) {\n          a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));\n        });\n        if (q) {\n          \"FeatureCollection\" === q.type && (this.mapTitle = q.title, q = r.geojson(q, this.type, this));\n          this.mapData = q;\n          this.mapMap = {};\n          for (n = 0; n < q.length; n++) k = q[n], m = k.properties, k._i = n, f[0] && m && m[f[0]] && (k[f[0]] = m[f[0]]), x[k[f[0]]] = k;\n          this.mapMap = x;\n          if (a && f[1]) {\n            var p = f[1];\n            a.forEach(function (a) {\n              a = A(p, a);\n              x[a] && u.push(x[a]);\n            });\n          }\n          if (g.allAreas) {\n            a = a || [];\n            if (f[1]) {\n              var z = f[1];\n              a.forEach(function (a) {\n                u.push(A(z, a));\n              });\n            }\n            u = \"|\" + u.map(function (a) {\n              return a && a[f[0]];\n            }).join(\"|\") + \"|\";\n            q.forEach(function (b) {\n              f[0] && -1 !== u.indexOf(\"|\" + b[f[0]] + \"|\") || (a.push(B(b, {\n                value: null\n              })), d = !1);\n            });\n          }\n        }\n        v.prototype.setData.call(this, a, b, c, d);\n        this.processData();\n        this.generatePoints();\n      };\n      c.prototype.setOptions = function (a) {\n        a = v.prototype.setOptions.call(this, a);\n        var b = a.joinBy;\n        null === b && (b = \"_i\");\n        b = this.joinBy = F(b);\n        b[1] || (b[1] = b[0]);\n        return a;\n      };\n      c.prototype.translate = function () {\n        var a = this.doFullTranslate(),\n          b = this.chart.mapView,\n          c = b && b.projection;\n        !this.chart.hasRendered || !this.isDirtyData && this.hasRendered || (this.processData(), this.generatePoints(), delete this.bounds, this.getProjectedBounds());\n        var d;\n        if (b) {\n          var h = b.getScale(),\n            g = b.projection.forward(b.center);\n          b = b.projection.hasCoordinates ? -1 : 1;\n          this.svgTransform = d = {\n            scaleX: h,\n            scaleY: h * b,\n            translateX: this.chart.plotWidth / 2 - g[0] * h,\n            translateY: this.chart.plotHeight / 2 - g[1] * h * b\n          };\n        }\n        this.points.forEach(function (b) {\n          d && b.bounds && l(b.bounds.midX) && l(b.bounds.midY) && (b.plotX = b.bounds.midX * d.scaleX + d.translateX, b.plotY = b.bounds.midY * d.scaleY + d.translateY);\n          a && (b.shapeType = \"path\", b.shapeArgs = {\n            d: e.getProjectedPath(b, c)\n          });\n        });\n        w(this, \"afterTranslate\");\n      };\n      c.defaultOptions = B(q.defaultOptions, {\n        animation: !1,\n        dataLabels: {\n          crop: !1,\n          formatter: function () {\n            var a = this.series.chart.numberFormatter,\n              b = this.point.value;\n            return l(b) ? a(b, -1) : \"\";\n          },\n          inside: !0,\n          overflow: !1,\n          padding: 0,\n          verticalAlign: \"middle\"\n        },\n        marker: null,\n        nullColor: \"#f7f7f7\",\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0,\n          pointFormat: \"{point.name}: {point.value}<br/>\"\n        },\n        turboThreshold: 0,\n        allAreas: !0,\n        borderColor: \"#cccccc\",\n        borderWidth: 1,\n        joinBy: \"hc-key\",\n        states: {\n          hover: {\n            halo: null,\n            brightness: .2\n          },\n          normal: {\n            animation: !0\n          },\n          select: {\n            color: \"#cccccc\"\n          },\n          inactive: {\n            opacity: 1\n          }\n        }\n      });\n      return c;\n    }(q);\n    u(a.prototype, {\n      type: \"map\",\n      axisTypes: f.SeriesMixin.axisTypes,\n      colorAttribs: f.SeriesMixin.colorAttribs,\n      colorKey: f.SeriesMixin.colorKey,\n      directTouch: !0,\n      drawDataLabels: c,\n      drawGraph: c,\n      drawLegendSymbol: n.drawRectangle,\n      forceDL: !0,\n      getCenter: p.getCenter,\n      getExtremesFromAll: !0,\n      getSymbol: f.SeriesMixin.getSymbol,\n      isCartesian: !1,\n      parallelArrays: f.SeriesMixin.parallelArrays,\n      pointArrayMap: f.SeriesMixin.pointArrayMap,\n      pointClass: e,\n      preserveAspectRatio: !0,\n      searchPoint: c,\n      trackerGroups: f.SeriesMixin.trackerGroups,\n      useMapGeometry: !0\n    });\n    m.registerSeriesType(\"map\", a);\n    \"\";\n    return a;\n  });\n  y(c, \"Series/MapLine/MapLineSeries.js\", [c[\"Series/Map/MapSeries.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p) {\n    var r = this && this.__extends || function () {\n        var b = function (c, e) {\n          b = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (b, a) {\n            b.__proto__ = a;\n          } || function (b, a) {\n            for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);\n          };\n          return b(c, e);\n        };\n        return function (c, e) {\n          function k() {\n            this.constructor = c;\n          }\n          b(c, e);\n          c.prototype = null === e ? Object.create(e) : (k.prototype = e.prototype, new k());\n        };\n      }(),\n      n = f.series,\n      u = p.extend,\n      e = p.merge;\n    p = function (b) {\n      function f() {\n        var c = null !== b && b.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n      r(f, b);\n      f.prototype.pointAttribs = function (b, e) {\n        b = c.prototype.pointAttribs.call(this, b, e);\n        b.fill = this.options.fillColor;\n        return b;\n      };\n      f.defaultOptions = e(c.defaultOptions, {\n        lineWidth: 1,\n        fillColor: \"none\"\n      });\n      return f;\n    }(c);\n    u(p.prototype, {\n      type: \"mapline\",\n      colorProp: \"stroke\",\n      drawLegendSymbol: n.prototype.drawLegendSymbol,\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      }\n    });\n    f.registerSeriesType(\"mapline\", p);\n    \"\";\n    return p;\n  });\n  y(c, \"Series/MapPoint/MapPointPoint.js\", [c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    var p = this && this.__extends || function () {\n        var c = function (e, b) {\n          c = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (b, c) {\n            b.__proto__ = c;\n          } || function (b, c) {\n            for (var e in c) c.hasOwnProperty(e) && (b[e] = c[e]);\n          };\n          return c(e, b);\n        };\n        return function (e, b) {\n          function f() {\n            this.constructor = e;\n          }\n          c(e, b);\n          e.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n        };\n      }(),\n      r = f.isNumber,\n      n = f.merge;\n    return function (c) {\n      function e() {\n        var b = null !== c && c.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n      p(e, c);\n      e.prototype.applyOptions = function (b, e) {\n        b = \"undefined\" !== typeof b.lat && \"undefined\" !== typeof b.lon ? n(b, this.series.chart.fromLatLonToPoint(b)) : b;\n        return c.prototype.applyOptions.call(this, b, e);\n      };\n      e.prototype.isValid = function () {\n        return !!(this.options.geometry || r(this.x) && r(this.y));\n      };\n      return e;\n    }(c.seriesTypes.scatter.prototype.pointClass);\n  });\n  y(c, \"Series/MapPoint/MapPointSeries.js\", [c[\"Core/Globals.js\"], c[\"Series/MapPoint/MapPointPoint.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r) {\n    var n = this && this.__extends || function () {\n      var b = function (a, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n        return b(a, c);\n      };\n      return function (a, c) {\n        function d() {\n          this.constructor = a;\n        }\n        b(a, c);\n        a.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }();\n    c = c.noop;\n    var u = p.seriesTypes.scatter,\n      e = r.extend,\n      b = r.fireEvent,\n      v = r.isNumber,\n      m = r.merge;\n    r = function (c) {\n      function a() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n      n(a, c);\n      a.prototype.drawDataLabels = function () {\n        c.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      };\n      a.prototype.translate = function () {\n        var a = this,\n          c = this.chart.mapView;\n        this.processedXData || this.processData();\n        this.generatePoints();\n        if (c) {\n          var e = c.projection,\n            k = e.forward,\n            f = e.hasCoordinates;\n          this.points.forEach(function (b) {\n            var d = b.x;\n            d = void 0 === d ? void 0 : d;\n            var g = b.y;\n            g = void 0 === g ? void 0 : g;\n            var h = b.options.geometry;\n            (h = h && \"Point\" === h.type && h.coordinates) ? (g = k(h), d = g[0], g = g[1]) : b.bounds && (d = b.bounds.midX, g = b.bounds.midY);\n            v(d) && v(g) ? (d = c.projectedUnitsToPixels({\n              x: d,\n              y: g\n            }), b.plotX = d.x, b.plotY = f ? d.y : a.chart.plotHeight - d.y) : (b.plotX = void 0, b.plotY = void 0);\n            b.isInside = a.isPointInside(b);\n            b.zone = a.zones.length ? b.getZone() : void 0;\n          });\n        }\n        b(this, \"afterTranslate\");\n      };\n      a.defaultOptions = m(u.defaultOptions, {\n        dataLabels: {\n          crop: !1,\n          defer: !1,\n          enabled: !0,\n          formatter: function () {\n            return this.point.name;\n          },\n          overflow: !1,\n          style: {\n            color: \"#000000\"\n          }\n        }\n      });\n      return a;\n    }(u);\n    e(r.prototype, {\n      type: \"mappoint\",\n      axisTypes: [\"colorAxis\"],\n      forceDL: !0,\n      isCartesian: !1,\n      pointClass: f,\n      searchPoint: c,\n      useMapGeometry: !0\n    });\n    p.registerSeriesType(\"mappoint\", r);\n    \"\";\n    return r;\n  });\n  y(c, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"10px\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  });\n  y(c, \"Series/Bubble/BubbleLegendItem.js\", [c[\"Core/Color/Color.js\"], c[\"Core/FormatUtilities.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r) {\n    var n = c.parse,\n      u = p.noop,\n      e = r.arrayMax,\n      b = r.arrayMin,\n      v = r.isNumber,\n      m = r.merge,\n      k = r.pick,\n      a = r.stableSort;\n    \"\";\n    return function () {\n      function c(a, b) {\n        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = u;\n        this.init(a, b);\n      }\n      c.prototype.init = function (a, b) {\n        this.options = a;\n        this.visible = !0;\n        this.chart = b.chart;\n        this.legend = b;\n      };\n      c.prototype.addToLegend = function (a) {\n        a.splice(this.options.legendIndex, 0, this);\n      };\n      c.prototype.drawLegendSymbol = function (b) {\n        var c = this.chart,\n          d = this.options,\n          g = k(b.options.itemDistance, 20),\n          e = d.ranges,\n          f = d.connectorDistance;\n        this.fontMetrics = c.renderer.fontMetrics(d.labels.style.fontSize);\n        e && e.length && v(e[0].value) ? (a(e, function (a, b) {\n          return b.value - a.value;\n        }), this.ranges = e, this.setOptions(), this.render(), b = this.getMaxLabelSize(), e = this.ranges[0].radius, c = 2 * e, f = f - e + b.width, f = 0 < f ? f : 0, this.maxLabel = b, this.movementX = \"left\" === d.labels.align ? f : 0, this.legendItemWidth = c + f + g, this.legendItemHeight = c + this.fontMetrics.h / 2) : b.options.bubbleLegend.autoRanges = !0;\n      };\n      c.prototype.setOptions = function () {\n        var a = this.ranges,\n          b = this.options,\n          c = this.chart.series[b.seriesIndex],\n          d = this.legend.baseline,\n          e = {\n            zIndex: b.zIndex,\n            \"stroke-width\": b.borderWidth\n          },\n          f = {\n            zIndex: b.zIndex,\n            \"stroke-width\": b.connectorWidth\n          },\n          u = {\n            align: this.legend.options.rtl || \"left\" === b.labels.align ? \"right\" : \"left\",\n            zIndex: b.zIndex\n          },\n          h = c.options.marker.fillOpacity,\n          l = this.chart.styledMode;\n        a.forEach(function (g, t) {\n          l || (e.stroke = k(g.borderColor, b.borderColor, c.color), e.fill = k(g.color, b.color, 1 !== h ? n(c.color).setOpacity(h).get(\"rgba\") : c.color), f.stroke = k(g.connectorColor, b.connectorColor, c.color));\n          a[t].radius = this.getRangeRadius(g.value);\n          a[t] = m(a[t], {\n            center: a[0].radius - a[t].radius + d\n          });\n          l || m(!0, a[t], {\n            bubbleAttribs: m(e),\n            connectorAttribs: m(f),\n            labelAttribs: u\n          });\n        }, this);\n      };\n      c.prototype.getRangeRadius = function (a) {\n        var b = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, b.ranges[b.ranges.length - 1].value, b.ranges[0].value, b.minSize, b.maxSize, a);\n      };\n      c.prototype.render = function () {\n        var a = this.chart.renderer,\n          b = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = a.g(\"bubble-legend\");\n        this.legendItem = a.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (a) {\n          a.value >= b && this.renderRange(a);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      };\n      c.prototype.renderRange = function (a) {\n        var b = this.options,\n          c = b.labels,\n          d = this.chart,\n          g = d.series[b.seriesIndex],\n          e = d.renderer,\n          k = this.symbols;\n        d = k.labels;\n        var h = a.center,\n          l = Math.abs(a.radius),\n          f = b.connectorDistance || 0,\n          m = c.align,\n          u = b.connectorWidth,\n          n = this.ranges[0].radius || 0,\n          v = h - l - b.borderWidth / 2 + u / 2,\n          p = this.fontMetrics;\n        p = p.f / 2 - (p.h - p.f) / 2;\n        var r = e.styledMode;\n        f = this.legend.options.rtl || \"left\" === m ? -f : f;\n        \"center\" === m && (f = 0, b.connectorDistance = 0, a.labelAttribs.align = \"center\");\n        m = v + b.labels.y;\n        var D = n + f + b.labels.x;\n        k.bubbleItems.push(e.circle(n, h + ((v % 1 ? 1 : .5) - (u % 2 ? 0 : .5)), l).attr(r ? {} : a.bubbleAttribs).addClass((r ? \"highcharts-color-\" + g.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (b.className || \"\")).add(this.legendSymbol));\n        k.connectors.push(e.path(e.crispLine([[\"M\", n, v], [\"L\", n + f, v]], b.connectorWidth)).attr(r ? {} : a.connectorAttribs).addClass((r ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (b.connectorClassName || \"\")).add(this.legendSymbol));\n        a = e.text(this.formatLabel(a), D, m + p).attr(r ? {} : a.labelAttribs).css(r ? {} : c.style).addClass(\"highcharts-bubble-legend-labels \" + (b.labels.className || \"\")).add(this.legendSymbol);\n        d.push(a);\n        a.placed = !0;\n        a.alignAttr = {\n          x: D,\n          y: m + p\n        };\n      };\n      c.prototype.getMaxLabelSize = function () {\n        var a, b;\n        this.symbols.labels.forEach(function (c) {\n          b = c.getBBox(!0);\n          a = a ? b.width > a.width ? b : a : b;\n        });\n        return a || {};\n      };\n      c.prototype.formatLabel = function (a) {\n        var b = this.options,\n          c = b.labels.formatter;\n        b = b.labels.format;\n        var d = this.chart.numberFormatter;\n        return b ? f.format(b, a) : c ? c.call(a) : d(a.value, 1);\n      };\n      c.prototype.hideOverlappingLabels = function () {\n        var a = this.chart,\n          b = this.symbols;\n        !this.options.labels.allowOverlap && b && (a.hideOverlappingLabels(b.labels), b.labels.forEach(function (a, c) {\n          a.newOpacity ? a.newOpacity !== a.oldOpacity && b.connectors[c].show() : b.connectors[c].hide();\n        }));\n      };\n      c.prototype.getRanges = function () {\n        var a = this.legend.bubbleLegend,\n          c = a.options.ranges,\n          d,\n          f = Number.MAX_VALUE,\n          q = -Number.MAX_VALUE;\n        a.chart.series.forEach(function (a) {\n          a.isBubble && !a.ignoreSeries && (d = a.zData.filter(v), d.length && (f = k(a.options.zMin, Math.min(f, Math.max(b(d), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), q = k(a.options.zMax, Math.max(q, e(d)))));\n        });\n        var n = f === q ? [{\n          value: q\n        }] : [{\n          value: f\n        }, {\n          value: (f + q) / 2\n        }, {\n          value: q,\n          autoRanges: !0\n        }];\n        c.length && c[0].radius && n.reverse();\n        n.forEach(function (a, b) {\n          c && c[b] && (n[b] = m(c[b], a));\n        });\n        return n;\n      };\n      c.prototype.predictBubbleSizes = function () {\n        var a = this.chart,\n          b = this.fontMetrics,\n          c = a.legend.options,\n          d = c.floating,\n          e = (c = \"horizontal\" === c.layout) ? a.legend.lastLineHeight : 0,\n          k = a.plotSizeX,\n          f = a.plotSizeY,\n          h = a.series[this.options.seriesIndex],\n          l = h.getPxExtremes();\n        a = Math.ceil(l.minPxSize);\n        l = Math.ceil(l.maxPxSize);\n        var m = Math.min(f, k);\n        h = h.options.maxSize;\n        if (d || !/%$/.test(h)) b = l;else if (h = parseFloat(h), b = (m + e - b.h / 2) * h / 100 / (h / 100 + 1), c && f - b >= k || !c && k - b >= f) b = l;\n        return [a, Math.ceil(b)];\n      };\n      c.prototype.updateRanges = function (a, b) {\n        var c = this.legend.options.bubbleLegend;\n        c.minSize = a;\n        c.maxSize = b;\n        c.ranges = this.getRanges();\n      };\n      c.prototype.correctSizes = function () {\n        var a = this.legend,\n          b = this.chart.series[this.options.seriesIndex].getPxExtremes();\n        1 < Math.abs(Math.ceil(b.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, b.maxPxSize), a.render());\n      };\n      return c;\n    }();\n  });\n  y(c, \"Series/Bubble/BubbleLegendComposition.js\", [c[\"Series/Bubble/BubbleLegendDefaults.js\"], c[\"Series/Bubble/BubbleLegendItem.js\"], c[\"Core/DefaultOptions.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r) {\n    var n = p.setOptions,\n      u = r.addEvent,\n      e = r.objectEach,\n      b = r.wrap,\n      v;\n    (function (m) {\n      function k(b, c, g) {\n        var h = this.legend,\n          l = 0 <= a(this);\n        if (h && h.options.enabled && h.bubbleLegend && h.options.bubbleLegend.autoRanges && l) {\n          var k = h.bubbleLegend.options;\n          l = h.bubbleLegend.predictBubbleSizes();\n          h.bubbleLegend.updateRanges(l[0], l[1]);\n          k.placed || (h.group.placed = !1, h.allItems.forEach(function (a) {\n            a.legendGroup.translateY = null;\n          }));\n          h.render();\n          this.getMargins();\n          this.axes.forEach(function (a) {\n            a.visible && a.render();\n            k.placed || (a.setScale(), a.updateNames(), e(a.ticks, function (a) {\n              a.isNew = !0;\n              a.isNewLabel = !0;\n            }));\n          });\n          k.placed = !0;\n          this.getMargins();\n          b.call(this, c, g);\n          h.bubbleLegend.correctSizes();\n          v(h, d(h));\n        } else b.call(this, c, g), h && h.options.enabled && h.bubbleLegend && (h.render(), v(h, d(h)));\n      }\n      function a(a) {\n        a = a.series;\n        for (var b = 0; b < a.length;) {\n          if (a[b] && a[b].isBubble && a[b].visible && a[b].zData.length) return b;\n          b++;\n        }\n        return -1;\n      }\n      function d(a) {\n        a = a.allItems;\n        var b = [],\n          c = a.length,\n          d,\n          e = 0;\n        for (d = 0; d < c; d++) if (a[d].legendItemHeight && (a[d].itemHeight = a[d].legendItemHeight), a[d] === a[c - 1] || a[d + 1] && a[d]._legendItemPos[1] !== a[d + 1]._legendItemPos[1]) {\n          b.push({\n            height: 0\n          });\n          var g = b[b.length - 1];\n          for (e; e <= d; e++) a[e].itemHeight > g.height && (g.height = a[e].itemHeight);\n          g.step = d;\n        }\n        return b;\n      }\n      function g(b) {\n        var c = this.bubbleLegend,\n          d = this.options,\n          h = d.bubbleLegend,\n          e = a(this.chart);\n        c && c.ranges && c.ranges.length && (h.ranges.length && (h.autoRanges = !!h.ranges[0].autoRanges), this.destroyItem(c));\n        0 <= e && d.enabled && h.enabled && (h.seriesIndex = e, this.bubbleLegend = new f(h, this), this.bubbleLegend.addToLegend(b.allItems));\n      }\n      function t() {\n        var b = this.chart,\n          c = this.visible,\n          d = this.chart.legend;\n        d && d.bubbleLegend && (this.visible = !c, this.ignoreSeries = c, b = 0 <= a(b), d.bubbleLegend.visible !== b && (d.update({\n          bubbleLegend: {\n            enabled: b\n          }\n        }), d.bubbleLegend.visible = b), this.visible = c);\n      }\n      function v(a, b) {\n        var c = a.options.rtl,\n          d,\n          e,\n          g,\n          k = 0;\n        a.allItems.forEach(function (a, h) {\n          d = a.legendGroup.translateX;\n          e = a._legendItemPos[1];\n          if ((g = a.movementX) || c && a.ranges) g = c ? d - a.options.maxSize / 2 : d + g, a.legendGroup.attr({\n            translateX: g\n          });\n          h > b[k].step && k++;\n          a.legendGroup.attr({\n            translateY: Math.round(e + b[k].height / 2)\n          });\n          a._legendItemPos[1] = e + b[k].height / 2;\n        });\n      }\n      var p = [];\n      m.compose = function (a, d, e) {\n        -1 === p.indexOf(a) && (p.push(a), n({\n          legend: {\n            bubbleLegend: c\n          }\n        }), b(a.prototype, \"drawChartBox\", k));\n        -1 === p.indexOf(d) && (p.push(d), u(d, \"afterGetAllItems\", g));\n        -1 === p.indexOf(e) && (p.push(e), u(e, \"legendItemClick\", t));\n      };\n    })(v || (v = {}));\n    return v;\n  });\n  y(c, \"Series/Bubble/BubblePoint.js\", [c[\"Core/Series/Point.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p) {\n    var r = this && this.__extends || function () {\n      var c = function (f, e) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var e in c) c.hasOwnProperty(e) && (b[e] = c[e]);\n        };\n        return c(f, e);\n      };\n      return function (f, e) {\n        function b() {\n          this.constructor = f;\n        }\n        c(f, e);\n        f.prototype = null === e ? Object.create(e) : (b.prototype = e.prototype, new b());\n      };\n    }();\n    p = p.extend;\n    f = function (f) {\n      function n() {\n        var c = null !== f && f.apply(this, arguments) || this;\n        c.options = void 0;\n        c.series = void 0;\n        return c;\n      }\n      r(n, f);\n      n.prototype.haloPath = function (e) {\n        return c.prototype.haloPath.call(this, 0 === e ? 0 : (this.marker ? this.marker.radius || 0 : 0) + e);\n      };\n      return n;\n    }(f.seriesTypes.scatter.prototype.pointClass);\n    p(f.prototype, {\n      ttBelow: !1\n    });\n    return f;\n  });\n  y(c, \"Series/Bubble/BubbleSeries.js\", [c[\"Core/Axis/Axis.js\"], c[\"Series/Bubble/BubbleLegendComposition.js\"], c[\"Series/Bubble/BubblePoint.js\"], c[\"Core/Color/Color.js\"], c[\"Core/Globals.js\"], c[\"Core/Series/Series.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r, n, u, e, b) {\n    var v = this && this.__extends || function () {\n        var a = function (b, c) {\n          a = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n          };\n          return a(b, c);\n        };\n        return function (b, c) {\n          function d() {\n            this.constructor = b;\n          }\n          a(b, c);\n          b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n        };\n      }(),\n      m = r.parse;\n    r = n.noop;\n    var k = e.seriesTypes;\n    n = k.column;\n    var a = k.scatter;\n    k = b.addEvent;\n    var d = b.arrayMax,\n      g = b.arrayMin,\n      t = b.clamp,\n      x = b.extend,\n      z = b.isNumber,\n      q = b.merge,\n      w = b.pick;\n    b = function (b) {\n      function c() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.maxPxSize = void 0;\n        a.minPxSize = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        a.radii = void 0;\n        a.yData = void 0;\n        a.zData = void 0;\n        return a;\n      }\n      v(c, b);\n      c.prototype.animate = function (a) {\n        !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {\n          var b = a.graphic;\n          b && b.width && (this.hasRendered || b.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), b.animate(this.markerAttribs(a), this.options.animation));\n        }, this);\n      };\n      c.prototype.getRadii = function () {\n        var a = this,\n          b = this.zData,\n          c = this.yData,\n          d = [],\n          e = this.chart.bubbleZExtremes;\n        var h = this.getPxExtremes();\n        var g = h.minPxSize,\n          k = h.maxPxSize;\n        if (!e) {\n          var f = Number.MAX_VALUE,\n            m = -Number.MAX_VALUE,\n            t;\n          this.chart.series.forEach(function (b) {\n            b.bubblePadding && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && (b = b.getZExtremes()) && (f = Math.min(f || b.zMin, b.zMin), m = Math.max(m || b.zMax, b.zMax), t = !0);\n          });\n          t ? (e = {\n            zMin: f,\n            zMax: m\n          }, this.chart.bubbleZExtremes = e) : e = {\n            zMin: 0,\n            zMax: 0\n          };\n        }\n        var q = 0;\n        for (h = b.length; q < h; q++) {\n          var n = b[q];\n          d.push(this.getRadius(e.zMin, e.zMax, g, k, n, c[q]));\n        }\n        this.radii = d;\n      };\n      c.prototype.getRadius = function (a, b, c, d, e, h) {\n        var g = this.options,\n          k = \"width\" !== g.sizeBy,\n          f = g.zThreshold,\n          l = b - a,\n          m = .5;\n        if (null === h || null === e) return null;\n        if (z(e)) {\n          g.sizeByAbsoluteValue && (e = Math.abs(e - f), l = Math.max(b - f, Math.abs(a - f)), a = 0);\n          if (e < a) return c / 2 - 1;\n          0 < l && (m = (e - a) / l);\n        }\n        k && 0 <= m && (m = Math.sqrt(m));\n        return Math.ceil(c + m * (d - c)) / 2;\n      };\n      c.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n      c.prototype.pointAttribs = function (a, b) {\n        var c = this.options.marker.fillOpacity;\n        a = u.prototype.pointAttribs.call(this, a, b);\n        1 !== c && (a.fill = m(a.fill).setOpacity(c).get(\"rgba\"));\n        return a;\n      };\n      c.prototype.translate = function () {\n        b.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n      };\n      c.prototype.translateBubble = function () {\n        for (var a = this.data, b = this.radii, c = this.getPxExtremes().minPxSize, d = a.length; d--;) {\n          var e = a[d],\n            h = b ? b[d] : 0;\n          z(h) && h >= c / 2 ? (e.marker = x(e.marker, {\n            radius: h,\n            width: 2 * h,\n            height: 2 * h\n          }), e.dlBox = {\n            x: e.plotX - h,\n            y: e.plotY - h,\n            width: 2 * h,\n            height: 2 * h\n          }) : e.shapeArgs = e.plotY = e.dlBox = void 0;\n        }\n      };\n      c.prototype.getPxExtremes = function () {\n        var a = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n          b = function (b) {\n            if (\"string\" === typeof b) {\n              var c = /%$/.test(b);\n              b = parseInt(b, 10);\n            }\n            return c ? a * b / 100 : b;\n          },\n          c = b(w(this.options.minSize, 8));\n        b = Math.max(b(w(this.options.maxSize, \"20%\")), c);\n        return {\n          minPxSize: c,\n          maxPxSize: b\n        };\n      };\n      c.prototype.getZExtremes = function () {\n        var a = this.options,\n          b = (this.zData || []).filter(z);\n        if (b.length) {\n          var c = w(a.zMin, t(g(b), !1 === a.displayNegative ? a.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));\n          a = w(a.zMax, d(b));\n          if (z(c) && z(a)) return {\n            zMin: c,\n            zMax: a\n          };\n        }\n      };\n      c.compose = f.compose;\n      c.defaultOptions = q(a.defaultOptions, {\n        dataLabels: {\n          formatter: function () {\n            var a = this.series.chart.numberFormatter,\n              b = this.point.z;\n            return z(b) ? a(b, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        animationLimit: 250,\n        marker: {\n          lineColor: null,\n          lineWidth: 1,\n          fillOpacity: .5,\n          radius: null,\n          states: {\n            hover: {\n              radiusPlus: 0\n            }\n          },\n          symbol: \"circle\"\n        },\n        minSize: 8,\n        maxSize: \"20%\",\n        softThreshold: !1,\n        states: {\n          hover: {\n            halo: {\n              size: 5\n            }\n          }\n        },\n        tooltip: {\n          pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: \"z\"\n      });\n      return c;\n    }(a);\n    x(b.prototype, {\n      alignDataLabel: n.prototype.alignDataLabel,\n      applyZones: r,\n      bubblePadding: !0,\n      buildKDTree: r,\n      directTouch: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: p,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    });\n    k(b, \"updatedData\", function (a) {\n      delete a.target.chart.bubbleZExtremes;\n    });\n    c.prototype.beforePadding = function () {\n      var a = this,\n        b = this.len,\n        c = this.chart,\n        d = 0,\n        e = b,\n        g = this.isXAxis,\n        k = g ? \"xData\" : \"yData\",\n        f = this.min,\n        m = this.max - f,\n        t = b / m,\n        q;\n      this.series.forEach(function (b) {\n        if (b.bubblePadding && (b.visible || !c.options.chart.ignoreHiddenSeries)) {\n          q = a.allowZoomOutside = !0;\n          var h = b[k];\n          g && b.getRadii(0, 0, b);\n          if (0 < m) for (var l = h.length; l--;) if (z(h[l]) && a.dataMin <= h[l] && h[l] <= a.max) {\n            var n = b.radii && b.radii[l] || 0;\n            d = Math.min((h[l] - f) * t - n, d);\n            e = Math.max((h[l] - f) * t + n, e);\n          }\n        }\n      });\n      q && 0 < m && !this.logarithmic && (e -= b, t *= (b + Math.max(0, d) - Math.min(e, b)) / b, [[\"min\", \"userMin\", d], [\"max\", \"userMax\", e]].forEach(function (b) {\n        \"undefined\" === typeof w(a.options[b[0]], a[b[1]]) && (a[b[0]] += b[2] / t);\n      }));\n    };\n    e.registerSeriesType(\"bubble\", b);\n    \"\";\n    \"\";\n    return b;\n  });\n  y(c, \"Series/MapBubble/MapBubblePoint.js\", [c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    var p = this && this.__extends || function () {\n      var c = function (e, b) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var e in c) c.hasOwnProperty(e) && (b[e] = c[e]);\n        };\n        return c(e, b);\n      };\n      return function (e, b) {\n        function f() {\n          this.constructor = e;\n        }\n        c(e, b);\n        e.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n      };\n    }();\n    c = c.seriesTypes;\n    var r = c.map,\n      n = f.merge;\n    return function (c) {\n      function e() {\n        return null !== c && c.apply(this, arguments) || this;\n      }\n      p(e, c);\n      e.prototype.applyOptions = function (b, e) {\n        return b && \"undefined\" !== typeof b.lat && \"undefined\" !== typeof b.lon ? c.prototype.applyOptions.call(this, n(b, this.series.chart.fromLatLonToPoint(b)), e) : r.prototype.pointClass.prototype.applyOptions.call(this, b, e);\n      };\n      e.prototype.isValid = function () {\n        return \"number\" === typeof this.z;\n      };\n      return e;\n    }(c.bubble.prototype.pointClass);\n  });\n  y(c, \"Series/MapBubble/MapBubbleSeries.js\", [c[\"Series/Bubble/BubbleSeries.js\"], c[\"Series/MapBubble/MapBubblePoint.js\"], c[\"Series/Map/MapSeries.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r, n) {\n    var u = this && this.__extends || function () {\n        var b = function (c, a) {\n          b = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n          };\n          return b(c, a);\n        };\n        return function (c, a) {\n          function d() {\n            this.constructor = c;\n          }\n          b(c, a);\n          c.prototype = null === a ? Object.create(a) : (d.prototype = a.prototype, new d());\n        };\n      }(),\n      e = r.seriesTypes.mappoint,\n      b = n.extend,\n      v = n.merge;\n    n = function (b) {\n      function f() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n      u(f, b);\n      f.prototype.translate = function () {\n        e.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n      };\n      f.compose = c.compose;\n      f.defaultOptions = v(c.defaultOptions, {\n        animationLimit: 500,\n        tooltip: {\n          pointFormat: \"{point.name}: {point.z}\"\n        }\n      });\n      return f;\n    }(c);\n    b(n.prototype, {\n      type: \"mapbubble\",\n      axisTypes: [\"colorAxis\"],\n      getProjectedBounds: p.prototype.getProjectedBounds,\n      isCartesian: !1,\n      pointArrayMap: [\"z\"],\n      pointClass: f,\n      setData: p.prototype.setData,\n      setOptions: p.prototype.setOptions,\n      useMapGeometry: !0,\n      xyFromShape: !0\n    });\n    r.registerSeriesType(\"mapbubble\", n);\n    \"\";\n    return n;\n  });\n  y(c, \"Series/Heatmap/HeatmapPoint.js\", [c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Utilities.js\"]], function (c, f) {\n    var p = this && this.__extends || function () {\n        var b = function (c, e) {\n          b = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (b, a) {\n            b.__proto__ = a;\n          } || function (b, a) {\n            for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);\n          };\n          return b(c, e);\n        };\n        return function (c, e) {\n          function f() {\n            this.constructor = c;\n          }\n          b(c, e);\n          c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());\n        };\n      }(),\n      r = f.clamp,\n      n = f.defined,\n      u = f.extend,\n      e = f.pick;\n    c = function (b) {\n      function c() {\n        var c = null !== b && b.apply(this, arguments) || this;\n        c.options = void 0;\n        c.series = void 0;\n        c.value = void 0;\n        c.x = void 0;\n        c.y = void 0;\n        return c;\n      }\n      p(c, b);\n      c.prototype.applyOptions = function (c, e) {\n        c = b.prototype.applyOptions.call(this, c, e);\n        c.formatPrefix = c.isNull || null === c.value ? \"null\" : \"point\";\n        return c;\n      };\n      c.prototype.getCellAttributes = function () {\n        var b = this.series,\n          c = b.options,\n          a = (c.colsize || 1) / 2,\n          d = (c.rowsize || 1) / 2,\n          g = b.xAxis,\n          f = b.yAxis,\n          p = this.options.marker || b.options.marker;\n        b = b.pointPlacementToXValue();\n        var u = e(this.pointPadding, c.pointPadding, 0),\n          q = {\n            x1: r(Math.round(g.len - (g.translate(this.x - a, !1, !0, !1, !0, -b) || 0)), -g.len, 2 * g.len),\n            x2: r(Math.round(g.len - (g.translate(this.x + a, !1, !0, !1, !0, -b) || 0)), -g.len, 2 * g.len),\n            y1: r(Math.round(f.translate(this.y - d, !1, !0, !1, !0) || 0), -f.len, 2 * f.len),\n            y2: r(Math.round(f.translate(this.y + d, !1, !0, !1, !0) || 0), -f.len, 2 * f.len)\n          };\n        [[\"width\", \"x\"], [\"height\", \"y\"]].forEach(function (a) {\n          var b = a[0];\n          a = a[1];\n          var c = a + \"1\",\n            d = a + \"2\",\n            e = Math.abs(q[c] - q[d]),\n            g = p && p.lineWidth || 0,\n            f = Math.abs(q[c] + q[d]) / 2;\n          b = p && p[b];\n          n(b) && b < e && (b = b / 2 + g / 2, q[c] = f - b, q[d] = f + b);\n          u && (\"y\" === a && (c = d, d = a + \"1\"), q[c] += u, q[d] -= u);\n        });\n        return q;\n      };\n      c.prototype.haloPath = function (b) {\n        if (!b) return [];\n        var c = this.shapeArgs;\n        return [\"M\", c.x - b, c.y - b, \"L\", c.x - b, c.y + c.height + b, c.x + c.width + b, c.y + c.height + b, c.x + c.width + b, c.y - b, \"Z\"];\n      };\n      c.prototype.isValid = function () {\n        return Infinity !== this.value && -Infinity !== this.value;\n      };\n      return c;\n    }(c.seriesTypes.scatter.prototype.pointClass);\n    u(c.prototype, {\n      dataLabelOnNull: !0,\n      moveToTopOnHover: !0,\n      ttBelow: !1\n    });\n    return c;\n  });\n  y(c, \"Series/Heatmap/HeatmapSeries.js\", [c[\"Core/Color/Color.js\"], c[\"Series/ColorMapMixin.js\"], c[\"Series/Heatmap/HeatmapPoint.js\"], c[\"Core/Legend/LegendSymbol.js\"], c[\"Core/Series/SeriesRegistry.js\"], c[\"Core/Renderer/SVG/SVGRenderer.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r, n, u, e) {\n    var b = this && this.__extends || function () {\n        var a = function (b, c) {\n          a = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n          };\n          return a(b, c);\n        };\n        return function (b, c) {\n          function d() {\n            this.constructor = b;\n          }\n          a(b, c);\n          b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n        };\n      }(),\n      v = n.series,\n      m = n.seriesTypes,\n      k = m.column,\n      a = m.scatter,\n      d = u.prototype.symbols,\n      g = e.extend,\n      t = e.fireEvent,\n      x = e.isNumber,\n      y = e.merge,\n      q = e.pick;\n    u = function (e) {\n      function f() {\n        var a = null !== e && e.apply(this, arguments) || this;\n        a.colorAxis = void 0;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        a.valueMax = NaN;\n        a.valueMin = NaN;\n        return a;\n      }\n      b(f, e);\n      f.prototype.drawPoints = function () {\n        var a = this;\n        if ((this.options.marker || {}).enabled || this._hasPointMarkers) v.prototype.drawPoints.call(this), this.points.forEach(function (b) {\n          b.graphic && (b.graphic[a.chart.styledMode ? \"css\" : \"animate\"](a.colorAttribs(b)), a.options.borderRadius && b.graphic.attr({\n            r: a.options.borderRadius\n          }), (b.shapeArgs || {}).r = a.options.borderRadius, (b.shapeArgs || {}).d = b.graphic.pathArray, null === b.value && b.graphic.addClass(\"highcharts-null-point\"));\n        });\n      };\n      f.prototype.getExtremes = function () {\n        var a = v.prototype.getExtremes.call(this, this.valueData),\n          b = a.dataMin;\n        a = a.dataMax;\n        x(b) && (this.valueMin = b);\n        x(a) && (this.valueMax = a);\n        return v.prototype.getExtremes.call(this);\n      };\n      f.prototype.getValidPoints = function (a, b) {\n        return v.prototype.getValidPoints.call(this, a, b, !0);\n      };\n      f.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n      f.prototype.init = function () {\n        v.prototype.init.apply(this, arguments);\n        var a = this.options;\n        a.pointRange = q(a.pointRange, a.colsize || 1);\n        this.yAxis.axisPointRange = a.rowsize || 1;\n        d.ellipse = d.circle;\n      };\n      f.prototype.markerAttribs = function (a, b) {\n        var c = a.marker || {},\n          d = this.options.marker || {},\n          e = a.shapeArgs || {},\n          g = {};\n        if (a.hasImage) return {\n          x: a.plotX,\n          y: a.plotY\n        };\n        if (b) {\n          var f = d.states[b] || {};\n          var h = c.states && c.states[b] || {};\n          [[\"width\", \"x\"], [\"height\", \"y\"]].forEach(function (a) {\n            g[a[0]] = (h[a[0]] || f[a[0]] || e[a[0]]) + (h[a[0] + \"Plus\"] || f[a[0] + \"Plus\"] || 0);\n            g[a[1]] = e[a[1]] + (e[a[0]] - g[a[0]]) / 2;\n          });\n        }\n        return b ? g : e;\n      };\n      f.prototype.pointAttribs = function (a, b) {\n        var d = v.prototype.pointAttribs.call(this, a, b),\n          e = this.options || {},\n          g = this.chart.options.plotOptions || {},\n          f = g.series || {},\n          h = g.heatmap || {};\n        g = a && a.options.borderColor || e.borderColor || h.borderColor || f.borderColor;\n        f = a && a.options.borderWidth || e.borderWidth || h.borderWidth || f.borderWidth || d[\"stroke-width\"];\n        d.stroke = a && a.marker && a.marker.lineColor || e.marker && e.marker.lineColor || g || this.color;\n        d[\"stroke-width\"] = f;\n        b && (a = y(e.states[b], e.marker && e.marker.states[b], a && a.options.states && a.options.states[b] || {}), b = a.brightness, d.fill = a.color || c.parse(d.fill).brighten(b || 0).get(), d.stroke = a.lineColor);\n        return d;\n      };\n      f.prototype.setClip = function (a) {\n        var b = this.chart;\n        v.prototype.setClip.apply(this, arguments);\n        (!1 !== this.options.clip || a) && this.markerGroup.clip((a || this.clipBox) && this.sharedClipKey ? b.sharedClips[this.sharedClipKey] : b.clipRect);\n      };\n      f.prototype.translate = function () {\n        var a = this.options,\n          b = a.marker && a.marker.symbol || \"rect\",\n          c = d[b] ? b : \"rect\",\n          e = -1 !== [\"circle\", \"square\"].indexOf(c);\n        this.generatePoints();\n        this.points.forEach(function (a) {\n          var f = a.getCellAttributes(),\n            h = {};\n          h.x = Math.min(f.x1, f.x2);\n          h.y = Math.min(f.y1, f.y2);\n          h.width = Math.max(Math.abs(f.x2 - f.x1), 0);\n          h.height = Math.max(Math.abs(f.y2 - f.y1), 0);\n          var k = a.hasImage = 0 === (a.marker && a.marker.symbol || b || \"\").indexOf(\"url\");\n          if (e) {\n            var l = Math.abs(h.width - h.height);\n            h.x = Math.min(f.x1, f.x2) + (h.width < h.height ? 0 : l / 2);\n            h.y = Math.min(f.y1, f.y2) + (h.width < h.height ? l / 2 : 0);\n            h.width = h.height = Math.min(h.width, h.height);\n          }\n          l = {\n            plotX: (f.x1 + f.x2) / 2,\n            plotY: (f.y1 + f.y2) / 2,\n            clientX: (f.x1 + f.x2) / 2,\n            shapeType: \"path\",\n            shapeArgs: y(!0, h, {\n              d: d[c](h.x, h.y, h.width, h.height)\n            })\n          };\n          k && (a.marker = {\n            width: h.width,\n            height: h.height\n          });\n          g(a, l);\n        });\n        t(this, \"afterTranslate\");\n      };\n      f.defaultOptions = y(a.defaultOptions, {\n        animation: !1,\n        borderRadius: 0,\n        borderWidth: 0,\n        nullColor: \"#f7f7f7\",\n        dataLabels: {\n          formatter: function () {\n            var a = this.series.chart.numberFormatter,\n              b = this.point.value;\n            return x(b) ? a(b, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\",\n          crop: !1,\n          overflow: !1,\n          padding: 0\n        },\n        marker: {\n          symbol: \"rect\",\n          radius: 0,\n          lineColor: void 0,\n          states: {\n            hover: {\n              lineWidthPlus: 0\n            },\n            select: {}\n          }\n        },\n        clip: !0,\n        pointRange: null,\n        tooltip: {\n          pointFormat: \"{point.x}, {point.y}: {point.value}<br/>\"\n        },\n        states: {\n          hover: {\n            halo: !1,\n            brightness: .2\n          }\n        }\n      });\n      return f;\n    }(a);\n    g(u.prototype, {\n      alignDataLabel: k.prototype.alignDataLabel,\n      axisTypes: f.SeriesMixin.axisTypes,\n      colorAttribs: f.SeriesMixin.colorAttribs,\n      colorKey: f.SeriesMixin.colorKey,\n      directTouch: !0,\n      drawLegendSymbol: r.drawRectangle,\n      getExtremesFromAll: !0,\n      getSymbol: v.prototype.getSymbol,\n      parallelArrays: f.SeriesMixin.parallelArrays,\n      pointArrayMap: [\"y\", \"value\"],\n      pointClass: p,\n      trackerGroups: f.SeriesMixin.trackerGroups\n    });\n    n.registerSeriesType(\"heatmap\", u);\n    \"\";\n    \"\";\n    return u;\n  });\n  y(c, \"Extensions/GeoJSON.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/FormatUtilities.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, f, p, r) {\n    function n(b, a) {\n      var c,\n        e = !1,\n        f = b.x,\n        k = b.y;\n      b = 0;\n      for (c = a.length - 1; b < a.length; c = b++) {\n        var m = a[b][1] > k;\n        var q = a[c][1] > k;\n        m !== q && f < (a[c][0] - a[b][0]) * (k - a[b][1]) / (a[c][1] - a[b][1]) + a[b][0] && (e = !e);\n      }\n      return e;\n    }\n    var u = f.format,\n      e = p.win,\n      b = r.error,\n      v = r.extend,\n      m = r.merge;\n    f = r.wrap;\n    \"\";\n    c.prototype.transformFromLatLon = function (c, a) {\n      var d = this.options.chart.proj4 || e.proj4;\n      if (!d) return b(21, !1, this), {\n        x: 0,\n        y: null\n      };\n      var f = a.jsonmarginX;\n      f = void 0 === f ? 0 : f;\n      var k = a.jsonmarginY;\n      k = void 0 === k ? 0 : k;\n      var m = a.jsonres;\n      m = void 0 === m ? 1 : m;\n      var n = a.scale;\n      n = void 0 === n ? 1 : n;\n      var q = a.xoffset;\n      q = void 0 === q ? 0 : q;\n      var p = a.xpan;\n      p = void 0 === p ? 0 : p;\n      var r = a.yoffset;\n      r = void 0 === r ? 0 : r;\n      var h = a.ypan;\n      h = void 0 === h ? 0 : h;\n      c = d(a.crs, [c.lon, c.lat]);\n      d = a.cosAngle || a.rotation && Math.cos(a.rotation);\n      var l = a.sinAngle || a.rotation && Math.sin(a.rotation);\n      a = a.rotation ? [c[0] * d + c[1] * l, -c[0] * l + c[1] * d] : c;\n      return {\n        x: ((a[0] - q) * n + p) * m + f,\n        y: -(((r - a[1]) * n + h) * m - k)\n      };\n    };\n    c.prototype.transformToLatLon = function (c, a) {\n      if (!this.options.chart.proj4 && !e.proj4) b(21, !1, this);else if (null !== c.y) {\n        var d = a.jsonmarginX,\n          f = a.jsonmarginY,\n          k = a.jsonres;\n        k = void 0 === k ? 1 : k;\n        var m = a.scale;\n        m = void 0 === m ? 1 : m;\n        var n = a.xoffset,\n          q = a.xpan,\n          p = a.yoffset,\n          r = a.ypan;\n        c = {\n          x: ((c.x - (void 0 === d ? 0 : d)) / k - (void 0 === q ? 0 : q)) / m + (void 0 === n ? 0 : n),\n          y: ((c.y - (void 0 === f ? 0 : f)) / k + (void 0 === r ? 0 : r)) / m + (void 0 === p ? 0 : p)\n        };\n        d = a.cosAngle || a.rotation && Math.cos(a.rotation);\n        f = a.sinAngle || a.rotation && Math.sin(a.rotation);\n        a = e.proj4(a.crs, \"WGS84\", a.rotation ? {\n          x: c.x * d + c.y * -f,\n          y: c.x * f + c.y * d\n        } : c);\n        return {\n          lat: a.y,\n          lon: a.x\n        };\n      }\n    };\n    c.prototype.fromPointToLatLon = function (c) {\n      var a = this.mapTransforms;\n      if (a) {\n        for (var d in a) if (Object.hasOwnProperty.call(a, d) && a[d].hitZone && n(c, a[d].hitZone.coordinates[0])) return this.transformToLatLon(c, a[d]);\n        return this.transformToLatLon(c, a[\"default\"]);\n      }\n      b(22, !1, this);\n    };\n    c.prototype.fromLatLonToPoint = function (c) {\n      var a = this.mapTransforms,\n        d;\n      if (!a) return b(22, !1, this), {\n        x: 0,\n        y: null\n      };\n      for (d in a) if (Object.hasOwnProperty.call(a, d) && a[d].hitZone) {\n        var e = this.transformFromLatLon(c, a[d]);\n        if (n(e, a[d].hitZone.coordinates[0])) return e;\n      }\n      return this.transformFromLatLon(c, a[\"default\"]);\n    };\n    p.geojson = function (b, a, c) {\n      void 0 === a && (a = \"map\");\n      var d = [];\n      b.features.forEach(function (b) {\n        var c = b.geometry || {},\n          e = c.type;\n        c = c.coordinates;\n        b = b.properties;\n        var f;\n        \"map\" !== a && \"mapbubble\" !== a || \"Polygon\" !== e && \"MultiPolygon\" !== e ? \"mapline\" !== a || \"LineString\" !== e && \"MultiLineString\" !== e ? \"mappoint\" === a && \"Point\" === e && c.length && (f = {\n          geometry: {\n            coordinates: c,\n            type: e\n          }\n        }) : c.length && (f = {\n          geometry: {\n            coordinates: c,\n            type: e\n          }\n        }) : c.length && (f = {\n          geometry: {\n            coordinates: c,\n            type: e\n          }\n        });\n        f && d.push(v(f, {\n          name: b.name || b.NAME,\n          properties: b\n        }));\n      });\n      c && b.copyrightShort && (c.chart.mapCredits = u(c.chart.options.credits.mapText, {\n        geojson: b\n      }), c.chart.mapCreditsFull = u(c.chart.options.credits.mapTextFull, {\n        geojson: b\n      }));\n      return d;\n    };\n    f(c.prototype, \"addCredits\", function (b, a) {\n      a = m(!0, this.options.credits, a);\n      this.mapCredits && (a.href = null);\n      b.call(this, a);\n      this.credits && this.mapCreditsFull && this.credits.attr({\n        title: this.mapCreditsFull\n      });\n    });\n  });\n  y(c, \"masters/modules/map.src.js\", [c[\"Core/Globals.js\"], c[\"Core/Axis/Color/ColorAxis.js\"], c[\"Series/MapBubble/MapBubbleSeries.js\"], c[\"Core/Chart/MapChart.js\"]], function (c, f, p, r) {\n    c.ColorAxis = f;\n    c.MapChart = r;\n    c.mapChart = c.Map = r.mapChart;\n    c.maps = r.maps;\n    f.compose(c.Chart, c.Fx, c.Legend, c.Series);\n    p.compose(c.Chart, c.Legend, c.Series);\n  });\n});\n//# sourceMappingURL=map.js.map","map":null,"metadata":{},"sourceType":"script"}