{"ast":null,"code":"import { collectLanes, getLanesRoot } from '../util/LaneUtil';\nimport { is } from '../../../util/ModelUtil';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n  LANES_ATTR = 'lanes';\n\n/**\n * A handler that updates lane refs on changed elements\n */\nexport default function UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\nUpdateFlowNodeRefsHandler.$inject = ['elementRegistry'];\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function (flowNodeShapes, laneShapes) {\n  var handledNodes = [];\n  var updates = [];\n  var participantCache = {};\n  var allFlowNodeShapes = [];\n  function isInLaneShape(element, laneShape) {\n    var laneTrbl = asTRBL(laneShape);\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;\n  }\n  function addFlowNodeShape(flowNodeShape) {\n    if (handledNodes.indexOf(flowNodeShape) === -1) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes.push(flowNodeShape);\n    }\n  }\n  function getAllLaneShapes(flowNodeShape) {\n    var root = getLanesRoot(flowNodeShape);\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n    return participantCache[root.id];\n  }\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n    return allLaneShapes.filter(function (l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function (shape) {\n      return shape.businessObject;\n    });\n  }\n  laneShapes.forEach(function (laneShape) {\n    var root = getLanesRoot(laneShape);\n    if (!root || handledNodes.indexOf(root) !== -1) {\n      return;\n    }\n    var children = root.children.filter(function (c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n    children.forEach(addFlowNodeShape);\n    handledNodes.push(root);\n  });\n  flowNodeShapes.forEach(addFlowNodeShape);\n  allFlowNodeShapes.forEach(function (flowNodeShape) {\n    var flowNode = flowNodeShape.businessObject;\n    var lanes = flowNode.get(LANES_ATTR),\n      remove = lanes.slice(),\n      add = getNewLanes(flowNodeShape);\n    updates.push({\n      flowNode: flowNode,\n      remove: remove,\n      add: add\n    });\n  });\n  laneShapes.forEach(function (laneShape) {\n    var lane = laneShape.businessObject;\n\n    // lane got removed XX-)\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function (flowNode) {\n        updates.push({\n          flowNode: flowNode,\n          remove: [lane],\n          add: []\n        });\n      });\n    }\n  });\n  return updates;\n};\nUpdateFlowNodeRefsHandler.prototype.execute = function (context) {\n  var updates = context.updates;\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n  updates.forEach(function (update) {\n    var flowNode = update.flowNode,\n      lanes = flowNode.get(LANES_ATTR);\n\n    // unwire old\n    update.remove.forEach(function (oldLane) {\n      collectionRemove(lanes, oldLane);\n      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire new\n    update.add.forEach(function (newLane) {\n      collectionAdd(lanes, newLane);\n      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\nUpdateFlowNodeRefsHandler.prototype.revert = function (context) {\n  var updates = context.updates;\n  updates.forEach(function (update) {\n    var flowNode = update.flowNode,\n      lanes = flowNode.get(LANES_ATTR);\n\n    // unwire new\n    update.add.forEach(function (newLane) {\n      collectionRemove(lanes, newLane);\n      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire old\n    update.remove.forEach(function (oldLane) {\n      collectionAdd(lanes, oldLane);\n      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};","map":null,"metadata":{},"sourceType":"module"}