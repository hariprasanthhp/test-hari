{"ast":null,"code":"/*\n * GoJS v2.1.34 JavaScript Library for HTML Diagrams, https://gojs.net\n * GoJS and Northwoods Software are registered trademarks of Northwoods Software Corporation, https://www.nwoods.com.\n * Copyright (C) 1998-2021 by Northwoods Software Corporation.  All Rights Reserved.\n * THIS SOFTWARE IS LICENSED.  THE LICENSE AGREEMENT IS AT: https://gojs.net/2.1.34/license.html.\n * DO NOT MODIFY THIS FILE.  DO NOT DISTRIBUTE A MODIFIED COPY OF THE CONTENTS OF THIS FILE.\n */\n(function () {\n  var t;\n  function aa(a) {\n    var b = 0;\n    return function () {\n      return b < a.length ? {\n        done: !1,\n        value: a[b++]\n      } : {\n        done: !0\n      };\n    };\n  }\n  function ba(a) {\n    var b = \"undefined\" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];\n    return b ? b.call(a) : {\n      next: aa(a)\n    };\n  }\n  function da(a) {\n    for (var b, c = []; !(b = a.next()).done;) c.push(b.value);\n    return c;\n  }\n  var ea = \"function\" == typeof Object.create ? Object.create : function (a) {\n      function b() {}\n      b.prototype = a;\n      return new b();\n    },\n    fa;\n  if (\"function\" == typeof Object.setPrototypeOf) fa = Object.setPrototypeOf;else {\n    var ha;\n    a: {\n      var ia = {\n          a: !0\n        },\n        ja = {};\n      try {\n        ja.__proto__ = ia;\n        ha = ja.a;\n        break a;\n      } catch (a) {}\n      ha = !1;\n    }\n    fa = ha ? function (a, b) {\n      a.__proto__ = b;\n      if (a.__proto__ !== b) throw new TypeError(a + \" is not extensible\");\n      return a;\n    } : null;\n  }\n  var ka = fa;\n  function la(a, b) {\n    a.prototype = ea(b.prototype);\n    a.prototype.constructor = a;\n    if (ka) ka(a, b);else for (var c in b) if (\"prototype\" != c) if (Object.defineProperties) {\n      var d = Object.getOwnPropertyDescriptor(b, c);\n      d && Object.defineProperty(a, c, d);\n    } else a[c] = b[c];\n    a.vB = b.prototype;\n  }\n  var ma = \"undefined\" != typeof window && window === self ? self : \"undefined\" != typeof global && null != global ? global : self,\n    na = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {\n      a != Array.prototype && a != Object.prototype && (a[b] = c.value);\n    };\n  function oa(a) {\n    if (a) {\n      for (var b = ma, c = [\"Array\", \"prototype\", \"fill\"], d = 0; d < c.length - 1; d++) {\n        var e = c[d];\n        e in b || (b[e] = {});\n        b = b[e];\n      }\n      c = c[c.length - 1];\n      d = b[c];\n      a = a(d);\n      a != d && null != a && na(b, c, {\n        writable: !0,\n        value: a\n      });\n    }\n  }\n  oa(function (a) {\n    return a ? a : function (a, c, d) {\n      var b = this.length || 0;\n      0 > c && (c = Math.max(0, b + c));\n      if (null == d || d > b) d = b;\n      d = Number(d);\n      0 > d && (d = Math.max(0, b + d));\n      for (c = Number(c || 0); c < d; c++) this[c] = a;\n      return this;\n    };\n  });\n  var x = \"object\" === typeof self && self.self === self && self || \"object\" === typeof global && global.global === global && global || \"object\" === typeof window && window.window === window && window || {};\n  void 0 === x.requestAnimationFrame && (void 0 === x.setImmediate ? x.requestAnimationFrame = function (a) {\n    x.setTimeout(a, 0);\n  } : x.requestAnimationFrame = x.setImmediate);\n  function pa() {}\n  function ra(a, b) {\n    var c = -1;\n    return function () {\n      var d = this,\n        e = arguments;\n      -1 !== c && x.clearTimeout(c);\n      c = sa(function () {\n        c = -1;\n        a.apply(d, e);\n      }, b);\n    };\n  }\n  function sa(a, b) {\n    return x.setTimeout(a, b);\n  }\n  function ta(a) {\n    return x.document.createElement(a);\n  }\n  function B(a) {\n    throw Error(a);\n  }\n  function ua(a, b) {\n    a = \"The object is frozen, so its properties cannot be set: \" + a.toString();\n    void 0 !== b && (a += \"  to value: \" + b);\n    B(a);\n  }\n  function va(a, b, c, d) {\n    c = null === c ? \"*\" : \"string\" === typeof c ? c : \"function\" === typeof c && \"string\" === typeof c.className ? c.className : \"\";\n    void 0 !== d && (c += \".\" + d);\n    B(c + \" is not in the range \" + b + \": \" + a);\n  }\n  function wa(a) {\n    x.console && x.console.log(a);\n  }\n  function xa() {\n    x.console && x.console.log(\"Warning: List/Map/Set constructors no longer take an argument that enforces type.Instead they take an optional collection of Values to add to the collection. See 2.0 changelog for details.\");\n  }\n  function ya(a) {\n    return \"object\" === typeof a && null !== a;\n  }\n  function Aa(a) {\n    return Array.isArray(a) || x.NodeList && a instanceof x.NodeList || x.HTMLCollection && a instanceof x.HTMLCollection;\n  }\n  function Ba(a) {\n    return Array.prototype.slice.call(a);\n  }\n  function Ca(a, b, c) {\n    Array.isArray(a) ? b >= a.length ? a.push(c) : a.splice(b, 0, c) : B(\"Cannot insert an object into an HTMLCollection or NodeList: \" + c + \" at \" + b);\n  }\n  function Da(a, b) {\n    Array.isArray(a) ? b >= a.length ? a.pop() : a.splice(b, 1) : B(\"Cannot remove an object from an HTMLCollection or NodeList at \" + b);\n  }\n  function Ea() {\n    var a = Ga.pop();\n    return void 0 === a ? [] : a;\n  }\n  function Ha(a) {\n    a.length = 0;\n    Ga.push(a);\n  }\n  function Ia(a) {\n    if (\"function\" === typeof a) {\n      if (a.className) return a.className;\n      if (a.name) return a.name;\n      var b = a.toString();\n      b = b.substring(9, b.indexOf(\"(\")).trim();\n      if (\"\" !== b) return a._className = b;\n    } else if (ya(a) && a.constructor) return Ia(a.constructor);\n    return typeof a;\n  }\n  function Ja(a) {\n    var b = a;\n    ya(a) && (a.text ? b = a.text : a.name ? b = a.name : void 0 !== a.key ? b = a.key : void 0 !== a.id ? b = a.id : a.constructor === Object && (a.Text ? b = a.Text : a.Name ? b = a.Name : void 0 !== a.Key ? b = a.Key : void 0 !== a.Id ? b = a.Id : void 0 !== a.ID && (b = a.ID)));\n    return void 0 === b ? \"undefined\" : null === b ? \"null\" : b.toString();\n  }\n  function Ka(a, b) {\n    if (a.hasOwnProperty(b)) return !0;\n    for (a = Object.getPrototypeOf(a); a && a !== Function;) {\n      if (a.hasOwnProperty(b)) return !0;\n      var c = a.gB;\n      if (c && c[b]) return !0;\n      a = Object.getPrototypeOf(a);\n    }\n    return !1;\n  }\n  function La(a, b, c) {\n    Object.defineProperty(Oa.prototype, a, {\n      get: b,\n      set: c\n    });\n  }\n  function Pa() {\n    var a = Qa;\n    if (void 0 === x.document) return a;\n    if (0 === a.length) for (var b = x.document.getElementsByTagName(\"canvas\"), c = b.length, d = 0; d < c; d++) {\n      var e = b[d];\n      e.parentElement && e.parentElement.B && a.push(e.parentElement.B);\n    }\n    return a;\n  }\n  function Ra(a) {\n    for (var b = [], c = 0; 256 > c; c++) b[\"0123456789abcdef\".charAt(c >> 4) + \"0123456789abcdef\".charAt(c & 15)] = String.fromCharCode(c);\n    a.length % 2 && (a = \"0\" + a);\n    c = [];\n    for (var d = 0, e = 0; e < a.length; e += 2) c[d++] = b[a.substr(e, 2)];\n    a = c.join(\"\");\n    a = \"\" === a ? \"0\" : a;\n    b = [];\n    for (c = 0; 256 > c; c++) b[c] = c;\n    for (c = d = 0; 256 > c; c++) d = (d + b[c] + 119) % 256, e = b[c], b[c] = b[d], b[d] = e;\n    d = c = 0;\n    for (var f = \"\", g = 0; g < a.length; g++) c = (c + 1) % 256, d = (d + b[c]) % 256, e = b[c], b[c] = b[d], b[d] = e, f += String.fromCharCode(a.charCodeAt(g) ^ b[(b[c] + b[d]) % 256]);\n    return f;\n  }\n  var Sa = void 0 !== x.navigator && 0 < x.navigator.userAgent.indexOf(\"MSIE 9.0\"),\n    Ta = void 0 !== x.navigator && 0 < x.navigator.userAgent.indexOf(\"MSIE 10.0\"),\n    Ua = void 0 !== x.navigator && 0 < x.navigator.userAgent.indexOf(\"Trident/7\"),\n    Va = void 0 !== x.navigator && 0 < x.navigator.userAgent.indexOf(\"Edge/\"),\n    Wa = void 0 !== x.navigator && void 0 !== x.navigator.platform && 0 <= x.navigator.platform.toUpperCase().indexOf(\"MAC\"),\n    Xa = void 0 !== x.navigator && void 0 !== x.navigator.platform && null !== x.navigator.platform.match(/(iPhone|iPod|iPad)/i),\n    Ga = [];\n  Object.freeze([]);\n  var Qa = [];\n  pa.className = \"Util\";\n  pa.Dx = \"32ab5ff3b26f42dc0ed90f21442913b5\";\n  pa.adym = \"gojs.net\";\n  pa.vfo = \"28e647fdb062\";\n  pa.className = \"Util\";\n  function D(a, b, c) {\n    Ya(this);\n    this.l = a;\n    this.Qa = b;\n    this.v = c;\n  }\n  D.prototype.toString = function () {\n    return \"EnumValue.\" + this.Qa;\n  };\n  function Za(a, b) {\n    return void 0 === b || null === b || \"\" === b ? null : a[b];\n  }\n  ma.Object.defineProperties(D.prototype, {\n    classType: {\n      get: function () {\n        return this.l;\n      }\n    },\n    name: {\n      get: function () {\n        return this.Qa;\n      }\n    },\n    value: {\n      get: function () {\n        return this.v;\n      }\n    }\n  });\n  D.className = \"EnumValue\";\n  function $a() {\n    this.ox = [];\n  }\n  $a.prototype.toString = function () {\n    return this.ox.join(\"\");\n  };\n  $a.prototype.add = function (a) {\n    \"\" !== a && this.ox.push(a);\n  };\n  $a.className = \"StringBuilder\";\n  function ab() {}\n  ab.className = \"PropertyCollection\";\n  var eb = {\n    iB: !1,\n    nB: !1,\n    kB: !1,\n    mB: !1,\n    sB: !1,\n    qB: !1,\n    jy: !1,\n    jB: null,\n    trace: function (a) {\n      x.console && x.console.log(a);\n    },\n    lB: function (a, b, c, d) {\n      a.strokeStyle = \"red\";\n      a.fillStyle = \"red\";\n      a.font = \"8px sans-serif\";\n      a.beginPath();\n      a.moveTo(-10, 0);\n      a.lineTo(10, 0);\n      a.moveTo(0, -10);\n      a.lineTo(0, 10);\n      a.stroke();\n      a.setTransform(1, 0, 0, 1, 0, 0);\n      a.scale(c, c);\n      a.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy);\n      a.lineWidth = 2;\n      a.beginPath();\n      a.moveTo(d.left, d.top + 20);\n      a.lineTo(d.left, d.top);\n      a.lineTo(d.left + 20, d.top);\n      a.moveTo(d.right, d.bottom - 20);\n      a.lineTo(d.right, d.bottom);\n      a.lineTo(d.right - 20, d.bottom);\n      a.stroke();\n      a.fillText(\"DB: \" + Math.round(d.x) + \", \" + Math.round(d.y) + \", \" + Math.round(d.width) + \", \" + Math.round(d.height), d.left, d.top - 5);\n    },\n    hB: function (a) {\n      var b = {},\n        c;\n      for (c in a) {\n        b.x = c;\n        if (\"licenseKey\" !== b.x) {\n          var d = a[b.x];\n          if (void 0 !== d.prototype) {\n            b.Im = Object.getOwnPropertyNames(d.prototype);\n            for (var e = {\n              wk: 0\n            }; e.wk < b.Im.length; e = {\n              wk: e.wk\n            }, e.wk++) {\n              var f = Object.getOwnPropertyDescriptor(d.prototype, b.Im[e.wk]);\n              void 0 !== f.get && void 0 === f.set && Object.defineProperty(d.prototype, b.Im[e.wk], {\n                set: function (a, b) {\n                  return function () {\n                    throw Error(\"Property \" + a.Im[b.wk] + \" of \" + a.x + \" is read-only.\");\n                  };\n                }(b, e)\n              });\n            }\n          }\n        }\n        b = {\n          Im: b.Im,\n          x: b.x\n        };\n      }\n    }\n  };\n  function fb() {}\n  fb.prototype.reset = function () {};\n  fb.prototype.next = function () {\n    return !1;\n  };\n  fb.prototype.ld = function () {\n    return !1;\n  };\n  fb.prototype.first = function () {\n    return null;\n  };\n  fb.prototype.any = function () {\n    return !1;\n  };\n  fb.prototype.all = function () {\n    return !0;\n  };\n  fb.prototype.each = function () {\n    return this;\n  };\n  fb.prototype.map = function () {\n    return this;\n  };\n  fb.prototype.filter = function () {\n    return this;\n  };\n  fb.prototype.Kd = function () {};\n  fb.prototype.toString = function () {\n    return \"EmptyIterator\";\n  };\n  ma.Object.defineProperties(fb.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return 0;\n      }\n    }\n  });\n  fb.prototype.first = fb.prototype.first;\n  fb.prototype.hasNext = fb.prototype.ld;\n  fb.prototype.next = fb.prototype.next;\n  fb.prototype.reset = fb.prototype.reset;\n  var gb = null;\n  fb.className = \"EmptyIterator\";\n  gb = new fb();\n  function hb(a) {\n    this.key = -1;\n    this.value = a;\n  }\n  hb.prototype.reset = function () {\n    this.key = -1;\n  };\n  hb.prototype.next = function () {\n    return -1 === this.key ? (this.key = 0, !0) : !1;\n  };\n  hb.prototype.ld = function () {\n    return this.next();\n  };\n  hb.prototype.first = function () {\n    this.key = 0;\n    return this.value;\n  };\n  hb.prototype.any = function (a) {\n    this.key = -1;\n    return a(this.value);\n  };\n  hb.prototype.all = function (a) {\n    this.key = -1;\n    return a(this.value);\n  };\n  hb.prototype.each = function (a) {\n    this.key = -1;\n    a(this.value);\n    return this;\n  };\n  hb.prototype.map = function (a) {\n    return new hb(a(this.value));\n  };\n  hb.prototype.filter = function (a) {\n    return a(this.value) ? new hb(this.value) : gb;\n  };\n  hb.prototype.Kd = function () {\n    this.value = null;\n  };\n  hb.prototype.toString = function () {\n    return \"SingletonIterator(\" + this.value + \")\";\n  };\n  ma.Object.defineProperties(hb.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return 1;\n      }\n    }\n  });\n  hb.prototype.first = hb.prototype.first;\n  hb.prototype.hasNext = hb.prototype.ld;\n  hb.prototype.next = hb.prototype.next;\n  hb.prototype.reset = hb.prototype.reset;\n  hb.className = \"SingletonIterator\";\n  function ib(a) {\n    this.rb = a;\n    this.ef = null;\n    a.Ha = null;\n    this.ia = a.Aa;\n    this.Pa = -1;\n  }\n  ib.prototype.reset = function () {\n    var a = this.rb;\n    a.Ha = null;\n    this.ia = a.Aa;\n    this.Pa = -1;\n  };\n  ib.prototype.next = function () {\n    var a = this.rb;\n    if (a.Aa !== this.ia && 0 > this.key) return !1;\n    a = a.j;\n    var b = a.length,\n      c = ++this.Pa,\n      d = this.ef;\n    if (null !== d) for (; c < b;) {\n      var e = a[c];\n      if (d(e)) return this.key = this.Pa = c, this.value = e, !0;\n      c++;\n    } else {\n      if (c < b) return this.key = c, this.value = a[c], !0;\n      this.Kd();\n    }\n    return !1;\n  };\n  ib.prototype.ld = function () {\n    return this.next();\n  };\n  ib.prototype.first = function () {\n    var a = this.rb;\n    this.ia = a.Aa;\n    this.Pa = 0;\n    a = a.j;\n    var b = a.length,\n      c = this.ef;\n    if (null !== c) {\n      for (var d = 0; d < b;) {\n        var e = a[d];\n        if (c(e)) return this.key = this.Pa = d, this.value = e;\n        d++;\n      }\n      return null;\n    }\n    return 0 < b ? (a = a[0], this.key = 0, this.value = a) : null;\n  };\n  ib.prototype.any = function (a) {\n    var b = this.rb;\n    b.Ha = null;\n    this.Pa = -1;\n    b = b.j;\n    for (var c = b.length, d = this.ef, e = 0; e < c; e++) {\n      var f = b[e];\n      if ((null === d || d(f)) && a(f)) return !0;\n    }\n    return !1;\n  };\n  ib.prototype.all = function (a) {\n    var b = this.rb;\n    b.Ha = null;\n    this.Pa = -1;\n    b = b.j;\n    for (var c = b.length, d = this.ef, e = 0; e < c; e++) {\n      var f = b[e];\n      if ((null === d || d(f)) && !a(f)) return !1;\n    }\n    return !0;\n  };\n  ib.prototype.each = function (a) {\n    var b = this.rb;\n    b.Ha = null;\n    this.Pa = -1;\n    b = b.j;\n    for (var c = b.length, d = this.ef, e = 0; e < c; e++) {\n      var f = b[e];\n      (null === d || d(f)) && a(f);\n    }\n    return this;\n  };\n  ib.prototype.map = function (a) {\n    var b = this.rb;\n    b.Ha = null;\n    this.Pa = -1;\n    var c = [];\n    b = b.j;\n    for (var d = b.length, e = this.ef, f = 0; f < d; f++) {\n      var g = b[f];\n      (null === e || e(g)) && c.push(a(g));\n    }\n    a = new E();\n    a.j = c;\n    a.mb();\n    return a.iterator;\n  };\n  ib.prototype.filter = function (a) {\n    var b = this.rb;\n    b.Ha = null;\n    this.Pa = -1;\n    var c = [];\n    b = b.j;\n    for (var d = b.length, e = this.ef, f = 0; f < d; f++) {\n      var g = b[f];\n      (null === e || e(g)) && a(g) && c.push(g);\n    }\n    a = new E();\n    a.j = c;\n    a.mb();\n    return a.iterator;\n  };\n  ib.prototype.Kd = function () {\n    this.key = -1;\n    this.value = null;\n    this.ia = -1;\n    this.ef = null;\n    this.rb.Ha = this;\n  };\n  ib.prototype.toString = function () {\n    return \"ListIterator@\" + this.Pa + \"/\" + this.rb.count;\n  };\n  ma.Object.defineProperties(ib.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    predicate: {\n      get: function () {\n        return this.ef;\n      },\n      set: function (a) {\n        this.ef = a;\n      }\n    },\n    count: {\n      get: function () {\n        var a = this.ef;\n        if (null !== a) {\n          for (var b = 0, c = this.rb.j, d = c.length, e = 0; e < d; e++) a(c[e]) && b++;\n          return b;\n        }\n        return this.rb.j.length;\n      }\n    }\n  });\n  ib.prototype.first = ib.prototype.first;\n  ib.prototype.hasNext = ib.prototype.ld;\n  ib.prototype.next = ib.prototype.next;\n  ib.prototype.reset = ib.prototype.reset;\n  ib.className = \"ListIterator\";\n  function lb(a) {\n    this.rb = a;\n    a.fh = null;\n    this.ia = a.Aa;\n    this.Pa = a.j.length;\n  }\n  lb.prototype.reset = function () {\n    var a = this.rb;\n    a.fh = null;\n    this.ia = a.Aa;\n    this.Pa = a.j.length;\n  };\n  lb.prototype.next = function () {\n    var a = this.rb;\n    if (a.Aa !== this.ia && 0 > this.key) return !1;\n    var b = --this.Pa;\n    if (0 <= b) return this.key = b, this.value = a.j[b], !0;\n    this.Kd();\n    return !1;\n  };\n  lb.prototype.ld = function () {\n    return this.next();\n  };\n  lb.prototype.first = function () {\n    var a = this.rb;\n    this.ia = a.Aa;\n    var b = a.j;\n    this.Pa = a = b.length - 1;\n    return 0 <= a ? (b = b[a], this.key = a, this.value = b) : null;\n  };\n  lb.prototype.any = function (a) {\n    var b = this.rb;\n    b.fh = null;\n    b = b.j;\n    var c = b.length;\n    this.Pa = c;\n    for (--c; 0 <= c; c--) if (a(b[c])) return !0;\n    return !1;\n  };\n  lb.prototype.all = function (a) {\n    var b = this.rb;\n    b.fh = null;\n    b = b.j;\n    var c = b.length;\n    this.Pa = c;\n    for (--c; 0 <= c; c--) if (!a(b[c])) return !1;\n    return !0;\n  };\n  lb.prototype.each = function (a) {\n    var b = this.rb;\n    b.fh = null;\n    b = b.j;\n    var c = b.length;\n    this.Pa = c;\n    for (--c; 0 <= c; c--) a(b[c]);\n    return this;\n  };\n  lb.prototype.map = function (a) {\n    var b = this.rb;\n    b.fh = null;\n    var c = [];\n    b = b.j;\n    var d = b.length;\n    this.Pa = d;\n    for (--d; 0 <= d; d--) c.push(a(b[d]));\n    a = new E();\n    a.j = c;\n    a.mb();\n    return a.iterator;\n  };\n  lb.prototype.filter = function (a) {\n    var b = this.rb;\n    b.fh = null;\n    var c = [];\n    b = b.j;\n    var d = b.length;\n    this.Pa = d;\n    for (--d; 0 <= d; d--) {\n      var e = b[d];\n      a(e) && c.push(e);\n    }\n    a = new E();\n    a.j = c;\n    a.mb();\n    return a.iterator;\n  };\n  lb.prototype.Kd = function () {\n    this.key = -1;\n    this.value = null;\n    this.ia = -1;\n    this.rb.fh = this;\n  };\n  lb.prototype.toString = function () {\n    return \"ListIteratorBackwards(\" + this.Pa + \"/\" + this.rb.count + \")\";\n  };\n  ma.Object.defineProperties(lb.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return this.rb.j.length;\n      }\n    }\n  });\n  lb.prototype.first = lb.prototype.first;\n  lb.prototype.hasNext = lb.prototype.ld;\n  lb.prototype.next = lb.prototype.next;\n  lb.prototype.reset = lb.prototype.reset;\n  lb.className = \"ListIteratorBackwards\";\n  function E(a) {\n    Ya(this);\n    this.s = !1;\n    this.j = [];\n    this.Aa = 0;\n    this.fh = this.Ha = null;\n    void 0 !== a && (\"function\" === typeof a || \"string\" === typeof a ? xa() : this.addAll(a));\n  }\n  t = E.prototype;\n  t.mb = function () {\n    var a = this.Aa;\n    a++;\n    999999999 < a && (a = 0);\n    this.Aa = a;\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    this.s = !1;\n    return this;\n  };\n  t.toString = function () {\n    return \"List()#\" + mb(this);\n  };\n  t.add = function (a) {\n    if (null === a) return this;\n    this.s && ua(this, a);\n    this.j.push(a);\n    this.mb();\n    return this;\n  };\n  t.push = function (a) {\n    this.add(a);\n  };\n  t.addAll = function (a) {\n    if (null === a) return this;\n    this.s && ua(this);\n    var b = this.j;\n    if (Aa(a)) for (var c = a.length, d = 0; d < c; d++) b.push(a[d]);else for (a = a.iterator; a.next();) b.push(a.value);\n    this.mb();\n    return this;\n  };\n  t.clear = function () {\n    this.s && ua(this);\n    this.j.length = 0;\n    this.mb();\n  };\n  t.contains = function (a) {\n    return null === a ? !1 : -1 !== this.j.indexOf(a);\n  };\n  t.has = function (a) {\n    return this.contains(a);\n  };\n  t.indexOf = function (a) {\n    return null === a ? -1 : this.j.indexOf(a);\n  };\n  t.L = function (a) {\n    var b = this.j;\n    (0 > a || a >= b.length) && va(a, \"0 <= i < length\", E, \"elt:i\");\n    return b[a];\n  };\n  t.get = function (a) {\n    return this.L(a);\n  };\n  t.nd = function (a, b) {\n    var c = this.j;\n    (0 > a || a >= c.length) && va(a, \"0 <= i < length\", E, \"setElt:i\");\n    this.s && ua(this, a);\n    c[a] = b;\n  };\n  t.set = function (a, b) {\n    this.nd(a, b);\n  };\n  t.first = function () {\n    var a = this.j;\n    return 0 === a.length ? null : a[0];\n  };\n  t.Xb = function () {\n    var a = this.j,\n      b = a.length;\n    return 0 < b ? a[b - 1] : null;\n  };\n  t.pop = function () {\n    this.s && ua(this);\n    var a = this.j;\n    return 0 < a.length ? a.pop() : null;\n  };\n  E.prototype.any = function (a) {\n    for (var b = this.j, c = b.length, d = 0; d < c; d++) if (a(b[d])) return !0;\n    return !1;\n  };\n  E.prototype.all = function (a) {\n    for (var b = this.j, c = b.length, d = 0; d < c; d++) if (!a(b[d])) return !1;\n    return !0;\n  };\n  E.prototype.each = function (a) {\n    for (var b = this.j, c = b.length, d = 0; d < c; d++) a(b[d]);\n    return this;\n  };\n  E.prototype.map = function (a) {\n    for (var b = new E(), c = [], d = this.j, e = d.length, f = 0; f < e; f++) c.push(a(d[f]));\n    b.j = c;\n    b.mb();\n    return b;\n  };\n  E.prototype.filter = function (a) {\n    for (var b = new E(), c = [], d = this.j, e = d.length, f = 0; f < e; f++) {\n      var g = d[f];\n      a(g) && c.push(g);\n    }\n    b.j = c;\n    b.mb();\n    return b;\n  };\n  t = E.prototype;\n  t.vb = function (a, b) {\n    0 > a && va(a, \">= 0\", E, \"insertAt:i\");\n    this.s && ua(this, a);\n    var c = this.j;\n    a >= c.length ? c.push(b) : c.splice(a, 0, b);\n    this.mb();\n  };\n  t.remove = function (a) {\n    if (null === a) return !1;\n    this.s && ua(this, a);\n    var b = this.j;\n    a = b.indexOf(a);\n    if (-1 === a) return !1;\n    a === b.length - 1 ? b.pop() : b.splice(a, 1);\n    this.mb();\n    return !0;\n  };\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n  t.bb = function (a) {\n    var b = this.j;\n    (0 > a || a >= b.length) && va(a, \"0 <= i < length\", E, \"removeAt:i\");\n    this.s && ua(this, a);\n    a === b.length - 1 ? b.pop() : b.splice(a, 1);\n    this.mb();\n  };\n  t.removeRange = function (a, b) {\n    var c = this.j,\n      d = c.length;\n    if (0 > a) a = 0;else if (a >= d) return this;\n    if (0 > b) return this;\n    b >= d && (b = d - 1);\n    if (a > b) return this;\n    this.s && ua(this);\n    for (var e = a, f = b + 1; f < d;) c[e++] = c[f++];\n    c.length = d - (b - a + 1);\n    this.mb();\n    return this;\n  };\n  E.prototype.copy = function () {\n    var a = new E(),\n      b = this.j;\n    0 < b.length && (a.j = Array.prototype.slice.call(b));\n    return a;\n  };\n  t = E.prototype;\n  t.ma = function () {\n    for (var a = this.j, b = this.count, c = Array(b), d = 0; d < b; d++) c[d] = a[d];\n    return c;\n  };\n  t.Kw = function () {\n    for (var a = new F(), b = this.j, c = this.count, d = 0; d < c; d++) a.add(b[d]);\n    return a;\n  };\n  t.sort = function (a) {\n    this.s && ua(this);\n    this.j.sort(a);\n    this.mb();\n    return this;\n  };\n  t.tj = function (a, b, c) {\n    var d = this.j,\n      e = d.length;\n    void 0 === b && (b = 0);\n    void 0 === c && (c = e);\n    this.s && ua(this);\n    var f = c - b;\n    if (1 >= f) return this;\n    (0 > b || b >= e - 1) && va(b, \"0 <= from < length\", E, \"sortRange:from\");\n    if (2 === f) return c = d[b], e = d[b + 1], 0 < a(c, e) && (d[b] = e, d[b + 1] = c, this.mb()), this;\n    if (0 === b) {\n      if (c >= e) d.sort(a);else for (b = d.slice(0, c), b.sort(a), a = 0; a < c; a++) d[a] = b[a];\n    } else if (c >= e) for (c = d.slice(b), c.sort(a), a = b; a < e; a++) d[a] = c[a - b];else for (e = d.slice(b, c), e.sort(a), a = b; a < c; a++) d[a] = e[a - b];\n    this.mb();\n    return this;\n  };\n  t.reverse = function () {\n    this.s && ua(this);\n    this.j.reverse();\n    this.mb();\n    return this;\n  };\n  ma.Object.defineProperties(E.prototype, {\n    _dataArray: {\n      get: function () {\n        return this.j;\n      }\n    },\n    count: {\n      get: function () {\n        return this.j.length;\n      }\n    },\n    size: {\n      get: function () {\n        return this.j.length;\n      }\n    },\n    length: {\n      get: function () {\n        return this.j.length;\n      }\n    },\n    iterator: {\n      get: function () {\n        if (0 >= this.j.length) return gb;\n        var a = this.Ha;\n        return null !== a ? (a.reset(), a) : new ib(this);\n      }\n    },\n    iteratorBackwards: {\n      get: function () {\n        if (0 >= this.j.length) return gb;\n        var a = this.fh;\n        return null !== a ? (a.reset(), a) : new lb(this);\n      }\n    }\n  });\n  E.prototype.reverse = E.prototype.reverse;\n  E.prototype.sortRange = E.prototype.tj;\n  E.prototype.sort = E.prototype.sort;\n  E.prototype.toSet = E.prototype.Kw;\n  E.prototype.toArray = E.prototype.ma;\n  E.prototype.removeRange = E.prototype.removeRange;\n  E.prototype.removeAt = E.prototype.bb;\n  E.prototype[\"delete\"] = E.prototype.delete;\n  E.prototype.remove = E.prototype.remove;\n  E.prototype.insertAt = E.prototype.vb;\n  E.prototype.pop = E.prototype.pop;\n  E.prototype.last = E.prototype.Xb;\n  E.prototype.first = E.prototype.first;\n  E.prototype.set = E.prototype.set;\n  E.prototype.setElt = E.prototype.nd;\n  E.prototype.get = E.prototype.get;\n  E.prototype.elt = E.prototype.L;\n  E.prototype.indexOf = E.prototype.indexOf;\n  E.prototype.has = E.prototype.has;\n  E.prototype.contains = E.prototype.contains;\n  E.prototype.clear = E.prototype.clear;\n  E.prototype.addAll = E.prototype.addAll;\n  E.prototype.push = E.prototype.push;\n  E.prototype.add = E.prototype.add;\n  E.prototype.thaw = E.prototype.ea;\n  E.prototype.freeze = E.prototype.freeze;\n  E.className = \"List\";\n  function nb(a) {\n    this.tg = a;\n    a.Ha = null;\n    this.ia = a.Aa;\n    this.ka = null;\n  }\n  nb.prototype.reset = function () {\n    var a = this.tg;\n    a.Ha = null;\n    this.ia = a.Aa;\n    this.ka = null;\n  };\n  nb.prototype.next = function () {\n    var a = this.tg;\n    if (a.Aa !== this.ia && null === this.key) return !1;\n    var b = this.ka;\n    b = null === b ? a.ba : b.oa;\n    if (null !== b) return this.ka = b, this.value = b.value, this.key = b.key, !0;\n    this.Kd();\n    return !1;\n  };\n  nb.prototype.ld = function () {\n    return this.next();\n  };\n  nb.prototype.first = function () {\n    var a = this.tg;\n    this.ia = a.Aa;\n    a = a.ba;\n    if (null !== a) {\n      this.ka = a;\n      var b = a.value;\n      this.key = a.key;\n      return this.value = b;\n    }\n    return null;\n  };\n  nb.prototype.any = function (a) {\n    var b = this.tg;\n    this.ka = b.Ha = null;\n    for (b = b.ba; null !== b;) {\n      if (a(b.value)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  nb.prototype.all = function (a) {\n    var b = this.tg;\n    this.ka = b.Ha = null;\n    for (b = b.ba; null !== b;) {\n      if (!a(b.value)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  nb.prototype.each = function (a) {\n    var b = this.tg;\n    this.ka = b.Ha = null;\n    for (b = b.ba; null !== b;) a(b.value), b = b.oa;\n    return this;\n  };\n  nb.prototype.map = function (a) {\n    var b = this.tg;\n    b.Ha = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) c.add(a(b.value)), b = b.oa;\n    return c.iterator;\n  };\n  nb.prototype.filter = function (a) {\n    var b = this.tg;\n    b.Ha = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) {\n      var d = b.value;\n      a(d) && c.add(d);\n      b = b.oa;\n    }\n    return c.iterator;\n  };\n  nb.prototype.Kd = function () {\n    this.value = this.key = null;\n    this.ia = -1;\n    this.tg.Ha = this;\n  };\n  nb.prototype.toString = function () {\n    return null !== this.ka ? \"SetIterator@\" + this.ka.value : \"SetIterator\";\n  };\n  ma.Object.defineProperties(nb.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return this.tg.Fb;\n      }\n    }\n  });\n  nb.prototype.first = nb.prototype.first;\n  nb.prototype.hasNext = nb.prototype.ld;\n  nb.prototype.next = nb.prototype.next;\n  nb.prototype.reset = nb.prototype.reset;\n  nb.className = \"SetIterator\";\n  function F(a) {\n    Ya(this);\n    this.s = !1;\n    this.Hb = {};\n    this.Fb = 0;\n    this.Ha = null;\n    this.Aa = 0;\n    this.Ze = this.ba = null;\n    void 0 !== a && (\"function\" === typeof a || \"string\" === typeof a ? xa() : this.addAll(a));\n  }\n  t = F.prototype;\n  t.mb = function () {\n    var a = this.Aa;\n    a++;\n    999999999 < a && (a = 0);\n    this.Aa = a;\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    this.s = !1;\n    return this;\n  };\n  t.toString = function () {\n    return \"Set()#\" + mb(this);\n  };\n  t.add = function (a) {\n    if (null === a) return this;\n    this.s && ua(this, a);\n    var b = a;\n    ya(a) && (b = ob(a));\n    void 0 === this.Hb[b] && (this.Fb++, a = new pb(a, a), this.Hb[b] = a, b = this.Ze, null === b ? this.ba = a : (a.Ql = b, b.oa = a), this.Ze = a, this.mb());\n    return this;\n  };\n  t.addAll = function (a) {\n    if (null === a) return this;\n    this.s && ua(this);\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) this.add(a[c]);else for (a = a.iterator; a.next();) this.add(a.value);\n    return this;\n  };\n  t.contains = function (a) {\n    if (null === a) return !1;\n    var b = a;\n    return ya(a) && (b = mb(a), void 0 === b) ? !1 : void 0 !== this.Hb[b];\n  };\n  t.has = function (a) {\n    return this.contains(a);\n  };\n  t.zz = function (a) {\n    if (null === a) return !0;\n    for (a = a.iterator; a.next();) if (!this.contains(a.value)) return !1;\n    return !0;\n  };\n  t.Az = function (a) {\n    if (null === a) return !0;\n    for (a = a.iterator; a.next();) if (this.contains(a.value)) return !0;\n    return !1;\n  };\n  t.first = function () {\n    var a = this.ba;\n    return null === a ? null : a.value;\n  };\n  F.prototype.any = function (a) {\n    for (var b = this.ba; null !== b;) {\n      if (a(b.value)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  F.prototype.all = function (a) {\n    for (var b = this.ba; null !== b;) {\n      if (!a(b.value)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  F.prototype.each = function (a) {\n    for (var b = this.ba; null !== b;) a(b.value), b = b.oa;\n    return this;\n  };\n  F.prototype.map = function (a) {\n    for (var b = new F(), c = this.ba; null !== c;) b.add(a(c.value)), c = c.oa;\n    return b;\n  };\n  F.prototype.filter = function (a) {\n    for (var b = new F(), c = this.ba; null !== c;) {\n      var d = c.value;\n      a(d) && b.add(d);\n      c = c.oa;\n    }\n    return b;\n  };\n  t = F.prototype;\n  t.remove = function (a) {\n    if (null === a) return !1;\n    this.s && ua(this, a);\n    var b = a;\n    if (ya(a) && (b = mb(a), void 0 === b)) return !1;\n    a = this.Hb[b];\n    if (void 0 === a) return !1;\n    var c = a.oa,\n      d = a.Ql;\n    null !== c && (c.Ql = d);\n    null !== d && (d.oa = c);\n    this.ba === a && (this.ba = c);\n    this.Ze === a && (this.Ze = d);\n    delete this.Hb[b];\n    this.Fb--;\n    this.mb();\n    return !0;\n  };\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n  t.$q = function (a) {\n    if (null === a) return this;\n    this.s && ua(this);\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) this.remove(a[c]);else for (a = a.iterator; a.next();) this.remove(a.value);\n    return this;\n  };\n  t.RA = function (a) {\n    if (null === a || 0 === this.count) return this;\n    this.s && ua(this);\n    var b = new F();\n    b.addAll(a);\n    a = [];\n    for (var c = this.iterator; c.next();) {\n      var d = c.value;\n      b.contains(d) || a.push(d);\n    }\n    this.$q(a);\n    return this;\n  };\n  t.clear = function () {\n    this.s && ua(this);\n    this.Hb = {};\n    this.Fb = 0;\n    null !== this.Ha && this.Ha.reset();\n    this.Ze = this.ba = null;\n    this.mb();\n  };\n  F.prototype.copy = function () {\n    var a = new F(),\n      b = this.Hb,\n      c;\n    for (c in b) a.add(b[c].value);\n    return a;\n  };\n  F.prototype.ma = function () {\n    var a = Array(this.Fb),\n      b = this.Hb,\n      c = 0,\n      d;\n    for (d in b) a[c] = b[d].value, c++;\n    return a;\n  };\n  F.prototype.Jw = function () {\n    var a = new E(),\n      b = this.Hb,\n      c;\n    for (c in b) a.add(b[c].value);\n    return a;\n  };\n  function Ya(a) {\n    a.__gohashid = qb++;\n  }\n  function ob(a) {\n    var b = a.__gohashid;\n    void 0 === b && (b = qb++, a.__gohashid = b);\n    return b;\n  }\n  function mb(a) {\n    return a.__gohashid;\n  }\n  ma.Object.defineProperties(F.prototype, {\n    count: {\n      get: function () {\n        return this.Fb;\n      }\n    },\n    size: {\n      get: function () {\n        return this.Fb;\n      }\n    },\n    iterator: {\n      get: function () {\n        if (0 >= this.Fb) return gb;\n        var a = this.Ha;\n        return null !== a ? (a.reset(), a) : new nb(this);\n      }\n    }\n  });\n  F.prototype.toList = F.prototype.Jw;\n  F.prototype.toArray = F.prototype.ma;\n  F.prototype.clear = F.prototype.clear;\n  F.prototype.retainAll = F.prototype.RA;\n  F.prototype.removeAll = F.prototype.$q;\n  F.prototype[\"delete\"] = F.prototype.delete;\n  F.prototype.remove = F.prototype.remove;\n  F.prototype.first = F.prototype.first;\n  F.prototype.containsAny = F.prototype.Az;\n  F.prototype.containsAll = F.prototype.zz;\n  F.prototype.has = F.prototype.has;\n  F.prototype.contains = F.prototype.contains;\n  F.prototype.addAll = F.prototype.addAll;\n  F.prototype.add = F.prototype.add;\n  F.prototype.thaw = F.prototype.ea;\n  F.prototype.freeze = F.prototype.freeze;\n  var qb = 1;\n  F.className = \"Set\";\n  F.uniqueHash = Ya;\n  F.hashIdUnique = ob;\n  F.hashId = mb;\n  function rb(a) {\n    this.fa = a;\n    this.ia = a.Aa;\n    this.ka = null;\n  }\n  rb.prototype.reset = function () {\n    this.ia = this.fa.Aa;\n    this.ka = null;\n  };\n  rb.prototype.next = function () {\n    var a = this.fa;\n    if (a.Aa !== this.ia && null === this.key) return !1;\n    var b = this.ka;\n    b = null === b ? a.ba : b.oa;\n    if (null !== b) return this.ka = b, this.value = this.key = a = b.key, !0;\n    this.Kd();\n    return !1;\n  };\n  rb.prototype.ld = function () {\n    return this.next();\n  };\n  rb.prototype.first = function () {\n    var a = this.fa;\n    this.ia = a.Aa;\n    a = a.ba;\n    return null !== a ? (this.ka = a, this.value = this.key = a = a.key) : null;\n  };\n  rb.prototype.any = function (a) {\n    var b = this.fa;\n    this.ka = null;\n    for (b = b.ba; null !== b;) {\n      if (a(b.key)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  rb.prototype.all = function (a) {\n    var b = this.fa;\n    this.ka = null;\n    for (b = b.ba; null !== b;) {\n      if (!a(b.key)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  rb.prototype.each = function (a) {\n    var b = this.fa;\n    this.ka = null;\n    for (b = b.ba; null !== b;) a(b.key), b = b.oa;\n    return this;\n  };\n  rb.prototype.map = function (a) {\n    var b = this.fa;\n    this.ka = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) c.add(a(b.key)), b = b.oa;\n    return c.iterator;\n  };\n  rb.prototype.filter = function (a) {\n    var b = this.fa;\n    this.ka = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) {\n      var d = b.key;\n      a(d) && c.add(d);\n      b = b.oa;\n    }\n    return c.iterator;\n  };\n  rb.prototype.Kd = function () {\n    this.value = this.key = null;\n    this.ia = -1;\n  };\n  rb.prototype.toString = function () {\n    return null !== this.ka ? \"MapKeySetIterator@\" + this.ka.value : \"MapKeySetIterator\";\n  };\n  ma.Object.defineProperties(rb.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return this.fa.Fb;\n      }\n    }\n  });\n  rb.prototype.first = rb.prototype.first;\n  rb.prototype.hasNext = rb.prototype.ld;\n  rb.prototype.next = rb.prototype.next;\n  rb.prototype.reset = rb.prototype.reset;\n  rb.className = \"MapKeySetIterator\";\n  function sb(a) {\n    F.call(this);\n    Ya(this);\n    this.s = !0;\n    this.fa = a;\n  }\n  la(sb, F);\n  t = sb.prototype;\n  t.freeze = function () {\n    return this;\n  };\n  t.ea = function () {\n    return this;\n  };\n  t.toString = function () {\n    return \"MapKeySet(\" + this.fa.toString() + \")\";\n  };\n  t.add = function () {\n    B(\"This Set is read-only: \" + this.toString());\n    return this;\n  };\n  t.contains = function (a) {\n    return this.fa.contains(a);\n  };\n  t.has = function (a) {\n    return this.contains(a);\n  };\n  t.remove = function () {\n    B(\"This Set is read-only: \" + this.toString());\n    return !1;\n  };\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n  t.clear = function () {\n    B(\"This Set is read-only: \" + this.toString());\n  };\n  t.first = function () {\n    var a = this.fa.ba;\n    return null !== a ? a.key : null;\n  };\n  sb.prototype.any = function (a) {\n    for (var b = this.fa.ba; null !== b;) {\n      if (a(b.key)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  sb.prototype.all = function (a) {\n    for (var b = this.fa.ba; null !== b;) {\n      if (!a(b.key)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  sb.prototype.each = function (a) {\n    for (var b = this.fa.ba; null !== b;) a(b.key), b = b.oa;\n    return this;\n  };\n  sb.prototype.map = function (a) {\n    for (var b = new F(), c = this.fa.ba; null !== c;) b.add(a(c.key)), c = c.oa;\n    return b;\n  };\n  sb.prototype.filter = function (a) {\n    for (var b = new F(), c = this.fa.ba; null !== c;) {\n      var d = c.key;\n      a(d) && b.add(d);\n      c = c.oa;\n    }\n    return b;\n  };\n  sb.prototype.copy = function () {\n    return new sb(this.fa);\n  };\n  sb.prototype.Kw = function () {\n    var a = new F(),\n      b = this.fa.Hb,\n      c;\n    for (c in b) a.add(b[c].key);\n    return a;\n  };\n  sb.prototype.ma = function () {\n    var a = this.fa.Hb,\n      b = Array(this.fa.Fb),\n      c = 0,\n      d;\n    for (d in a) b[c] = a[d].key, c++;\n    return b;\n  };\n  sb.prototype.Jw = function () {\n    var a = new E(),\n      b = this.fa.Hb,\n      c;\n    for (c in b) a.add(b[c].key);\n    return a;\n  };\n  ma.Object.defineProperties(sb.prototype, {\n    count: {\n      get: function () {\n        return this.fa.Fb;\n      }\n    },\n    size: {\n      get: function () {\n        return this.fa.Fb;\n      }\n    },\n    iterator: {\n      get: function () {\n        return 0 >= this.fa.Fb ? gb : new rb(this.fa);\n      }\n    }\n  });\n  sb.prototype.toList = sb.prototype.Jw;\n  sb.prototype.toArray = sb.prototype.ma;\n  sb.prototype.toSet = sb.prototype.Kw;\n  sb.prototype.first = sb.prototype.first;\n  sb.prototype.clear = sb.prototype.clear;\n  sb.prototype[\"delete\"] = sb.prototype.delete;\n  sb.prototype.remove = sb.prototype.remove;\n  sb.prototype.has = sb.prototype.has;\n  sb.prototype.contains = sb.prototype.contains;\n  sb.prototype.add = sb.prototype.add;\n  sb.prototype.thaw = sb.prototype.ea;\n  sb.prototype.freeze = sb.prototype.freeze;\n  sb.className = \"MapKeySet\";\n  function tb(a) {\n    this.fa = a;\n    a.Ye = null;\n    this.ia = a.Aa;\n    this.ka = null;\n  }\n  tb.prototype.reset = function () {\n    var a = this.fa;\n    a.Ye = null;\n    this.ia = a.Aa;\n    this.ka = null;\n  };\n  tb.prototype.next = function () {\n    var a = this.fa;\n    if (a.Aa !== this.ia && null === this.key) return !1;\n    var b = this.ka;\n    b = null === b ? a.ba : b.oa;\n    if (null !== b) return this.ka = b, this.value = b.value, this.key = b.key, !0;\n    this.Kd();\n    return !1;\n  };\n  tb.prototype.ld = function () {\n    return this.next();\n  };\n  tb.prototype.first = function () {\n    var a = this.fa;\n    this.ia = a.Aa;\n    a = a.ba;\n    if (null !== a) {\n      this.ka = a;\n      var b = a.value;\n      this.key = a.key;\n      return this.value = b;\n    }\n    return null;\n  };\n  tb.prototype.any = function (a) {\n    var b = this.fa;\n    this.ka = b.Ye = null;\n    for (b = b.ba; null !== b;) {\n      if (a(b.value)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  tb.prototype.all = function (a) {\n    var b = this.fa;\n    this.ka = b.Ye = null;\n    for (b = b.ba; null !== b;) {\n      if (!a(b.value)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  tb.prototype.each = function (a) {\n    var b = this.fa;\n    this.ka = b.Ye = null;\n    for (b = b.ba; null !== b;) a(b.value), b = b.oa;\n    return this;\n  };\n  tb.prototype.map = function (a) {\n    var b = this.fa;\n    this.ka = b.Ye = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) c.add(a(b.value)), b = b.oa;\n    return c.iterator;\n  };\n  tb.prototype.filter = function (a) {\n    var b = this.fa;\n    this.ka = b.Ye = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) {\n      var d = b.value;\n      a(d) && c.add(d);\n      b = b.oa;\n    }\n    return c.iterator;\n  };\n  tb.prototype.Kd = function () {\n    this.value = this.key = null;\n    this.ia = -1;\n    this.fa.Ye = this;\n  };\n  tb.prototype.toString = function () {\n    return null !== this.ka ? \"MapValueSetIterator@\" + this.ka.value : \"MapValueSetIterator\";\n  };\n  ma.Object.defineProperties(tb.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return this.fa.Fb;\n      }\n    }\n  });\n  tb.prototype.first = tb.prototype.first;\n  tb.prototype.hasNext = tb.prototype.ld;\n  tb.prototype.next = tb.prototype.next;\n  tb.prototype.reset = tb.prototype.reset;\n  tb.className = \"MapValueSetIterator\";\n  function pb(a, b) {\n    this.key = a;\n    this.value = b;\n    this.Ql = this.oa = null;\n  }\n  pb.prototype.toString = function () {\n    return \"{\" + this.key + \":\" + this.value + \"}\";\n  };\n  pb.className = \"KeyValuePair\";\n  function ub(a) {\n    this.fa = a;\n    a.Ha = null;\n    this.ia = a.Aa;\n    this.ka = null;\n  }\n  ub.prototype.reset = function () {\n    var a = this.fa;\n    a.Ha = null;\n    this.ia = a.Aa;\n    this.ka = null;\n  };\n  ub.prototype.next = function () {\n    var a = this.fa;\n    if (a.Aa !== this.ia && null === this.key) return !1;\n    var b = this.ka;\n    b = null === b ? a.ba : b.oa;\n    if (null !== b) return this.ka = b, this.key = b.key, this.value = b.value, !0;\n    this.Kd();\n    return !1;\n  };\n  ub.prototype.ld = function () {\n    return this.next();\n  };\n  ub.prototype.first = function () {\n    var a = this.fa;\n    this.ia = a.Aa;\n    a = a.ba;\n    return null !== a ? (this.ka = a, this.key = a.key, this.value = a.value, a) : null;\n  };\n  ub.prototype.any = function (a) {\n    var b = this.fa;\n    this.ka = b.Ha = null;\n    for (b = b.ba; null !== b;) {\n      if (a(b)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  ub.prototype.all = function (a) {\n    var b = this.fa;\n    this.ka = b.Ha = null;\n    for (b = b.ba; null !== b;) {\n      if (!a(b)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  ub.prototype.each = function (a) {\n    var b = this.fa;\n    this.ka = b.Ha = null;\n    for (b = b.ba; null !== b;) a(b), b = b.oa;\n    return this;\n  };\n  ub.prototype.map = function (a) {\n    var b = this.fa;\n    this.ka = b.Ha = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) c.add(a(b)), b = b.oa;\n    return c.iterator;\n  };\n  ub.prototype.filter = function (a) {\n    var b = this.fa;\n    this.ka = b.Ha = null;\n    var c = new E();\n    for (b = b.ba; null !== b;) a(b) && c.add(b), b = b.oa;\n    return c.iterator;\n  };\n  ub.prototype.Kd = function () {\n    this.value = this.key = null;\n    this.ia = -1;\n    this.fa.Ha = this;\n  };\n  ub.prototype.toString = function () {\n    return null !== this.ka ? \"MapIterator@\" + this.ka : \"MapIterator\";\n  };\n  ma.Object.defineProperties(ub.prototype, {\n    iterator: {\n      get: function () {\n        return this;\n      }\n    },\n    count: {\n      get: function () {\n        return this.fa.Fb;\n      }\n    }\n  });\n  ub.prototype.first = ub.prototype.first;\n  ub.prototype.hasNext = ub.prototype.ld;\n  ub.prototype.next = ub.prototype.next;\n  ub.prototype.reset = ub.prototype.reset;\n  ub.className = \"MapIterator\";\n  function H(a) {\n    Ya(this);\n    this.s = !1;\n    this.Hb = {};\n    this.Fb = 0;\n    this.Ye = this.Ha = null;\n    this.Aa = 0;\n    this.Ze = this.ba = null;\n    void 0 !== a && (\"function\" === typeof a || \"string\" === typeof a ? xa() : this.addAll(a));\n  }\n  t = H.prototype;\n  t.mb = function () {\n    var a = this.Aa;\n    a++;\n    999999999 < a && (a = 0);\n    this.Aa = a;\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    this.s = !1;\n    return this;\n  };\n  t.toString = function () {\n    return \"Map()#\" + mb(this);\n  };\n  t.add = function (a, b) {\n    this.s && ua(this, a);\n    var c = a;\n    ya(a) && (c = ob(a));\n    var d = this.Hb[c];\n    void 0 === d ? (this.Fb++, a = new pb(a, b), this.Hb[c] = a, c = this.Ze, null === c ? this.ba = a : (a.Ql = c, c.oa = a), this.Ze = a, this.mb()) : d.value = b;\n    return this;\n  };\n  t.set = function (a, b) {\n    return this.add(a, b);\n  };\n  t.addAll = function (a) {\n    if (null === a) return this;\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n      this.add(d.key, d.value);\n    } else if (a instanceof H) for (a = a.iterator; a.next();) this.add(a.key, a.value);else for (a = a.iterator; a.next();) b = a.value, this.add(b.key, b.value);\n    return this;\n  };\n  t.first = function () {\n    return this.ba;\n  };\n  H.prototype.any = function (a) {\n    for (var b = this.ba; null !== b;) {\n      if (a(b)) return !0;\n      b = b.oa;\n    }\n    return !1;\n  };\n  H.prototype.all = function (a) {\n    for (var b = this.ba; null !== b;) {\n      if (!a(b)) return !1;\n      b = b.oa;\n    }\n    return !0;\n  };\n  H.prototype.each = function (a) {\n    for (var b = this.ba; null !== b;) a(b), b = b.oa;\n    return this;\n  };\n  H.prototype.map = function (a) {\n    for (var b = new H(), c = this.ba; null !== c;) b.add(c.key, a(c)), c = c.oa;\n    return b;\n  };\n  H.prototype.filter = function (a) {\n    for (var b = new H(), c = this.ba; null !== c;) a(c) && b.add(c.key, c.value), c = c.oa;\n    return b;\n  };\n  t = H.prototype;\n  t.contains = function (a) {\n    var b = a;\n    return ya(a) && (b = mb(a), void 0 === b) ? !1 : void 0 !== this.Hb[b];\n  };\n  t.has = function (a) {\n    return this.contains(a);\n  };\n  t.H = function (a) {\n    var b = a;\n    if (ya(a) && (b = mb(a), void 0 === b)) return null;\n    a = this.Hb[b];\n    return void 0 === a ? null : a.value;\n  };\n  t.get = function (a) {\n    return this.H(a);\n  };\n  t.remove = function (a) {\n    if (null === a) return !1;\n    this.s && ua(this, a);\n    var b = a;\n    if (ya(a) && (b = mb(a), void 0 === b)) return !1;\n    a = this.Hb[b];\n    if (void 0 === a) return !1;\n    var c = a.oa,\n      d = a.Ql;\n    null !== c && (c.Ql = d);\n    null !== d && (d.oa = c);\n    this.ba === a && (this.ba = c);\n    this.Ze === a && (this.Ze = d);\n    delete this.Hb[b];\n    this.Fb--;\n    this.mb();\n    return !0;\n  };\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n  t.clear = function () {\n    this.s && ua(this);\n    this.Hb = {};\n    this.Fb = 0;\n    null !== this.Ha && this.Ha.reset();\n    null !== this.Ye && this.Ye.reset();\n    this.Ze = this.ba = null;\n    this.mb();\n  };\n  H.prototype.copy = function () {\n    var a = new H(),\n      b = this.Hb,\n      c;\n    for (c in b) {\n      var d = b[c];\n      a.add(d.key, d.value);\n    }\n    return a;\n  };\n  H.prototype.ma = function () {\n    var a = this.Hb,\n      b = Array(this.Fb),\n      c = 0,\n      d;\n    for (d in a) {\n      var e = a[d];\n      b[c] = new pb(e.key, e.value);\n      c++;\n    }\n    return b;\n  };\n  H.prototype.Jf = function () {\n    return new sb(this);\n  };\n  ma.Object.defineProperties(H.prototype, {\n    count: {\n      get: function () {\n        return this.Fb;\n      }\n    },\n    size: {\n      get: function () {\n        return this.Fb;\n      }\n    },\n    iterator: {\n      get: function () {\n        if (0 >= this.count) return gb;\n        var a = this.Ha;\n        return null !== a ? (a.reset(), a) : new ub(this);\n      }\n    },\n    iteratorKeys: {\n      get: function () {\n        return 0 >= this.count ? gb : new rb(this);\n      }\n    },\n    iteratorValues: {\n      get: function () {\n        if (0 >= this.count) return gb;\n        var a = this.Ye;\n        return null !== a ? (a.reset(), a) : new tb(this);\n      }\n    }\n  });\n  H.prototype.toKeySet = H.prototype.Jf;\n  H.prototype.toArray = H.prototype.ma;\n  H.prototype.clear = H.prototype.clear;\n  H.prototype[\"delete\"] = H.prototype.delete;\n  H.prototype.remove = H.prototype.remove;\n  H.prototype.get = H.prototype.get;\n  H.prototype.getValue = H.prototype.H;\n  H.prototype.has = H.prototype.has;\n  H.prototype.contains = H.prototype.contains;\n  H.prototype.first = H.prototype.first;\n  H.prototype.addAll = H.prototype.addAll;\n  H.prototype.set = H.prototype.set;\n  H.prototype.add = H.prototype.add;\n  H.prototype.thaw = H.prototype.ea;\n  H.prototype.freeze = H.prototype.freeze;\n  H.className = \"Map\";\n  function J(a, b) {\n    void 0 === a ? this.y = this.x = 0 : \"number\" === typeof a && \"number\" === typeof b ? (this.x = a, this.y = b) : B(\"Invalid arguments to Point constructor: \" + a + \", \" + b);\n    this.s = !1;\n  }\n  J.prototype.assign = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  };\n  J.prototype.h = function (a, b) {\n    this.x = a;\n    this.y = b;\n    return this;\n  };\n  J.prototype.Ig = function (a, b) {\n    this.x = a;\n    this.y = b;\n    return this;\n  };\n  J.prototype.set = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  };\n  J.prototype.copy = function () {\n    var a = new J();\n    a.x = this.x;\n    a.y = this.y;\n    return a;\n  };\n  t = J.prototype;\n  t.ca = function () {\n    this.s = !0;\n    Object.freeze(this);\n    return this;\n  };\n  t.G = function () {\n    return this.s || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    return this;\n  };\n  function vb(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n      for (var b = 0, c = 0; \"\" === a[b];) b++;\n      var d = a[b++];\n      d && (c = parseFloat(d));\n      for (var e = 0; \"\" === a[b];) b++;\n      (d = a[b++]) && (e = parseFloat(d));\n      return new J(c, e);\n    }\n    return new J();\n  }\n  function wb(a) {\n    return a.x.toString() + \" \" + a.y.toString();\n  }\n  t.toString = function () {\n    return \"Point(\" + this.x + \",\" + this.y + \")\";\n  };\n  t.w = function (a) {\n    return a instanceof J ? this.x === a.x && this.y === a.y : !1;\n  };\n  t.fj = function (a, b) {\n    return this.x === a && this.y === b;\n  };\n  t.Na = function (a) {\n    return K.A(this.x, a.x) && K.A(this.y, a.y);\n  };\n  t.add = function (a) {\n    this.x += a.x;\n    this.y += a.y;\n    return this;\n  };\n  t.ce = function (a) {\n    this.x -= a.x;\n    this.y -= a.y;\n    return this;\n  };\n  t.offset = function (a, b) {\n    this.x += a;\n    this.y += b;\n    return this;\n  };\n  J.prototype.rotate = function (a) {\n    if (0 === a) return this;\n    var b = this.x,\n      c = this.y;\n    if (0 === b && 0 === c) return this;\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    if (90 === a) {\n      a = 0;\n      var d = 1;\n    } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d));\n    this.x = a * b - d * c;\n    this.y = d * b + a * c;\n    return this;\n  };\n  t = J.prototype;\n  t.scale = function (a, b) {\n    this.x *= a;\n    this.y *= b;\n    return this;\n  };\n  t.Fe = function (a) {\n    var b = a.x - this.x;\n    a = a.y - this.y;\n    return b * b + a * a;\n  };\n  t.kd = function (a, b) {\n    a -= this.x;\n    b -= this.y;\n    return a * a + b * b;\n  };\n  t.normalize = function () {\n    var a = this.x,\n      b = this.y,\n      c = Math.sqrt(a * a + b * b);\n    0 < c && (this.x = a / c, this.y = b / c);\n    return this;\n  };\n  t.Sa = function (a) {\n    return xb(a.x - this.x, a.y - this.y);\n  };\n  t.direction = function (a, b) {\n    return xb(a - this.x, b - this.y);\n  };\n  function xb(a, b) {\n    if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0;\n    if (0 === b) return 0 < a ? 0 : 180;\n    if (isNaN(a) || isNaN(b)) return 0;\n    var c = 180 * Math.atan(Math.abs(b / a)) / Math.PI;\n    0 > a ? c = 0 > b ? c + 180 : 180 - c : 0 > b && (c = 360 - c);\n    return c;\n  }\n  t.KA = function (a, b, c, d) {\n    K.Qh(a, b, c, d, this.x, this.y, this);\n    return this;\n  };\n  t.LA = function (a, b) {\n    K.Qh(a.x, a.y, b.x, b.y, this.x, this.y, this);\n    return this;\n  };\n  t.WA = function (a, b, c, d) {\n    K.Eq(this.x, this.y, a, b, c, d, this);\n    return this;\n  };\n  t.XA = function (a, b) {\n    K.Eq(this.x, this.y, a.x, a.y, b.width, b.height, this);\n    return this;\n  };\n  t.sj = function (a, b) {\n    this.x = a.x + b.x * a.width + b.offsetX;\n    this.y = a.y + b.y * a.height + b.offsetY;\n    return this;\n  };\n  t.Lk = function (a, b, c, d, e) {\n    this.x = a + e.x * c + e.offsetX;\n    this.y = b + e.y * d + e.offsetY;\n    return this;\n  };\n  t.transform = function (a) {\n    a.sa(this);\n    return this;\n  };\n  function Bb(a, b) {\n    b.Zd(a);\n    return a;\n  }\n  function Cb(a, b, c, d, e, f) {\n    var g = e - c,\n      h = f - d,\n      k = g * g + h * h;\n    c -= a;\n    d -= b;\n    var l = -c * g - d * h;\n    if (0 >= l || l >= k) return g = e - a, h = f - b, Math.min(c * c + d * d, g * g + h * h);\n    a = g * d - h * c;\n    return a * a / k;\n  }\n  function Db(a, b, c, d) {\n    a = c - a;\n    b = d - b;\n    return a * a + b * b;\n  }\n  function Eb(a, b, c, d) {\n    a = c - a;\n    b = d - b;\n    if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0;\n    if (0 === b) return 0 < a ? 0 : 180;\n    if (isNaN(a) || isNaN(b)) return 0;\n    d = 180 * Math.atan(Math.abs(b / a)) / Math.PI;\n    0 > a ? d = 0 > b ? d + 180 : 180 - d : 0 > b && (d = 360 - d);\n    return d;\n  }\n  t.u = function () {\n    return isFinite(this.x) && isFinite(this.y);\n  };\n  J.alloc = function () {\n    var a = Fb.pop();\n    return void 0 === a ? new J() : a;\n  };\n  J.allocAt = function (a, b) {\n    var c = Fb.pop();\n    if (void 0 === c) return new J(a, b);\n    c.x = a;\n    c.y = b;\n    return c;\n  };\n  J.free = function (a) {\n    Fb.push(a);\n  };\n  J.prototype.isReal = J.prototype.u;\n  J.prototype.setSpot = J.prototype.Lk;\n  J.prototype.setRectSpot = J.prototype.sj;\n  J.prototype.snapToGridPoint = J.prototype.XA;\n  J.prototype.snapToGrid = J.prototype.WA;\n  J.prototype.projectOntoLineSegmentPoint = J.prototype.LA;\n  J.prototype.projectOntoLineSegment = J.prototype.KA;\n  J.intersectingLineSegments = function (a, b, c, d, e, f, g, h) {\n    return K.Mq(a, b, c, d, e, f, g, h);\n  };\n  J.prototype.direction = J.prototype.direction;\n  J.prototype.directionPoint = J.prototype.Sa;\n  J.prototype.normalize = J.prototype.normalize;\n  J.prototype.distanceSquared = J.prototype.kd;\n  J.prototype.distanceSquaredPoint = J.prototype.Fe;\n  J.prototype.scale = J.prototype.scale;\n  J.prototype.rotate = J.prototype.rotate;\n  J.prototype.offset = J.prototype.offset;\n  J.prototype.subtract = J.prototype.ce;\n  J.prototype.add = J.prototype.add;\n  J.prototype.equalsApprox = J.prototype.Na;\n  J.prototype.equalTo = J.prototype.fj;\n  J.prototype.equals = J.prototype.w;\n  J.prototype.set = J.prototype.set;\n  J.prototype.setTo = J.prototype.Ig;\n  var Hb = null,\n    Ib = null,\n    Jb = null,\n    Kb = null,\n    Lb = null,\n    Fb = [];\n  J.className = \"Point\";\n  J.parse = vb;\n  J.stringify = wb;\n  J.distanceLineSegmentSquared = Cb;\n  J.distanceSquared = Db;\n  J.direction = Eb;\n  J.Origin = Hb = new J(0, 0).ca();\n  J.InfiniteTopLeft = Ib = new J(-Infinity, -Infinity).ca();\n  J.InfiniteBottomRight = Jb = new J(Infinity, Infinity).ca();\n  J.SixPoint = Kb = new J(6, 6).ca();\n  J.NoPoint = Lb = new J(NaN, NaN).ca();\n  J.parse = vb;\n  J.stringify = wb;\n  J.distanceLineSegmentSquared = Cb;\n  J.distanceSquared = Db;\n  J.direction = Eb;\n  function M(a, b) {\n    void 0 === a ? this.height = this.width = 0 : \"number\" === typeof a && (0 <= a || isNaN(a)) && \"number\" === typeof b && (0 <= b || isNaN(b)) ? (this.width = a, this.height = b) : B(\"Invalid arguments to Size constructor: \" + a + \", \" + b);\n    this.s = !1;\n  }\n  var Mb, Nb, Ob, Pb, Qb, Rb, Sb;\n  M.prototype.assign = function (a) {\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n  M.prototype.h = function (a, b) {\n    this.width = a;\n    this.height = b;\n    return this;\n  };\n  M.prototype.Ig = function (a, b) {\n    this.width = a;\n    this.height = b;\n    return this;\n  };\n  M.prototype.set = function (a) {\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n  M.prototype.copy = function () {\n    var a = new M();\n    a.width = this.width;\n    a.height = this.height;\n    return a;\n  };\n  t = M.prototype;\n  t.ca = function () {\n    this.s = !0;\n    Object.freeze(this);\n    return this;\n  };\n  t.G = function () {\n    return this.s || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    return this;\n  };\n  function Tb(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n      for (var b = 0, c = 0; \"\" === a[b];) b++;\n      var d = a[b++];\n      d && (c = parseFloat(d));\n      for (var e = 0; \"\" === a[b];) b++;\n      (d = a[b++]) && (e = parseFloat(d));\n      return new M(c, e);\n    }\n    return new M();\n  }\n  function Ub(a) {\n    return a.width.toString() + \" \" + a.height.toString();\n  }\n  t.toString = function () {\n    return \"Size(\" + this.width + \",\" + this.height + \")\";\n  };\n  t.w = function (a) {\n    return a instanceof M ? this.width === a.width && this.height === a.height : !1;\n  };\n  t.fj = function (a, b) {\n    return this.width === a && this.height === b;\n  };\n  t.Na = function (a) {\n    return K.A(this.width, a.width) && K.A(this.height, a.height);\n  };\n  t.u = function () {\n    return isFinite(this.width) && isFinite(this.height);\n  };\n  M.alloc = function () {\n    var a = Vb.pop();\n    return void 0 === a ? new M() : a;\n  };\n  M.free = function (a) {\n    Vb.push(a);\n  };\n  M.prototype.isReal = M.prototype.u;\n  M.prototype.equalsApprox = M.prototype.Na;\n  M.prototype.equalTo = M.prototype.fj;\n  M.prototype.equals = M.prototype.w;\n  M.prototype.set = M.prototype.set;\n  M.prototype.setTo = M.prototype.Ig;\n  var Vb = [];\n  M.className = \"Size\";\n  M.parse = Tb;\n  M.stringify = Ub;\n  M.ZeroSize = Mb = new M(0, 0).ca();\n  M.OneSize = Nb = new M(1, 1).ca();\n  M.SixSize = Ob = new M(6, 6).ca();\n  M.EightSize = Pb = new M(8, 8).ca();\n  M.TenSize = Qb = new M(10, 10).ca();\n  M.InfiniteSize = Rb = new M(Infinity, Infinity).ca();\n  M.NoSize = Sb = new M(NaN, NaN).ca();\n  M.parse = Tb;\n  M.stringify = Ub;\n  function N(a, b, c, d) {\n    void 0 === a ? this.height = this.width = this.y = this.x = 0 : a instanceof J ? (c = a.x, a = a.y, b instanceof J ? (d = b.x, b = b.y, this.x = Math.min(c, d), this.y = Math.min(a, b), this.width = Math.abs(c - d), this.height = Math.abs(a - b)) : b instanceof M ? (this.x = c, this.y = a, this.width = b.width, this.height = b.height) : B(\"Incorrect arguments supplied to Rect constructor\")) : \"number\" === typeof a && \"number\" === typeof b && \"number\" === typeof c && (0 <= c || isNaN(c)) && \"number\" === typeof d && (0 <= d || isNaN(d)) ? (this.x = a, this.y = b, this.width = c, this.height = d) : B(\"Invalid arguments to Rect constructor: \" + a + \", \" + b + \", \" + c + \", \" + d);\n    this.s = !1;\n  }\n  t = N.prototype;\n  t.assign = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n  t.h = function (a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.width = c;\n    this.height = d;\n    return this;\n  };\n  function Wb(a, b, c) {\n    a.width = b;\n    a.height = c;\n  }\n  t.Ig = function (a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.width = c;\n    this.height = d;\n    return this;\n  };\n  t.set = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n  t.od = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  };\n  t.VA = function (a) {\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n  N.prototype.copy = function () {\n    var a = new N();\n    a.x = this.x;\n    a.y = this.y;\n    a.width = this.width;\n    a.height = this.height;\n    return a;\n  };\n  t = N.prototype;\n  t.ca = function () {\n    this.s = !0;\n    Object.freeze(this);\n    return this;\n  };\n  t.G = function () {\n    return this.s || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    return this;\n  };\n  function Xb(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n      for (var b = 0, c = 0; \"\" === a[b];) b++;\n      var d = a[b++];\n      d && (c = parseFloat(d));\n      for (var e = 0; \"\" === a[b];) b++;\n      (d = a[b++]) && (e = parseFloat(d));\n      for (var f = 0; \"\" === a[b];) b++;\n      (d = a[b++]) && (f = parseFloat(d));\n      for (var g = 0; \"\" === a[b];) b++;\n      (d = a[b++]) && (g = parseFloat(d));\n      return new N(c, e, f, g);\n    }\n    return new N();\n  }\n  function Yb(a) {\n    return a.x.toString() + \" \" + a.y.toString() + \" \" + a.width.toString() + \" \" + a.height.toString();\n  }\n  t.toString = function () {\n    return \"Rect(\" + this.x + \",\" + this.y + \",\" + this.width + \",\" + this.height + \")\";\n  };\n  t.w = function (a) {\n    return a instanceof N ? this.x === a.x && this.y === a.y && this.width === a.width && this.height === a.height : !1;\n  };\n  t.fj = function (a, b, c, d) {\n    return this.x === a && this.y === b && this.width === c && this.height === d;\n  };\n  t.Na = function (a) {\n    return K.A(this.x, a.x) && K.A(this.y, a.y) && K.A(this.width, a.width) && K.A(this.height, a.height);\n  };\n  function ac(a, b) {\n    return K.$(a.x, b.x) && K.$(a.y, b.y) && K.$(a.width, b.width) && K.$(a.height, b.height);\n  }\n  t.aa = function (a) {\n    return this.x <= a.x && this.x + this.width >= a.x && this.y <= a.y && this.y + this.height >= a.y;\n  };\n  t.De = function (a) {\n    return this.x <= a.x && a.x + a.width <= this.x + this.width && this.y <= a.y && a.y + a.height <= this.y + this.height;\n  };\n  t.contains = function (a, b, c, d) {\n    void 0 === c && (c = 0);\n    void 0 === d && (d = 0);\n    return this.x <= a && a + c <= this.x + this.width && this.y <= b && b + d <= this.y + this.height;\n  };\n  t.offset = function (a, b) {\n    this.x += a;\n    this.y += b;\n    return this;\n  };\n  t.Ic = function (a, b) {\n    return bc(this, b, a, b, a);\n  };\n  t.sq = function (a) {\n    return bc(this, a.top, a.right, a.bottom, a.left);\n  };\n  t.Iw = function (a) {\n    return bc(this, -a.top, -a.right, -a.bottom, -a.left);\n  };\n  t.nA = function (a, b, c, d) {\n    return bc(this, a, b, c, d);\n  };\n  function bc(a, b, c, d, e) {\n    var f = a.width;\n    c + e <= -f ? (a.x += f / 2, a.width = 0) : (a.x -= e, a.width += c + e);\n    c = a.height;\n    b + d <= -c ? (a.y += c / 2, a.height = 0) : (a.y -= b, a.height += b + d);\n    return a;\n  }\n  t.sA = function (a) {\n    return cc(this, a.x, a.y, a.width, a.height);\n  };\n  t.aw = function (a, b, c, d) {\n    return cc(this, a, b, c, d);\n  };\n  function cc(a, b, c, d, e) {\n    var f = Math.max(a.x, b),\n      g = Math.max(a.y, c);\n    b = Math.min(a.x + a.width, b + d);\n    c = Math.min(a.y + a.height, c + e);\n    a.x = f;\n    a.y = g;\n    a.width = Math.max(0, b - f);\n    a.height = Math.max(0, c - g);\n    return a;\n  }\n  t.Lc = function (a) {\n    return this.bw(a.x, a.y, a.width, a.height);\n  };\n  t.bw = function (a, b, c, d) {\n    var e = this.width,\n      f = this.x;\n    if (Infinity !== e && Infinity !== c && (e += f, c += a, isNaN(c) || isNaN(e) || f > c || a > e)) return !1;\n    a = this.height;\n    c = this.y;\n    return Infinity !== a && Infinity !== d && (a += c, d += b, isNaN(d) || isNaN(a) || c > d || b > a) ? !1 : !0;\n  };\n  function dc(a, b) {\n    var c = a.width,\n      d = a.x,\n      e = b.x - 10;\n    if (d > b.width + 10 + 10 + e || e > c + d) return !1;\n    c = a.height;\n    a = a.y;\n    d = b.y - 10;\n    return a > b.height + 10 + 10 + d || d > c + a ? !1 : !0;\n  }\n  t.Me = function (a) {\n    return fc(this, a.x, a.y, 0, 0);\n  };\n  t.Oc = function (a) {\n    return fc(this, a.x, a.y, a.width, a.height);\n  };\n  t.Pw = function (a, b, c, d) {\n    void 0 === c && (c = 0);\n    void 0 === d && (d = 0);\n    return fc(this, a, b, c, d);\n  };\n  function fc(a, b, c, d, e) {\n    var f = Math.min(a.x, b),\n      g = Math.min(a.y, c);\n    b = Math.max(a.x + a.width, b + d);\n    c = Math.max(a.y + a.height, c + e);\n    a.x = f;\n    a.y = g;\n    a.width = b - f;\n    a.height = c - g;\n    return a;\n  }\n  t.Lk = function (a, b, c) {\n    this.x = a - c.offsetX - c.x * this.width;\n    this.y = b - c.offsetY - c.y * this.height;\n    return this;\n  };\n  function gc(a, b, c, d, e, f, g, h) {\n    void 0 === g && (g = 0);\n    void 0 === h && (h = 0);\n    return a <= e && e + g <= a + c && b <= f && f + h <= b + d;\n  }\n  function hc(a, b, c, d, e, f, g, h) {\n    return a > g + e || e > c + a ? !1 : b > h + f || f > d + b ? !1 : !0;\n  }\n  t.u = function () {\n    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);\n  };\n  t.uA = function () {\n    return 0 === this.width && 0 === this.height;\n  };\n  N.alloc = function () {\n    var a = ic.pop();\n    return void 0 === a ? new N() : a;\n  };\n  N.allocAt = function (a, b, c, d) {\n    var e = ic.pop();\n    return void 0 === e ? new N(a, b, c, d) : e.h(a, b, c, d);\n  };\n  N.free = function (a) {\n    ic.push(a);\n  };\n  ma.Object.defineProperties(N.prototype, {\n    left: {\n      get: function () {\n        return this.x;\n      },\n      set: function (a) {\n        this.x = a;\n      }\n    },\n    top: {\n      get: function () {\n        return this.y;\n      },\n      set: function (a) {\n        this.y = a;\n      }\n    },\n    right: {\n      get: function () {\n        return this.x + this.width;\n      },\n      set: function (a) {\n        this.x += a - (this.x + this.width);\n      }\n    },\n    bottom: {\n      get: function () {\n        return this.y + this.height;\n      },\n      set: function (a) {\n        this.y += a - (this.y + this.height);\n      }\n    },\n    position: {\n      get: function () {\n        return new J(this.x, this.y);\n      },\n      set: function (a) {\n        this.x = a.x;\n        this.y = a.y;\n      }\n    },\n    size: {\n      get: function () {\n        return new M(this.width, this.height);\n      },\n      set: function (a) {\n        this.width = a.width;\n        this.height = a.height;\n      }\n    },\n    center: {\n      get: function () {\n        return new J(this.x + this.width / 2, this.y + this.height / 2);\n      },\n      set: function (a) {\n        this.x = a.x - this.width / 2;\n        this.y = a.y - this.height / 2;\n      }\n    },\n    centerX: {\n      get: function () {\n        return this.x + this.width / 2;\n      },\n      set: function (a) {\n        this.x = a - this.width / 2;\n      }\n    },\n    centerY: {\n      get: function () {\n        return this.y + this.height / 2;\n      },\n      set: function (a) {\n        this.y = a - this.height / 2;\n      }\n    }\n  });\n  N.prototype.isEmpty = N.prototype.uA;\n  N.prototype.isReal = N.prototype.u;\n  N.intersectsLineSegment = function (a, b, c, d, e, f, g, h) {\n    return K.Ay(a, b, c, d, e, f, g, h);\n  };\n  N.prototype.setSpot = N.prototype.Lk;\n  N.prototype.union = N.prototype.Pw;\n  N.prototype.unionRect = N.prototype.Oc;\n  N.prototype.unionPoint = N.prototype.Me;\n  N.prototype.intersects = N.prototype.bw;\n  N.prototype.intersectsRect = N.prototype.Lc;\n  N.prototype.intersect = N.prototype.aw;\n  N.prototype.intersectRect = N.prototype.sA;\n  N.prototype.grow = N.prototype.nA;\n  N.prototype.subtractMargin = N.prototype.Iw;\n  N.prototype.addMargin = N.prototype.sq;\n  N.prototype.inflate = N.prototype.Ic;\n  N.prototype.offset = N.prototype.offset;\n  N.prototype.contains = N.prototype.contains;\n  N.prototype.containsRect = N.prototype.De;\n  N.prototype.containsPoint = N.prototype.aa;\n  N.prototype.equalsApprox = N.prototype.Na;\n  N.prototype.equalTo = N.prototype.fj;\n  N.prototype.equals = N.prototype.w;\n  N.prototype.setSize = N.prototype.VA;\n  N.prototype.setPoint = N.prototype.od;\n  N.prototype.set = N.prototype.set;\n  N.prototype.setTo = N.prototype.Ig;\n  var jc = null,\n    kc = null,\n    ic = [];\n  N.className = \"Rect\";\n  N.parse = Xb;\n  N.stringify = Yb;\n  N.contains = gc;\n  N.intersects = hc;\n  N.ZeroRect = jc = new N(0, 0, 0, 0).ca();\n  N.NoRect = kc = new N(NaN, NaN, NaN, NaN).ca();\n  N.parse = Xb;\n  N.stringify = Yb;\n  N.contains = gc;\n  N.intersects = hc;\n  function pc(a, b, c, d) {\n    void 0 === a ? this.left = this.bottom = this.right = this.top = 0 : void 0 === b ? this.left = this.bottom = this.right = this.top = a : void 0 === c ? (this.top = a, this.right = b, this.bottom = a, this.left = b) : void 0 !== d ? (this.top = a, this.right = b, this.bottom = c, this.left = d) : B(\"Invalid arguments to Margin constructor: \" + a + \", \" + b + \", \" + c + \", \" + d);\n    this.s = !1;\n  }\n  pc.prototype.assign = function (a) {\n    this.top = a.top;\n    this.right = a.right;\n    this.bottom = a.bottom;\n    this.left = a.left;\n    return this;\n  };\n  pc.prototype.Ig = function (a, b, c, d) {\n    this.top = a;\n    this.right = b;\n    this.bottom = c;\n    this.left = d;\n    return this;\n  };\n  pc.prototype.set = function (a) {\n    this.top = a.top;\n    this.right = a.right;\n    this.bottom = a.bottom;\n    this.left = a.left;\n    return this;\n  };\n  pc.prototype.copy = function () {\n    var a = new pc();\n    a.top = this.top;\n    a.right = this.right;\n    a.bottom = this.bottom;\n    a.left = this.left;\n    return a;\n  };\n  t = pc.prototype;\n  t.ca = function () {\n    this.s = !0;\n    Object.freeze(this);\n    return this;\n  };\n  t.G = function () {\n    return this.s || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    return this;\n  };\n  function qc(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n      for (var b = 0, c = NaN; \"\" === a[b];) b++;\n      var d = a[b++];\n      d && (c = parseFloat(d));\n      if (isNaN(c)) return new pc();\n      for (var e = NaN; \"\" === a[b];) b++;\n      (d = a[b++]) && (e = parseFloat(d));\n      if (isNaN(e)) return new pc(c);\n      for (var f = NaN; \"\" === a[b];) b++;\n      (d = a[b++]) && (f = parseFloat(d));\n      if (isNaN(f)) return new pc(c, e);\n      for (var g = NaN; \"\" === a[b];) b++;\n      (d = a[b++]) && (g = parseFloat(d));\n      return isNaN(g) ? new pc(c, e) : new pc(c, e, f, g);\n    }\n    return new pc();\n  }\n  function rc(a) {\n    return a.top.toString() + \" \" + a.right.toString() + \" \" + a.bottom.toString() + \" \" + a.left.toString();\n  }\n  t.toString = function () {\n    return \"Margin(\" + this.top + \",\" + this.right + \",\" + this.bottom + \",\" + this.left + \")\";\n  };\n  t.w = function (a) {\n    return a instanceof pc ? this.top === a.top && this.right === a.right && this.bottom === a.bottom && this.left === a.left : !1;\n  };\n  t.fj = function (a, b, c, d) {\n    return this.top === a && this.right === b && this.bottom === c && this.left === d;\n  };\n  t.Na = function (a) {\n    return K.A(this.top, a.top) && K.A(this.right, a.right) && K.A(this.bottom, a.bottom) && K.A(this.left, a.left);\n  };\n  t.u = function () {\n    return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left);\n  };\n  pc.alloc = function () {\n    var a = sc.pop();\n    return void 0 === a ? new pc() : a;\n  };\n  pc.free = function (a) {\n    sc.push(a);\n  };\n  pc.prototype.isReal = pc.prototype.u;\n  pc.prototype.equalsApprox = pc.prototype.Na;\n  pc.prototype.equalTo = pc.prototype.fj;\n  pc.prototype.equals = pc.prototype.w;\n  pc.prototype.set = pc.prototype.set;\n  pc.prototype.setTo = pc.prototype.Ig;\n  var tc = null,\n    uc = null,\n    sc = [];\n  pc.className = \"Margin\";\n  pc.parse = qc;\n  pc.stringify = rc;\n  pc.ZeroMargin = tc = new pc(0, 0, 0, 0).ca();\n  pc.TwoMargin = uc = new pc(2, 2, 2, 2).ca();\n  pc.parse = qc;\n  pc.stringify = rc;\n  function P(a, b, c, d) {\n    void 0 === a ? this.offsetY = this.offsetX = this.y = this.x = 0 : (void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.x = a, this.y = b, this.offsetX = c, this.offsetY = d);\n    this.s = !1;\n  }\n  var vc, wc, yc, zc, Ac, Bc, Cc, Dc, Gc, Hc, Ic, Jc, Kc, Lc, Mc, Nc, Oc, Qc, Rc, Sc, Tc, Uc, Vc, Wc, $c, ad, bd, cd, dd, ed, fd, gd, hd, id, jd, kd;\n  P.prototype.assign = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.offsetX = a.offsetX;\n    this.offsetY = a.offsetY;\n    return this;\n  };\n  P.prototype.Ig = function (a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.offsetX = c;\n    this.offsetY = d;\n    return this;\n  };\n  P.prototype.set = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.offsetX = a.offsetX;\n    this.offsetY = a.offsetY;\n    return this;\n  };\n  P.prototype.copy = function () {\n    var a = new P();\n    a.x = this.x;\n    a.y = this.y;\n    a.offsetX = this.offsetX;\n    a.offsetY = this.offsetY;\n    return a;\n  };\n  t = P.prototype;\n  t.ca = function () {\n    this.s = !0;\n    Object.freeze(this);\n    return this;\n  };\n  t.G = function () {\n    return this.s || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    return this;\n  };\n  function ld(a, b) {\n    a.x = NaN;\n    a.y = NaN;\n    a.offsetX = b;\n    return a;\n  }\n  function md(a) {\n    if (\"string\" === typeof a) {\n      a = a.trim();\n      if (\"None\" === a) return vc;\n      if (\"TopLeft\" === a) return wc;\n      if (\"Top\" === a || \"TopCenter\" === a || \"MiddleTop\" === a) return yc;\n      if (\"TopRight\" === a) return zc;\n      if (\"Left\" === a || \"LeftCenter\" === a || \"MiddleLeft\" === a) return Ac;\n      if (\"Center\" === a) return Bc;\n      if (\"Right\" === a || \"RightCenter\" === a || \"MiddleRight\" === a) return Cc;\n      if (\"BottomLeft\" === a) return Dc;\n      if (\"Bottom\" === a || \"BottomCenter\" === a || \"MiddleBottom\" === a) return Gc;\n      if (\"BottomRight\" === a) return Hc;\n      if (\"TopSide\" === a) return Ic;\n      if (\"LeftSide\" === a) return Jc;\n      if (\"RightSide\" === a) return Kc;\n      if (\"BottomSide\" === a) return Lc;\n      if (\"TopBottomSides\" === a) return Mc;\n      if (\"LeftRightSides\" === a) return Nc;\n      if (\"TopLeftSides\" === a) return Oc;\n      if (\"TopRightSides\" === a) return Qc;\n      if (\"BottomLeftSides\" === a) return Rc;\n      if (\"BottomRightSides\" === a) return Sc;\n      if (\"NotTopSide\" === a) return Tc;\n      if (\"NotLeftSide\" === a) return Uc;\n      if (\"NotRightSide\" === a) return Vc;\n      if (\"NotBottomSide\" === a) return Wc;\n      if (\"AllSides\" === a) return $c;\n      if (\"Default\" === a) return ad;\n      a = a.split(\" \");\n      for (var b = 0, c = 0; \"\" === a[b];) b++;\n      var d = a[b++];\n      void 0 !== d && 0 < d.length && (c = parseFloat(d));\n      for (var e = 0; \"\" === a[b];) b++;\n      d = a[b++];\n      void 0 !== d && 0 < d.length && (e = parseFloat(d));\n      for (var f = 0; \"\" === a[b];) b++;\n      d = a[b++];\n      void 0 !== d && 0 < d.length && (f = parseFloat(d));\n      for (var g = 0; \"\" === a[b];) b++;\n      d = a[b++];\n      void 0 !== d && 0 < d.length && (g = parseFloat(d));\n      return new P(c, e, f, g);\n    }\n    return new P();\n  }\n  function nd(a) {\n    return a.ib() ? a.x.toString() + \" \" + a.y.toString() + \" \" + a.offsetX.toString() + \" \" + a.offsetY.toString() : a.toString();\n  }\n  t.toString = function () {\n    return this.ib() ? 0 === this.offsetX && 0 === this.offsetY ? \"Spot(\" + this.x + \",\" + this.y + \")\" : \"Spot(\" + this.x + \",\" + this.y + \",\" + this.offsetX + \",\" + this.offsetY + \")\" : this.w(vc) ? \"None\" : this.w(wc) ? \"TopLeft\" : this.w(yc) ? \"Top\" : this.w(zc) ? \"TopRight\" : this.w(Ac) ? \"Left\" : this.w(Bc) ? \"Center\" : this.w(Cc) ? \"Right\" : this.w(Dc) ? \"BottomLeft\" : this.w(Gc) ? \"Bottom\" : this.w(Hc) ? \"BottomRight\" : this.w(Ic) ? \"TopSide\" : this.w(Jc) ? \"LeftSide\" : this.w(Kc) ? \"RightSide\" : this.w(Lc) ? \"BottomSide\" : this.w(Mc) ? \"TopBottomSides\" : this.w(Nc) ? \"LeftRightSides\" : this.w(Oc) ? \"TopLeftSides\" : this.w(Qc) ? \"TopRightSides\" : this.w(Rc) ? \"BottomLeftSides\" : this.w(Sc) ? \"BottomRightSides\" : this.w(Tc) ? \"NotTopSide\" : this.w(Uc) ? \"NotLeftSide\" : this.w(Vc) ? \"NotRightSide\" : this.w(Wc) ? \"NotBottomSide\" : this.w($c) ? \"AllSides\" : this.w(ad) ? \"Default\" : \"None\";\n  };\n  t.w = function (a) {\n    return a instanceof P ? (this.x === a.x || isNaN(this.x) && isNaN(a.x)) && (this.y === a.y || isNaN(this.y) && isNaN(a.y)) && this.offsetX === a.offsetX && this.offsetY === a.offsetY : !1;\n  };\n  t.kw = function () {\n    return new P(.5 - (this.x - .5), .5 - (this.y - .5), -this.offsetX, -this.offsetY);\n  };\n  t.Df = function (a) {\n    if (!this.Mc()) return !1;\n    if (!a.Mc()) if (a.w(bd)) a = Jc;else if (a.w(cd)) a = Kc;else if (a.w(dd)) a = Ic;else if (a.w(ed)) a = Lc;else return !1;\n    a = a.offsetY;\n    return (this.offsetY & a) === a;\n  };\n  t.ib = function () {\n    return !isNaN(this.x) && !isNaN(this.y);\n  };\n  t.mc = function () {\n    return isNaN(this.x) || isNaN(this.y);\n  };\n  t.Mc = function () {\n    return isNaN(this.x) && isNaN(this.y) && 1 === this.offsetX && 0 !== this.offsetY;\n  };\n  t.Vt = function () {\n    return isNaN(this.x) && isNaN(this.y) && 0 === this.offsetX && 0 === this.offsetY;\n  };\n  t.Mb = function () {\n    return isNaN(this.x) && isNaN(this.y) && -1 === this.offsetX && 0 === this.offsetY;\n  };\n  P.alloc = function () {\n    var a = qd.pop();\n    return void 0 === a ? new P() : a;\n  };\n  P.free = function (a) {\n    qd.push(a);\n  };\n  P.prototype.isDefault = P.prototype.Mb;\n  P.prototype.isNone = P.prototype.Vt;\n  P.prototype.isSide = P.prototype.Mc;\n  P.prototype.isNoSpot = P.prototype.mc;\n  P.prototype.isSpot = P.prototype.ib;\n  P.prototype.includesSide = P.prototype.Df;\n  P.prototype.opposite = P.prototype.kw;\n  P.prototype.equals = P.prototype.w;\n  P.prototype.set = P.prototype.set;\n  P.prototype.setTo = P.prototype.Ig;\n  var qd = [];\n  P.className = \"Spot\";\n  P.parse = md;\n  P.stringify = nd;\n  P.None = vc = ld(new P(0, 0, 0, 0), 0).ca();\n  P.Default = ad = ld(new P(0, 0, -1, 0), -1).ca();\n  P.TopLeft = wc = new P(0, 0, 0, 0).ca();\n  P.TopCenter = yc = new P(.5, 0, 0, 0).ca();\n  P.TopRight = zc = new P(1, 0, 0, 0).ca();\n  P.LeftCenter = Ac = new P(0, .5, 0, 0).ca();\n  P.Center = Bc = new P(.5, .5, 0, 0).ca();\n  P.RightCenter = Cc = new P(1, .5, 0, 0).ca();\n  P.BottomLeft = Dc = new P(0, 1, 0, 0).ca();\n  P.BottomCenter = Gc = new P(.5, 1, 0, 0).ca();\n  P.BottomRight = Hc = new P(1, 1, 0, 0).ca();\n  P.MiddleTop = fd = yc;\n  P.MiddleLeft = gd = Ac;\n  P.MiddleRight = hd = Cc;\n  P.MiddleBottom = id = Gc;\n  P.Top = dd = yc;\n  P.Left = bd = Ac;\n  P.Right = cd = Cc;\n  P.Bottom = ed = Gc;\n  P.TopSide = Ic = ld(new P(0, 0, 1, 1), 1).ca();\n  P.LeftSide = Jc = ld(new P(0, 0, 1, 2), 1).ca();\n  P.RightSide = Kc = ld(new P(0, 0, 1, 4), 1).ca();\n  P.BottomSide = Lc = ld(new P(0, 0, 1, 8), 1).ca();\n  P.TopBottomSides = Mc = ld(new P(0, 0, 1, 9), 1).ca();\n  P.LeftRightSides = Nc = ld(new P(0, 0, 1, 6), 1).ca();\n  P.TopLeftSides = Oc = ld(new P(0, 0, 1, 3), 1).ca();\n  P.TopRightSides = Qc = ld(new P(0, 0, 1, 5), 1).ca();\n  P.BottomLeftSides = Rc = ld(new P(0, 0, 1, 10), 1).ca();\n  P.BottomRightSides = Sc = ld(new P(0, 0, 1, 12), 1).ca();\n  P.NotTopSide = Tc = ld(new P(0, 0, 1, 14), 1).ca();\n  P.NotLeftSide = Uc = ld(new P(0, 0, 1, 13), 1).ca();\n  P.NotRightSide = Vc = ld(new P(0, 0, 1, 11), 1).ca();\n  P.NotBottomSide = Wc = ld(new P(0, 0, 1, 7), 1).ca();\n  P.AllSides = $c = ld(new P(0, 0, 1, 15), 1).ca();\n  jd = new P(.156, .156).ca();\n  kd = new P(.844, .844).ca();\n  P.parse = md;\n  P.stringify = nd;\n  function rd() {\n    this.m11 = 1;\n    this.m21 = this.m12 = 0;\n    this.m22 = 1;\n    this.dy = this.dx = 0;\n  }\n  rd.prototype.set = function (a) {\n    this.m11 = a.m11;\n    this.m12 = a.m12;\n    this.m21 = a.m21;\n    this.m22 = a.m22;\n    this.dx = a.dx;\n    this.dy = a.dy;\n    return this;\n  };\n  rd.prototype.copy = function () {\n    var a = new rd();\n    a.m11 = this.m11;\n    a.m12 = this.m12;\n    a.m21 = this.m21;\n    a.m22 = this.m22;\n    a.dx = this.dx;\n    a.dy = this.dy;\n    return a;\n  };\n  t = rd.prototype;\n  t.toString = function () {\n    return \"Transform(\" + this.m11 + \",\" + this.m12 + \",\" + this.m21 + \",\" + this.m22 + \",\" + this.dx + \",\" + this.dy + \")\";\n  };\n  t.w = function (a) {\n    return this.m11 === a.m11 && this.m12 === a.m12 && this.m21 === a.m21 && this.m22 === a.m22 && this.dx === a.dx && this.dy === a.dy;\n  };\n  t.Tt = function () {\n    return 0 === this.dx && 0 === this.dy && 1 === this.m11 && 0 === this.m12 && 0 === this.m21 && 1 === this.m22;\n  };\n  t.reset = function () {\n    this.m11 = 1;\n    this.m21 = this.m12 = 0;\n    this.m22 = 1;\n    this.dy = this.dx = 0;\n    return this;\n  };\n  t.multiply = function (a) {\n    var b = this.m11 * a.m11 + this.m21 * a.m12,\n      c = this.m12 * a.m11 + this.m22 * a.m12,\n      d = this.m11 * a.m21 + this.m21 * a.m22,\n      e = this.m12 * a.m21 + this.m22 * a.m22;\n    this.dx = this.m11 * a.dx + this.m21 * a.dy + this.dx;\n    this.dy = this.m12 * a.dx + this.m22 * a.dy + this.dy;\n    this.m11 = b;\n    this.m12 = c;\n    this.m21 = d;\n    this.m22 = e;\n    return this;\n  };\n  t.iw = function (a) {\n    var b = 1 / (a.m11 * a.m22 - a.m12 * a.m21),\n      c = a.m22 * b,\n      d = -a.m12 * b,\n      e = -a.m21 * b,\n      f = a.m11 * b,\n      g = b * (a.m21 * a.dy - a.m22 * a.dx);\n    a = b * (a.m12 * a.dx - a.m11 * a.dy);\n    b = this.m11 * c + this.m21 * d;\n    c = this.m12 * c + this.m22 * d;\n    d = this.m11 * e + this.m21 * f;\n    e = this.m12 * e + this.m22 * f;\n    this.dx = this.m11 * g + this.m21 * a + this.dx;\n    this.dy = this.m12 * g + this.m22 * a + this.dy;\n    this.m11 = b;\n    this.m12 = c;\n    this.m21 = d;\n    this.m22 = e;\n    return this;\n  };\n  t.St = function () {\n    var a = 1 / (this.m11 * this.m22 - this.m12 * this.m21),\n      b = -this.m12 * a,\n      c = -this.m21 * a,\n      d = this.m11 * a,\n      e = a * (this.m21 * this.dy - this.m22 * this.dx),\n      f = a * (this.m12 * this.dx - this.m11 * this.dy);\n    this.m11 = this.m22 * a;\n    this.m12 = b;\n    this.m21 = c;\n    this.m22 = d;\n    this.dx = e;\n    this.dy = f;\n    return this;\n  };\n  rd.prototype.rotate = function (a, b, c) {\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    if (0 === a) return this;\n    this.translate(b, c);\n    if (90 === a) {\n      a = 0;\n      var d = 1;\n    } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d));\n    var e = this.m12 * a + this.m22 * d,\n      f = this.m11 * -d + this.m21 * a,\n      g = this.m12 * -d + this.m22 * a;\n    this.m11 = this.m11 * a + this.m21 * d;\n    this.m12 = e;\n    this.m21 = f;\n    this.m22 = g;\n    this.translate(-b, -c);\n    return this;\n  };\n  t = rd.prototype;\n  t.translate = function (a, b) {\n    this.dx += this.m11 * a + this.m21 * b;\n    this.dy += this.m12 * a + this.m22 * b;\n    return this;\n  };\n  t.scale = function (a, b) {\n    void 0 === b && (b = a);\n    this.m11 *= a;\n    this.m12 *= a;\n    this.m21 *= b;\n    this.m22 *= b;\n    return this;\n  };\n  t.sa = function (a) {\n    var b = a.x,\n      c = a.y;\n    return a.h(b * this.m11 + c * this.m21 + this.dx, b * this.m12 + c * this.m22 + this.dy);\n  };\n  t.Zd = function (a) {\n    var b = 1 / (this.m11 * this.m22 - this.m12 * this.m21),\n      c = a.x,\n      d = a.y;\n    return a.h(c * this.m22 * b + d * -this.m21 * b + b * (this.m21 * this.dy - this.m22 * this.dx), c * -this.m12 * b + d * this.m11 * b + b * (this.m12 * this.dx - this.m11 * this.dy));\n  };\n  t.Ow = function (a) {\n    var b = a.x,\n      c = a.y,\n      d = b + a.width,\n      e = c + a.height,\n      f = this.m11,\n      g = this.m12,\n      h = this.m21,\n      k = this.m22,\n      l = this.dx,\n      m = this.dy,\n      n = b * f + c * h + l,\n      p = b * g + c * k + m,\n      r = d * f + c * h + l,\n      q = d * g + c * k + m;\n    c = b * f + e * h + l;\n    b = b * g + e * k + m;\n    f = d * f + e * h + l;\n    d = d * g + e * k + m;\n    e = Math.min(n, r);\n    n = Math.max(n, r);\n    r = Math.min(p, q);\n    p = Math.max(p, q);\n    e = Math.min(e, c);\n    n = Math.max(n, c);\n    r = Math.min(r, b);\n    p = Math.max(p, b);\n    e = Math.min(e, f);\n    n = Math.max(n, f);\n    r = Math.min(r, d);\n    p = Math.max(p, d);\n    a.h(e, r, n - e, p - r);\n    return a;\n  };\n  rd.alloc = function () {\n    var a = sd.pop();\n    return void 0 === a ? new rd() : a;\n  };\n  rd.free = function (a) {\n    sd.push(a);\n  };\n  rd.prototype.transformRect = rd.prototype.Ow;\n  rd.prototype.invertedTransformPoint = rd.prototype.Zd;\n  rd.prototype.transformPoint = rd.prototype.sa;\n  rd.prototype.scale = rd.prototype.scale;\n  rd.prototype.translate = rd.prototype.translate;\n  rd.prototype.rotate = rd.prototype.rotate;\n  rd.prototype.invert = rd.prototype.St;\n  rd.prototype.multiplyInverted = rd.prototype.iw;\n  rd.prototype.multiply = rd.prototype.multiply;\n  rd.prototype.reset = rd.prototype.reset;\n  rd.prototype.isIdentity = rd.prototype.Tt;\n  rd.prototype.equals = rd.prototype.w;\n  rd.prototype.set = rd.prototype.set;\n  var sd = [];\n  rd.className = \"Transform\";\n  rd.xF = \"54a702f3e53909c447824c6706603faf4c\";\n  var K = {\n    eB: \"7da71ca0ad381e90\",\n    Kg: (Math.sqrt(2) - 1) / 3 * 4,\n    hx: null,\n    sqrt: function (a) {\n      if (0 >= a) return 0;\n      var b = K.hx;\n      if (null === b) {\n        b = [];\n        for (var c = 0; 2E3 >= c; c++) b[c] = Math.sqrt(c);\n        K.hx = b;\n      }\n      return 1 > a ? (c = 1 / a, 2E3 >= c ? 1 / b[c | 0] : Math.sqrt(a)) : 2E3 >= a ? b[a | 0] : Math.sqrt(a);\n    },\n    A: function (a, b) {\n      a -= b;\n      return .5 > a && -.5 < a;\n    },\n    $: function (a, b) {\n      a -= b;\n      return 5E-8 > a && -5E-8 < a;\n    },\n    Nb: function (a, b, c, d, e, f, g) {\n      0 >= e && (e = 1E-6);\n      if (a < c) {\n        var h = a;\n        var k = c;\n      } else h = c, k = a;\n      if (b < d) {\n        var l = b;\n        var m = d;\n      } else l = d, m = b;\n      if (a === c) return l <= g && g <= m && a - e <= f && f <= a + e;\n      if (b === d) return h <= f && f <= k && b - e <= g && g <= b + e;\n      k += e;\n      h -= e;\n      if (h <= f && f <= k && (m += e, l -= e, l <= g && g <= m)) if (k - h > m - l) {\n        if (a - c > e || c - a > e) {\n          if (f = (d - b) / (c - a) * (f - a) + b, f - e <= g && g <= f + e) return !0;\n        } else return !0;\n      } else if (b - d > e || d - b > e) {\n        if (g = (c - a) / (d - b) * (g - b) + a, g - e <= f && f <= g + e) return !0;\n      } else return !0;\n      return !1;\n    },\n    yt: function (a, b, c, d, e, f, g, h, k, l, m, n) {\n      if (K.Nb(a, b, g, h, n, c, d) && K.Nb(a, b, g, h, n, e, f)) return K.Nb(a, b, g, h, n, l, m);\n      var p = (a + c) / 2,\n        r = (b + d) / 2,\n        q = (c + e) / 2,\n        u = (d + f) / 2;\n      e = (e + g) / 2;\n      f = (f + h) / 2;\n      d = (p + q) / 2;\n      c = (r + u) / 2;\n      q = (q + e) / 2;\n      u = (u + f) / 2;\n      var v = (d + q) / 2,\n        w = (c + u) / 2;\n      return K.yt(a, b, p, r, d, c, v, w, k, l, m, n) || K.yt(v, w, q, u, e, f, g, h, k, l, m, n);\n    },\n    sz: function (a, b, c, d, e, f, g, h, k) {\n      var l = (c + e) / 2,\n        m = (d + f) / 2;\n      k.h((((a + c) / 2 + l) / 2 + (l + (e + g) / 2) / 2) / 2, (((b + d) / 2 + m) / 2 + (m + (f + h) / 2) / 2) / 2);\n      return k;\n    },\n    rz: function (a, b, c, d, e, f, g, h) {\n      var k = (c + e) / 2,\n        l = (d + f) / 2;\n      return Eb(((a + c) / 2 + k) / 2, ((b + d) / 2 + l) / 2, (k + (e + g) / 2) / 2, (l + (f + h) / 2) / 2);\n    },\n    pm: function (a, b, c, d, e, f, g, h, k, l) {\n      if (K.Nb(a, b, g, h, k, c, d) && K.Nb(a, b, g, h, k, e, f)) fc(l, a, b, 0, 0), fc(l, g, h, 0, 0);else {\n        var m = (a + c) / 2,\n          n = (b + d) / 2,\n          p = (c + e) / 2,\n          r = (d + f) / 2;\n        e = (e + g) / 2;\n        f = (f + h) / 2;\n        d = (m + p) / 2;\n        c = (n + r) / 2;\n        p = (p + e) / 2;\n        r = (r + f) / 2;\n        var q = (d + p) / 2,\n          u = (c + r) / 2;\n        K.pm(a, b, m, n, d, c, q, u, k, l);\n        K.pm(q, u, p, r, e, f, g, h, k, l);\n      }\n      return l;\n    },\n    Ce: function (a, b, c, d, e, f, g, h, k, l) {\n      if (K.Nb(a, b, g, h, k, c, d) && K.Nb(a, b, g, h, k, e, f)) 0 === l.length && (l.push(a), l.push(b)), l.push(g), l.push(h);else {\n        var m = (a + c) / 2,\n          n = (b + d) / 2,\n          p = (c + e) / 2,\n          r = (d + f) / 2;\n        e = (e + g) / 2;\n        f = (f + h) / 2;\n        d = (m + p) / 2;\n        c = (n + r) / 2;\n        p = (p + e) / 2;\n        r = (r + f) / 2;\n        var q = (d + p) / 2,\n          u = (c + r) / 2;\n        K.Ce(a, b, m, n, d, c, q, u, k, l);\n        K.Ce(q, u, p, r, e, f, g, h, k, l);\n      }\n      return l;\n    },\n    nw: function (a, b, c, d, e, f, g, h, k, l) {\n      if (K.Nb(a, b, e, f, l, c, d)) return K.Nb(a, b, e, f, l, h, k);\n      var m = (a + c) / 2,\n        n = (b + d) / 2;\n      c = (c + e) / 2;\n      d = (d + f) / 2;\n      var p = (m + c) / 2,\n        r = (n + d) / 2;\n      return K.nw(a, b, m, n, p, r, g, h, k, l) || K.nw(p, r, c, d, e, f, g, h, k, l);\n    },\n    tB: function (a, b, c, d, e, f, g) {\n      g.h(((a + c) / 2 + (c + e) / 2) / 2, ((b + d) / 2 + (d + f) / 2) / 2);\n      return g;\n    },\n    mw: function (a, b, c, d, e, f, g, h) {\n      if (K.Nb(a, b, e, f, g, c, d)) fc(h, a, b, 0, 0), fc(h, e, f, 0, 0);else {\n        var k = (a + c) / 2,\n          l = (b + d) / 2;\n        c = (c + e) / 2;\n        d = (d + f) / 2;\n        var m = (k + c) / 2,\n          n = (l + d) / 2;\n        K.mw(a, b, k, l, m, n, g, h);\n        K.mw(m, n, c, d, e, f, g, h);\n      }\n      return h;\n    },\n    Wq: function (a, b, c, d, e, f, g, h) {\n      if (K.Nb(a, b, e, f, g, c, d)) 0 === h.length && (h.push(a), h.push(b)), h.push(e), h.push(f);else {\n        var k = (a + c) / 2,\n          l = (b + d) / 2;\n        c = (c + e) / 2;\n        d = (d + f) / 2;\n        var m = (k + c) / 2,\n          n = (l + d) / 2;\n        K.Wq(a, b, k, l, m, n, g, h);\n        K.Wq(m, n, c, d, e, f, g, h);\n      }\n      return h;\n    },\n    uq: function (a, b, c, d, e, f, g, h, k, l, m, n, p, r) {\n      if (K.Nb(a, b, g, h, p, c, d) && K.Nb(a, b, g, h, p, e, f)) {\n        if (a < k && g < k && a < m && g < m || a > k && g > k && a > m && g > m || b < l && h < l && b < n && h < n || b > l && h > l && b > n && h > n) return !1;\n        var q = (a - g) * (l - n) - (b - h) * (k - m);\n        if (0 === q) return !1;\n        p = ((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / q;\n        q = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / q;\n        if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) {\n          if (b < h ? g = b : (g = h, h = b), 1E-5 + q < g || q > h + 1E-5) return !1;\n        } else if (a < g ? h = a : (h = g, g = a), 1E-5 + p < h || p > g + 1E-5) return !1;\n        r.h(p, q);\n        return !0;\n      }\n      q = (a + c) / 2;\n      var u = (b + d) / 2,\n        v = (c + e) / 2,\n        w = (d + f) / 2;\n      e = (e + g) / 2;\n      f = (f + h) / 2;\n      d = (q + v) / 2;\n      c = (u + w) / 2;\n      v = (v + e) / 2;\n      w = (w + f) / 2;\n      var y = (d + v) / 2,\n        z = (c + w) / 2,\n        A = (m - k) * (m - k) + (n - l) * (n - l),\n        C = !1,\n        G = 0,\n        L = 0;\n      K.uq(a, b, q, u, d, c, y, z, k, l, m, n, p, r) && (a = (r.x - k) * (r.x - k) + (r.y - l) * (r.y - l), a < A && (A = a, C = !0, G = r.x, L = r.y));\n      K.uq(y, z, v, w, e, f, g, h, k, l, m, n, p, r) && (r.x - k) * (r.x - k) + (r.y - l) * (r.y - l) < A && (C = !0, G = r.x, L = r.y);\n      C && (r.x = G, r.y = L);\n      return C;\n    },\n    vq: function (a, b, c, d, e, f, g, h, k, l, m, n, p) {\n      var r = 0;\n      if (K.Nb(a, b, g, h, p, c, d) && K.Nb(a, b, g, h, p, e, f)) {\n        p = (a - g) * (l - n) - (b - h) * (k - m);\n        if (0 === p) return r;\n        var q = ((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / p,\n          u = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / p;\n        if (q >= m) return r;\n        if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) {\n          if (b < h ? (a = b, b = h) : a = h, u < a || u > b) return r;\n        } else if (a < g ? (b = a, a = g) : b = g, q < b || q > a) return r;\n        0 < p ? r++ : 0 > p && r--;\n      } else {\n        q = (a + c) / 2;\n        u = (b + d) / 2;\n        var v = (c + e) / 2,\n          w = (d + f) / 2;\n        e = (e + g) / 2;\n        f = (f + h) / 2;\n        d = (q + v) / 2;\n        c = (u + w) / 2;\n        v = (v + e) / 2;\n        w = (w + f) / 2;\n        var y = (d + v) / 2,\n          z = (c + w) / 2;\n        r += K.vq(a, b, q, u, d, c, y, z, k, l, m, n, p);\n        r += K.vq(y, z, v, w, e, f, g, h, k, l, m, n, p);\n      }\n      return r;\n    },\n    Qh: function (a, b, c, d, e, f, g) {\n      if (K.$(a, c)) {\n        b < d ? (c = b, b = d) : c = d;\n        if (f < c) return g.h(a, c), !1;\n        if (f > b) return g.h(a, b), !1;\n        g.h(a, f);\n        return !0;\n      }\n      if (K.$(b, d)) {\n        a < c ? (d = a, a = c) : d = c;\n        if (e < d) return g.h(d, b), !1;\n        if (e > a) return g.h(a, b), !1;\n        g.h(e, b);\n        return !0;\n      }\n      e = ((a - e) * (a - c) + (b - f) * (b - d)) / ((c - a) * (c - a) + (d - b) * (d - b));\n      if (-5E-6 > e) return g.h(a, b), !1;\n      if (1.000005 < e) return g.h(c, d), !1;\n      g.h(a + e * (c - a), b + e * (d - b));\n      return !0;\n    },\n    Ie: function (a, b, c, d, e, f, g, h, k) {\n      if (K.A(a, c) && K.A(b, d)) return k.h(a, b), !1;\n      if (K.$(e, g)) return K.$(a, c) ? (K.Qh(a, b, c, d, e, f, k), !1) : K.Qh(a, b, c, d, e, (d - b) / (c - a) * (e - a) + b, k);\n      h = (h - f) / (g - e);\n      if (K.$(a, c)) {\n        c = h * (a - e) + f;\n        b < d ? (e = b, b = d) : e = d;\n        if (c < e) return k.h(a, e), !1;\n        if (c > b) return k.h(a, b), !1;\n        k.h(a, c);\n        return !0;\n      }\n      g = (d - b) / (c - a);\n      if (K.$(h, g)) return K.Qh(a, b, c, d, e, f, k), !1;\n      e = (g * a - h * e + f - b) / (g - h);\n      if (K.$(g, 0)) {\n        a < c ? (d = a, a = c) : d = c;\n        if (e < d) return k.h(d, b), !1;\n        if (e > a) return k.h(a, b), !1;\n        k.h(e, b);\n        return !0;\n      }\n      return K.Qh(a, b, c, d, e, g * (e - a) + b, k);\n    },\n    rB: function (a, b, c, d, e) {\n      return K.Ie(c.x, c.y, d.x, d.y, a.x, a.y, b.x, b.y, e);\n    },\n    pB: function (a, b, c, d, e, f, g, h, k, l) {\n      function m(c, d) {\n        var e = (c - a) * (c - a) + (d - b) * (d - b);\n        e < n && (n = e, k.h(c, d));\n      }\n      var n = Infinity;\n      m(k.x, k.y);\n      var p = 0,\n        r = 0,\n        q = 0,\n        u = 0;\n      e < g ? (p = e, r = g) : (p = g, r = e);\n      f < h ? (q = e, u = g) : (q = g, u = e);\n      p = (r - p) / 2 + l;\n      l = (u - q) / 2 + l;\n      e = (e + g) / 2;\n      f = (f + h) / 2;\n      if (0 === p || 0 === l) return k;\n      if (.5 > (c > a ? c - a : a - c)) {\n        p = 1 - (c - e) * (c - e) / (p * p);\n        if (0 > p) return k;\n        p = Math.sqrt(p);\n        d = -l * p + f;\n        m(c, l * p + f);\n        m(c, d);\n      } else {\n        c = (d - b) / (c - a);\n        d = 1 / (p * p) + c * c / (l * l);\n        h = 2 * c * (b - c * a) / (l * l) - 2 * c * f / (l * l) - 2 * e / (p * p);\n        p = h * h - 4 * d * (2 * c * a * f / (l * l) - 2 * b * f / (l * l) + f * f / (l * l) + e * e / (p * p) - 1 + (b - c * a) * (b - c * a) / (l * l));\n        if (0 > p) return k;\n        p = Math.sqrt(p);\n        l = (-h + p) / (2 * d);\n        m(l, c * l - c * a + b);\n        p = (-h - p) / (2 * d);\n        m(p, c * p - c * a + b);\n      }\n      return k;\n    },\n    bd: function (a, b, c, d, e, f, g, h, k) {\n      var l = 1E21,\n        m = a,\n        n = b;\n      if (K.Ie(a, b, a, d, e, f, g, h, k)) {\n        var p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f);\n        p < l && (l = p, m = k.x, n = k.y);\n      }\n      K.Ie(c, b, c, d, e, f, g, h, k) && (p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), p < l && (l = p, m = k.x, n = k.y));\n      K.Ie(a, b, c, b, e, f, g, h, k) && (b = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), b < l && (l = b, m = k.x, n = k.y));\n      K.Ie(a, d, c, d, e, f, g, h, k) && (a = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), a < l && (l = a, m = k.x, n = k.y));\n      k.h(m, n);\n      return 1E21 > l;\n    },\n    oB: function (a, b, c, d, e, f, g, h, k) {\n      c = a - c;\n      g = e - g;\n      0 === c || 0 === g ? 0 === c ? (b = (f - h) / g, h = a, e = b * h + (f - b * e)) : (f = (b - d) / c, h = e, e = f * h + (b - f * a)) : (d = (b - d) / c, h = (f - h) / g, a = b - d * a, h = (f - h * e - a) / (d - h), e = d * h + a);\n      k.h(h, e);\n      return k;\n    },\n    Qt: function (a, b, c) {\n      return K.Ay(a.x, a.y, a.width, a.height, b.x, b.y, c.x, c.y);\n    },\n    Ay: function (a, b, c, d, e, f, g, h) {\n      var k = a + c,\n        l = b + d;\n      return e === g ? (f < h ? (g = f, f = h) : g = h, a <= e && e <= k && g <= l && f >= b) : f === h ? (e < g ? (h = e, e = g) : h = g, b <= f && f <= l && h <= k && e >= a) : gc(a, b, c, d, e, f) || gc(a, b, c, d, g, h) || K.Mq(a, b, k, b, e, f, g, h) || K.Mq(k, b, k, l, e, f, g, h) || K.Mq(k, l, a, l, e, f, g, h) || K.Mq(a, l, a, b, e, f, g, h) ? !0 : !1;\n    },\n    Mq: function (a, b, c, d, e, f, g, h) {\n      return 0 >= K.Bt(a, b, c, d, e, f) * K.Bt(a, b, c, d, g, h) && 0 >= K.Bt(e, f, g, h, a, b) * K.Bt(e, f, g, h, c, d);\n    },\n    Bt: function (a, b, c, d, e, f) {\n      c -= a;\n      d -= b;\n      a = e - a;\n      b = f - b;\n      f = a * d - b * c;\n      0 === f && (f = a * c + b * d, 0 < f && (f = (a - c) * c + (b - d) * d, 0 > f && (f = 0)));\n      return 0 > f ? -1 : 0 < f ? 1 : 0;\n    },\n    Tq: function (a) {\n      0 > a && (a += 360);\n      360 <= a && (a -= 360);\n      return a;\n    },\n    by: function (a, b, c, d, e, f) {\n      var g = Math.PI;\n      f || (d *= g / 180, e *= g / 180);\n      var h = d > e ? -1 : 1;\n      f = [];\n      var k = g / 2,\n        l = d;\n      d = Math.min(2 * g, Math.abs(e - d));\n      if (1E-5 > d) return k = l + h * Math.min(d, k), h = a + c * Math.cos(l), l = b + c * Math.sin(l), a += c * Math.cos(k), b += c * Math.sin(k), c = (h + a) / 2, k = (l + b) / 2, f.push([h, l, c, k, c, k, a, b]), f;\n      for (; 1E-5 < d;) e = l + h * Math.min(d, k), f.push(K.Cz(c, l, e, a, b)), d -= Math.abs(e - l), l = e;\n      return f;\n    },\n    Cz: function (a, b, c, d, e) {\n      var f = (c - b) / 2,\n        g = a * Math.cos(f),\n        h = a * Math.sin(f),\n        k = -h,\n        l = g * g + k * k,\n        m = l + g * g + k * h;\n      l = 4 / 3 * (Math.sqrt(2 * l * m) - m) / (g * h - k * g);\n      h = g - l * k;\n      g = k + l * g;\n      k = -g;\n      l = f + b;\n      f = Math.cos(l);\n      l = Math.sin(l);\n      return [d + a * Math.cos(b), e + a * Math.sin(b), d + h * f - g * l, e + h * l + g * f, d + h * f - k * l, e + h * l + k * f, d + a * Math.cos(c), e + a * Math.sin(c)];\n    },\n    Eq: function (a, b, c, d, e, f, g) {\n      c = Math.floor((a - c) / e) * e + c;\n      d = Math.floor((b - d) / f) * f + d;\n      var h = c;\n      c + e - a < e / 2 && (h = c + e);\n      a = d;\n      d + f - b < f / 2 && (a = d + f);\n      g.h(h, a);\n      return g;\n    },\n    qy: function (a, b) {\n      var c = Math.max(a, b);\n      a = Math.min(a, b);\n      var d;\n      do b = c % a, c = d = a, a = b; while (0 < b);\n      return d;\n    },\n    Hz: function (a, b, c, d) {\n      var e = 0 > c,\n        f = 0 > d;\n      if (a < b) {\n        var g = 1;\n        var h = 0;\n      } else g = 0, h = 1;\n      var k = 0 === g ? a : b;\n      var l = 0 === g ? c : d;\n      if (0 === g ? e : f) l = -l;\n      g = h;\n      c = 0 === g ? c : d;\n      if (0 === g ? e : f) c = -c;\n      return K.Iz(k, 0 === g ? a : b, l, c, 0, 0);\n    },\n    Iz: function (a, b, c, d, e, f) {\n      if (0 < d) {\n        if (0 < c) {\n          e = a * a;\n          f = b * b;\n          a *= c;\n          var g = b * d,\n            h = -f + g,\n            k = -f + Math.sqrt(a * a + g * g);\n          b = h;\n          for (var l = 0; 9999999999 > l; ++l) {\n            b = .5 * (h + k);\n            if (b === h || b === k) break;\n            var m = a / (b + e),\n              n = g / (b + f);\n            m = m * m + n * n - 1;\n            if (0 < m) h = b;else if (0 > m) k = b;else break;\n          }\n          c = e * c / (b + e) - c;\n          d = f * d / (b + f) - d;\n          c = Math.sqrt(c * c + d * d);\n        } else c = Math.abs(d - b);\n      } else d = a * a - b * b, f = a * c, f < d ? (d = f / d, f = b * Math.sqrt(Math.abs(1 - d * d)), c = a * d - c, c = Math.sqrt(c * c + f * f)) : c = Math.abs(c - a);\n      return c;\n    },\n    Oe: new ab(),\n    bn: new ab(),\n    Uh: new ab(),\n    Vh: 0\n  };\n  K.za = K.eB;\n  function td(a) {\n    Ya(this);\n    this.s = !1;\n    void 0 === a && (a = ud);\n    this.pa = a;\n    this.nc = this.gc = this.$c = this.Zc = 0;\n    this.Gj = new E();\n    this.Zr = this.Gj.Aa;\n    this.Hr = new N().freeze();\n    this.qa = !0;\n    this.jn = this.Uk = null;\n    this.kn = NaN;\n    this.nf = wc;\n    this.pf = Hc;\n    this.wl = this.xl = NaN;\n    this.Rf = vd;\n  }\n  td.prototype.copy = function () {\n    var a = new td();\n    a.pa = this.pa;\n    a.Zc = this.Zc;\n    a.$c = this.$c;\n    a.gc = this.gc;\n    a.nc = this.nc;\n    for (var b = this.Gj.j, c = b.length, d = a.Gj, e = 0; e < c; e++) {\n      var f = b[e].copy();\n      d.add(f);\n    }\n    a.Zr = this.Zr;\n    a.Hr.assign(this.Hr);\n    a.qa = this.qa;\n    a.Uk = this.Uk;\n    a.jn = this.jn;\n    a.kn = this.kn;\n    a.nf = this.nf.G();\n    a.pf = this.pf.G();\n    a.xl = this.xl;\n    a.wl = this.wl;\n    a.Rf = this.Rf;\n    return a;\n  };\n  t = td.prototype;\n  t.ca = function () {\n    this.freeze();\n    Object.freeze(this);\n    return this;\n  };\n  t.freeze = function () {\n    this.s = !0;\n    var a = this.figures;\n    a.freeze();\n    a = a.j;\n    for (var b = a.length, c = 0; c < b; c++) a[c].freeze();\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    var a = this.figures;\n    a.ea();\n    a = a.j;\n    for (var b = a.length, c = 0; c < b; c++) a[c].ea();\n    return this;\n  };\n  t.Na = function (a) {\n    if (!(a instanceof td)) return !1;\n    if (this.type !== a.type) return this.type === wd && a.type === ud ? xd(this, a) : a.type === wd && this.type === ud ? xd(a, this) : !1;\n    if (this.type === ud) {\n      var b = this.figures.j;\n      a = a.figures.j;\n      var c = b.length;\n      if (c !== a.length) return !1;\n      for (var d = 0; d < c; d++) if (!b[d].Na(a[d])) return !1;\n      return !0;\n    }\n    return K.A(this.startX, a.startX) && K.A(this.startY, a.startY) && K.A(this.endX, a.endX) && K.A(this.endY, a.endY);\n  };\n  function xd(a, b) {\n    return a.type !== wd || b.type !== ud ? !1 : 1 === b.figures.count && (b = b.figures.L(0), 1 === b.segments.count && K.A(a.startX, b.startX) && K.A(a.startY, b.startY) && (b = b.segments.L(0), b.type === yd && K.A(a.endX, b.endX) && K.A(a.endY, b.endY))) ? !0 : !1;\n  }\n  function zd(a) {\n    return a.toString();\n  }\n  t.hb = function (a) {\n    a.classType === td && (this.type = a);\n  };\n  t.toString = function (a) {\n    void 0 === a && (a = -1);\n    switch (this.type) {\n      case wd:\n        return 0 > a ? \"M\" + this.startX.toString() + \" \" + this.startY.toString() + \"L\" + this.endX.toString() + \" \" + this.endY.toString() : \"M\" + this.startX.toFixed(a) + \" \" + this.startY.toFixed(a) + \"L\" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n      case Hd:\n        var b = new N(this.startX, this.startY, 0, 0);\n        b.Pw(this.endX, this.endY, 0, 0);\n        return 0 > a ? \"M\" + b.x.toString() + \" \" + b.y.toString() + \"H\" + b.right.toString() + \"V\" + b.bottom.toString() + \"H\" + b.left.toString() + \"z\" : \"M\" + b.x.toFixed(a) + \" \" + b.y.toFixed(a) + \"H\" + b.right.toFixed(a) + \"V\" + b.bottom.toFixed(a) + \"H\" + b.left.toFixed(a) + \"z\";\n      case Id:\n        b = new N(this.startX, this.startY, 0, 0);\n        b.Pw(this.endX, this.endY, 0, 0);\n        if (0 > a) return a = b.left.toString() + \" \" + (b.y + b.height / 2).toString(), \"M\" + a + \"A\" + (b.width / 2).toString() + \" \" + (b.height / 2).toString() + \" 0 0 1 \" + (b.right.toString() + \" \" + (b.y + b.height / 2).toString()) + \"A\" + (b.width / 2).toString() + \" \" + (b.height / 2).toString() + \" 0 0 1 \" + a;\n        var c = b.left.toFixed(a) + \" \" + (b.y + b.height / 2).toFixed(a);\n        return \"M\" + c + \"A\" + (b.width / 2).toFixed(a) + \" \" + (b.height / 2).toFixed(a) + \" 0 0 1 \" + (b.right.toFixed(a) + \" \" + (b.y + b.height / 2).toFixed(a)) + \"A\" + (b.width / 2).toFixed(a) + \" \" + (b.height / 2).toFixed(a) + \" 0 0 1 \" + c;\n      case ud:\n        b = \"\";\n        c = this.figures.j;\n        for (var d = c.length, e = 0; e < d; e++) {\n          var f = c[e];\n          0 < e && (b += \" x \");\n          f.isFilled && (b += \"F \");\n          b += f.toString(a);\n        }\n        return b;\n      default:\n        return this.type.toString();\n    }\n  };\n  function Jd(a, b) {\n    function c() {\n      return u >= A - 1 ? !0 : null !== k[u + 1].match(/[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/);\n    }\n    function d() {\n      u++;\n      return k[u];\n    }\n    function e() {\n      var a = new J(parseFloat(d()), parseFloat(d()));\n      v === v.toLowerCase() && (a.x = z.x + a.x, a.y = z.y + a.y);\n      return a;\n    }\n    function f() {\n      return z = e();\n    }\n    function g() {\n      return y = e();\n    }\n    function h() {\n      var a = w.toLowerCase();\n      return \"c\" !== a && \"s\" !== a && \"q\" !== a && \"t\" !== a ? z : new J(2 * z.x - y.x, 2 * z.y - y.y);\n    }\n    void 0 === b && (b = !1);\n    a = a.replace(/,/gm, \" \");\n    a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, \"$1 $2\");\n    a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, \"$1 $2\");\n    a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([^\\s])/gm, \"$1 $2\");\n    a = a.replace(/([^\\s])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, \"$1 $2\");\n    a = a.replace(/([0-9])([+\\-])/gm, \"$1 $2\");\n    a = a.replace(/[\\s\\r\\t\\n]+/gm, \" \");\n    a = a.replace(/^\\s+|\\s+$/g, \"\");\n    var k = a.split(\" \");\n    for (a = 0; a < k.length; a++) {\n      var l = k[a];\n      if (null !== l.match(/(\\.[0-9]*)(\\.)/gm)) {\n        for (var m = Ea(), n = \"\", p = !1, r = 0; r < l.length; r++) {\n          var q = l[r];\n          \".\" !== q || p ? \".\" === q ? (m.push(n), n = \".\") : n += q : (p = !0, n += q);\n        }\n        m.push(n);\n        k.splice(a, 1);\n        for (l = 0; l < m.length; l++) k.splice(a + l, 0, m[l]);\n        a += m.length - 1;\n        Ha(m);\n      }\n    }\n    var u = -1,\n      v = \"\",\n      w = \"\";\n    m = new J(0, 0);\n    var y = new J(0, 0),\n      z = new J(0, 0),\n      A = k.length;\n    a = Kd(null);\n    n = l = !1;\n    p = !0;\n    for (r = null; !(u >= A - 1);) if (w = v, v = d(), \"\" !== v) switch (v.toUpperCase()) {\n      case \"X\":\n        p = !0;\n        n = l = !1;\n        break;\n      case \"M\":\n        r = f();\n        null === a.hc || !0 === p ? (Ld(a, r.x, r.y, l, !n), p = !1) : a.moveTo(r.x, r.y);\n        for (m = z; !c();) r = f(), a.lineTo(r.x, r.y);\n        break;\n      case \"L\":\n        for (; !c();) r = f(), a.lineTo(r.x, r.y);\n        break;\n      case \"H\":\n        for (; !c();) z = new J((v === v.toLowerCase() ? z.x : 0) + parseFloat(d()), z.y), a.lineTo(z.x, z.y);\n        break;\n      case \"V\":\n        for (; !c();) z = new J(z.x, (v === v.toLowerCase() ? z.y : 0) + parseFloat(d())), a.lineTo(z.x, z.y);\n        break;\n      case \"C\":\n        for (; !c();) {\n          r = e();\n          q = g();\n          var C = f();\n          Md(a, r.x, r.y, q.x, q.y, C.x, C.y);\n        }\n        break;\n      case \"S\":\n        for (; !c();) r = h(), q = g(), C = f(), Md(a, r.x, r.y, q.x, q.y, C.x, C.y);\n        break;\n      case \"Q\":\n        for (; !c();) r = g(), q = f(), Rd(a, r.x, r.y, q.x, q.y);\n        break;\n      case \"T\":\n        for (; !c();) y = r = h(), q = f(), Rd(a, r.x, r.y, q.x, q.y);\n        break;\n      case \"B\":\n        for (; !c();) {\n          r = parseFloat(d());\n          q = parseFloat(d());\n          C = parseFloat(d());\n          var G = parseFloat(d()),\n            L = parseFloat(d()),\n            I = L,\n            T = !1;\n          c() || (I = parseFloat(d()), c() || (T = 0 !== parseFloat(d())));\n          v === v.toLowerCase() && (C += z.x, G += z.y);\n          a.arcTo(r, q, C, G, L, I, T);\n        }\n        break;\n      case \"A\":\n        for (; !c();) r = Math.abs(parseFloat(d())), q = Math.abs(parseFloat(d())), C = parseFloat(d()), L = G = !1, T = I = 0, I = d(), 1 === I.length ? (G = !!parseFloat(I), L = !!parseFloat(d()), I = parseFloat(d())) : 2 === I.length ? (G = !!parseFloat(I[0]), L = !!parseFloat(I[1]), I = parseFloat(d())) : (G = !!parseFloat(I[0]), L = !!parseFloat(I[1]), I = parseFloat(I.slice(2))), T = parseFloat(d()), v === v.toLowerCase() && (I = z.x + I, T = z.y + T), z.h(I, T), Sd(a, r, q, C, G, L, I, T);\n        break;\n      case \"Z\":\n        Td(a);\n        z = m;\n        break;\n      case \"F\":\n        r = \"\";\n        for (q = 1; k[u + q];) if (null !== k[u + q].match(/[Uu]/)) q++;else if (null === k[u + q].match(/[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/)) q++;else {\n          r = k[u + q];\n          break;\n        }\n        r.match(/[Mm]/) ? l = !0 : 0 < a.hc.segments.length && (a.hc.isFilled = !0);\n        break;\n      case \"U\":\n        r = \"\";\n        for (q = 1; k[u + q];) if (null !== k[u + q].match(/[Ff]/)) q++;else if (null === k[u + q].match(/[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/)) q++;else {\n          r = k[u + q];\n          break;\n        }\n        r.match(/[Mm]/) ? n = !0 : a.gr(!1);\n    }\n    m = a.Lt;\n    Ud = a;\n    if (b) for (b = m.figures.iterator; b.next();) b.value.isFilled = !0;\n    return m;\n  }\n  function Vd(a, b) {\n    for (var c = a.length, d = J.alloc(), e = 0; e < c; e++) {\n      var f = a[e];\n      d.x = f[0];\n      d.y = f[1];\n      b.sa(d);\n      f[0] = d.x;\n      f[1] = d.y;\n      d.x = f[2];\n      d.y = f[3];\n      b.sa(d);\n      f[2] = d.x;\n      f[3] = d.y;\n      d.x = f[4];\n      d.y = f[5];\n      b.sa(d);\n      f[4] = d.x;\n      f[5] = d.y;\n      d.x = f[6];\n      d.y = f[7];\n      b.sa(d);\n      f[6] = d.x;\n      f[7] = d.y;\n    }\n    J.free(d);\n  }\n  t.fw = function () {\n    if (this.qa || this.Zr !== this.figures.Aa) return !0;\n    for (var a = this.figures.j, b = a.length, c = 0; c < b; c++) if (a[c].fw()) return !0;\n    return !1;\n  };\n  td.prototype.computeBounds = function () {\n    this.qa = !1;\n    this.jn = this.Uk = null;\n    this.kn = NaN;\n    this.Zr = this.figures.Aa;\n    for (var a = this.figures.j, b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n      d.qa = !1;\n      var e = d.segments;\n      d.dt = e.Aa;\n      d = e.j;\n      e = d.length;\n      for (var f = 0; f < e; f++) {\n        var g = d[f];\n        g.qa = !1;\n        g.Qe = null;\n      }\n    }\n    a = this.Hr;\n    a.ea();\n    isNaN(this.xl) || isNaN(this.wl) ? a.h(0, 0, 0, 0) : a.h(0, 0, this.xl, this.wl);\n    Wd(this, a, !1);\n    fc(a, 0, 0, 0, 0);\n    a.freeze();\n  };\n  td.prototype.ay = function () {\n    var a = new N();\n    Wd(this, a, !0);\n    return a;\n  };\n  function Wd(a, b, c) {\n    switch (a.type) {\n      case wd:\n      case Hd:\n      case Id:\n        c ? b.h(a.Zc, a.$c, 0, 0) : fc(b, a.Zc, a.$c, 0, 0);\n        fc(b, a.gc, a.nc, 0, 0);\n        break;\n      case ud:\n        var d = a.figures;\n        a = d.j;\n        d = d.length;\n        for (var e = 0; e < d; e++) {\n          var f = a[e];\n          c && 0 === e ? b.h(f.startX, f.startY, 0, 0) : fc(b, f.startX, f.startY, 0, 0);\n          for (var g = f.segments.j, h = g.length, k = f.startX, l = f.startY, m = 0; m < h; m++) {\n            var n = g[m];\n            switch (n.type) {\n              case yd:\n              case Xd:\n                k = n.endX;\n                l = n.endY;\n                fc(b, k, l, 0, 0);\n                break;\n              case Yd:\n                K.pm(k, l, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .5, b);\n                k = n.endX;\n                l = n.endY;\n                break;\n              case Zd:\n                K.mw(k, l, n.point1X, n.point1Y, n.endX, n.endY, .5, b);\n                k = n.endX;\n                l = n.endY;\n                break;\n              case $d:\n              case ae:\n                var p = n.type === $d ? be(n, f) : ce(n, f, k, l),\n                  r = p.length;\n                if (0 === r) {\n                  k = n.centerX;\n                  l = n.centerY;\n                  fc(b, k, l, 0, 0);\n                  break;\n                }\n                n = null;\n                for (var q = 0; q < r; q++) n = p[q], K.pm(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .5, b);\n                null !== n && (k = n[6], l = n[7]);\n                break;\n              default:\n                B(\"Unknown Segment type: \" + n.type);\n            }\n          }\n        }\n        break;\n      default:\n        B(\"Unknown Geometry type: \" + a.type);\n    }\n  }\n  td.prototype.normalize = function () {\n    this.s && ua(this);\n    var a = this.ay();\n    this.offset(-a.x, -a.y);\n    return new J(-a.x, -a.y);\n  };\n  td.prototype.offset = function (a, b) {\n    this.s && ua(this);\n    this.transform(1, 0, 0, 1, a, b);\n    return this;\n  };\n  td.prototype.scale = function (a, b) {\n    this.s && ua(this);\n    this.transform(a, 0, 0, b, 0, 0);\n    return this;\n  };\n  td.prototype.rotate = function (a, b, c) {\n    this.s && ua(this);\n    void 0 === b && (b = 0);\n    void 0 === c && (c = 0);\n    var d = rd.alloc();\n    d.reset();\n    d.rotate(a, b, c);\n    this.transform(d.m11, d.m12, d.m21, d.m22, d.dx, d.dy);\n    rd.free(d);\n    return this;\n  };\n  t = td.prototype;\n  t.transform = function (a, b, c, d, e, f) {\n    switch (this.type) {\n      case wd:\n      case Hd:\n      case Id:\n        var g = this.Zc;\n        var h = this.$c;\n        this.Zc = g * a + h * c + e;\n        this.$c = g * b + h * d + f;\n        g = this.gc;\n        h = this.nc;\n        this.gc = g * a + h * c + e;\n        this.nc = g * b + h * d + f;\n        break;\n      case ud:\n        for (var k = this.figures.j, l = k.length, m = 0; m < l; m++) {\n          var n = k[m];\n          g = n.startX;\n          h = n.startY;\n          n.startX = g * a + h * c + e;\n          n.startY = g * b + h * d + f;\n          n = n.segments.j;\n          for (var p = n.length, r = 0; r < p; r++) {\n            var q = n[r];\n            switch (q.type) {\n              case yd:\n              case Xd:\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                break;\n              case Yd:\n                g = q.point1X;\n                h = q.point1Y;\n                q.point1X = g * a + h * c + e;\n                q.point1Y = g * b + h * d + f;\n                g = q.point2X;\n                h = q.point2Y;\n                q.point2X = g * a + h * c + e;\n                q.point2Y = g * b + h * d + f;\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                break;\n              case Zd:\n                g = q.point1X;\n                h = q.point1Y;\n                q.point1X = g * a + h * c + e;\n                q.point1Y = g * b + h * d + f;\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                break;\n              case $d:\n                g = q.centerX;\n                h = q.centerY;\n                q.centerX = g * a + h * c + e;\n                q.centerY = g * b + h * d + f;\n                0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), q.startAngle += g);\n                0 > a && (q.startAngle = 180 - q.startAngle, q.sweepAngle = -q.sweepAngle);\n                0 > d && (q.startAngle = -q.startAngle, q.sweepAngle = -q.sweepAngle);\n                q.radiusX *= Math.sqrt(a * a + c * c);\n                void 0 !== q.radiusY && (q.radiusY *= Math.sqrt(b * b + d * d));\n                break;\n              case ae:\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), q.xAxisRotation += g);\n                0 > a && (q.xAxisRotation = 180 - q.xAxisRotation, q.isClockwiseArc = !q.isClockwiseArc);\n                0 > d && (q.xAxisRotation = -q.xAxisRotation, q.isClockwiseArc = !q.isClockwiseArc);\n                q.radiusX *= Math.sqrt(a * a + c * c);\n                q.radiusY *= Math.sqrt(b * b + d * d);\n                break;\n              default:\n                B(\"Unknown Segment type: \" + q.type);\n            }\n          }\n        }\n    }\n    this.qa = !0;\n    return this;\n  };\n  t.aa = function (a, b) {\n    void 0 === b && (b = 0);\n    var c = this.Zc,\n      d = this.$c,\n      e = this.gc,\n      f = this.nc;\n    switch (this.type) {\n      case wd:\n        return K.Nb(c, d, e, f, b, a.x, a.y);\n      case Hd:\n        var g = N.allocAt(Math.min(c, e) - b, Math.min(d, f) - b, Math.abs(e - c) + 2 * b, Math.abs(f - d) + 2 * b);\n        a = g.aa(a);\n        N.free(g);\n        return a;\n      case Id:\n        g = Math.min(c, e) - b;\n        var h = Math.min(d, f) - b;\n        c = (Math.abs(e - c) + 2 * b) / 2;\n        b = (Math.abs(f - d) + 2 * b) / 2;\n        if (0 >= c || 0 >= b) return !1;\n        g = a.x - (g + c);\n        h = a.y - (h + b);\n        return 1 >= g * g / (c * c) + h * h / (b * b);\n      case ud:\n        return de(this, a, b, !0, !1);\n      default:\n        return !1;\n    }\n  };\n  function de(a, b, c, d, e) {\n    var f = b.x;\n    b = b.y;\n    for (var g = a.bounds.x - 20, h = 0, k, l, m, n, p = a.figures.j, r = p.length, q = 0; q < r; q++) {\n      var u = p[q];\n      if (u.isFilled) {\n        if (d && u.aa(f, b, c)) return !0;\n        var v = u.segments;\n        k = u.startX;\n        l = u.startY;\n        for (var w = k, y = l, z = v.j, A = 0; A <= v.length; A++) {\n          var C = void 0;\n          if (A !== v.length) {\n            C = z[A];\n            var G = C.type;\n            a = C.endX;\n            n = C.endY;\n          } else G = yd, a = w, n = y;\n          switch (G) {\n            case Xd:\n              w = ee(f, b, g, b, k, l, w, y);\n              if (isNaN(w)) return !0;\n              h += w;\n              w = a;\n              y = n;\n              break;\n            case yd:\n              k = ee(f, b, g, b, k, l, a, n);\n              if (isNaN(k)) return !0;\n              h += k;\n              break;\n            case Yd:\n              m = K.vq(k, l, C.point1X, C.point1Y, C.point2X, C.point2Y, a, n, g, b, f, b, .5);\n              h += m;\n              break;\n            case Zd:\n              m = K.vq(k, l, (k + 2 * C.point1X) / 3, (l + 2 * C.point1Y) / 3, (2 * C.point1X + a) / 3, (2 * C.point1Y + n) / 3, a, n, g, b, f, b, .5);\n              h += m;\n              break;\n            case $d:\n            case ae:\n              G = C.type === $d ? be(C, u) : ce(C, u, k, l);\n              var L = G.length;\n              if (0 === L) {\n                k = ee(f, b, g, b, k, l, C.centerX, C.centerY);\n                if (isNaN(k)) return !0;\n                h += k;\n                break;\n              }\n              C = null;\n              for (var I = 0; I < L; I++) {\n                C = G[I];\n                if (0 === I) {\n                  m = ee(f, b, g, b, k, l, C[0], C[1]);\n                  if (isNaN(m)) return !0;\n                  h += m;\n                }\n                m = K.vq(C[0], C[1], C[2], C[3], C[4], C[5], C[6], C[7], g, b, f, b, .5);\n                h += m;\n              }\n              null !== C && (a = C[6], n = C[7]);\n              break;\n            default:\n              B(\"Unknown Segment type: \" + C.type);\n          }\n          k = a;\n          l = n;\n        }\n        if (0 !== h) return !0;\n        h = 0;\n      } else if (u.aa(f, b, e ? c : c + 2)) return !0;\n    }\n    return 0 !== h;\n  }\n  function ee(a, b, c, d, e, f, g, h) {\n    if (K.Nb(e, f, g, h, .05, a, b)) return NaN;\n    var k = (a - c) * (f - h);\n    if (0 === k) return 0;\n    var l = ((a * d - b * c) * (e - g) - (a - c) * (e * h - f * g)) / k;\n    b = (a * d - b * c) * (f - h) / k;\n    if (l >= a) return 0;\n    if ((e > g ? e - g : g - e) < (f > h ? f - h : h - f)) {\n      if (f < h) {\n        if (b < f || b > h) return 0;\n      } else {\n        if (b < h || b > f) return 0;\n      }\n    } else if (e < g) {\n      if (l < e || l > g) return 0;\n    } else if (l < g || l > e) return 0;\n    return 0 < k ? 1 : -1;\n  }\n  function fe(a, b, c, d) {\n    a = a.figures.j;\n    for (var e = a.length, f = 0; f < e; f++) if (a[f].aa(b, c, d)) return !0;\n    return !1;\n  }\n  t.Wv = function (a, b) {\n    0 > a ? a = 0 : 1 < a && (a = 1);\n    void 0 === b && (b = new J());\n    if (this.type === wd) return b.h(this.startX + a * (this.endX - this.startX), this.startY + a * (this.endY - this.startY)), b;\n    for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) {\n      var k = d[h],\n        l = k.length;\n      for (a = 0; a < l; a++) {\n        var m = k[a];\n        if (g + m >= f) return d = f - g, d = 0 === m ? 0 : d / m, c = c[h], h = c[2 * a], e = c[2 * a + 1], b.h(h + (c[2 * a + 2] - h) * d, e + (c[2 * a + 3] - e) * d), b;\n        g += m;\n      }\n    }\n    return b;\n  };\n  t.sy = function (a) {\n    0 > a ? a = 0 : 1 < a && (a = 1);\n    if (this.type === wd) return 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI;\n    for (var b = this.flattenedSegments, c = this.flattenedLengths, d = b.length, e = this.flattenedTotalLength * a, f = 0, g = 0; g < d; g++) {\n      var h = c[g],\n        k = h.length;\n      for (a = 0; a < k; a++) {\n        var l = h[a];\n        if (f + l >= e) return e = b[g], b = e[2 * a], c = e[2 * a + 1], d = e[2 * a + 2], a = e[2 * a + 3], 1 > Math.abs(d - b) && 1 > Math.abs(a - c) ? 0 : 1 > Math.abs(d - b) ? 0 <= a - c ? 90 : 270 : 1 > Math.abs(a - c) ? 0 <= d - b ? 0 : 180 : 180 * Math.atan2(a - c, d - b) / Math.PI;\n        f += l;\n      }\n    }\n    return NaN;\n  };\n  t.Xv = function (a, b) {\n    0 > a ? a = 0 : 1 < a && (a = 1);\n    void 0 === b && (b = []);\n    b.length = 3;\n    if (this.type === wd) return b[0] = this.startX + a * (this.endX - this.startX), b[1] = this.startY + a * (this.endY - this.startY), b[2] = 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI, b;\n    for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) {\n      var k = d[h],\n        l = k.length;\n      for (a = 0; a < l; a++) {\n        var m = k[a];\n        if (g + m >= f) return d = f - g, d = 0 === m ? 0 : d / m, m = c[h], c = m[2 * a], h = m[2 * a + 1], e = m[2 * a + 2], a = m[2 * a + 3], b[0] = c + (e - c) * d, b[1] = h + (a - h) * d, b[2] = 1 > Math.abs(e - c) && 1 > Math.abs(a - h) ? 0 : 1 > Math.abs(e - c) ? 0 <= a - h ? 90 : 270 : 1 > Math.abs(a - h) ? 0 <= e - c ? 0 : 180 : 180 * Math.atan2(a - h, e - c) / Math.PI, b;\n        g += m;\n      }\n    }\n    return b;\n  };\n  t.ty = function (a) {\n    if (this.type === wd) {\n      var b = this.startX,\n        c = this.startY,\n        d = this.endX,\n        e = this.endY;\n      if (b !== d || c !== e) {\n        var f = a.x;\n        a = a.y;\n        if (b === d) {\n          if (c < e) {\n            var g = c;\n            d = e;\n          } else g = e, d = c;\n          return a <= g ? g === c ? 0 : 1 : a >= d ? d === c ? 0 : 1 : Math.abs(a - c) / (d - g);\n        }\n        if (c === e) return b < d ? g = b : (g = d, d = b), f <= g ? g === b ? 0 : 1 : f >= d ? d === b ? 0 : 1 : Math.abs(f - b) / (d - g);\n        g = (d - b) * (d - b) + (e - c) * (e - c);\n        var h = J.alloc();\n        K.Qh(b, c, d, e, f, a, h);\n        a = h.x;\n        f = h.y;\n        J.free(h);\n        return Math.sqrt(((a - b) * (a - b) + (f - c) * (f - c)) / g);\n      }\n    } else if (this.type === Hd) {\n      g = this.startX;\n      h = this.startY;\n      var k = this.endX;\n      e = this.endY;\n      if (g !== k || h !== e) {\n        b = k - g;\n        c = e - h;\n        f = 2 * b + 2 * c;\n        d = a.x;\n        a = a.y;\n        d = Math.min(Math.max(d, g), k);\n        a = Math.min(Math.max(a, h), e);\n        g = Math.abs(d - g);\n        k = Math.abs(d - k);\n        h = Math.abs(a - h);\n        e = Math.abs(a - e);\n        var l = Math.min(g, k, h, e);\n        if (l === h) return d / f;\n        if (l === k) return (b + a) / f;\n        if (l === e) return (2 * b + c - d) / f;\n        if (l === g) return (2 * b + 2 * c - a) / f;\n      }\n    } else {\n      b = this.flattenedSegments;\n      c = this.flattenedLengths;\n      f = this.flattenedTotalLength;\n      d = J.alloc();\n      e = Infinity;\n      h = g = 0;\n      k = b.length;\n      for (var m = l = 0, n = 0; n < k; n++) for (var p = b[n], r = c[n], q = p.length, u = 0; u < q; u += 2) {\n        var v = p[u],\n          w = p[u + 1];\n        if (0 !== u) {\n          K.Qh(l, m, v, w, a.x, a.y, d);\n          var y = (d.x - a.x) * (d.x - a.x) + (d.y - a.y) * (d.y - a.y);\n          y < e && (e = y, g = h, g += Math.sqrt((d.x - l) * (d.x - l) + (d.y - m) * (d.y - m)));\n          h += r[(u - 2) / 2];\n        }\n        l = v;\n        m = w;\n      }\n      J.free(d);\n      a = g / f;\n      return 0 > a ? 0 : 1 < a ? 1 : a;\n    }\n    return 0;\n  };\n  function ge(a) {\n    if (null === a.Uk) {\n      var b = a.Uk = [],\n        c = a.jn = [],\n        d = [],\n        e = [];\n      if (a.type === wd) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.endY), b.push(d), e.push(Math.sqrt((a.startX - a.endX) * (a.startX - a.endX) + (a.startY - a.endY) * (a.startY - a.endY))), c.push(e);else if (a.type === Hd) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.startY), d.push(a.endX), d.push(a.endY), d.push(a.startX), d.push(a.endY), d.push(a.startX), d.push(a.startY), b.push(d), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY - a.endY)), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY - a.endY)), c.push(e);else if (a.type === Id) {\n        var f = new he();\n        f.startX = a.endX;\n        f.startY = (a.startY + a.endY) / 2;\n        var g = new pe($d);\n        g.startAngle = 0;\n        g.sweepAngle = 360;\n        g.centerX = (a.startX + a.endX) / 2;\n        g.centerY = (a.startY + a.endY) / 2;\n        g.radiusX = Math.abs(a.startX - a.endX) / 2;\n        g.radiusY = Math.abs(a.startY - a.endY) / 2;\n        f.add(g);\n        a = be(g, f);\n        e = a.length;\n        if (0 === e) d.push(g.centerX), d.push(g.centerY);else {\n          g = f.startX;\n          f = f.startY;\n          for (var h = 0; h < e; h++) {\n            var k = a[h];\n            K.Ce(g, f, k[2], k[3], k[4], k[5], k[6], k[7], .5, d);\n            g = k[6];\n            f = k[7];\n          }\n        }\n        b.push(d);\n        c.push(qe(d));\n      } else for (a = a.figures.iterator; a.next();) {\n        e = a.value;\n        d = [];\n        d.push(e.startX);\n        d.push(e.startY);\n        g = e.startX;\n        f = e.startY;\n        h = g;\n        k = f;\n        for (var l = e.segments.j, m = l.length, n = 0; n < m; n++) {\n          var p = l[n];\n          switch (p.type) {\n            case Xd:\n              4 <= d.length && (b.push(d), c.push(qe(d)));\n              d = [];\n              d.push(p.endX);\n              d.push(p.endY);\n              g = p.endX;\n              f = p.endY;\n              h = g;\n              k = f;\n              break;\n            case yd:\n              d.push(p.endX);\n              d.push(p.endY);\n              g = p.endX;\n              f = p.endY;\n              break;\n            case Yd:\n              K.Ce(g, f, p.point1X, p.point1Y, p.point2X, p.point2Y, p.endX, p.endY, .5, d);\n              g = p.endX;\n              f = p.endY;\n              break;\n            case Zd:\n              K.Wq(g, f, p.point1X, p.point1Y, p.endX, p.endY, .5, d);\n              g = p.endX;\n              f = p.endY;\n              break;\n            case $d:\n              var r = be(p, e),\n                q = r.length;\n              if (0 === q) {\n                d.push(p.centerX);\n                d.push(p.centerY);\n                g = p.centerX;\n                f = p.centerY;\n                break;\n              }\n              for (var u = 0; u < q; u++) {\n                var v = r[u];\n                K.Ce(g, f, v[2], v[3], v[4], v[5], v[6], v[7], .5, d);\n                g = v[6];\n                f = v[7];\n              }\n              break;\n            case ae:\n              r = ce(p, e, g, f);\n              q = r.length;\n              if (0 === q) {\n                d.push(p.centerX);\n                d.push(p.centerY);\n                g = p.centerX;\n                f = p.centerY;\n                break;\n              }\n              for (u = 0; u < q; u++) v = r[u], K.Ce(g, f, v[2], v[3], v[4], v[5], v[6], v[7], .5, d), g = v[6], f = v[7];\n              break;\n            default:\n              B(\"Segment not of valid type: \" + p.type);\n          }\n          p.isClosed && (d.push(h), d.push(k));\n        }\n        4 <= d.length && (b.push(d), c.push(qe(d)));\n      }\n    }\n  }\n  function qe(a) {\n    for (var b = [], c = 0, d = 0, e = a.length, f = 0; f < e; f += 2) {\n      var g = a[f],\n        h = a[f + 1];\n      0 !== f && b.push(Math.sqrt(Db(c, d, g, h)));\n      c = g;\n      d = h;\n    }\n    return b;\n  }\n  t.add = function (a) {\n    this.Gj.add(a);\n    return this;\n  };\n  t.Xm = function (a, b, c, d, e, f, g, h) {\n    this.s && ua(this);\n    this.nf = new P(a, b, e, f).freeze();\n    this.pf = new P(c, d, g, h).freeze();\n    return this;\n  };\n  ma.Object.defineProperties(td.prototype, {\n    flattenedSegments: {\n      get: function () {\n        ge(this);\n        return this.Uk;\n      }\n    },\n    flattenedLengths: {\n      get: function () {\n        ge(this);\n        return this.jn;\n      }\n    },\n    flattenedTotalLength: {\n      get: function () {\n        var a = this.kn;\n        if (isNaN(a)) {\n          if (this.type === wd) {\n            a = Math.abs(this.endX - this.startX);\n            var b = Math.abs(this.endY - this.startY);\n            a = Math.sqrt(a * a + b * b);\n          } else if (this.type === Hd) a = 2 * Math.abs(this.endX - this.startX) + 2 * Math.abs(this.endY - this.startY);else {\n            b = this.flattenedLengths;\n            for (var c = b.length, d = a = 0; d < c; d++) for (var e = b[d], f = e.length, g = 0; g < f; g++) a += e[g];\n          }\n          this.kn = a;\n        }\n        return a;\n      }\n    },\n    type: {\n      get: function () {\n        return this.pa;\n      },\n      set: function (a) {\n        this.pa !== a && (this.s && ua(this, a), this.pa = a, this.qa = !0);\n      }\n    },\n    startX: {\n      get: function () {\n        return this.Zc;\n      },\n      set: function (a) {\n        this.Zc !== a && (this.s && ua(this, a), this.Zc = a, this.qa = !0);\n      }\n    },\n    startY: {\n      get: function () {\n        return this.$c;\n      },\n      set: function (a) {\n        this.$c !== a && (this.s && ua(this, a), this.$c = a, this.qa = !0);\n      }\n    },\n    endX: {\n      get: function () {\n        return this.gc;\n      },\n      set: function (a) {\n        this.gc !== a && (this.s && ua(this, a), this.gc = a, this.qa = !0);\n      }\n    },\n    endY: {\n      get: function () {\n        return this.nc;\n      },\n      set: function (a) {\n        this.nc !== a && (this.s && ua(this, a), this.nc = a, this.qa = !0);\n      }\n    },\n    figures: {\n      get: function () {\n        return this.Gj;\n      },\n      set: function (a) {\n        this.Gj !== a && (this.s && ua(this, a), this.Gj = a, this.qa = !0);\n      }\n    },\n    spot1: {\n      get: function () {\n        return this.nf;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.nf = a.G();\n      }\n    },\n    spot2: {\n      get: function () {\n        return this.pf;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.pf = a.G();\n      }\n    },\n    defaultStretch: {\n      get: function () {\n        return this.Rf;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Rf = a;\n      }\n    },\n    bounds: {\n      get: function () {\n        this.fw() && this.computeBounds();\n        return this.Hr;\n      }\n    }\n  });\n  td.prototype.setSpots = td.prototype.Xm;\n  td.prototype.add = td.prototype.add;\n  td.prototype.getFractionForPoint = td.prototype.ty;\n  td.prototype.getPointAndAngleAlongPath = td.prototype.Xv;\n  td.prototype.getAngleAlongPath = td.prototype.sy;\n  td.prototype.getPointAlongPath = td.prototype.Wv;\n  td.prototype.containsPoint = td.prototype.aa;\n  td.prototype.transform = td.prototype.transform;\n  td.prototype.rotate = td.prototype.rotate;\n  td.prototype.scale = td.prototype.scale;\n  td.prototype.offset = td.prototype.offset;\n  td.prototype.normalize = td.prototype.normalize;\n  td.prototype.computeBoundsWithoutOrigin = td.prototype.ay;\n  td.prototype.equalsApprox = td.prototype.Na;\n  var wd = new D(td, \"Line\", 0),\n    Hd = new D(td, \"Rectangle\", 1),\n    Id = new D(td, \"Ellipse\", 2),\n    ud = new D(td, \"Path\", 3);\n  td.className = \"Geometry\";\n  td.stringify = zd;\n  td.fillPath = function (a) {\n    a = a.split(/[Xx]/);\n    for (var b = a.length, c = \"\", d = 0; d < b; d++) {\n      var e = a[d];\n      c = null !== e.match(/[Ff]/) ? 0 === d ? c + e : c + (\"X\" + (\" \" === e[0] ? \"\" : \" \") + e) : c + ((0 === d ? \"\" : \"X \") + \"F\" + (\" \" === e[0] ? \"\" : \" \") + e);\n    }\n    return c;\n  };\n  td.parse = Jd;\n  td.Line = wd;\n  td.Rectangle = Hd;\n  td.Ellipse = Id;\n  td.Path = ud;\n  function he(a, b, c, d) {\n    Ya(this);\n    this.s = !1;\n    void 0 === c && (c = !0);\n    this.ls = c;\n    void 0 === d && (d = !0);\n    this.qs = d;\n    void 0 !== a ? this.Zc = a : this.Zc = 0;\n    void 0 !== b ? this.$c = b : this.$c = 0;\n    this.Yl = new E();\n    this.dt = this.Yl.Aa;\n    this.qa = !0;\n  }\n  he.prototype.copy = function () {\n    var a = new he();\n    a.ls = this.ls;\n    a.qs = this.qs;\n    a.Zc = this.Zc;\n    a.$c = this.$c;\n    for (var b = this.Yl.j, c = b.length, d = a.Yl, e = 0; e < c; e++) {\n      var f = b[e].copy();\n      d.add(f);\n    }\n    a.dt = this.dt;\n    a.qa = this.qa;\n    return a;\n  };\n  t = he.prototype;\n  t.Na = function (a) {\n    if (!(a instanceof he && K.A(this.startX, a.startX) && K.A(this.startY, a.startY))) return !1;\n    var b = this.segments.j;\n    a = a.segments.j;\n    var c = b.length;\n    if (c !== a.length) return !1;\n    for (var d = 0; d < c; d++) if (!b[d].Na(a[d])) return !1;\n    return !0;\n  };\n  t.toString = function (a) {\n    void 0 === a && (a = -1);\n    var b = 0 > a ? \"M\" + this.startX.toString() + \" \" + this.startY.toString() : \"M\" + this.startX.toFixed(a) + \" \" + this.startY.toFixed(a);\n    for (var c = this.segments.j, d = c.length, e = 0; e < d; e++) b += \" \" + c[e].toString(a);\n    return b;\n  };\n  t.freeze = function () {\n    this.s = !0;\n    var a = this.segments;\n    a.freeze();\n    var b = a.j;\n    a = a.length;\n    for (var c = 0; c < a; c++) b[c].freeze();\n    return this;\n  };\n  t.ea = function () {\n    this.s = !1;\n    var a = this.segments;\n    a.ea();\n    a = a.j;\n    for (var b = a.length, c = 0; c < b; c++) a[c].ea();\n    return this;\n  };\n  t.fw = function () {\n    if (this.qa) return !0;\n    var a = this.segments;\n    if (this.dt !== a.Aa) return !0;\n    a = a.j;\n    for (var b = a.length, c = 0; c < b; c++) if (a[c].qa) return !0;\n    return !1;\n  };\n  t.add = function (a) {\n    this.Yl.add(a);\n    return this;\n  };\n  t.aa = function (a, b, c) {\n    for (var d = this.startX, e = this.startY, f = d, g = e, h = this.segments.j, k = h.length, l = 0; l < k; l++) {\n      var m = h[l];\n      switch (m.type) {\n        case Xd:\n          f = m.endX;\n          g = m.endY;\n          d = m.endX;\n          e = m.endY;\n          break;\n        case yd:\n          if (K.Nb(d, e, m.endX, m.endY, c, a, b)) return !0;\n          d = m.endX;\n          e = m.endY;\n          break;\n        case Yd:\n          if (K.yt(d, e, m.point1X, m.point1Y, m.point2X, m.point2Y, m.endX, m.endY, .5, a, b, c)) return !0;\n          d = m.endX;\n          e = m.endY;\n          break;\n        case Zd:\n          if (K.nw(d, e, m.point1X, m.point1Y, m.endX, m.endY, .5, a, b, c)) return !0;\n          d = m.endX;\n          e = m.endY;\n          break;\n        case $d:\n        case ae:\n          var n = m.type === $d ? be(m, this) : ce(m, this, d, e),\n            p = n.length;\n          if (0 === p) {\n            if (K.Nb(d, e, m.centerX, m.centerY, c, a, b)) return !0;\n            d = m.centerX;\n            e = m.centerY;\n            break;\n          }\n          for (var r = null, q = 0; q < p; q++) if (r = n[q], 0 === q && K.Nb(d, e, r[0], r[1], c, a, b) || K.yt(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], .5, a, b, c)) return !0;\n          null !== r && (d = r[6], e = r[7]);\n          break;\n        default:\n          B(\"Unknown Segment type: \" + m.type);\n      }\n      if (m.isClosed && (d !== f || e !== g) && K.Nb(d, e, f, g, c, a, b)) return !0;\n    }\n    return !1;\n  };\n  ma.Object.defineProperties(he.prototype, {\n    isFilled: {\n      get: function () {\n        return this.ls;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.ls = a;\n      }\n    },\n    isShadowed: {\n      get: function () {\n        return this.qs;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.qs = a;\n      }\n    },\n    startX: {\n      get: function () {\n        return this.Zc;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Zc = a;\n        this.qa = !0;\n      }\n    },\n    startY: {\n      get: function () {\n        return this.$c;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.$c = a;\n        this.qa = !0;\n      }\n    },\n    segments: {\n      get: function () {\n        return this.Yl;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Yl = a;\n        this.qa = !0;\n      }\n    }\n  });\n  he.prototype.add = he.prototype.add;\n  he.prototype.equalsApprox = he.prototype.Na;\n  he.className = \"PathFigure\";\n  function pe(a, b, c, d, e, f, g, h) {\n    Ya(this);\n    this.s = !1;\n    void 0 === a && (a = yd);\n    this.pa = a;\n    void 0 !== b ? this.gc = b : this.gc = 0;\n    void 0 !== c ? this.nc = c : this.nc = 0;\n    void 0 === d && (d = 0);\n    void 0 === e && (e = 0);\n    void 0 === f && (f = 0);\n    void 0 === g && (g = 0);\n    a === ae ? (a = f % 360, 0 > a && (a += 360), this.ye = a, this.Qi = 0, this.Ri = Math.max(d, 0), this.ph = Math.max(e, 0), this.Fl = \"boolean\" === typeof g ? g : \"number\" === typeof g ? !!g : !1, this.Yk = !!h) : (this.ye = d, this.Qi = e, a === $d && (f = Math.max(f, 0)), this.Ri = f, \"number\" === typeof g ? (a === $d && (g = Math.max(g, 0)), this.ph = g) : this.ph = 0, this.Yk = this.Fl = !1);\n    this.Lj = !1;\n    this.qa = !0;\n    this.Qe = null;\n  }\n  pe.prototype.copy = function () {\n    var a = new pe();\n    a.pa = this.pa;\n    a.gc = this.gc;\n    a.nc = this.nc;\n    a.ye = this.ye;\n    a.Qi = this.Qi;\n    a.Ri = this.Ri;\n    a.ph = this.ph;\n    a.Fl = this.Fl;\n    a.Yk = this.Yk;\n    a.Lj = this.Lj;\n    a.qa = this.qa;\n    return a;\n  };\n  t = pe.prototype;\n  t.Na = function (a) {\n    if (!(a instanceof pe) || this.type !== a.type || this.isClosed !== a.isClosed) return !1;\n    switch (this.type) {\n      case Xd:\n      case yd:\n        return K.A(this.endX, a.endX) && K.A(this.endY, a.endY);\n      case Yd:\n        return K.A(this.endX, a.endX) && K.A(this.endY, a.endY) && K.A(this.point1X, a.point1X) && K.A(this.point1Y, a.point1Y) && K.A(this.point2X, a.point2X) && K.A(this.point2Y, a.point2Y);\n      case Zd:\n        return K.A(this.endX, a.endX) && K.A(this.endY, a.endY) && K.A(this.point1X, a.point1X) && K.A(this.point1Y, a.point1Y);\n      case $d:\n        return K.A(this.startAngle, a.startAngle) && K.A(this.sweepAngle, a.sweepAngle) && K.A(this.centerX, a.centerX) && K.A(this.centerY, a.centerY) && K.A(this.radiusX, a.radiusX) && K.A(this.radiusY, a.radiusY);\n      case ae:\n        return this.isClockwiseArc === a.isClockwiseArc && this.isLargeArc === a.isLargeArc && K.A(this.xAxisRotation, a.xAxisRotation) && K.A(this.endX, a.endX) && K.A(this.endY, a.endY) && K.A(this.radiusX, a.radiusX) && K.A(this.radiusY, a.radiusY);\n      default:\n        return !1;\n    }\n  };\n  t.hb = function (a) {\n    a.classType === pe && (this.type = a);\n  };\n  t.toString = function (a) {\n    void 0 === a && (a = -1);\n    switch (this.type) {\n      case Xd:\n        a = 0 > a ? \"M\" + this.endX.toString() + \" \" + this.endY.toString() : \"M\" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n      case yd:\n        a = 0 > a ? \"L\" + this.endX.toString() + \" \" + this.endY.toString() : \"L\" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n      case Yd:\n        a = 0 > a ? \"C\" + this.point1X.toString() + \" \" + this.point1Y.toString() + \" \" + this.point2X.toString() + \" \" + this.point2Y.toString() + \" \" + this.endX.toString() + \" \" + this.endY.toString() : \"C\" + this.point1X.toFixed(a) + \" \" + this.point1Y.toFixed(a) + \" \" + this.point2X.toFixed(a) + \" \" + this.point2Y.toFixed(a) + \" \" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n      case Zd:\n        a = 0 > a ? \"Q\" + this.point1X.toString() + \" \" + this.point1Y.toString() + \" \" + this.endX.toString() + \" \" + this.endY.toString() : \"Q\" + this.point1X.toFixed(a) + \" \" + this.point1Y.toFixed(a) + \" \" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n      case $d:\n        a = 0 > a ? \"B\" + this.startAngle.toString() + \" \" + this.sweepAngle.toString() + \" \" + this.centerX.toString() + \" \" + this.centerY.toString() + \" \" + this.radiusX.toString() + \" \" + this.radiusY.toString() : \"B\" + this.startAngle.toFixed(a) + \" \" + this.sweepAngle.toFixed(a) + \" \" + this.centerX.toFixed(a) + \" \" + this.centerY.toFixed(a) + \" \" + this.radiusX.toFixed(a) + \" \" + this.radiusY.toFixed(a);\n        break;\n      case ae:\n        a = 0 > a ? \"A\" + this.radiusX.toString() + \" \" + this.radiusY.toString() + \" \" + this.xAxisRotation.toString() + \" \" + (this.isLargeArc ? 1 : 0) + \" \" + (this.isClockwiseArc ? 1 : 0) + \" \" + this.endX.toString() + \" \" + this.endY.toString() : \"A\" + this.radiusX.toFixed(a) + \" \" + this.radiusY.toFixed(a) + \" \" + this.xAxisRotation.toFixed(a) + \" \" + (this.isLargeArc ? 1 : 0) + \" \" + (this.isClockwiseArc ? 1 : 0) + \" \" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n      default:\n        a = this.type.toString();\n    }\n    return a + (this.Lj ? \"z\" : \"\");\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    this.s = !1;\n    return this;\n  };\n  t.close = function () {\n    this.Lj = !0;\n    return this;\n  };\n  function be(a, b) {\n    if (null !== a.Qe && !1 === b.qa) return a.Qe;\n    var c = a.radiusX,\n      d = a.radiusY;\n    void 0 === d && (d = c);\n    if (0 === c || 0 === d) return a.Qe = [], a.Qe;\n    b = a.ye;\n    var e = a.Qi,\n      f = K.by(0, 0, c < d ? c : d, a.startAngle, a.startAngle + a.sweepAngle, !1);\n    if (c !== d) {\n      var g = rd.alloc();\n      g.reset();\n      c < d ? g.scale(1, d / c) : g.scale(c / d, 1);\n      Vd(f, g);\n      rd.free(g);\n    }\n    c = f.length;\n    for (d = 0; d < c; d++) g = f[d], g[0] += b, g[1] += e, g[2] += b, g[3] += e, g[4] += b, g[5] += e, g[6] += b, g[7] += e;\n    a.Qe = f;\n    return a.Qe;\n  }\n  function ce(a, b, c, d) {\n    function e(a, b, c, d) {\n      return (a * d < b * c ? -1 : 1) * Math.acos((a * c + b * d) / (Math.sqrt(a * a + b * b) * Math.sqrt(c * c + d * d)));\n    }\n    if (null !== a.Qe && !1 === b.qa) return a.Qe;\n    b = a.Ri;\n    var f = a.ph;\n    0 === b && (b = 1E-4);\n    0 === f && (f = 1E-4);\n    var g = Math.PI / 180 * a.ye,\n      h = a.Fl,\n      k = a.Yk,\n      l = a.gc,\n      m = a.nc,\n      n = Math.cos(g),\n      p = Math.sin(g),\n      r = n * (c - l) / 2 + p * (d - m) / 2;\n    g = -p * (c - l) / 2 + n * (d - m) / 2;\n    var q = r * r / (b * b) + g * g / (f * f);\n    1 < q && (b *= Math.sqrt(q), f *= Math.sqrt(q));\n    q = (h === k ? -1 : 1) * Math.sqrt((b * b * f * f - b * b * g * g - f * f * r * r) / (b * b * g * g + f * f * r * r));\n    isNaN(q) && (q = 0);\n    h = q * b * g / f;\n    q = q * -f * r / b;\n    isNaN(h) && (h = 0);\n    isNaN(q) && (q = 0);\n    c = (c + l) / 2 + n * h - p * q;\n    d = (d + m) / 2 + p * h + n * q;\n    m = e(1, 0, (r - h) / b, (g - q) / f);\n    n = (r - h) / b;\n    l = (g - q) / f;\n    r = (-r - h) / b;\n    h = (-g - q) / f;\n    g = e(n, l, r, h);\n    r = (n * r + l * h) / (Math.sqrt(n * n + l * l) * Math.sqrt(r * r + h * h));\n    -1 >= r ? g = Math.PI : 1 <= r && (g = 0);\n    !k && 0 < g && (g -= 2 * Math.PI);\n    k && 0 > g && (g += 2 * Math.PI);\n    k = b > f ? 1 : b / f;\n    r = b > f ? f / b : 1;\n    b = K.by(0, 0, b > f ? b : f, m, m + g, !0);\n    f = rd.alloc();\n    f.reset();\n    f.translate(c, d);\n    f.rotate(a.ye, 0, 0);\n    f.scale(k, r);\n    Vd(b, f);\n    rd.free(f);\n    a.Qe = b;\n    return a.Qe;\n  }\n  ma.Object.defineProperties(pe.prototype, {\n    isClosed: {\n      get: function () {\n        return this.Lj;\n      },\n      set: function (a) {\n        this.Lj !== a && (this.Lj = a, this.qa = !0);\n      }\n    },\n    type: {\n      get: function () {\n        return this.pa;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.pa = a;\n        this.qa = !0;\n      }\n    },\n    endX: {\n      get: function () {\n        return this.gc;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.gc = a;\n        this.qa = !0;\n      }\n    },\n    endY: {\n      get: function () {\n        return this.nc;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.nc = a;\n        this.qa = !0;\n      }\n    },\n    point1X: {\n      get: function () {\n        return this.ye;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.ye = a;\n        this.qa = !0;\n      }\n    },\n    point1Y: {\n      get: function () {\n        return this.Qi;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Qi = a;\n        this.qa = !0;\n      }\n    },\n    point2X: {\n      get: function () {\n        return this.Ri;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Ri = a;\n        this.qa = !0;\n      }\n    },\n    point2Y: {\n      get: function () {\n        return this.ph;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.ph = a;\n        this.qa = !0;\n      }\n    },\n    centerX: {\n      get: function () {\n        return this.ye;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.ye = a;\n        this.qa = !0;\n      }\n    },\n    centerY: {\n      get: function () {\n        return this.Qi;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Qi = a;\n        this.qa = !0;\n      }\n    },\n    radiusX: {\n      get: function () {\n        return this.Ri;\n      },\n      set: function (a) {\n        0 > a && va(a, \">= zero\", pe, \"radiusX\");\n        this.s && ua(this, a);\n        this.Ri = a;\n        this.qa = !0;\n      }\n    },\n    radiusY: {\n      get: function () {\n        return this.ph;\n      },\n      set: function (a) {\n        0 > a && va(a, \">= zero\", pe, \"radiusY\");\n        this.s && ua(this, a);\n        this.ph = a;\n        this.qa = !0;\n      }\n    },\n    startAngle: {\n      get: function () {\n        return this.gc;\n      },\n      set: function (a) {\n        this.gc !== a && (this.s && ua(this, a), a %= 360, 0 > a && (a += 360), this.gc = a, this.qa = !0);\n      }\n    },\n    sweepAngle: {\n      get: function () {\n        return this.nc;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        360 < a && (a = 360);\n        -360 > a && (a = -360);\n        this.nc = a;\n        this.qa = !0;\n      }\n    },\n    isClockwiseArc: {\n      get: function () {\n        return this.Yk;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Yk = a;\n        this.qa = !0;\n      }\n    },\n    isLargeArc: {\n      get: function () {\n        return this.Fl;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Fl = a;\n        this.qa = !0;\n      }\n    },\n    xAxisRotation: {\n      get: function () {\n        return this.ye;\n      },\n      set: function (a) {\n        a %= 360;\n        0 > a && (a += 360);\n        this.s && ua(this, a);\n        this.ye = a;\n        this.qa = !0;\n      }\n    }\n  });\n  pe.prototype.equalsApprox = pe.prototype.Na;\n  var Xd = new D(pe, \"Move\", 0),\n    yd = new D(pe, \"Line\", 1),\n    Yd = new D(pe, \"Bezier\", 2),\n    Zd = new D(pe, \"QuadraticBezier\", 3),\n    $d = new D(pe, \"Arc\", 4),\n    ae = new D(pe, \"SvgArc\", 4);\n  pe.className = \"PathSegment\";\n  pe.Move = Xd;\n  pe.Line = yd;\n  pe.Bezier = Yd;\n  pe.QuadraticBezier = Zd;\n  pe.Arc = $d;\n  pe.SvgArc = ae;\n  function re() {\n    this.B = null;\n    this.yv = new J(0, 0).freeze();\n    this.Hu = new J(0, 0).freeze();\n    this.zr = this.Bs = 0;\n    this.Ar = 1;\n    this.Ci = \"\";\n    this.st = this.Tr = !1;\n    this.Qr = this.Cr = 0;\n    this.Pg = this.ds = this.os = !1;\n    this.Yr = null;\n    this.nt = 0;\n    this.jd = this.mt = null;\n  }\n  re.prototype.copy = function () {\n    var a = new re();\n    return this.clone(a);\n  };\n  re.prototype.clone = function (a) {\n    a.B = this.B;\n    a.yv.assign(this.viewPoint);\n    a.Hu.assign(this.documentPoint);\n    a.Bs = this.Bs;\n    a.zr = this.zr;\n    a.Ar = this.Ar;\n    a.Ci = this.Ci;\n    a.Tr = this.Tr;\n    a.st = this.st;\n    a.Cr = this.Cr;\n    a.Qr = this.Qr;\n    a.os = this.os;\n    a.ds = this.ds;\n    a.Pg = this.Pg;\n    a.Yr = this.Yr;\n    a.nt = this.nt;\n    a.mt = this.mt;\n    a.jd = this.jd;\n    return a;\n  };\n  re.prototype.toString = function () {\n    var a = \"^\";\n    0 !== this.modifiers && (a += \"M:\" + this.modifiers);\n    0 !== this.button && (a += \"B:\" + this.button);\n    \"\" !== this.key && (a += \"K:\" + this.key);\n    0 !== this.clickCount && (a += \"C:\" + this.clickCount);\n    0 !== this.delta && (a += \"D:\" + this.delta);\n    this.handled && (a += \"h\");\n    this.bubbles && (a += \"b\");\n    null !== this.documentPoint && (a += \"@\" + this.documentPoint.toString());\n    return a;\n  };\n  re.prototype.Hq = function (a, b) {\n    var c = this.diagram;\n    if (null === c) return b;\n    se(c, this.event, a, b);\n    return b;\n  };\n  re.prototype.hA = function (a, b) {\n    var c = this.diagram;\n    if (null === c) return b;\n    se(c, this.event, a, b);\n    b.assign(c.nu(b));\n    return b;\n  };\n  ma.Object.defineProperties(re.prototype, {\n    diagram: {\n      get: function () {\n        return this.B;\n      },\n      set: function (a) {\n        this.B = a;\n      }\n    },\n    viewPoint: {\n      get: function () {\n        return this.yv;\n      },\n      set: function (a) {\n        this.yv.assign(a);\n      }\n    },\n    documentPoint: {\n      get: function () {\n        return this.Hu;\n      },\n      set: function (a) {\n        this.Hu.assign(a);\n      }\n    },\n    modifiers: {\n      get: function () {\n        return this.Bs;\n      },\n      set: function (a) {\n        this.Bs = a;\n      }\n    },\n    button: {\n      get: function () {\n        return this.zr;\n      },\n      set: function (a) {\n        this.zr = a;\n        if (null === this.event) switch (a) {\n          case 0:\n            this.buttons = 1;\n            break;\n          case 1:\n            this.buttons = 4;\n            break;\n          case 2:\n            this.buttons = 2;\n        }\n      }\n    },\n    buttons: {\n      get: function () {\n        return this.Ar;\n      },\n      set: function (a) {\n        this.Ar = a;\n      }\n    },\n    key: {\n      get: function () {\n        return this.Ci;\n      },\n      set: function (a) {\n        this.Ci = a;\n      }\n    },\n    down: {\n      get: function () {\n        return this.Tr;\n      },\n      set: function (a) {\n        this.Tr = a;\n      }\n    },\n    up: {\n      get: function () {\n        return this.st;\n      },\n      set: function (a) {\n        this.st = a;\n      }\n    },\n    clickCount: {\n      get: function () {\n        return this.Cr;\n      },\n      set: function (a) {\n        this.Cr = a;\n      }\n    },\n    delta: {\n      get: function () {\n        return this.Qr;\n      },\n      set: function (a) {\n        this.Qr = a;\n      }\n    },\n    isMultiTouch: {\n      get: function () {\n        return this.os;\n      },\n      set: function (a) {\n        this.os = a;\n      }\n    },\n    handled: {\n      get: function () {\n        return this.ds;\n      },\n      set: function (a) {\n        this.ds = a;\n      }\n    },\n    bubbles: {\n      get: function () {\n        return this.Pg;\n      },\n      set: function (a) {\n        this.Pg = a;\n      }\n    },\n    event: {\n      get: function () {\n        return this.Yr;\n      },\n      set: function (a) {\n        this.Yr = a;\n      }\n    },\n    isTouchEvent: {\n      get: function () {\n        var a = x.TouchEvent,\n          b = this.event;\n        return a && b instanceof a ? !0 : (a = x.PointerEvent) && b instanceof a && (\"touch\" === b.pointerType || \"pen\" === b.pointerType);\n      }\n    },\n    timestamp: {\n      get: function () {\n        return this.nt;\n      },\n      set: function (a) {\n        this.nt = a;\n      }\n    },\n    targetDiagram: {\n      get: function () {\n        return this.mt;\n      },\n      set: function (a) {\n        this.mt = a;\n      }\n    },\n    targetObject: {\n      get: function () {\n        return this.jd;\n      },\n      set: function (a) {\n        this.jd = a;\n      }\n    },\n    control: {\n      get: function () {\n        return 0 !== (this.modifiers & 1);\n      },\n      set: function (a) {\n        this.modifiers = a ? this.modifiers | 1 : this.modifiers & -2;\n      }\n    },\n    shift: {\n      get: function () {\n        return 0 !== (this.modifiers & 4);\n      },\n      set: function (a) {\n        this.modifiers = a ? this.modifiers | 4 : this.modifiers & -5;\n      }\n    },\n    alt: {\n      get: function () {\n        return 0 !== (this.modifiers & 2);\n      },\n      set: function (a) {\n        this.modifiers = a ? this.modifiers | 2 : this.modifiers & -3;\n      }\n    },\n    meta: {\n      get: function () {\n        return 0 !== (this.modifiers & 8);\n      },\n      set: function (a) {\n        this.modifiers = a ? this.modifiers | 8 : this.modifiers & -9;\n      }\n    },\n    left: {\n      get: function () {\n        var a = this.event;\n        return null === a || \"mousedown\" !== a.type && \"mouseup\" !== a.type && \"pointerdown\" !== a.type && \"pointerup\" !== a.type ? 0 !== (this.buttons & 1) : 0 === this.button;\n      },\n      set: function (a) {\n        this.buttons = a ? this.buttons | 1 : this.buttons & -2;\n      }\n    },\n    right: {\n      get: function () {\n        var a = this.event;\n        return null === a || \"mousedown\" !== a.type && \"mouseup\" !== a.type && \"pointerdown\" !== a.type && \"pointerup\" !== a.type ? 0 !== (this.buttons & 2) : 2 === this.button;\n      },\n      set: function (a) {\n        this.buttons = a ? this.buttons | 2 : this.buttons & -3;\n      }\n    },\n    middle: {\n      get: function () {\n        var a = this.event;\n        return null === a || \"mousedown\" !== a.type && \"mouseup\" !== a.type && \"pointerdown\" !== a.type && \"pointerup\" !== a.type ? 0 !== (this.buttons & 4) : 1 === this.button;\n      },\n      set: function (a) {\n        this.buttons = a ? this.buttons | 4 : this.buttons & -5;\n      }\n    }\n  });\n  re.prototype.getMultiTouchDocumentPoint = re.prototype.hA;\n  re.prototype.getMultiTouchViewPoint = re.prototype.Hq;\n  re.className = \"InputEvent\";\n  function te() {\n    this.B = null;\n    this.Qa = \"\";\n    this.Ls = this.kt = null;\n  }\n  te.prototype.copy = function () {\n    var a = new te();\n    a.B = this.B;\n    a.Qa = this.Qa;\n    a.kt = this.kt;\n    a.Ls = this.Ls;\n    return a;\n  };\n  te.prototype.toString = function () {\n    var a = \"*\" + this.name;\n    null !== this.subject && (a += \":\" + this.subject.toString());\n    null !== this.parameter && (a += \"(\" + this.parameter.toString() + \")\");\n    return a;\n  };\n  ma.Object.defineProperties(te.prototype, {\n    diagram: {\n      get: function () {\n        return this.B;\n      },\n      set: function (a) {\n        this.B = a;\n      }\n    },\n    name: {\n      get: function () {\n        return this.Qa;\n      },\n      set: function (a) {\n        this.Qa = a;\n      }\n    },\n    subject: {\n      get: function () {\n        return this.kt;\n      },\n      set: function (a) {\n        this.kt = a;\n      }\n    },\n    parameter: {\n      get: function () {\n        return this.Ls;\n      },\n      set: function (a) {\n        this.Ls = a;\n      }\n    }\n  });\n  te.className = \"DiagramEvent\";\n  function ue() {\n    this.vn = ve;\n    this.ff = this.As = \"\";\n    this.cp = this.ep = this.kp = this.lp = this.jp = this.B = this.ac = null;\n  }\n  ue.prototype.clear = function () {\n    this.cp = this.ep = this.kp = this.lp = this.jp = this.B = this.ac = null;\n  };\n  ue.prototype.copy = function () {\n    var a = new ue();\n    a.vn = this.vn;\n    a.As = this.As;\n    a.ff = this.ff;\n    a.ac = this.ac;\n    a.B = this.B;\n    a.jp = this.jp;\n    var b = this.lp;\n    a.lp = ya(b) && \"function\" === typeof b.G ? b.G() : b;\n    b = this.kp;\n    a.kp = ya(b) && \"function\" === typeof b.G ? b.G() : b;\n    b = this.ep;\n    a.ep = ya(b) && \"function\" === typeof b.G ? b.G() : b;\n    b = this.cp;\n    a.cp = ya(b) && \"function\" === typeof b.G ? b.G() : b;\n    return a;\n  };\n  ue.prototype.hb = function (a) {\n    a.classType === ue && (this.change = a);\n  };\n  ue.prototype.toString = function () {\n    var a = \"\";\n    a = this.change === we ? a + \"* \" : this.change === ve ? a + (null !== this.model ? \"!m\" : \"!d\") : a + ((null !== this.model ? \"!m\" : \"!d\") + this.change);\n    this.propertyName && \"string\" === typeof this.propertyName && (a += \" \" + this.propertyName);\n    this.modelChange && this.modelChange !== this.propertyName && (a += \" \" + this.modelChange);\n    a += \": \";\n    this.change === we ? null !== this.oldValue && (a += \" \" + this.oldValue) : (null !== this.object && (a += Ja(this.object)), null !== this.oldValue && (a += \"  old: \" + Ja(this.oldValue)), null !== this.oldParam && (a += \" \" + this.oldParam), null !== this.newValue && (a += \"  new: \" + Ja(this.newValue)), null !== this.newParam && (a += \" \" + this.newParam));\n    return a;\n  };\n  ue.prototype.H = function (a) {\n    return a ? this.oldValue : this.newValue;\n  };\n  ue.prototype.jA = function (a) {\n    return a ? this.oldParam : this.newParam;\n  };\n  ue.prototype.canUndo = function () {\n    return null !== this.model || null !== this.diagram ? !0 : !1;\n  };\n  ue.prototype.undo = function () {\n    this.canUndo() && (null !== this.model ? this.model.changeState(this, !0) : null !== this.diagram && this.diagram.changeState(this, !0));\n  };\n  ue.prototype.canRedo = function () {\n    return null !== this.model || null !== this.diagram ? !0 : !1;\n  };\n  ue.prototype.redo = function () {\n    this.canRedo() && (null !== this.model ? this.model.changeState(this, !1) : null !== this.diagram && this.diagram.changeState(this, !1));\n  };\n  ma.Object.defineProperties(ue.prototype, {\n    model: {\n      get: function () {\n        return this.ac;\n      },\n      set: function (a) {\n        this.ac = a;\n      }\n    },\n    diagram: {\n      get: function () {\n        return this.B;\n      },\n      set: function (a) {\n        this.B = a;\n      }\n    },\n    change: {\n      get: function () {\n        return this.vn;\n      },\n      set: function (a) {\n        this.vn = a;\n      }\n    },\n    modelChange: {\n      get: function () {\n        return this.As;\n      },\n      set: function (a) {\n        this.As = a;\n      }\n    },\n    propertyName: {\n      get: function () {\n        return this.ff;\n      },\n      set: function (a) {\n        this.ff = a;\n      }\n    },\n    isTransactionFinished: {\n      get: function () {\n        return this.vn === we && (\"CommittedTransaction\" === this.ff || \"FinishedUndo\" === this.ff || \"FinishedRedo\" === this.ff);\n      }\n    },\n    object: {\n      get: function () {\n        return this.jp;\n      },\n      set: function (a) {\n        this.jp = a;\n      }\n    },\n    oldValue: {\n      get: function () {\n        return this.lp;\n      },\n      set: function (a) {\n        this.lp = a;\n      }\n    },\n    oldParam: {\n      get: function () {\n        return this.kp;\n      },\n      set: function (a) {\n        this.kp = a;\n      }\n    },\n    newValue: {\n      get: function () {\n        return this.ep;\n      },\n      set: function (a) {\n        this.ep = a;\n      }\n    },\n    newParam: {\n      get: function () {\n        return this.cp;\n      },\n      set: function (a) {\n        this.cp = a;\n      }\n    }\n  });\n  ue.prototype.redo = ue.prototype.redo;\n  ue.prototype.canRedo = ue.prototype.canRedo;\n  ue.prototype.undo = ue.prototype.undo;\n  ue.prototype.canUndo = ue.prototype.canUndo;\n  ue.prototype.getParam = ue.prototype.jA;\n  ue.prototype.getValue = ue.prototype.H;\n  ue.prototype.clear = ue.prototype.clear;\n  var we = new D(ue, \"Transaction\", -1),\n    ve = new D(ue, \"Property\", 0),\n    xe = new D(ue, \"Insert\", 1),\n    ye = new D(ue, \"Remove\", 2);\n  ue.className = \"ChangedEvent\";\n  ue.Transaction = we;\n  ue.Property = ve;\n  ue.Insert = xe;\n  ue.Remove = ye;\n  function ze() {\n    this.v = new E().freeze();\n    this.Qa = \"\";\n    this.l = !1;\n  }\n  ze.prototype.toString = function (a) {\n    var b = \"Transaction: \" + this.name + \" \" + this.changes.count.toString() + (this.isComplete ? \"\" : \", incomplete\");\n    if (void 0 !== a && 0 < a) {\n      a = this.changes.count;\n      for (var c = 0; c < a; c++) {\n        var d = this.changes.L(c);\n        null !== d && (b += \"\\n  \" + d.toString());\n      }\n    }\n    return b;\n  };\n  ze.prototype.clear = function () {\n    var a = this.changes;\n    a.ea();\n    for (var b = a.count - 1; 0 <= b; b--) {\n      var c = a.L(b);\n      null !== c && c.clear();\n    }\n    a.clear();\n    a.freeze();\n  };\n  ze.prototype.canUndo = function () {\n    return this.isComplete;\n  };\n  ze.prototype.undo = function () {\n    if (this.canUndo()) for (var a = this.changes.count - 1; 0 <= a; a--) {\n      var b = this.changes.L(a);\n      null !== b && b.undo();\n    }\n  };\n  ze.prototype.canRedo = function () {\n    return this.isComplete;\n  };\n  ze.prototype.redo = function () {\n    if (this.canRedo()) for (var a = this.changes.count, b = 0; b < a; b++) {\n      var c = this.changes.L(b);\n      null !== c && c.redo();\n    }\n  };\n  ma.Object.defineProperties(ze.prototype, {\n    changes: {\n      get: function () {\n        return this.v;\n      }\n    },\n    name: {\n      get: function () {\n        return this.Qa;\n      },\n      set: function (a) {\n        this.Qa = a;\n      }\n    },\n    isComplete: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    }\n  });\n  ze.prototype.redo = ze.prototype.redo;\n  ze.prototype.canRedo = ze.prototype.canRedo;\n  ze.prototype.undo = ze.prototype.undo;\n  ze.prototype.canUndo = ze.prototype.canUndo;\n  ze.prototype.clear = ze.prototype.clear;\n  ze.className = \"Transaction\";\n  function Ae() {\n    this.fv = new F();\n    this.gd = !1;\n    this.I = new E().freeze();\n    this.Pd = -1;\n    this.v = 999;\n    this.oe = !1;\n    this.Nr = null;\n    this.Yi = 0;\n    this.l = !1;\n    this.ue = new E().freeze();\n    this.Nl = new E();\n    this.Ou = !0;\n    this.Vu = this.ms = this.Zu = this.Yu = !1;\n  }\n  Ae.prototype.toString = function (a) {\n    var b = \"UndoManager \" + this.historyIndex + \"<\" + this.history.count + \"<=\" + this.maxHistoryLength;\n    b += \"[\";\n    for (var c = this.nestedTransactionNames.count, d = 0; d < c; d++) 0 < d && (b += \" \"), b += this.nestedTransactionNames.L(d);\n    b += \"]\";\n    if (void 0 !== a && 0 < a) for (c = this.history.count, d = 0; d < c; d++) b += \"\\n \" + this.history.L(d).toString(a - 1);\n    return b;\n  };\n  Ae.prototype.clear = function () {\n    var a = this.history;\n    a.ea();\n    for (var b = a.count - 1; 0 <= b; b--) {\n      var c = a.L(b);\n      null !== c && c.clear();\n    }\n    a.clear();\n    this.Pd = -1;\n    a.freeze();\n    this.oe = !1;\n    this.Nr = null;\n    this.Yi = 0;\n    this.ue.ea();\n    this.ue.clear();\n    this.ue.freeze();\n    this.Nl.clear();\n    this.Vu = this.ms = this.Zu = this.Yu = !1;\n  };\n  Ae.prototype.copyProperties = function (a) {\n    this.isEnabled = a.isEnabled;\n    this.maxHistoryLength = a.maxHistoryLength;\n    this.checksTransactionLevel = a.checksTransactionLevel;\n  };\n  t = Ae.prototype;\n  t.Ux = function (a) {\n    this.fv.add(a);\n  };\n  t.My = function (a) {\n    this.fv.remove(a);\n  };\n  t.va = function (a) {\n    void 0 === a && (a = \"\");\n    null === a && (a = \"\");\n    if (this.isUndoingRedoing) return !1;\n    !0 === this.Ou && (this.Ou = !1, this.Yi++, this.isInternalTransaction || this.Bb(\"StartingFirstTransaction\", a, this.currentTransaction), 0 < this.Yi && this.Yi--);\n    this.isEnabled && (this.ue.ea(), this.ue.add(a), this.ue.freeze(), null === this.currentTransaction ? this.Nl.add(0) : this.Nl.add(this.currentTransaction.changes.count));\n    this.Yi++;\n    var b = 1 === this.transactionLevel;\n    b && (this.isInternalTransaction || this.Bb(\"StartedTransaction\", a, this.currentTransaction));\n    return b;\n  };\n  t.Wa = function (a) {\n    void 0 === a && (a = \"\");\n    return Be(this, !0, a);\n  };\n  t.Hf = function () {\n    return Be(this, !1, \"\");\n  };\n  function Be(a, b, c) {\n    if (a.isUndoingRedoing) return !1;\n    a.checksTransactionLevel && 1 > a.transactionLevel && wa(\"Ending transaction without having started a transaction: \" + c);\n    var d = 1 === a.transactionLevel,\n      e = a.currentTransaction;\n    d && b && (a.isInternalTransaction || a.Bb(\"CommittingTransaction\", c, e));\n    var f = 0;\n    if (0 < a.transactionLevel && (a.Yi--, a.isEnabled)) {\n      var g = a.ue.count;\n      0 < g && (\"\" === c && (c = a.ue.L(0)), a.ue.ea(), a.ue.bb(g - 1), a.ue.freeze());\n      g = a.Nl.count;\n      0 < g && (f = a.Nl.L(g - 1), a.Nl.bb(g - 1));\n    }\n    if (d) {\n      if (b) {\n        a.ms = !1;\n        null === e && \"\" !== c && (e = a.currentTransaction);\n        if (a.isEnabled && null !== e) {\n          e.isComplete || (e.isComplete = !0, e.name = c);\n          b = a.history;\n          b.ea();\n          for (d = b.count - 1; d > a.historyIndex; d--) f = b.L(d), null !== f && f.clear(), b.bb(d), a.ms = !0;\n          d = a.maxHistoryLength;\n          0 <= d && (0 === d ? b.clear() : b.count >= d && (f = b.L(0), null !== f && f.clear(), b.bb(0), a.Pd--));\n          0 === d || 0 !== b.count && b.get(b.count - 1) === e || (b.add(e), a.Pd++);\n          b.freeze();\n        }\n        a.isInternalTransaction || a.Bb(\"CommittedTransaction\", c, e);\n      } else {\n        a.oe = !0;\n        try {\n          a.isEnabled && null !== e && (e.isComplete = !0, e.undo());\n        } finally {\n          a.isInternalTransaction || a.Bb(\"RolledBackTransaction\", c, e), a.oe = !1;\n        }\n        null !== e && e.clear();\n      }\n      a.Nr = null;\n      a.isPendingClear && a.clear();\n      a.isPendingClear = !1;\n      a.isPendingUnmodified = !1;\n      return !0;\n    }\n    if (a.isEnabled && !b && null !== e) {\n      a = f;\n      c = e.changes;\n      for (e = c.count - 1; e >= a; e--) b = c.L(e), null !== b && b.undo(), c.ea(), c.bb(e);\n      c.freeze();\n    }\n    return !1;\n  }\n  Ae.prototype.canUndo = function () {\n    if (!this.isEnabled || 0 < this.transactionLevel) return !1;\n    var a = this.transactionToUndo;\n    return null !== a && a.canUndo() ? !0 : !1;\n  };\n  Ae.prototype.undo = function () {\n    if (this.canUndo()) {\n      var a = this.transactionToUndo;\n      try {\n        this.oe = !0, this.Bb(\"StartingUndo\", \"Undo\", a), this.Pd--, a.undo();\n      } catch (b) {\n        wa(\"undo error: \" + b.toString());\n      } finally {\n        this.Bb(\"FinishedUndo\", \"Undo\", a), this.oe = !1;\n      }\n    }\n  };\n  Ae.prototype.canRedo = function () {\n    if (!this.isEnabled || 0 < this.transactionLevel) return !1;\n    var a = this.transactionToRedo;\n    return null !== a && a.canRedo() ? !0 : !1;\n  };\n  Ae.prototype.redo = function () {\n    if (this.canRedo()) {\n      var a = this.transactionToRedo;\n      try {\n        this.oe = !0, this.Bb(\"StartingRedo\", \"Redo\", a), this.Pd++, a.redo();\n      } catch (b) {\n        wa(\"redo error: \" + b.toString());\n      } finally {\n        this.Bb(\"FinishedRedo\", \"Redo\", a), this.oe = !1;\n      }\n    }\n  };\n  Ae.prototype.Bb = function (a, b, c) {\n    void 0 === c && (c = null);\n    var d = new ue();\n    d.change = we;\n    d.propertyName = a;\n    d.object = c;\n    d.oldValue = b;\n    for (a = this.models; a.next();) b = a.value, d.model = b, b.zt(d);\n  };\n  Ae.prototype.$v = function (a) {\n    if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(a)) {\n      var b = this.currentTransaction;\n      null === b && (this.Nr = b = new ze());\n      var c = a.copy();\n      b = b.changes;\n      b.ea();\n      b.add(c);\n      b.freeze();\n      this.checksTransactionLevel && 0 >= this.transactionLevel && !this.Ou && (a = a.diagram, null !== a && !1 === a.oj || wa(\"Change not within a transaction: \" + c.toString()));\n    }\n  };\n  Ae.prototype.skipsEvent = function (a) {\n    if (null === a || 0 > a.change.value) return !0;\n    a = a.object;\n    if (null === a) return !1;\n    if (void 0 !== a.layer) {\n      if (a = a.layer, null !== a && a.isTemporary) return !0;\n    } else if (a.isTemporary) return !0;\n    return !1;\n  };\n  ma.Object.defineProperties(Ae.prototype, {\n    models: {\n      get: function () {\n        return this.fv.iterator;\n      }\n    },\n    isEnabled: {\n      get: function () {\n        return this.gd;\n      },\n      set: function (a) {\n        this.gd = a;\n      }\n    },\n    transactionToUndo: {\n      get: function () {\n        return 0 <= this.historyIndex && this.historyIndex <= this.history.count - 1 ? this.history.L(this.historyIndex) : null;\n      }\n    },\n    transactionToRedo: {\n      get: function () {\n        return this.historyIndex < this.history.count - 1 ? this.history.L(this.historyIndex + 1) : null;\n      }\n    },\n    isUndoingRedoing: {\n      get: function () {\n        return this.oe;\n      }\n    },\n    history: {\n      get: function () {\n        return this.I;\n      }\n    },\n    maxHistoryLength: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    historyIndex: {\n      get: function () {\n        return this.Pd;\n      }\n    },\n    currentTransaction: {\n      get: function () {\n        return this.Nr;\n      }\n    },\n    transactionLevel: {\n      get: function () {\n        return this.Yi;\n      }\n    },\n    isInTransaction: {\n      get: function () {\n        return 0 < this.Yi;\n      }\n    },\n    checksTransactionLevel: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    },\n    nestedTransactionNames: {\n      get: function () {\n        return this.ue;\n      }\n    },\n    isPendingClear: {\n      get: function () {\n        return this.Yu;\n      },\n      set: function (a) {\n        this.Yu = a;\n      }\n    },\n    isPendingUnmodified: {\n      get: function () {\n        return this.Zu;\n      },\n      set: function (a) {\n        this.Zu = a;\n      }\n    },\n    isInternalTransaction: {\n      get: function () {\n        return this.Vu;\n      },\n      set: function (a) {\n        this.Vu = a;\n      }\n    },\n    isJustDiscarded: {\n      get: function () {\n        return this.ms;\n      }\n    }\n  });\n  Ae.prototype.handleChanged = Ae.prototype.$v;\n  Ae.prototype.redo = Ae.prototype.redo;\n  Ae.prototype.undo = Ae.prototype.undo;\n  Ae.prototype.canUndo = Ae.prototype.canUndo;\n  Ae.prototype.rollbackTransaction = Ae.prototype.Hf;\n  Ae.prototype.commitTransaction = Ae.prototype.Wa;\n  Ae.prototype.startTransaction = Ae.prototype.va;\n  Ae.prototype.removeModel = Ae.prototype.My;\n  Ae.prototype.addModel = Ae.prototype.Ux;\n  Ae.prototype.clear = Ae.prototype.clear;\n  Ae.className = \"UndoManager\";\n  function Ce() {\n    Ya(this);\n    this.B = De;\n    this.Qa = \"\";\n    this.gd = !0;\n    this.Pc = !1;\n    this.gx = null;\n    this.hz = new re();\n    this.vt = -1;\n  }\n  Ce.prototype.toString = function () {\n    return \"\" !== this.name ? this.name + \" Tool\" : Ia(this.constructor);\n  };\n  Ce.prototype.updateAdornments = function () {};\n  Ce.prototype.canStart = function () {\n    return this.isEnabled;\n  };\n  Ce.prototype.doStart = function () {};\n  Ce.prototype.doActivate = function () {\n    this.isActive = !0;\n  };\n  Ce.prototype.doDeactivate = function () {\n    this.isActive = !1;\n  };\n  Ce.prototype.doStop = function () {};\n  Ce.prototype.doCancel = function () {\n    this.transactionResult = null;\n    this.stopTool();\n  };\n  Ce.prototype.stopTool = function () {\n    var a = this.diagram;\n    a.currentTool === this && (a.currentTool = null, a.currentCursor = \"\");\n  };\n  Ce.prototype.doMouseDown = function () {\n    !this.isActive && this.canStart() && this.doActivate();\n  };\n  Ce.prototype.doMouseMove = function () {};\n  Ce.prototype.doMouseUp = function () {\n    this.stopTool();\n  };\n  Ce.prototype.doMouseWheel = function () {};\n  Ce.prototype.canStartMultiTouch = function () {\n    return !0;\n  };\n  Ce.prototype.standardPinchZoomStart = function () {\n    var a = this.diagram,\n      b = a.lastInput,\n      c = b.Hq(0, J.allocAt(NaN, NaN)),\n      d = b.Hq(1, J.allocAt(NaN, NaN));\n    if (c.u() && d.u() && (this.doCancel(), a.xm(\"hasGestureZoom\"))) {\n      a.Pl = a.scale;\n      var e = d.x - c.x,\n        f = d.y - c.y;\n      a.sv = Math.sqrt(e * e + f * f);\n      b.bubbles = !1;\n    }\n    J.free(c);\n    J.free(d);\n  };\n  Ce.prototype.standardPinchZoomMove = function () {\n    var a = this.diagram,\n      b = a.lastInput,\n      c = b.Hq(0, J.allocAt(NaN, NaN)),\n      d = b.Hq(1, J.allocAt(NaN, NaN));\n    if (c.u() && d.u() && (this.doCancel(), a.xm(\"hasGestureZoom\"))) {\n      var e = d.x - c.x,\n        f = d.y - c.y;\n      f = Math.sqrt(e * e + f * f) / a.sv;\n      e = new J((Math.min(d.x, c.x) + Math.max(d.x, c.x)) / 2, (Math.min(d.y, c.y) + Math.max(d.y, c.y)) / 2);\n      f *= a.Pl;\n      var g = a.commandHandler;\n      if (f !== a.scale && g.canResetZoom(f)) {\n        var h = a.zoomPoint;\n        a.zoomPoint = e;\n        g.resetZoom(f);\n        a.zoomPoint = h;\n      }\n      b.bubbles = !1;\n    }\n    J.free(c);\n    J.free(d);\n  };\n  Ce.prototype.doKeyDown = function () {\n    \"Esc\" === this.diagram.lastInput.key && this.doCancel();\n  };\n  Ce.prototype.doKeyUp = function () {};\n  Ce.prototype.va = function (a) {\n    void 0 === a && (a = this.name);\n    this.transactionResult = null;\n    return this.diagram.va(a);\n  };\n  Ce.prototype.Jg = function () {\n    var a = this.diagram;\n    return null === this.transactionResult ? a.Hf() : a.Wa(this.transactionResult);\n  };\n  Ce.prototype.standardMouseSelect = function () {\n    var a = this.diagram;\n    if (a.allowSelect) {\n      var b = a.lastInput,\n        c = a.um(b.documentPoint, !1);\n      if (null !== c) {\n        if (Wa ? b.meta : b.control) {\n          a.R(\"ChangingSelection\", a.selection);\n          for (b = c; null !== b && !b.canSelect();) b = b.containingGroup;\n          null !== b && (b.isSelected = !b.isSelected);\n          a.R(\"ChangedSelection\", a.selection);\n        } else if (b.shift) {\n          if (!c.isSelected) {\n            a.R(\"ChangingSelection\", a.selection);\n            for (b = c; null !== b && !b.canSelect();) b = b.containingGroup;\n            null !== b && (b.isSelected = !0);\n            a.R(\"ChangedSelection\", a.selection);\n          }\n        } else {\n          if (!c.isSelected) {\n            for (b = c; null !== b && !b.canSelect();) b = b.containingGroup;\n            null !== b && a.select(b);\n          }\n        }\n      } else !b.left || (Wa ? b.meta : b.control) || b.shift || a.clearSelection();\n    }\n  };\n  Ce.prototype.standardMouseClick = function (a, b) {\n    void 0 === a && (a = null);\n    void 0 === b && (b = function (a) {\n      return !a.layer.isTemporary;\n    });\n    var c = this.diagram,\n      d = c.lastInput;\n    a = c.Ub(d.documentPoint, a, b);\n    d.targetObject = a;\n    Ee(a, d, c);\n    return d.handled;\n  };\n  function Ee(a, b, c) {\n    b.handled = !1;\n    if (null === a || a.Hg()) {\n      var d = 0;\n      b.left ? d = 1 === b.clickCount ? 1 : 2 === b.clickCount ? 2 : 1 : b.right && 1 === b.clickCount && (d = 3);\n      var e = \"ObjectSingleClicked\";\n      if (null !== a) {\n        switch (d) {\n          case 1:\n            e = \"ObjectSingleClicked\";\n            break;\n          case 2:\n            e = \"ObjectDoubleClicked\";\n            break;\n          case 3:\n            e = \"ObjectContextClicked\";\n        }\n        0 !== d && c.R(e, a);\n      } else {\n        switch (d) {\n          case 1:\n            e = \"BackgroundSingleClicked\";\n            break;\n          case 2:\n            e = \"BackgroundDoubleClicked\";\n            break;\n          case 3:\n            e = \"BackgroundContextClicked\";\n        }\n        0 !== d && c.R(e);\n      }\n      if (null !== a) for (; null !== a;) {\n        c = null;\n        switch (d) {\n          case 1:\n            c = a.click;\n            break;\n          case 2:\n            c = a.doubleClick ? a.doubleClick : a.click;\n            break;\n          case 3:\n            c = a.contextClick;\n        }\n        if (null !== c && (c(b, a), b.handled)) break;\n        a = a.panel;\n      } else {\n        a = null;\n        switch (d) {\n          case 1:\n            a = c.click;\n            break;\n          case 2:\n            a = c.doubleClick ? c.doubleClick : c.click;\n            break;\n          case 3:\n            a = c.contextClick;\n        }\n        null !== a && a(b);\n      }\n    }\n  }\n  Ce.prototype.standardMouseOver = function () {\n    var a = this.diagram,\n      b = a.lastInput;\n    if (!0 !== a.animationManager.rc) {\n      var c = a.skipsUndoManager;\n      a.skipsUndoManager = !0;\n      var d = a.viewportBounds.aa(b.documentPoint) ? a.Ub(b.documentPoint, null, null) : null;\n      b.targetObject = d;\n      var e = !1;\n      if (d !== a.Bj) {\n        var f = a.Bj,\n          g = f;\n        a.Bj = d;\n        this.doCurrentObjectChanged(f, d);\n        for (b.handled = !1; null !== f;) {\n          var h = f.mouseLeave;\n          if (null !== h) {\n            if (d === f) break;\n            if (null !== d && d.Gg(f)) break;\n            h(b, f, d);\n            e = !0;\n            if (b.handled) break;\n          }\n          f = f.panel;\n        }\n        f = g;\n        for (b.handled = !1; null !== d;) {\n          g = d.mouseEnter;\n          if (null !== g) {\n            if (f === d) break;\n            if (null !== f && f.Gg(d)) break;\n            g(b, d, f);\n            e = !0;\n            if (b.handled) break;\n          }\n          d = d.panel;\n        }\n        d = a.Bj;\n      }\n      if (null !== d) {\n        f = d;\n        for (g = \"\"; null !== f;) {\n          g = f.cursor;\n          if (\"\" !== g) break;\n          f = f.panel;\n        }\n        a.currentCursor = g;\n        b.handled = !1;\n        for (f = d; null !== f;) {\n          d = f.mouseOver;\n          if (null !== d && (d(b, f), e = !0, b.handled)) break;\n          f = f.panel;\n        }\n      } else a.currentCursor = \"\", d = a.mouseOver, null !== d && (d(b), e = !0);\n      e && a.Db();\n      a.skipsUndoManager = c;\n    }\n  };\n  Ce.prototype.doCurrentObjectChanged = function () {};\n  Ce.prototype.standardMouseWheel = function () {\n    var a = this.diagram,\n      b = a.lastInput,\n      c = b.delta;\n    if (0 !== c && a.documentBounds.u()) {\n      var d = a.commandHandler,\n        e = a.toolManager.mouseWheelBehavior;\n      if (null !== d && (e === Fe && !b.shift || e === Ge && b.control)) {\n        if (0 < c ? d.canIncreaseZoom() : d.canDecreaseZoom()) e = a.zoomPoint, a.zoomPoint = b.viewPoint, 0 < c ? d.increaseZoom() : d.decreaseZoom(), a.zoomPoint = e;\n        b.bubbles = !1;\n      } else if (e === Fe && b.shift || e === Ge && !b.control) {\n        d = a.position.copy();\n        var f = 0 < c ? c : -c,\n          g = b.event,\n          h = g.deltaMode;\n        e = g.deltaX;\n        g = g.deltaY;\n        if (Ta || Ua || Va) h = 1, 0 < e && (e = 3), 0 > e && (e = -3), 0 < g && (g = 3), 0 > g && (g = -3);\n        if (void 0 === h || void 0 === e || void 0 === g || 0 === e && 0 === g || b.shift) !b.shift && a.allowVerticalScroll ? (f = 3 * f * a.scrollVerticalLineChange, 0 < c ? a.scroll(\"pixel\", \"up\", f) : a.scroll(\"pixel\", \"down\", f)) : b.shift && a.allowHorizontalScroll && (f = 3 * f * a.scrollHorizontalLineChange, 0 < c ? a.scroll(\"pixel\", \"left\", f) : a.scroll(\"pixel\", \"right\", f));else {\n          switch (h) {\n            case 0:\n              c = \"pixel\";\n              break;\n            case 1:\n              c = \"line\";\n              break;\n            case 2:\n              c = \"page\";\n              break;\n            default:\n              c = \"pixel\";\n          }\n          0 !== e && a.allowHorizontalScroll && (e *= a.scrollHorizontalLineChange / 16, 0 < e ? a.scroll(c, \"left\", -e) : a.scroll(c, \"right\", e));\n          0 !== g && a.allowVerticalScroll && (g *= a.scrollVerticalLineChange / 16, 0 < g ? a.scroll(c, \"up\", -g) : a.scroll(c, \"down\", g));\n        }\n        a.position.w(d) || (b.bubbles = !1);\n      }\n    }\n  };\n  Ce.prototype.standardWaitAfter = function (a, b) {\n    void 0 === b && (b = this.diagram.lastInput);\n    this.cancelWaitAfter();\n    var c = this,\n      d = b.clone(this.hz);\n    this.vt = sa(function () {\n      c.doWaitAfter(d);\n    }, a);\n  };\n  Ce.prototype.cancelWaitAfter = function () {\n    -1 !== this.vt && x.clearTimeout(this.vt);\n    this.vt = -1;\n  };\n  Ce.prototype.doWaitAfter = function () {};\n  Ce.prototype.findToolHandleAt = function (a, b) {\n    a = this.diagram.Ub(a, function (a) {\n      for (; null !== a && !(a.panel instanceof He);) a = a.panel;\n      return a;\n    });\n    return null === a ? null : a.part.category === b ? a : null;\n  };\n  Ce.prototype.isBeyondDragSize = function (a, b) {\n    var c = this.diagram;\n    void 0 === a && (a = c.firstInput.viewPoint);\n    void 0 === b && (b = c.lastInput.viewPoint);\n    var d = c.toolManager.dragSize,\n      e = d.width;\n    d = d.height;\n    c.firstInput.isTouchEvent && (e += 6, d += 6);\n    return Math.abs(b.x - a.x) > e || Math.abs(b.y - a.y) > d;\n  };\n  ma.Object.defineProperties(Ce.prototype, {\n    diagram: {\n      get: function () {\n        return this.B;\n      },\n      set: function (a) {\n        a instanceof Q && (this.B = a);\n      }\n    },\n    name: {\n      get: function () {\n        return this.Qa;\n      },\n      set: function (a) {\n        this.Qa = a;\n      }\n    },\n    isEnabled: {\n      get: function () {\n        return this.gd;\n      },\n      set: function (a) {\n        this.gd = a;\n      }\n    },\n    isActive: {\n      get: function () {\n        return this.Pc;\n      },\n      set: function (a) {\n        this.Pc = a;\n      }\n    },\n    transactionResult: {\n      get: function () {\n        return this.gx;\n      },\n      set: function (a) {\n        this.gx = a;\n      }\n    }\n  });\n  Ce.prototype.stopTransaction = Ce.prototype.Jg;\n  Ce.prototype.startTransaction = Ce.prototype.va;\n  Ce.className = \"Tool\";\n  function Oa() {\n    Ce.call(this);\n    this.name = \"ToolManager\";\n    this.Bc = new E();\n    this.Qc = new E();\n    this.Gd = new E();\n    this.T = this.Ja = 850;\n    this.v = new M(2, 2).ca();\n    this.cb = 5E3;\n    this.Ka = Ge;\n    this.I = Me;\n    this.Mr = this.l = null;\n    this.fk = -1;\n  }\n  la(Oa, Ce);\n  Oa.prototype.initializeStandardTools = function () {};\n  Oa.prototype.updateAdornments = function (a) {\n    var b = this.currentToolTip;\n    if (b instanceof He && this.Mr === a) {\n      var c = b.adornedObject;\n      (null !== a ? c.part === a : null === c) ? this.showToolTip(b, c) : this.hideToolTip();\n    }\n  };\n  Oa.prototype.doMouseDown = function () {\n    var a = this.diagram,\n      b = a.lastInput;\n    b.isTouchEvent && this.gestureBehavior === Ne && (b.bubbles = !1);\n    if (b.isMultiTouch) {\n      this.cancelWaitAfter();\n      if (this.gestureBehavior === Oe) {\n        b.bubbles = !0;\n        return;\n      }\n      if (this.gestureBehavior === Ne) return;\n      if (a.currentTool.canStartMultiTouch()) {\n        a.currentTool.standardPinchZoomStart();\n        return;\n      }\n    }\n    for (var c = this.mouseDownTools.length, d = 0; d < c; d++) {\n      var e = this.mouseDownTools.L(d);\n      e.diagram = this.diagram;\n      if (e.canStart()) {\n        a.doFocus();\n        a.currentTool = e;\n        a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseDown());\n        return;\n      }\n    }\n    1 === a.lastInput.button && (this.mouseWheelBehavior === Ge ? this.mouseWheelBehavior = Fe : this.mouseWheelBehavior === Fe && (this.mouseWheelBehavior = Ge));\n    this.doActivate();\n    this.standardWaitAfter(this.holdDelay, b);\n  };\n  Oa.prototype.doMouseMove = function () {\n    var a = this.diagram,\n      b = a.lastInput;\n    if (b.isMultiTouch) {\n      if (this.gestureBehavior === Oe) {\n        b.bubbles = !0;\n        return;\n      }\n      if (this.gestureBehavior === Ne) return;\n      if (a.currentTool.canStartMultiTouch()) {\n        a.currentTool.standardPinchZoomMove();\n        return;\n      }\n    }\n    if (this.isActive) for (var c = this.mouseMoveTools.length, d = 0; d < c; d++) {\n      var e = this.mouseMoveTools.L(d);\n      e.diagram = this.diagram;\n      if (e.canStart()) {\n        a.doFocus();\n        a.currentTool = e;\n        a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseMove());\n        return;\n      }\n    }\n    Pe(this, a);\n    a = b.event;\n    null === a || \"mousemove\" !== a.type && \"pointermove\" !== a.type && a.cancelable || (b.bubbles = !0);\n  };\n  function Pe(a, b) {\n    a.standardMouseOver();\n    a.isBeyondDragSize() && a.standardWaitAfter(a.isActive ? a.holdDelay : a.hoverDelay, b.lastInput);\n  }\n  Oa.prototype.doCurrentObjectChanged = function (a, b) {\n    a = this.currentToolTip;\n    null === a || null !== b && a instanceof He && (b === a || b.Gg(a)) || this.hideToolTip();\n  };\n  Oa.prototype.doWaitAfter = function (a) {\n    var b = this.diagram;\n    b.ta && (this.doMouseHover(), this.isActive || this.doToolTip(), a.isTouchEvent && !b.lastInput.handled && (a = a.copy(), a.button = 2, a.buttons = 2, b.lastInput = a, b.ek = !0, b.doMouseUp()));\n  };\n  Oa.prototype.doMouseHover = function () {\n    var a = this.diagram,\n      b = a.lastInput;\n    null === b.targetObject && (b.targetObject = a.Ub(b.documentPoint, null, null));\n    var c = b.targetObject;\n    if (null !== c) for (b.handled = !1; null !== c;) {\n      a = this.isActive ? c.mouseHold : c.mouseHover;\n      if (null !== a && (a(b, c), b.handled)) break;\n      c = c.panel;\n    } else c = this.isActive ? a.mouseHold : a.mouseHover, null !== c && c(b);\n  };\n  Oa.prototype.doToolTip = function () {\n    var a = this.diagram,\n      b = a.lastInput;\n    null === b.targetObject && (b.targetObject = a.Ub(b.documentPoint, null, null));\n    b = b.targetObject;\n    if (null !== b) {\n      if (a = this.currentToolTip, !(a instanceof He) || b !== a && !b.Gg(a)) {\n        for (; null !== b;) {\n          a = b.toolTip;\n          if (null !== a) {\n            this.showToolTip(a, b);\n            return;\n          }\n          b = b.panel;\n        }\n        this.hideToolTip();\n      }\n    } else b = a.toolTip, null !== b ? this.showToolTip(b, null) : this.hideToolTip();\n  };\n  Oa.prototype.showToolTip = function (a, b) {\n    var c = this.diagram;\n    a !== this.currentToolTip && this.hideToolTip();\n    if (a instanceof He) {\n      a.layerName = \"Tool\";\n      a.selectable = !1;\n      a.scale = 1 / c.scale;\n      a.category = \"ToolTip\";\n      null !== a.placeholder && (a.placeholder.scale = c.scale);\n      var d = a.diagram;\n      null !== d && d !== c && d.remove(a);\n      c.add(a);\n      null !== b ? a.adornedObject = b : a.data = c.model;\n      a.Ta();\n      this.positionToolTip(a, b);\n    } else a instanceof Qe && a !== this.currentToolTip && a.show(b, c, this);\n    this.currentToolTip = a;\n    -1 !== this.fk && (x.clearTimeout(this.fk), this.fk = -1);\n    a = this.toolTipDuration;\n    if (0 < a && Infinity !== a) {\n      var e = this;\n      this.fk = sa(function () {\n        e.hideToolTip();\n      }, a);\n    }\n  };\n  Oa.prototype.positionToolTip = function (a) {\n    if (null === a.placeholder) {\n      var b = this.diagram,\n        c = b.lastInput.documentPoint.copy(),\n        d = a.measuredBounds,\n        e = b.viewportBounds;\n      b.lastInput.isTouchEvent && (c.x -= d.width);\n      c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale);\n      c.x < e.x && (c.x = e.x);\n      c.y = c.y + 20 / b.scale + d.height > e.bottom ? c.y - (d.height + 5 / b.scale) : c.y + 20 / b.scale;\n      c.y < e.y && (c.y = e.y);\n      a.position = c;\n    }\n  };\n  Oa.prototype.hideToolTip = function () {\n    -1 !== this.fk && (x.clearTimeout(this.fk), this.fk = -1);\n    var a = this.diagram,\n      b = this.currentToolTip;\n    null !== b && (b instanceof He ? (a.remove(b), null !== this.Mr && this.Mr.Gf(b.category), b.data = null, b.adornedObject = null) : b instanceof Qe && null !== b.hide && b.hide(a, this), this.currentToolTip = null);\n  };\n  Oa.prototype.doMouseUp = function () {\n    this.cancelWaitAfter();\n    var a = this.diagram;\n    if (this.isActive) for (var b = this.mouseUpTools.length, c = 0; c < b; c++) {\n      var d = this.mouseUpTools.L(c);\n      d.diagram = this.diagram;\n      if (d.canStart()) {\n        a.doFocus();\n        a.currentTool = d;\n        a.currentTool === d && (d.isActive || d.doActivate(), d.doMouseUp());\n        return;\n      }\n    }\n    a.doFocus();\n    this.doDeactivate();\n  };\n  Oa.prototype.doMouseWheel = function () {\n    this.standardMouseWheel();\n  };\n  Oa.prototype.doKeyDown = function () {\n    var a = this.diagram;\n    null !== a.commandHandler && a.commandHandler.doKeyDown();\n  };\n  Oa.prototype.doKeyUp = function () {\n    var a = this.diagram;\n    null !== a.commandHandler && a.commandHandler.doKeyUp();\n  };\n  Oa.prototype.findTool = function (a) {\n    for (var b = this.mouseDownTools.length, c = 0; c < b; c++) {\n      var d = this.mouseDownTools.L(c);\n      if (d.name === a) return d;\n    }\n    b = this.mouseMoveTools.length;\n    for (c = 0; c < b; c++) if (d = this.mouseMoveTools.L(c), d.name === a) return d;\n    b = this.mouseUpTools.length;\n    for (c = 0; c < b; c++) if (d = this.mouseUpTools.L(c), d.name === a) return d;\n    return null;\n  };\n  Oa.prototype.replaceTool = function (a, b) {\n    null !== b && (b.diagram = this.diagram);\n    for (var c = this.mouseDownTools.length, d = 0; d < c; d++) {\n      var e = this.mouseDownTools.L(d);\n      if (e.name === a) return null !== b ? this.mouseDownTools.nd(d, b) : this.mouseDownTools.bb(d), e;\n    }\n    c = this.mouseMoveTools.length;\n    for (d = 0; d < c; d++) if (e = this.mouseMoveTools.L(d), e.name === a) return null !== b ? this.mouseMoveTools.nd(d, b) : this.mouseMoveTools.bb(d), e;\n    c = this.mouseUpTools.length;\n    for (d = 0; d < c; d++) if (e = this.mouseUpTools.L(d), e.name === a) return null !== b ? this.mouseUpTools.nd(d, b) : this.mouseUpTools.bb(d), e;\n    return null;\n  };\n  Oa.prototype.Xa = function (a, b, c) {\n    null !== b && (b.name = a, b.diagram = this.diagram);\n    this.findTool(a) ? this.replaceTool(a, b) : null !== b && c.add(b);\n  };\n  ma.Object.defineProperties(Oa.prototype, {\n    mouseWheelBehavior: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka = a;\n      }\n    },\n    gestureBehavior: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    currentToolTip: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n        this.Mr = null !== a && a instanceof He ? a.adornedPart : null;\n      }\n    },\n    mouseDownTools: {\n      get: function () {\n        return this.Bc;\n      }\n    },\n    mouseMoveTools: {\n      get: function () {\n        return this.Qc;\n      }\n    },\n    mouseUpTools: {\n      get: function () {\n        return this.Gd;\n      }\n    },\n    hoverDelay: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja = a;\n      }\n    },\n    holdDelay: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    dragSize: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a.G();\n      }\n    },\n    toolTipDuration: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb = a;\n      }\n    }\n  });\n  Oa.prototype.replaceStandardTool = Oa.prototype.Xa;\n  var Ge = new D(Oa, \"WheelScroll\", 0),\n    Fe = new D(Oa, \"WheelZoom\", 1),\n    Re = new D(Oa, \"WheelNone\", 2),\n    Me = new D(Oa, \"GestureZoom\", 3),\n    Ne = new D(Oa, \"GestureCancel\", 4),\n    Oe = new D(Oa, \"GestureNone\", 5);\n  Oa.className = \"ToolManager\";\n  Oa.WheelScroll = Ge;\n  Oa.WheelZoom = Fe;\n  Oa.WheelNone = Re;\n  Oa.GestureZoom = Me;\n  Oa.GestureCancel = Ne;\n  Oa.GestureNone = Oe;\n  function Se() {\n    Ce.call(this);\n    this.name = \"Dragging\";\n    this.I = this.Qc = !0;\n    this.v = this.cb = this.Ja = this.pg = null;\n    this.Sn = this.Gd = !1;\n    this.dm = new J(NaN, NaN);\n    this.it = new J();\n    this.Bc = !0;\n    this.il = 100;\n    this.Wg = [];\n    this.nr = new F().freeze();\n    this.Ka = new Te();\n    this.Bo = null;\n    this.T = \"copy\";\n    this.Wh = \"\";\n    this.Xh = \"no-drop\";\n  }\n  la(Se, Ce);\n  Se.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly && !a.allowDragOut || !a.allowMove && !a.allowCopy && !a.allowDragOut || !a.allowSelect) return !1;\n    var b = a.lastInput;\n    return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.isTouchEvent && b.timestamp - a.firstInput.timestamp < this.il) ? !1 : null !== this.findDraggablePart();\n  };\n  Se.prototype.findDraggablePart = function () {\n    var a = this.diagram;\n    a = a.um(a.firstInput.documentPoint, !1);\n    if (null === a) return null;\n    for (; null !== a && !a.canSelect();) a = a.containingGroup;\n    return null !== a && (a.canMove() || a.canCopy()) ? a : null;\n  };\n  Se.prototype.standardMouseSelect = function () {\n    var a = this.diagram;\n    if (a.allowSelect) {\n      var b = a.um(a.firstInput.documentPoint, !1);\n      if (null !== b) {\n        for (; null !== b && !b.canSelect();) b = b.containingGroup;\n        this.currentPart = b;\n        null === this.currentPart || this.currentPart.isSelected || (a.R(\"ChangingSelection\", a.selection), b = a.lastInput, (Wa ? b.meta : b.control) || b.shift || a.clearSelection(!0), this.currentPart.isSelected = !0, a.R(\"ChangedSelection\", a.selection));\n      }\n    }\n  };\n  Se.prototype.doActivate = function () {\n    var a = this.diagram;\n    this.Bo = null;\n    null === this.currentPart && this.standardMouseSelect();\n    var b = this.currentPart;\n    null !== b && (b.canMove() || b.canCopy()) && (Ue = null, this.isActive = !0, this.dm.set(a.position), Ve(this, a.selection), this.Wg.length = 0, a.animationManager.Nc(), this.draggedParts = this.computeEffectiveCollection(a.selection, this.dragOptions), a.mu = !0, !0 === a.Ge(\"temporaryPixelRatio\") && 30 < a.Xx && We(a), Xe(a, this.draggedParts), this.va(\"Drag\"), this.startPoint = a.firstInput.documentPoint, a.isMouseCaptured = !0, a.allowDragOut && (this.isDragOutStarted = !0, this.Sn = !1, Ue = this, Ye = this.diagram, this.doSimulatedDragOut()));\n  };\n  function Ve(a, b) {\n    if (a.dragsLink) {\n      var c = a.diagram;\n      c.allowRelink && (c.model.xk() && 1 === b.count && b.first() instanceof S ? (a.draggedLink = b.first(), a.draggedLink.canRelinkFrom() && a.draggedLink.canRelinkTo() && a.draggedLink.kk(), a.pg = c.toolManager.findTool(\"Relinking\"), null === a.pg && (a.pg = new Ze(), a.pg.diagram = c)) : (a.draggedLink = null, a.pg = null));\n    }\n  }\n  Se.prototype.computeEffectiveCollection = function (a, b) {\n    return this.diagram.commandHandler.computeEffectiveCollection(a, b);\n  };\n  Se.prototype.xd = function (a) {\n    return void 0 === a ? new $e(Hb) : this.isGridSnapEnabled ? new $e(new J(Math.round(1E3 * a.x) / 1E3, Math.round(1E3 * a.y) / 1E3)) : new $e(a.copy());\n  };\n  Se.prototype.doDeactivate = function () {\n    this.isActive = !1;\n    var a = this.diagram;\n    a.If();\n    af(this);\n    ff(a, this.draggedParts);\n    this.draggedParts = this.currentPart = this.Bo = null;\n    this.Sn = this.isDragOutStarted = !1;\n    if (0 < gf.count) {\n      for (var b = gf, c = b.length, d = 0; d < c; d++) {\n        var e = b.L(d);\n        hf(e);\n        jf(e);\n        af(e);\n        e.diagram.If();\n      }\n      b.clear();\n    }\n    hf(this);\n    this.dm.h(NaN, NaN);\n    Ue = Ye = null;\n    jf(this);\n    a.isMouseCaptured = !1;\n    a.currentCursor = \"\";\n    a.mu = !1;\n    this.Jg();\n    kf(a, !0);\n  };\n  function af(a) {\n    var b = a.diagram,\n      c = b.skipsUndoManager;\n    b.skipsUndoManager = !0;\n    lf(a, b.lastInput, null);\n    b.skipsUndoManager = c;\n    a.Wg.length = 0;\n  }\n  function mf() {\n    var a = Ue;\n    jf(a);\n    nf(a);\n    var b = a.diagram;\n    a.dm.u() && (b.position = a.dm);\n    b.If();\n  }\n  Se.prototype.doCancel = function () {\n    jf(this);\n    nf(this);\n    var a = this.diagram;\n    this.dm.u() && (a.position = this.dm);\n    this.stopTool();\n  };\n  Se.prototype.doKeyDown = function () {\n    this.isActive && (\"Esc\" === this.diagram.lastInput.key ? this.doCancel() : this.doMouseMove());\n  };\n  Se.prototype.doKeyUp = function () {\n    this.isActive && this.doMouseMove();\n  };\n  function of(a, b) {\n    var c = Infinity,\n      d = Infinity,\n      e = -Infinity,\n      f = -Infinity;\n    for (a = a.iterator; a.next();) {\n      var g = a.value;\n      if (g.Wb() && g.isVisible()) {\n        var h = g.location;\n        g = h.x;\n        h = h.y;\n        isNaN(g) || isNaN(h) || (g < c && (c = g), h < d && (d = h), g > e && (e = g), h > f && (f = h));\n      }\n    }\n    Infinity === c ? b.h(0, 0, 0, 0) : b.h(c, d, e - c, f - d);\n  }\n  function pf(a, b) {\n    if (null === a.copiedParts) {\n      var c = a.diagram;\n      if ((!b || !c.isReadOnly && !c.isModelReadOnly) && null !== a.draggedParts) {\n        var d = c.undoManager;\n        d.isEnabled && d.isInTransaction ? null !== d.currentTransaction && 0 < d.currentTransaction.changes.count && (c.undoManager.Hf(), c.va(\"Drag\")) : nf(a);\n        c.skipsUndoManager = !b;\n        c.partManager.addsToTemporaryLayer = !b;\n        a.startPoint = c.firstInput.documentPoint;\n        b = a.copiesEffectiveCollection ? a.draggedParts.Jf() : c.selection;\n        c = c.qk(b, c, !0);\n        for (b = c.iterator; b.next();) b.value.location = b.key.location;\n        b = N.alloc();\n        of(c, b);\n        N.free(b);\n        b = new H();\n        for (d = a.draggedParts.iterator; d.next();) {\n          var e = d.key;\n          e.Wb() && e.canCopy() && (e = c.H(e), null !== e && (e.Ta(), b.add(e, a.xd(e.location))));\n        }\n        for (c = c.iterator; c.next();) d = c.value, d instanceof S && d.canCopy() && b.add(d, a.xd());\n        a.copiedParts = b;\n        Ve(a, b.Jf());\n        null !== a.draggedLink && (c = a.draggedLink, b = c.routeBounds, qf(c, a.startPoint.x - (b.x + b.width / 2), a.startPoint.y - (b.y + b.height / 2)));\n      }\n    }\n  }\n  function jf(a) {\n    var b = a.diagram;\n    if (null !== a.copiedParts && (b.gu(a.copiedParts.Jf(), !1), a.copiedParts = null, null !== a.draggedParts)) for (var c = a.draggedParts.iterator; c.next();) c.key instanceof S && (c.value.point = new J(0, 0));\n    b.skipsUndoManager = !1;\n    b.partManager.addsToTemporaryLayer = !1;\n    a.startPoint = b.firstInput.documentPoint;\n  }\n  function hf(a) {\n    if (null !== a.draggedLink) {\n      if (a.dragsLink && null !== a.pg) {\n        var b = a.pg;\n        b.diagram.remove(b.temporaryFromNode);\n        b.diagram.remove(b.temporaryToNode);\n      }\n      a.draggedLink = null;\n      a.pg = null;\n    }\n  }\n  function rf(a, b, c) {\n    var d = a.diagram,\n      e = a.startPoint,\n      f = J.alloc();\n    f.assign(d.lastInput.documentPoint);\n    a.moveParts(b, f.ce(e), c);\n    J.free(f);\n    !0 === d.Ge(\"temporaryPixelRatio\") && null === d.yh && 30 < d.Xx && (We(d), d.Zq());\n  }\n  Se.prototype.moveParts = function (a, b, c) {\n    var d = this.diagram;\n    null !== d && sf(d, a, b, this.dragOptions, c);\n  };\n  function nf(a) {\n    if (null !== a.draggedParts) {\n      for (var b = a.diagram, c = a.draggedParts.iterator; c.next();) {\n        var d = c.key;\n        d.Wb() && (d.location = c.value.point);\n      }\n      for (c = a.draggedParts.iterator; c.next();) if (d = c.key, d instanceof S && d.suspendsRouting) {\n        var e = c.value.point;\n        a.draggedParts.add(d, a.xd());\n        qf(d, -e.x, -e.y);\n      }\n      b.cd();\n    }\n  }\n  function tf(a, b) {\n    var c = a.diagram;\n    a.dragsLink && (null !== a.draggedLink && (a.draggedLink.fromNode = null, a.draggedLink.toNode = null), uf(a, !1));\n    var d = a.findDragOverObject(b),\n      e = c.lastInput;\n    e.targetObject = d;\n    a.doUpdateCursor(d);\n    var f = c.skipsUndoManager,\n      g = !1;\n    try {\n      c.skipsUndoManager = !0;\n      g = lf(a, e, d);\n      if (!a.isActive && null === Ue) return;\n      var h = null !== d ? d.part : null;\n      if (null === h || c.handlesDragDropForTopLevelParts && h.isTopLevel && !(h instanceof vf)) {\n        var k = c.mouseDragOver;\n        null !== k && (k(e), g = !0);\n      }\n      if (!a.isActive && null === Ue) return;\n      a.doDragOver(b, d);\n      if (!a.isActive && null === Ue) return;\n    } finally {\n      c.skipsUndoManager = f, g && c.cd();\n    }\n    a.Bo = d;\n    c.isReadOnly || !c.allowMove && !c.allowCopy || !c.allowHorizontalScroll && !c.allowVerticalScroll || c.Ft(e.viewPoint);\n  }\n  Se.prototype.findDragOverObject = function (a) {\n    var b = this;\n    return wf(this.diagram, a, null, function (a) {\n      null === a ? a = !0 : (a = a.part, a = null === a || a instanceof He || a.layer.isTemporary || b.draggedParts && b.draggedParts.contains(a) || b.copiedParts && b.copiedParts.contains(a) ? !0 : !1);\n      return !a;\n    });\n  };\n  Se.prototype.doUpdateCursor = function (a) {\n    var b = this.diagram;\n    this.Bo !== a && (!this.diagram.currentTool.isActive || this.mayCopy() ? b.currentCursor = this.copyCursor : this.mayMove() ? b.currentCursor = this.moveCursor : this.mayDragOut() && (b.currentCursor = this.nodropCursor));\n  };\n  function lf(a, b, c) {\n    var d = !1,\n      e = a.Wg.length,\n      f = 0 < e ? a.Wg[0] : null;\n    if (c === f) return !1;\n    b.handled = !1;\n    for (var g = 0; g < e; g++) {\n      var h = a.Wg[g],\n        k = h.mouseDragLeave;\n      if (null !== k && (k(b, h, c), d = !0, b.handled)) break;\n    }\n    a.Wg.length = 0;\n    if (!a.isActive && null === Ue || null === c) return d;\n    b.handled = !1;\n    for (e = c; null !== e;) a.Wg.push(e), e = xf(e);\n    e = a.Wg.length;\n    for (c = 0; c < e && (g = a.Wg[c], h = g.mouseDragEnter, null === h || (h(b, g, f), d = !0, !b.handled)); c++);\n    return d;\n  }\n  function xf(a) {\n    var b = a.panel;\n    return null !== b ? b : a instanceof U && !(a instanceof vf) && (a = a.containingGroup, null !== a && a.handlesDragDropForMembers) ? a : null;\n  }\n  function yf(a, b, c) {\n    var d = a.pg;\n    if (null === d) return null;\n    var e = a.diagram.Eg(b, d.portGravity, function (a) {\n      return d.findValidLinkablePort(a, c);\n    });\n    a = J.alloc();\n    var f = Infinity,\n      g = null;\n    for (e = e.iterator; e.next();) {\n      var h = e.value;\n      if (null !== h.part) {\n        var k = h.ga(Bc, a);\n        k = b.Fe(k);\n        k < f && (g = h, f = k);\n      }\n    }\n    J.free(a);\n    return g;\n  }\n  function uf(a, b) {\n    var c = a.draggedLink;\n    if (null !== c && !(2 > c.pointsCount)) {\n      var d = a.diagram;\n      if (!d.isReadOnly) {\n        var e = a.pg;\n        if (null !== e) {\n          var f = null,\n            g = null;\n          null === c.fromNode && (f = yf(a, c.i(0), !1), null !== f && (g = f.part));\n          var h = null,\n            k = null;\n          null === c.toNode && (h = yf(a, c.i(c.pointsCount - 1), !0), null !== h && (k = h.part));\n          e.isValidLink(g, f, k, h) ? b ? (c.defaultFromPoint = c.i(0), c.defaultToPoint = c.i(c.pointsCount - 1), c.suspendsRouting = !1, c.fromNode = g, null !== f && (c.fromPortId = f.portId), c.toNode = k, null !== h && (c.toPortId = h.portId), c.fromPort !== d.Hy && d.R(\"LinkRelinked\", c, d.Hy), c.toPort !== d.Iy && d.R(\"LinkRelinked\", c, d.Iy)) : zf(e, g, f, k, h) : zf(e, null, null, null, null);\n        }\n      }\n    }\n  }\n  Se.prototype.doDragOver = function () {};\n  function Af(a, b) {\n    var c = a.diagram;\n    a.dragsLink && uf(a, !0);\n    af(a);\n    var d = a.findDragOverObject(b),\n      e = c.lastInput;\n    e.targetObject = d;\n    if (null !== d) {\n      e.handled = !1;\n      for (var f = d; null !== f;) {\n        var g = f.mouseDrop;\n        if (null !== g && (g(e, f), e.handled)) break;\n        Gf(a, e, f);\n        f = xf(f);\n      }\n    } else f = c.mouseDrop, null !== f && f(e);\n    if (a.isActive || null !== Ue) {\n      for (e = (a.copiedParts || a.draggedParts).iterator; e.next();) f = e.key, f instanceof V && f.linksConnected.each(function (a) {\n        a.suspendsRouting = !1;\n      });\n      a.doDropOnto(b, d);\n      if (a.isActive || null !== Ue) {\n        a = N.alloc();\n        for (b = c.selection.iterator; b.next();) d = b.value, d instanceof V && Hf(c, d, a);\n        N.free(a);\n      }\n    }\n  }\n  function Gf(a, b, c) {\n    a = a.diagram;\n    c = c.part;\n    !a.handlesDragDropForTopLevelParts || !c.isTopLevel || c instanceof vf || (c = a.mouseDrop, null !== c && c(b));\n  }\n  function Hf(a, b, c) {\n    var d = !1;\n    b.getAvoidableRect(c);\n    a.viewportBounds.De(c) && (d = !0);\n    a = a.Uv(c, function (a) {\n      return a.part;\n    }, function (a) {\n      return a instanceof S;\n    }, !0, function (a) {\n      return a instanceof S;\n    }, d);\n    if (0 !== a.count) for (a = a.iterator; a.next();) c = a.value, !c.Cd(b) && c.isAvoiding && c.Ua();\n  }\n  Se.prototype.doDropOnto = function () {};\n  Se.prototype.doMouseMove = function () {\n    if (this.isActive) {\n      var a = this.diagram,\n        b = a.lastInput;\n      this.simulatedMouseMove(b.event, b.documentPoint, b.targetDiagram) || null === this.currentPart || null === this.draggedParts || (this.mayCopy() ? (pf(this, !1), Xe(a, this.copiedParts), rf(this, this.copiedParts, !1), ff(a, this.copiedParts)) : this.mayMove() ? (jf(this), rf(this, this.draggedParts, !0)) : this.mayDragOut() ? (pf(this, !1), rf(this, this.copiedParts, !1)) : jf(this), tf(this, a.lastInput.documentPoint));\n    }\n  };\n  Se.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram,\n        b = a.lastInput;\n      if (!this.simulatedMouseUp(b.event, b.documentPoint, b.targetDiagram)) {\n        b = !1;\n        var c = this.mayCopy();\n        c && null !== this.copiedParts ? (jf(this), pf(this, !0), Xe(a, this.copiedParts), rf(this, this.copiedParts, !1), ff(a, this.copiedParts), null !== this.copiedParts && (a.R(\"ChangingSelection\", a.selection), a.clearSelection(!0), this.copiedParts.iteratorKeys.each(function (a) {\n          a.isSelected = !0;\n        }))) : (b = !0, jf(this), this.mayMove() && (rf(this, this.draggedParts, !0), tf(this, a.lastInput.documentPoint)));\n        this.Sn = !0;\n        Af(this, a.lastInput.documentPoint);\n        if (this.isActive) {\n          var d = c ? this.copiedParts.Jf() : this.draggedParts.Jf();\n          this.copiedParts = null;\n          b && If(this);\n          a.Oa();\n          ff(a, this.draggedParts);\n          this.transactionResult = c ? \"Copy\" : \"Move\";\n          a.R(c ? \"SelectionCopied\" : \"SelectionMoved\", d);\n        }\n        this.stopTool();\n        c && a.R(\"ChangedSelection\", a.selection);\n      }\n    }\n  };\n  Se.prototype.simulatedMouseMove = function (a, b, c) {\n    if (null === Ue) return !1;\n    var d = Ue.diagram;\n    c instanceof Q || (c = null);\n    var e = Ye;\n    c !== e && (null !== e && e !== d && (e.If(), Ue.isDragOutStarted = !1, e = e.toolManager.findTool(\"Dragging\"), null !== e && e.doSimulatedDragLeave()), Ye = c, null !== c && c !== d && (mf(), e = c.toolManager.findTool(\"Dragging\"), null !== e && (gf.contains(e) || gf.add(e), e.doSimulatedDragEnter())));\n    if (null === c || c === d || !c.allowDrop || c.isReadOnly || !c.allowInsert) return !1;\n    d = c.toolManager.findTool(\"Dragging\");\n    null !== d && (null !== a && (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length && (a = a.changedTouches[0])), b = c.getMouse(a)), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.ir(b), c.lastInput.down = !1, c.lastInput.up = !1, d.doSimulatedDragOver());\n    return !0;\n  };\n  Se.prototype.simulatedMouseUp = function (a, b, c) {\n    if (null === Ue) return !1;\n    var d = Ye,\n      e = Ue.diagram;\n    if (null === c) return Ue.doCancel(), !0;\n    if (c !== d) {\n      var f = d.toolManager.findTool(\"Dragging\");\n      if (null !== d && d !== e && null !== f) return d.If(), Ue.isDragOutStarted = !1, f.doSimulatedDragLeave(), !1;\n      Ye = c;\n      d = c.toolManager.findTool(\"Dragging\");\n      null !== d && (mf(), gf.contains(d) || gf.add(d), d.doSimulatedDragEnter());\n    }\n    return c !== this.diagram ? (null !== a ? (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length && (a = a.changedTouches[0])), b = c.getMouse(a)) : null === b && (b = new J()), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.ir(b), c.lastInput.down = !1, c.lastInput.up = !0, a = c.toolManager.findTool(\"Dragging\"), null !== a && a.doSimulatedDrop(), a = Ue, null !== a && (c = a.mayCopy(), a.transactionResult = c ? \"Copy\" : \"Move\", a.stopTool()), !0) : !1;\n  };\n  function If(a) {\n    if (null !== a.draggedParts) for (var b = a.draggedParts.iterator; b.next();) {\n      var c = b.key;\n      c instanceof V && (c = c.containingGroup, null === c || null === c.placeholder || a.draggedParts.contains(c) || c.placeholder.o());\n    }\n  }\n  Se.prototype.mayCopy = function () {\n    if (!this.isCopyEnabled) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowCopy || (Wa ? !a.lastInput.alt : !a.lastInput.control)) return !1;\n    for (a = a.selection.iterator; a.next();) {\n      var b = a.value;\n      if (b.Wb() && b.canCopy()) return !0;\n    }\n    return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1;\n  };\n  Se.prototype.mayDragOut = function () {\n    if (!this.isCopyEnabled) return !1;\n    var a = this.diagram;\n    if (!a.allowDragOut || !a.allowCopy || a.allowMove) return !1;\n    for (a = a.selection.iterator; a.next();) {\n      var b = a.value;\n      if (b.Wb() && b.canCopy()) return !0;\n    }\n    return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1;\n  };\n  Se.prototype.mayMove = function () {\n    var a = this.diagram;\n    if (a.isReadOnly || !a.allowMove) return !1;\n    for (a = a.selection.iterator; a.next();) {\n      var b = a.value;\n      if (b.Wb() && b.canMove()) return !0;\n    }\n    return null !== this.draggedLink && this.dragsLink && this.draggedLink.canMove() ? !0 : !1;\n  };\n  Se.prototype.computeBorder = function (a, b, c) {\n    return this.Sn || null === this.draggedParts || this.draggedParts.contains(a) ? null : c.assign(b);\n  };\n  Se.prototype.gA = function () {\n    return Ue;\n  };\n  Se.prototype.mayDragIn = function () {\n    var a = this.diagram;\n    if (!a.allowDrop || a.isReadOnly || a.isModelReadOnly || !a.allowInsert) return !1;\n    var b = Ue;\n    return null === b || b.diagram.model.dataFormat !== a.model.dataFormat ? !1 : !0;\n  };\n  Se.prototype.doSimulatedDragEnter = function () {\n    if (this.mayDragIn()) {\n      var a = this.diagram;\n      a.animationManager.Nc();\n      Jf(a);\n      a.animationManager.Nc();\n      var b = Ue;\n      null !== b && (b.diagram.mu = !1);\n      this.doUpdateCursor(a.grid);\n    }\n  };\n  Se.prototype.doSimulatedDragLeave = function () {\n    var a = Ue;\n    null !== a && a.doSimulatedDragOut();\n    this.doCancel();\n  };\n  Se.prototype.doSimulatedDragOver = function () {\n    var a = this.diagram;\n    a.animationManager.sn = !0;\n    var b = Ue;\n    if (null !== b && null !== b.draggedParts) {\n      if (!this.mayDragIn()) return;\n      Kf(this, b.draggedParts.Jf(), !1, a.firstInput);\n      rf(this, this.copiedParts, !1);\n      tf(this, a.lastInput.documentPoint);\n    }\n    a.animationManager.sn = !1;\n  };\n  Se.prototype.doSimulatedDrop = function () {\n    var a = this.diagram,\n      b = Ue;\n    if (null !== b) {\n      var c = b.diagram;\n      b.Sn = !0;\n      jf(this);\n      if (!this.mayDragIn()) return;\n      a.animationManager.sn = !0;\n      a.R(\"ChangingSelection\", a.selection);\n      this.va(\"Drop\");\n      Kf(this, b.draggedParts.Jf(), !0, a.lastInput);\n      rf(this, this.copiedParts, !1);\n      null !== this.copiedParts && (a.clearSelection(!0), this.copiedParts.iteratorKeys.each(function (a) {\n        a.isSelected = !0;\n      }));\n      Af(this, a.lastInput.documentPoint);\n      a.Oa();\n      b = a.selection;\n      null !== this.copiedParts ? this.transactionResult = \"ExternalCopy\" : b = new F();\n      this.copiedParts = null;\n      a.doFocus();\n      a.R(\"ExternalObjectsDropped\", b, c);\n      this.Jg();\n      a.R(\"ChangedSelection\", a.selection);\n    }\n    a.animationManager.sn = !1;\n  };\n  function Kf(a, b, c, d) {\n    if (null === a.copiedParts) {\n      var e = a.diagram;\n      if (!e.isReadOnly && !e.isModelReadOnly) {\n        e.skipsUndoManager = !c;\n        e.partManager.addsToTemporaryLayer = !c;\n        a.startPoint = d.documentPoint;\n        c = e.qk(b, e, !0);\n        var f = N.alloc();\n        of(b, f);\n        d = f.x + f.width / 2;\n        e = f.y + f.height / 2;\n        N.free(f);\n        f = a.it;\n        var g = new H(),\n          h = J.alloc();\n        for (b = b.iterator; b.next();) {\n          var k = b.value,\n            l = c.H(k);\n          k.Wb() && k.canCopy() ? (k = k.location, h.h(f.x - (d - k.x), f.y - (e - k.y)), l.location = h, l.Ta(), g.add(l, a.xd(h))) : l instanceof S && k.canCopy() && (qf(l, f.x - d, f.y - e), g.add(l, a.xd()));\n        }\n        J.free(h);\n        a.copiedParts = g;\n        Ve(a, g.Jf());\n        null !== a.draggedLink && (c = a.draggedLink, d = c.routeBounds, qf(c, a.startPoint.x - (d.x + d.width / 2), a.startPoint.y - (d.y + d.height / 2)));\n      }\n    }\n  }\n  Se.prototype.doSimulatedDragOut = function () {\n    var a = this.diagram;\n    a.mu = !1;\n    this.mayCopy() || this.mayMove() ? a.currentCursor = \"\" : a.currentCursor = this.nodropCursor;\n    this.Bo = null;\n  };\n  Se.prototype.computeMove = function (a, b, c, d) {\n    c = this.diagram;\n    return null !== c ? c.computeMove(a, b, this.dragOptions, d) : new J();\n  };\n  ma.Object.defineProperties(Se.prototype, {\n    isCopyEnabled: {\n      get: function () {\n        return this.Qc;\n      },\n      set: function (a) {\n        this.Qc = a;\n      }\n    },\n    copiesEffectiveCollection: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    dragOptions: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka = a;\n      }\n    },\n    isGridSnapEnabled: {\n      get: function () {\n        return this.dragOptions.isGridSnapEnabled;\n      },\n      set: function (a) {\n        this.dragOptions.isGridSnapEnabled = a;\n      }\n    },\n    isComplexRoutingRealtime: {\n      get: function () {\n        return this.Bc;\n      },\n      set: function (a) {\n        this.Bc = a;\n      }\n    },\n    isGridSnapRealtime: {\n      get: function () {\n        return this.dragOptions.isGridSnapRealtime;\n      },\n      set: function (a) {\n        this.dragOptions.isGridSnapRealtime = a;\n      }\n    },\n    gridSnapCellSize: {\n      get: function () {\n        return this.dragOptions.gridSnapCellSize;\n      },\n      set: function (a) {\n        this.dragOptions.gridSnapCellSize.w(a) || (a = a.G(), this.dragOptions.gridSnapCellSize = a);\n      }\n    },\n    gridSnapCellSpot: {\n      get: function () {\n        return this.dragOptions.gridSnapCellSpot;\n      },\n      set: function (a) {\n        this.dragOptions.gridSnapCellSpot.w(a) || (a = a.G(), this.dragOptions.gridSnapCellSpot = a);\n      }\n    },\n    gridSnapOrigin: {\n      get: function () {\n        return this.dragOptions.gridSnapOrigin;\n      },\n      set: function (a) {\n        this.dragOptions.gridSnapOrigin.w(a) || (a = a.G(), this.dragOptions.gridSnapOrigin = a);\n      }\n    },\n    dragsLink: {\n      get: function () {\n        return this.dragOptions.dragsLink;\n      },\n      set: function (a) {\n        this.dragOptions.dragsLink = a;\n      }\n    },\n    dragsTree: {\n      get: function () {\n        return this.dragOptions.dragsTree;\n      },\n      set: function (a) {\n        this.dragOptions.dragsTree = a;\n      }\n    },\n    copyCursor: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    moveCursor: {\n      get: function () {\n        return this.Wh;\n      },\n      set: function (a) {\n        this.Wh = a;\n      }\n    },\n    nodropCursor: {\n      get: function () {\n        return this.Xh;\n      },\n      set: function (a) {\n        this.Xh = a;\n      }\n    },\n    currentPart: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja = a;\n      }\n    },\n    copiedParts: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    draggedParts: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb = a;\n      }\n    },\n    draggingParts: {\n      get: function () {\n        return null !== this.copiedParts ? this.copiedParts.Jf() : null !== this.draggedParts ? this.draggedParts.Jf() : this.nr;\n      }\n    },\n    draggedLink: {\n      get: function () {\n        return this.diagram.draggedLink;\n      },\n      set: function (a) {\n        this.diagram.draggedLink = a;\n      }\n    },\n    isDragOutStarted: {\n      get: function () {\n        return this.Gd;\n      },\n      set: function (a) {\n        this.Gd = a;\n      }\n    },\n    startPoint: {\n      get: function () {\n        return this.it;\n      },\n      set: function (a) {\n        this.it.w(a) || this.it.assign(a);\n      }\n    },\n    delay: {\n      get: function () {\n        return this.il;\n      },\n      set: function (a) {\n        this.il = a;\n      }\n    }\n  });\n  Se.prototype.getDraggingSource = Se.prototype.gA;\n  var gf = null,\n    Ue = null,\n    Ye = null;\n  Se.className = \"DraggingTool\";\n  gf = new E();\n  La(\"draggingTool\", function () {\n    return this.findTool(\"Dragging\");\n  }, function (a) {\n    this.Xa(\"Dragging\", a, this.mouseMoveTools);\n  });\n  Oa.prototype.doCancel = function () {\n    null !== Ue && Ue.doCancel();\n    Ce.prototype.doCancel.call(this);\n  };\n  function Lf() {\n    Ce.call(this);\n    this.Xh = 100;\n    this.Ka = !1;\n    this.oi = \"pointer\";\n    var a = new S(),\n      b = new W();\n    b.isPanelMain = !0;\n    b.stroke = \"blue\";\n    a.add(b);\n    b = new W();\n    b.toArrow = \"Standard\";\n    b.fill = \"blue\";\n    b.stroke = \"blue\";\n    a.add(b);\n    a.layerName = \"Tool\";\n    this.bx = a;\n    a = new V();\n    b = new W();\n    b.portId = \"\";\n    b.figure = \"Rectangle\";\n    b.fill = null;\n    b.stroke = \"magenta\";\n    b.strokeWidth = 2;\n    b.desiredSize = Nb;\n    a.add(b);\n    a.selectable = !1;\n    a.layerName = \"Tool\";\n    this.ax = a;\n    this.l = b;\n    a = new V();\n    b = new W();\n    b.portId = \"\";\n    b.figure = \"Rectangle\";\n    b.fill = null;\n    b.stroke = \"magenta\";\n    b.strokeWidth = 2;\n    b.desiredSize = Nb;\n    a.add(b);\n    a.selectable = !1;\n    a.layerName = \"Tool\";\n    this.ex = a;\n    this.v = b;\n    this.Wh = this.Gd = this.Bc = this.cb = this.Qc = null;\n    this.Ja = !0;\n    this.$y = new H();\n    this.nr = this.Hi = this.$w = null;\n  }\n  la(Lf, Ce);\n  Lf.prototype.doStop = function () {\n    this.diagram.If();\n    this.originalToPort = this.originalToNode = this.originalFromPort = this.originalFromNode = this.originalLink = null;\n    this.validPortsCache.clear();\n    this.targetPort = null;\n  };\n  Lf.prototype.copyPortProperties = function (a, b, c, d, e) {\n    if (null !== a && null !== b && null !== c && null !== d) {\n      var f = b.Af(),\n        g = M.alloc();\n      g.width = b.naturalBounds.width * f;\n      g.height = b.naturalBounds.height * f;\n      d.desiredSize = g;\n      M.free(g);\n      e ? (d.toSpot = b.toSpot, d.toEndSegmentLength = b.toEndSegmentLength) : (d.fromSpot = b.fromSpot, d.fromEndSegmentLength = b.fromEndSegmentLength);\n      c.locationSpot = Bc;\n      f = J.alloc();\n      c.location = b.ga(Bc, f);\n      J.free(f);\n      d.angle = b.lj();\n      null !== this.portTargeted && this.portTargeted(a, b, c, d, e);\n    }\n  };\n  Lf.prototype.setNoTargetPortProperties = function (a, b, c) {\n    null !== b && (b.desiredSize = Nb, b.fromSpot = vc, b.toSpot = vc);\n    null !== a && (a.location = this.diagram.lastInput.documentPoint);\n    null !== this.portTargeted && this.portTargeted(null, null, a, b, c);\n  };\n  Lf.prototype.doMouseDown = function () {\n    this.isActive && this.doMouseMove();\n  };\n  Lf.prototype.doMouseMove = function () {\n    if (this.isActive) {\n      var a = this.diagram;\n      this.targetPort = this.findTargetPort(this.isForwards);\n      if (null !== this.targetPort && this.targetPort.part instanceof V) {\n        var b = this.targetPort.part;\n        this.isForwards ? this.copyPortProperties(b, this.targetPort, this.temporaryToNode, this.temporaryToPort, !0) : this.copyPortProperties(b, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, !1);\n      } else this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort, !0) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, !1);\n      (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Ft(a.lastInput.viewPoint);\n    }\n  };\n  Lf.prototype.findValidLinkablePort = function (a, b) {\n    if (null === a) return null;\n    var c = a.part;\n    if (!(c instanceof V)) return null;\n    for (; null !== a;) {\n      var d = b ? a.toLinkable : a.fromLinkable;\n      if (!0 === d && (null !== a.portId || a instanceof V) && (b ? this.isValidTo(c, a) : this.isValidFrom(c, a))) return a;\n      if (!1 === d) break;\n      a = a.panel;\n    }\n    return null;\n  };\n  Lf.prototype.findTargetPort = function (a) {\n    var b = this.diagram,\n      c = b.lastInput.documentPoint,\n      d = this.portGravity;\n    0 >= d && (d = .1);\n    var e = this,\n      f = b.Eg(c, d, function (b) {\n        return e.findValidLinkablePort(b, a);\n      }, null, !0);\n    d = Infinity;\n    b = null;\n    for (f = f.iterator; f.next();) {\n      var g = f.value,\n        h = g.part;\n      if (h instanceof V) {\n        var k = g.ga(Bc, J.alloc()),\n          l = c.x - k.x,\n          m = c.y - k.y;\n        J.free(k);\n        k = l * l + m * m;\n        k < d && (l = this.validPortsCache.H(g), null !== l ? l && (b = g, d = k) : a && this.isValidLink(this.originalFromNode, this.originalFromPort, h, g) || !a && this.isValidLink(h, g, this.originalToNode, this.originalToPort) ? (this.validPortsCache.add(g, !0), b = g, d = k) : this.validPortsCache.add(g, !1));\n      }\n    }\n    return null !== b && (c = b.part, c instanceof V && (null === c.layer || c.layer.allowLink)) ? b : null;\n  };\n  Lf.prototype.isValidFrom = function (a, b) {\n    if (null === a || null === b) return this.isUnconnectedLinkValid;\n    if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.fromLinkable)) return !1;\n    var c = b.fromMaxLinks;\n    if (Infinity > c) {\n      if (null !== this.originalLink && a === this.originalFromNode && b === this.originalFromPort) return !0;\n      b = b.portId;\n      null === b && (b = \"\");\n      if (a.Dq(b).count >= c) return !1;\n    }\n    return !0;\n  };\n  Lf.prototype.isValidTo = function (a, b) {\n    if (null === a || null === b) return this.isUnconnectedLinkValid;\n    if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.toLinkable)) return !1;\n    var c = b.toMaxLinks;\n    if (Infinity > c) {\n      if (null !== this.originalLink && a === this.originalToNode && b === this.originalToPort) return !0;\n      b = b.portId;\n      null === b && (b = \"\");\n      if (a.Bd(b).count >= c) return !1;\n    }\n    return !0;\n  };\n  Lf.prototype.isInSameNode = function (a, b) {\n    if (null === a || null === b) return !1;\n    if (a === b) return !0;\n    a = a.part;\n    b = b.part;\n    return null !== a && a === b;\n  };\n  Lf.prototype.isLinked = function (a, b) {\n    if (null === a || null === b) return !1;\n    var c = a.part;\n    if (!(c instanceof V)) return !1;\n    a = a.portId;\n    null === a && (a = \"\");\n    var d = b.part;\n    if (!(d instanceof V)) return !1;\n    b = b.portId;\n    null === b && (b = \"\");\n    for (b = d.Bd(b); b.next();) if (d = b.value, d.fromNode === c && d.fromPortId === a) return !0;\n    return !1;\n  };\n  Lf.prototype.isValidLink = function (a, b, c, d) {\n    if (!this.isValidFrom(a, b) || !this.isValidTo(c, d) || !(null === b || null === d || (b.fromLinkableSelfNode && d.toLinkableSelfNode || !this.isInSameNode(b, d)) && (b.fromLinkableDuplicates && d.toLinkableDuplicates || !this.isLinked(b, d))) || null !== this.originalLink && (null !== a && this.isLabelDependentOnLink(a, this.originalLink) || null !== c && this.isLabelDependentOnLink(c, this.originalLink)) || null !== a && null !== c && (null === a.data && null !== c.data || null !== a.data && null === c.data) || !this.isValidCycle(a, c, this.originalLink)) return !1;\n    if (null !== a) {\n      var e = a.linkValidation;\n      if (null !== e && !e(a, b, c, d, this.originalLink)) return !1;\n    }\n    if (null !== c && (e = c.linkValidation, null !== e && !e(a, b, c, d, this.originalLink))) return !1;\n    e = this.linkValidation;\n    return null !== e ? e(a, b, c, d, this.originalLink) : !0;\n  };\n  Lf.prototype.isLabelDependentOnLink = function (a, b) {\n    if (null === a) return !1;\n    var c = a.labeledLink;\n    if (null === c) return !1;\n    if (c === b) return !0;\n    var d = new F();\n    d.add(a);\n    return Mf(this, c, b, d);\n  };\n  function Mf(a, b, c, d) {\n    if (b === c) return !0;\n    var e = b.fromNode;\n    if (null !== e && e.isLinkLabel && (d.add(e), Mf(a, e.labeledLink, c, d))) return !0;\n    b = b.toNode;\n    return null !== b && b.isLinkLabel && (d.add(b), Mf(a, b.labeledLink, c, d)) ? !0 : !1;\n  }\n  Lf.prototype.isValidCycle = function (a, b, c) {\n    void 0 === c && (c = null);\n    if (null === a || null === b) return this.isUnconnectedLinkValid;\n    var d = this.diagram.validCycle;\n    if (d !== Nf) {\n      if (d === Of) {\n        d = c || this.temporaryLink;\n        if (null !== d && !d.isTreeLink) return !0;\n        for (d = b.linksConnected; d.next();) {\n          var e = d.value;\n          if (e !== c && e.isTreeLink && e.toNode === b) return !1;\n        }\n        return !Pf(this, a, b, c, !0);\n      }\n      if (d === Qf) {\n        d = c || this.temporaryLink;\n        if (null !== d && !d.isTreeLink) return !0;\n        for (d = a.linksConnected; d.next();) if (e = d.value, e !== c && e.isTreeLink && e.fromNode === a) return !1;\n        return !Pf(this, a, b, c, !0);\n      }\n      if (d === Rf) return a === b ? a = !0 : (d = new F(), d.add(b), a = Sf(this, d, a, b, c)), !a;\n      if (d === Tf) return !Pf(this, a, b, c, !1);\n      if (d === Uf) return a === b ? a = !0 : (d = new F(), d.add(b), a = Vf(this, d, a, b, c)), !a;\n    }\n    return !0;\n  };\n  function Pf(a, b, c, d, e) {\n    if (b === c) return !0;\n    if (null === b || null === c) return !1;\n    for (var f = b.linksConnected; f.next();) {\n      var g = f.value;\n      if (g !== d && (!e || g.isTreeLink) && g.toNode === b && (g = g.fromNode, g !== b && Pf(a, g, c, d, e))) return !0;\n    }\n    return !1;\n  }\n  function Sf(a, b, c, d, e) {\n    if (c === d) return !0;\n    if (null === c || null === d || b.contains(c)) return !1;\n    b.add(c);\n    for (var f = c.linksConnected; f.next();) {\n      var g = f.value;\n      if (g !== e && g.toNode === c && (g = g.fromNode, g !== c && Sf(a, b, g, d, e))) return !0;\n    }\n    return !1;\n  }\n  function Vf(a, b, c, d, e) {\n    if (c === d) return !0;\n    if (null === c || null === d || b.contains(c)) return !1;\n    b.add(c);\n    for (var f = c.linksConnected; f.next();) {\n      var g = f.value;\n      if (g !== e) {\n        var h = g.fromNode;\n        g = g.toNode;\n        h = h === c ? g : h;\n        if (h !== c && Vf(a, b, h, d, e)) return !0;\n      }\n    }\n    return !1;\n  }\n  ma.Object.defineProperties(Lf.prototype, {\n    portGravity: {\n      get: function () {\n        return this.Xh;\n      },\n      set: function (a) {\n        0 <= a && (this.Xh = a);\n      }\n    },\n    isUnconnectedLinkValid: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka = a;\n      }\n    },\n    linkingCursor: {\n      get: function () {\n        return this.oi;\n      },\n      set: function (a) {\n        this.oi = a;\n      }\n    },\n    temporaryLink: {\n      get: function () {\n        return this.bx;\n      },\n      set: function (a) {\n        this.bx = a;\n      }\n    },\n    temporaryFromNode: {\n      get: function () {\n        return this.ax;\n      },\n      set: function (a) {\n        if (this.ax = a) this.l = a.port;\n      }\n    },\n    temporaryFromPort: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        if (null !== this.l) {\n          var b = this.l.panel;\n          if (null !== b) {\n            var c = b.W.indexOf(this.l);\n            b.bb(c);\n            b.vb(c, a);\n          }\n        }\n        this.l = a;\n      }\n    },\n    temporaryToNode: {\n      get: function () {\n        return this.ex;\n      },\n      set: function (a) {\n        if (this.ex = a) this.v = a.port;\n      }\n    },\n    temporaryToPort: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        if (null !== this.v) {\n          var b = this.v.panel;\n          if (null !== b) {\n            var c = b.W.indexOf(this.v);\n            b.bb(c);\n            b.vb(c, a);\n          }\n        }\n        this.v = a;\n      }\n    },\n    originalLink: {\n      get: function () {\n        return this.Qc;\n      },\n      set: function (a) {\n        this.Qc = a;\n      }\n    },\n    originalFromNode: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb = a;\n      }\n    },\n    originalFromPort: {\n      get: function () {\n        return this.Bc;\n      },\n      set: function (a) {\n        this.Bc = a;\n      }\n    },\n    originalToNode: {\n      get: function () {\n        return this.Gd;\n      },\n      set: function (a) {\n        this.Gd = a;\n      }\n    },\n    originalToPort: {\n      get: function () {\n        return this.Wh;\n      },\n      set: function (a) {\n        this.Wh = a;\n      }\n    },\n    isForwards: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja = a;\n      }\n    },\n    validPortsCache: {\n      get: function () {\n        return this.$y;\n      }\n    },\n    targetPort: {\n      get: function () {\n        return this.$w;\n      },\n      set: function (a) {\n        this.$w = a;\n      }\n    },\n    linkValidation: {\n      get: function () {\n        return this.Hi;\n      },\n      set: function (a) {\n        this.Hi = a;\n      }\n    },\n    portTargeted: {\n      get: function () {\n        return this.nr;\n      },\n      set: function (a) {\n        this.nr = a;\n      }\n    }\n  });\n  Lf.className = \"LinkingBaseTool\";\n  function Wf() {\n    Lf.call(this);\n    this.name = \"Linking\";\n    this.T = {};\n    this.I = null;\n    this.J = Xf;\n    this.cn = null;\n  }\n  la(Wf, Lf);\n  Wf.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly || !a.allowLink || !a.model.Ut() || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : null !== this.findLinkablePort();\n  };\n  Wf.prototype.findLinkablePort = function () {\n    var a = this.diagram,\n      b = this.startObject;\n    null === b && (b = a.Ub(a.firstInput.documentPoint, null, null));\n    if (null === b || !(b.part instanceof V)) return null;\n    a = this.direction;\n    if (a === Xf || a === Yf) {\n      var c = this.findValidLinkablePort(b, !1);\n      if (null !== c) return this.isForwards = !0, c;\n    }\n    if (a === Xf || a === Zf) if (b = this.findValidLinkablePort(b, !0), null !== b) return this.isForwards = !1, b;\n    return null;\n  };\n  Wf.prototype.doActivate = function () {\n    var a = this.diagram,\n      b = this.findLinkablePort();\n    null !== b && (this.va(this.name), a.isMouseCaptured = !0, a.currentCursor = this.linkingCursor, this.isForwards ? (null === this.temporaryToNode || this.temporaryToNode.location.u() || (this.temporaryToNode.location = a.lastInput.documentPoint), this.originalFromPort = b, b = this.originalFromPort.part, b instanceof V && (this.originalFromNode = b), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1)) : (null === this.temporaryFromNode || this.temporaryFromNode.location.u() || (this.temporaryFromNode.location = a.lastInput.documentPoint), this.originalToPort = b, b = this.originalToPort.part, b instanceof V && (this.originalToNode = b), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0)), a.add(this.temporaryFromNode), a.add(this.temporaryToNode), null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.Ua(), a.add(this.temporaryLink)), this.isActive = !0);\n  };\n  Wf.prototype.doDeactivate = function () {\n    this.isActive = !1;\n    var a = this.diagram;\n    a.remove(this.temporaryLink);\n    a.remove(this.temporaryFromNode);\n    a.remove(this.temporaryToNode);\n    a.isMouseCaptured = !1;\n    a.currentCursor = \"\";\n    this.Jg();\n  };\n  Wf.prototype.doStop = function () {\n    Lf.prototype.doStop.call(this);\n    this.startObject = null;\n  };\n  Wf.prototype.doMouseUp = function () {\n    var a = this.diagram;\n    if (this.isActive) {\n      var b = this.transactionResult = null,\n        c = null,\n        d = null,\n        e = null,\n        f = null;\n      try {\n        var g = this.targetPort = this.findTargetPort(this.isForwards);\n        if (null !== g) {\n          var h = g.part;\n          h instanceof V && (this.isForwards ? (null !== this.originalFromNode && (b = this.originalFromNode, c = this.originalFromPort), d = h, e = g) : (b = h, c = g, null !== this.originalToNode && (d = this.originalToNode, e = this.originalToPort)));\n        } else this.isForwards ? null !== this.originalFromNode && this.isUnconnectedLinkValid && (b = this.originalFromNode, c = this.originalFromPort) : null !== this.originalToNode && this.isUnconnectedLinkValid && (d = this.originalToNode, e = this.originalToPort);\n        null !== b || null !== d ? (f = this.insertLink(b, c, d, e), null !== f ? (null === g && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint), a.allowSelect && (a.R(\"ChangingSelection\", a.selection), a.clearSelection(!0), f.isSelected = !0), this.transactionResult = this.name, a.R(\"LinkDrawn\", f)) : this.doNoLink(b, c, d, e)) : this.isForwards ? this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) : this.doNoLink(null, null, this.originalToNode, this.originalToPort);\n      } finally {\n        this.stopTool(), f && a.allowSelect && a.R(\"ChangedSelection\", a.selection);\n      }\n    }\n  };\n  Wf.prototype.isNewTreeLink = function () {\n    var a = this.archetypeLinkData;\n    if (null === a) return !0;\n    if (a instanceof S) return a.isTreeLink;\n    var b = this.diagram;\n    if (null === b) return !0;\n    a = b.partManager.getLinkCategoryForData(a);\n    b = b.partManager.findLinkTemplateForCategory(a);\n    return null !== b ? b.isTreeLink : !0;\n  };\n  Wf.prototype.insertLink = function (a, b, c, d) {\n    return this.diagram.partManager.insertLink(a, b, c, d);\n  };\n  Wf.prototype.doNoLink = function () {};\n  ma.Object.defineProperties(Wf.prototype, {\n    archetypeLinkData: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    archetypeLabelNodeData: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    direction: {\n      get: function () {\n        return this.J;\n      },\n      set: function (a) {\n        this.J = a;\n      }\n    },\n    startObject: {\n      get: function () {\n        return this.cn;\n      },\n      set: function (a) {\n        this.cn = a;\n      }\n    }\n  });\n  var Xf = new D(Wf, \"Either\", 0),\n    Yf = new D(Wf, \"ForwardsOnly\", 0),\n    Zf = new D(Wf, \"BackwardsOnly\", 0);\n  Wf.className = \"LinkingTool\";\n  Wf.Either = Xf;\n  Wf.ForwardsOnly = Yf;\n  Wf.BackwardsOnly = Zf;\n  function Ze() {\n    Lf.call(this);\n    this.name = \"Relinking\";\n    var a = new W();\n    a.figure = \"Diamond\";\n    a.desiredSize = Pb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.cursor = this.linkingCursor;\n    a.segmentIndex = 0;\n    this.T = a;\n    a = new W();\n    a.figure = \"Diamond\";\n    a.desiredSize = Pb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.cursor = this.linkingCursor;\n    a.segmentIndex = -1;\n    this.cn = a;\n    this.I = null;\n    this.Fx = new N();\n  }\n  la(Ze, Lf);\n  Ze.prototype.updateAdornments = function (a) {\n    if (null !== a && a instanceof S) {\n      var b = \"RelinkFrom\",\n        c = null;\n      if (a.isSelected && !this.diagram.isReadOnly) {\n        var d = a.selectionObject;\n        null !== d && a.canRelinkFrom() && a.actualBounds.u() && a.isVisible() && d.actualBounds.u() && d.Ff() && (c = a.tk(b), null === c && (c = this.makeAdornment(d, !1), a.Gh(b, c)));\n      }\n      null === c && a.Gf(b);\n      b = \"RelinkTo\";\n      c = null;\n      a.isSelected && !this.diagram.isReadOnly && (d = a.selectionObject, null !== d && a.canRelinkTo() && a.actualBounds.u() && a.isVisible() && d.actualBounds.u() && d.Ff() && (c = a.tk(b), null === c ? (c = this.makeAdornment(d, !0), a.Gh(b, c)) : c.o()));\n      null === c && a.Gf(b);\n    }\n  };\n  Ze.prototype.makeAdornment = function (a, b) {\n    var c = new He();\n    c.type = X.Link;\n    b = b ? this.toHandleArchetype : this.fromHandleArchetype;\n    null !== b && c.add(b.copy());\n    c.adornedObject = a;\n    return c;\n  };\n  Ze.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowRelink || !a.model.Ut() || !a.lastInput.left) return !1;\n    var b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkFrom\");\n    null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkTo\"));\n    return null !== b;\n  };\n  Ze.prototype.doActivate = function () {\n    var a = this.diagram;\n    if (null === this.originalLink) {\n      var b = this.handle;\n      null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkFrom\"), null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkTo\")));\n      if (null === b) return;\n      var c = b.part;\n      if (!(c instanceof He && c.adornedPart instanceof S)) return;\n      this.handle = b;\n      this.isForwards = null === c || \"RelinkTo\" === c.category;\n      this.originalLink = c.adornedPart;\n    }\n    this.va(this.name);\n    a.isMouseCaptured = !0;\n    a.currentCursor = this.linkingCursor;\n    this.originalFromPort = this.originalLink.fromPort;\n    this.originalFromNode = this.originalLink.fromNode;\n    this.originalToPort = this.originalLink.toPort;\n    this.originalToNode = this.originalLink.toNode;\n    this.Fx.set(this.originalLink.actualBounds);\n    null !== this.originalLink && 0 < this.originalLink.pointsCount && (null === this.originalLink.fromNode && (null !== this.temporaryFromPort && (this.temporaryFromPort.desiredSize = Mb), null !== this.temporaryFromNode && (this.temporaryFromNode.location = this.originalLink.i(0))), null === this.originalLink.toNode && (null !== this.temporaryToPort && (this.temporaryToPort.desiredSize = Mb), null !== this.temporaryToNode && (this.temporaryToNode.location = this.originalLink.i(this.originalLink.pointsCount - 1))));\n    this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1);\n    this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0);\n    a.add(this.temporaryFromNode);\n    a.add(this.temporaryToNode);\n    null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(this.originalLink, this.temporaryLink), this.temporaryLink.Ua(), a.add(this.temporaryLink));\n    this.isActive = !0;\n  };\n  Ze.prototype.copyLinkProperties = function (a, b) {\n    if (null !== a && null !== b) {\n      b.adjusting = a.adjusting;\n      b.corner = a.corner;\n      var c = a.curve;\n      if (c === $f || c === ag) c = bg;\n      b.curve = c;\n      b.curviness = a.curviness;\n      b.isTreeLink = a.isTreeLink;\n      b.points = a.points;\n      b.routing = a.routing;\n      b.smoothness = a.smoothness;\n      b.fromSpot = a.fromSpot;\n      b.fromEndSegmentLength = a.fromEndSegmentLength;\n      b.fromShortLength = a.fromShortLength;\n      b.toSpot = a.toSpot;\n      b.toEndSegmentLength = a.toEndSegmentLength;\n      b.toShortLength = a.toShortLength;\n    }\n  };\n  Ze.prototype.doDeactivate = function () {\n    this.isActive = !1;\n    var a = this.diagram;\n    a.remove(this.temporaryLink);\n    a.remove(this.temporaryFromNode);\n    a.remove(this.temporaryToNode);\n    a.isMouseCaptured = !1;\n    a.currentCursor = \"\";\n    this.Jg();\n  };\n  Ze.prototype.doStop = function () {\n    Lf.prototype.doStop.call(this);\n    this.handle = null;\n  };\n  Ze.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram;\n      this.transactionResult = null;\n      var b = this.originalFromNode,\n        c = this.originalFromPort,\n        d = this.originalToNode,\n        e = this.originalToPort,\n        f = this.originalLink;\n      this.targetPort = this.findTargetPort(this.isForwards);\n      if (null !== this.targetPort) {\n        var g = this.targetPort.part;\n        g instanceof V && (this.isForwards ? (d = g, e = this.targetPort) : (b = g, c = this.targetPort));\n      } else this.isUnconnectedLinkValid ? this.isForwards ? e = d = null : c = b = null : f = null;\n      null !== f ? (this.reconnectLink(f, this.isForwards ? d : b, this.isForwards ? e : c, this.isForwards), null === this.targetPort && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint, f.Ua()), a.allowSelect && (f.isSelected = !0), this.transactionResult = this.name, a.R(\"LinkRelinked\", f, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.doNoRelink(this.originalLink, this.isForwards);\n      this.originalLink.Nq(this.Fx);\n    }\n    this.stopTool();\n  };\n  Ze.prototype.reconnectLink = function (a, b, c, d) {\n    c = null !== c && null !== c.portId ? c.portId : \"\";\n    d ? (a.toNode = b, a.toPortId = c) : (a.fromNode = b, a.fromPortId = c);\n    return !0;\n  };\n  Ze.prototype.doNoRelink = function () {};\n  function zf(a, b, c, d, e) {\n    null !== b ? (a.copyPortProperties(b, c, a.temporaryFromNode, a.temporaryFromPort, !1), a.diagram.add(a.temporaryFromNode)) : a.diagram.remove(a.temporaryFromNode);\n    null !== d ? (a.copyPortProperties(d, e, a.temporaryToNode, a.temporaryToPort, !0), a.diagram.add(a.temporaryToNode)) : a.diagram.remove(a.temporaryToNode);\n  }\n  ma.Object.defineProperties(Ze.prototype, {\n    fromHandleArchetype: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    toHandleArchetype: {\n      get: function () {\n        return this.cn;\n      },\n      set: function (a) {\n        this.cn = a;\n      }\n    },\n    handle: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        if (null !== a && !(a.part instanceof He)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.I = a;\n      }\n    }\n  });\n  Ze.className = \"RelinkingTool\";\n  La(\"linkingTool\", function () {\n    return this.findTool(\"Linking\");\n  }, function (a) {\n    this.Xa(\"Linking\", a, this.mouseMoveTools);\n  });\n  La(\"relinkingTool\", function () {\n    return this.findTool(\"Relinking\");\n  }, function (a) {\n    this.Xa(\"Relinking\", a, this.mouseDownTools);\n  });\n  function cg() {\n    Ce.call(this);\n    this.name = \"LinkReshaping\";\n    var a = new W();\n    a.figure = \"Rectangle\";\n    a.desiredSize = Ob;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    this.v = a;\n    a = new W();\n    a.figure = \"Diamond\";\n    a.desiredSize = Pb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.cursor = \"move\";\n    this.I = a;\n    this.T = 3;\n    this.vu = this.l = null;\n    this.Gx = new J();\n    this.Ks = new E();\n  }\n  la(cg, Ce);\n  cg.prototype.Yv = function (a) {\n    return a && a.Rs && 0 !== a.Rs.value ? a.Rs : og;\n  };\n  cg.prototype.Wm = function (a, b) {\n    a.Rs = b;\n  };\n  cg.prototype.updateAdornments = function (a) {\n    if (null !== a && a instanceof S) {\n      var b = null;\n      if (a.isSelected && !this.diagram.isReadOnly) {\n        var c = a.path;\n        null !== c && a.canReshape() && a.actualBounds.u() && a.isVisible() && c.actualBounds.u() && c.Ff() && (b = a.tk(this.name), null === b || b.Bx !== a.pointsCount || b.Qx !== a.resegmentable) && (b = this.makeAdornment(c), null !== b && (b.Bx = a.pointsCount, b.Qx = a.resegmentable, a.Gh(this.name, b)));\n      }\n      null === b && a.Gf(this.name);\n    }\n  };\n  cg.prototype.makeAdornment = function (a) {\n    var b = a.part,\n      c = b.pointsCount,\n      d = b.isOrthogonal,\n      e = null;\n    if (null !== b.points && 1 < c) {\n      e = new He();\n      e.type = X.Link;\n      c = b.firstPickIndex;\n      var f = b.lastPickIndex,\n        g = d ? 1 : 0;\n      if (b.resegmentable && b.computeCurve() !== pg) for (var h = c + g; h < f - g; h++) {\n        var k = this.makeResegmentHandle(a, h);\n        null !== k && (k.segmentIndex = h, k.segmentFraction = .5, k.fromMaxLinks = 999, e.add(k));\n      }\n      for (g = c + 1; g < f; g++) if (h = this.makeHandle(a, g), null !== h) {\n        h.segmentIndex = g;\n        if (g !== c) if (g === c + 1 && d) {\n          k = b.i(c);\n          var l = b.i(c + 1);\n          K.A(k.x, l.x) && K.A(k.y, l.y) && (l = b.i(c - 1));\n          K.A(k.x, l.x) ? (this.Wm(h, qg), h.cursor = \"n-resize\") : K.A(k.y, l.y) && (this.Wm(h, rg), h.cursor = \"w-resize\");\n        } else g === f - 1 && d ? (k = b.i(f - 1), l = b.i(f), K.A(k.x, l.x) && K.A(k.y, l.y) && (k = b.i(f + 1)), K.A(k.x, l.x) ? (this.Wm(h, qg), h.cursor = \"n-resize\") : K.A(k.y, l.y) && (this.Wm(h, rg), h.cursor = \"w-resize\")) : g !== f && (this.Wm(h, sg), h.cursor = \"move\");\n        e.add(h);\n      }\n      e.adornedObject = a;\n    }\n    return e;\n  };\n  cg.prototype.makeHandle = function () {\n    var a = this.handleArchetype;\n    return null === a ? null : a.copy();\n  };\n  cg.prototype.makeResegmentHandle = function () {\n    var a = this.midHandleArchetype;\n    return null === a ? null : a.copy();\n  };\n  cg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.isReadOnly && a.allowReshape && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1;\n  };\n  cg.prototype.doActivate = function () {\n    var a = this.diagram;\n    null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));\n    if (null !== this.handle) {\n      var b = this.handle.part.adornedPart;\n      if (b instanceof S) {\n        this.vu = b;\n        a.isMouseCaptured = !0;\n        this.va(this.name);\n        if (b.resegmentable && 999 === this.handle.fromMaxLinks) {\n          var c = b.points.copy(),\n            d = this.getResegmentingPoint();\n          c.vb(this.handle.segmentIndex + 1, d);\n          b.isOrthogonal && c.vb(this.handle.segmentIndex + 1, d);\n          b.points = c;\n          b.Lb();\n          b.updateAdornments();\n          this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name);\n          if (null === this.handle) {\n            this.doDeactivate();\n            return;\n          }\n        }\n        this.Gx = b.i(this.handle.segmentIndex);\n        this.Ks = b.points.copy();\n        this.isActive = !0;\n      }\n    }\n  };\n  cg.prototype.doDeactivate = function () {\n    this.Jg();\n    this.vu = this.handle = null;\n    this.isActive = this.diagram.isMouseCaptured = !1;\n  };\n  cg.prototype.doCancel = function () {\n    var a = this.adornedLink;\n    null !== a && (a.points = this.Ks);\n    this.stopTool();\n  };\n  cg.prototype.getResegmentingPoint = function () {\n    return this.handle.ga(Bc);\n  };\n  cg.prototype.doMouseMove = function () {\n    var a = this.diagram;\n    this.isActive && (a = this.computeReshape(a.lastInput.documentPoint), this.reshape(a));\n  };\n  cg.prototype.doMouseUp = function () {\n    var a = this.diagram;\n    if (this.isActive) {\n      var b = this.computeReshape(a.lastInput.documentPoint);\n      this.reshape(b);\n      b = this.adornedLink;\n      if (null !== b && b.resegmentable) {\n        var c = this.handle.segmentIndex,\n          d = b.i(c - 1),\n          e = b.i(c),\n          f = b.i(c + 1);\n        if (b.isOrthogonal) {\n          if (c > b.firstPickIndex + 1 && c < b.lastPickIndex - 1) {\n            var g = b.i(c - 2);\n            if (Math.abs(d.x - e.x) < this.resegmentingDistance && Math.abs(d.y - e.y) < this.resegmentingDistance && (tg(this, g, d, e, f, !0) || tg(this, g, d, e, f, !1))) {\n              var h = b.points.copy();\n              tg(this, g, d, e, f, !0) ? (h.nd(c - 2, new J(g.x, (f.y + g.y) / 2)), h.nd(c + 1, new J(f.x, (f.y + g.y) / 2))) : (h.nd(c - 2, new J((f.x + g.x) / 2, g.y)), h.nd(c + 1, new J((f.x + g.x) / 2, f.y)));\n              h.bb(c);\n              h.bb(c - 1);\n              b.points = h;\n              b.Lb();\n            } else g = b.i(c + 2), Math.abs(e.x - f.x) < this.resegmentingDistance && Math.abs(e.y - f.y) < this.resegmentingDistance && (tg(this, d, e, f, g, !0) || tg(this, d, e, f, g, !1)) && (h = b.points.copy(), tg(this, d, e, f, g, !0) ? (h.nd(c - 1, new J(d.x, (d.y + g.y) / 2)), h.nd(c + 2, new J(g.x, (d.y + g.y) / 2))) : (h.nd(c - 1, new J((d.x + g.x) / 2, d.y)), h.nd(c + 2, new J((d.x + g.x) / 2, g.y))), h.bb(c + 1), h.bb(c), b.points = h, b.Lb());\n          }\n        } else g = J.alloc(), K.Qh(d.x, d.y, f.x, f.y, e.x, e.y, g) && g.Fe(e) < this.resegmentingDistance * this.resegmentingDistance && (d = b.points.copy(), d.bb(c), b.points = d, b.Lb()), J.free(g);\n      }\n      a.Oa();\n      this.transactionResult = this.name;\n      a.R(\"LinkReshaped\", this.adornedLink, this.Ks);\n    }\n    this.stopTool();\n  };\n  function tg(a, b, c, d, e, f) {\n    return f ? Math.abs(b.y - c.y) < a.resegmentingDistance && Math.abs(c.y - d.y) < a.resegmentingDistance && Math.abs(d.y - e.y) < a.resegmentingDistance : Math.abs(b.x - c.x) < a.resegmentingDistance && Math.abs(c.x - d.x) < a.resegmentingDistance && Math.abs(d.x - e.x) < a.resegmentingDistance;\n  }\n  cg.prototype.reshape = function (a) {\n    var b = this.adornedLink;\n    b.Th();\n    var c = this.handle.segmentIndex,\n      d = this.Yv(this.handle);\n    if (b.isOrthogonal) {\n      if (c === b.firstPickIndex + 1) c = b.firstPickIndex + 1, d === qg ? (b.K(c, b.i(c - 1).x, a.y), b.K(c + 1, b.i(c + 2).x, a.y)) : d === rg && (b.K(c, a.x, b.i(c - 1).y), b.K(c + 1, a.x, b.i(c + 2).y));else if (c === b.lastPickIndex - 1) c = b.lastPickIndex - 1, d === qg ? (b.K(c - 1, b.i(c - 2).x, a.y), b.K(c, b.i(c + 1).x, a.y)) : d === rg && (b.K(c - 1, a.x, b.i(c - 2).y), b.K(c, a.x, b.i(c + 1).y));else {\n        d = c;\n        var e = b.i(d),\n          f = b.i(d - 1),\n          g = b.i(d + 1);\n        K.A(f.x, e.x) && K.A(e.y, g.y) ? (K.A(f.x, b.i(d - 2).x) && !K.A(f.y, b.i(d - 2).y) ? (b.m(d, a.x, f.y), c++, d++) : b.K(d - 1, a.x, f.y), K.A(g.y, b.i(d + 2).y) && !K.A(g.x, b.i(d + 2).x) ? b.m(d + 1, g.x, a.y) : b.K(d + 1, g.x, a.y)) : K.A(f.y, e.y) && K.A(e.x, g.x) ? (K.A(f.y, b.i(d - 2).y) && !K.A(f.x, b.i(d - 2).x) ? (b.m(d, f.x, a.y), c++, d++) : b.K(d - 1, f.x, a.y), K.A(g.x, b.i(d + 2).x) && !K.A(g.y, b.i(d + 2).y) ? b.m(d + 1, a.x, g.y) : b.K(d + 1, a.x, g.y)) : K.A(f.x, e.x) && K.A(e.x, g.x) ? (K.A(f.x, b.i(d - 2).x) && !K.A(f.y, b.i(d - 2).y) ? (b.m(d, a.x, f.y), c++, d++) : b.K(d - 1, a.x, f.y), K.A(g.x, b.i(d + 2).x) && !K.A(g.y, b.i(d + 2).y) ? b.m(d + 1, a.x, g.y) : b.K(d + 1, a.x, g.y)) : K.A(f.y, e.y) && K.A(e.y, g.y) && (K.A(f.y, b.i(d - 2).y) && !K.A(f.x, b.i(d - 2).x) ? (b.m(d, f.x, a.y), c++, d++) : b.K(d - 1, f.x, a.y), K.A(g.y, b.i(d + 2).y) && !K.A(g.x, b.i(d + 2).x) ? b.m(d + 1, g.x, a.y) : b.K(d + 1, g.x, a.y));\n        b.K(c, a.x, a.y);\n      }\n    } else b.K(c, a.x, a.y), d = b.fromNode, e = b.fromPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), 1 === c && b.computeSpot(!0, e).mc() && (f = e.ga(Bc, J.alloc()), d = b.getLinkPointFromPoint(d, e, f, a, !0, J.alloc()), b.K(0, d.x, d.y), J.free(f), J.free(d)), d = b.toNode, e = b.toPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), c === b.pointsCount - 2 && b.computeSpot(!1, e).mc() && (c = e.ga(Bc, J.alloc()), a = b.getLinkPointFromPoint(d, e, c, a, !1, J.alloc()), b.K(b.pointsCount - 1, a.x, a.y), J.free(c), J.free(a));\n    b.xf();\n  };\n  cg.prototype.computeReshape = function (a) {\n    var b = this.adornedLink,\n      c = this.handle.segmentIndex;\n    switch (this.Yv(this.handle)) {\n      case sg:\n        return a;\n      case qg:\n        return new J(b.i(c).x, a.y);\n      case rg:\n        return new J(a.x, b.i(c).y);\n      default:\n      case og:\n        return b.i(c);\n    }\n  };\n  ma.Object.defineProperties(cg.prototype, {\n    handleArchetype: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    midHandleArchetype: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    handle: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        if (null !== a && !(a.part instanceof He)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.l = a;\n      }\n    },\n    adornedLink: {\n      get: function () {\n        return this.vu;\n      }\n    },\n    resegmentingDistance: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    originalPoint: {\n      get: function () {\n        return this.Gx;\n      }\n    },\n    originalPoints: {\n      get: function () {\n        return this.Ks;\n      }\n    }\n  });\n  cg.prototype.setReshapingBehavior = cg.prototype.Wm;\n  cg.prototype.getReshapingBehavior = cg.prototype.Yv;\n  var og = new D(cg, \"None\", 0),\n    rg = new D(cg, \"Horizontal\", 1),\n    qg = new D(cg, \"Vertical\", 2),\n    sg = new D(cg, \"All\", 3);\n  cg.className = \"LinkReshapingTool\";\n  cg.None = og;\n  cg.Horizontal = rg;\n  cg.Vertical = qg;\n  cg.All = sg;\n  La(\"linkReshapingTool\", function () {\n    return this.findTool(\"LinkReshaping\");\n  }, function (a) {\n    this.Xa(\"LinkReshaping\", a, this.mouseDownTools);\n  });\n  function ug() {\n    Ce.call(this);\n    this.name = \"Resizing\";\n    this.fg = new M(1, 1).freeze();\n    this.eg = new M(9999, 9999).freeze();\n    this.Qg = new M(NaN, NaN).freeze();\n    this.I = !1;\n    this.T = !0;\n    this.ee = null;\n    var a = new W();\n    a.alignmentFocus = Bc;\n    a.figure = \"Rectangle\";\n    a.desiredSize = Ob;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.strokeWidth = 1;\n    a.cursor = \"pointer\";\n    this.v = a;\n    this.l = null;\n    this.Js = new J();\n    this.Ex = new M();\n    this.mp = new J();\n    this.Mu = new M(0, 0);\n    this.Lu = new M(Infinity, Infinity);\n    this.Ku = new M(1, 1);\n    this.Ax = !0;\n  }\n  la(ug, Ce);\n  ug.prototype.updateAdornments = function (a) {\n    if (!(null === a || a instanceof S)) {\n      if (a.isSelected && !this.diagram.isReadOnly) {\n        var b = a.resizeObject,\n          c = a.tk(this.name);\n        if (null !== b && a.canResize() && a.actualBounds.u() && a.isVisible() && b.actualBounds.u() && b.Ff()) {\n          if (null === c || c.adornedObject !== b) c = this.makeAdornment(b);\n          if (null !== c) {\n            b = b.lj();\n            vg(a) && this.updateResizeHandles(c, b);\n            a.Gh(this.name, c);\n            return;\n          }\n        }\n      }\n      a.Gf(this.name);\n    }\n  };\n  ug.prototype.makeAdornment = function (a) {\n    var b = a.part.resizeAdornmentTemplate;\n    if (null === b) {\n      b = new He();\n      b.type = X.Spot;\n      b.locationSpot = Bc;\n      var c = new wg();\n      c.isPanelMain = !0;\n      b.add(c);\n      b.add(this.makeHandle(a, wc));\n      b.add(this.makeHandle(a, zc));\n      b.add(this.makeHandle(a, Hc));\n      b.add(this.makeHandle(a, Dc));\n      b.add(this.makeHandle(a, fd));\n      b.add(this.makeHandle(a, hd));\n      b.add(this.makeHandle(a, id));\n      b.add(this.makeHandle(a, gd));\n    } else if (xg(b), b = b.copy(), null === b) return null;\n    b.adornedObject = a;\n    return b;\n  };\n  ug.prototype.makeHandle = function (a, b) {\n    a = this.handleArchetype;\n    if (null === a) return null;\n    a = a.copy();\n    a.alignment = b;\n    return a;\n  };\n  ug.prototype.updateResizeHandles = function (a, b) {\n    if (null !== a) if (!a.alignment.Mb() && (\"pointer\" === a.cursor || 0 < a.cursor.indexOf(\"resize\"))) a: {\n      var c = a.alignment;\n      c.mc() && (c = Bc);\n      if (0 >= c.x) b = 0 >= c.y ? b + 225 : 1 <= c.y ? b + 135 : b + 180;else if (1 <= c.x) 0 >= c.y ? b += 315 : 1 <= c.y && (b += 45);else if (0 >= c.y) b += 270;else if (1 <= c.y) b += 90;else break a;\n      0 > b ? b += 360 : 360 <= b && (b -= 360);\n      a.cursor = 22.5 > b ? \"e-resize\" : 67.5 > b ? \"se-resize\" : 112.5 > b ? \"s-resize\" : 157.5 > b ? \"sw-resize\" : 202.5 > b ? \"w-resize\" : 247.5 > b ? \"nw-resize\" : 292.5 > b ? \"n-resize\" : 337.5 > b ? \"ne-resize\" : \"e-resize\";\n    } else if (a instanceof X) for (a = a.elements; a.next();) this.updateResizeHandles(a.value, b);\n  };\n  ug.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.isReadOnly && a.allowResize && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1;\n  };\n  ug.prototype.doActivate = function () {\n    var a = this.diagram;\n    null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));\n    null !== this.handle && (this.adornedObject = this.handle.part.adornedObject, null !== this.adornedObject && (a.isMouseCaptured = !0, this.Ax = a.animationManager.isEnabled, a.animationManager.isEnabled = !1, this.va(this.name), this.Js.set(this.adornedObject.ga(this.handle.alignment.kw())), this.mp.set(this.adornedObject.part.location), this.Ex.set(this.adornedObject.desiredSize), this.Ku = this.computeCellSize(), this.Mu = this.computeMinSize(), this.Lu = this.computeMaxSize(), this.isActive = !0));\n  };\n  ug.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    this.Jg();\n    this.ee = this.handle = null;\n    this.isActive = a.isMouseCaptured = !1;\n    a.animationManager.isEnabled = this.Ax;\n  };\n  ug.prototype.doCancel = function () {\n    null !== this.adornedObject && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation);\n    this.stopTool();\n  };\n  ug.prototype.doMouseMove = function () {\n    var a = this.diagram;\n    if (this.isActive) {\n      var b = this.Mu,\n        c = this.Lu,\n        d = this.Ku,\n        e = this.adornedObject.Nt(a.lastInput.documentPoint, J.alloc()),\n        f = this.computeReshape();\n      b = this.computeResize(e, this.handle.alignment, b, c, d, f);\n      this.resize(b);\n      a.cd();\n      J.free(e);\n    }\n  };\n  ug.prototype.doMouseUp = function () {\n    var a = this.diagram;\n    if (this.isActive) {\n      var b = this.Mu,\n        c = this.Lu,\n        d = this.Ku,\n        e = this.adornedObject.Nt(a.lastInput.documentPoint, J.alloc()),\n        f = this.computeReshape();\n      b = this.computeResize(e, this.handle.alignment, b, c, d, f);\n      this.resize(b);\n      J.free(e);\n      a.Oa();\n      this.transactionResult = this.name;\n      a.R(\"PartResized\", this.adornedObject, this.originalDesiredSize);\n    }\n    this.stopTool();\n  };\n  ug.prototype.resize = function (a) {\n    var b = this.diagram,\n      c = this.adornedObject;\n    if (null !== c) {\n      c.desiredSize = a.size;\n      a = c.part;\n      a.Ta();\n      c = c.ga(this.handle.alignment.kw());\n      if (a instanceof vf) {\n        var d = new E();\n        d.add(a);\n        if (!this.dragsMembers && null === a.placeholder) {\n          var e = new Te();\n          e.dragsMembers = !1;\n        }\n        b.moveParts(d, this.oppositePoint.copy().ce(c), !0, e);\n      } else a.location = a.location.copy().ce(c).add(this.oppositePoint);\n      b.cd();\n    }\n  };\n  ug.prototype.computeResize = function (a, b, c, d, e, f) {\n    b.mc() && (b = Bc);\n    var g = this.adornedObject.naturalBounds,\n      h = g.x,\n      k = g.y,\n      l = g.x + g.width,\n      m = g.y + g.height,\n      n = 1;\n    if (!f) {\n      n = g.width;\n      var p = g.height;\n      0 >= n && (n = 1);\n      0 >= p && (p = 1);\n      n = p / n;\n    }\n    p = J.alloc();\n    K.Eq(a.x, a.y, h, k, e.width, e.height, p);\n    a = g.copy();\n    0 >= b.x ? 0 >= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width, a.y = m - a.height)) : 1 <= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width)) : (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = l - a.x, f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 1 <= b.x ? 0 >= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.y = m - a.height)) : 1 <= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width))) : (a.width = Math.max(Math.min(p.x - h, d.width), c.width), f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 0 >= b.y ? (a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = m - a.y, f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width))) : 1 <= b.y && (a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width)));\n    J.free(p);\n    return a;\n  };\n  ug.prototype.computeReshape = function () {\n    var a = yg;\n    this.adornedObject instanceof W && (a = zg(this.adornedObject));\n    return !(a === Ag || this.diagram.lastInput.shift);\n  };\n  ug.prototype.computeMinSize = function () {\n    var a = this.adornedObject.minSize.copy(),\n      b = this.minSize;\n    !isNaN(b.width) && b.width > a.width && (a.width = b.width);\n    !isNaN(b.height) && b.height > a.height && (a.height = b.height);\n    return a;\n  };\n  ug.prototype.computeMaxSize = function () {\n    var a = this.adornedObject.maxSize.copy(),\n      b = this.maxSize;\n    !isNaN(b.width) && b.width < a.width && (a.width = b.width);\n    !isNaN(b.height) && b.height < a.height && (a.height = b.height);\n    return a;\n  };\n  ug.prototype.computeCellSize = function () {\n    var a = new M(NaN, NaN),\n      b = this.adornedObject.part;\n    null !== b && (b = b.resizeCellSize, !isNaN(b.width) && 0 < b.width && (a.width = b.width), !isNaN(b.height) && 0 < b.height && (a.height = b.height));\n    b = this.cellSize;\n    isNaN(a.width) && !isNaN(b.width) && 0 < b.width && (a.width = b.width);\n    isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height);\n    b = this.diagram;\n    (isNaN(a.width) || isNaN(a.height)) && b && (b = b.grid, null !== b && b.visible && this.isGridSnapEnabled && (b = b.gridCellSize, isNaN(a.width) && !isNaN(b.width) && 0 < b.width && (a.width = b.width), isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height)));\n    if (isNaN(a.width) || 0 === a.width || Infinity === a.width) a.width = 1;\n    if (isNaN(a.height) || 0 === a.height || Infinity === a.height) a.height = 1;\n    return a;\n  };\n  ma.Object.defineProperties(ug.prototype, {\n    handleArchetype: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    handle: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        if (null !== a && !(a.part instanceof He)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.l = a;\n      }\n    },\n    adornedObject: {\n      get: function () {\n        return this.ee;\n      },\n      set: function (a) {\n        if (null !== a && a.part instanceof He) throw Error(\"new handle must not be in an Adornment: \" + a);\n        this.ee = a;\n      }\n    },\n    minSize: {\n      get: function () {\n        return this.fg;\n      },\n      set: function (a) {\n        if (!this.fg.w(a)) {\n          var b = a.width;\n          isNaN(b) && (b = 0);\n          a = a.height;\n          isNaN(a) && (a = 0);\n          this.fg.h(b, a);\n        }\n      }\n    },\n    maxSize: {\n      get: function () {\n        return this.eg;\n      },\n      set: function (a) {\n        if (!this.eg.w(a)) {\n          var b = a.width;\n          isNaN(b) && (b = Infinity);\n          a = a.height;\n          isNaN(a) && (a = Infinity);\n          this.eg.h(b, a);\n        }\n      }\n    },\n    cellSize: {\n      get: function () {\n        return this.Qg;\n      },\n      set: function (a) {\n        this.Qg.w(a) || this.Qg.assign(a);\n      }\n    },\n    isGridSnapEnabled: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    dragsMembers: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    oppositePoint: {\n      get: function () {\n        return this.Js;\n      },\n      set: function (a) {\n        this.Js.w(a) || this.Js.assign(a);\n      }\n    },\n    originalDesiredSize: {\n      get: function () {\n        return this.Ex;\n      }\n    },\n    originalLocation: {\n      get: function () {\n        return this.mp;\n      }\n    }\n  });\n  ug.className = \"ResizingTool\";\n  La(\"resizingTool\", function () {\n    return this.findTool(\"Resizing\");\n  }, function (a) {\n    this.Xa(\"Resizing\", a, this.mouseDownTools);\n  });\n  function Bg() {\n    Ce.call(this);\n    this.name = \"Rotating\";\n    this.Ka = 45;\n    this.Ja = 2;\n    this.mp = new J();\n    this.ee = null;\n    var a = new W();\n    a.figure = \"Ellipse\";\n    a.desiredSize = Pb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.strokeWidth = 1;\n    a.cursor = \"pointer\";\n    this.v = a;\n    this.l = null;\n    this.Cx = 0;\n    this.mv = new J(NaN, NaN);\n    this.I = 0;\n    this.T = 50;\n  }\n  la(Bg, Ce);\n  Bg.prototype.updateAdornments = function (a) {\n    if (null !== a) {\n      if (a.Ph()) {\n        var b = a.rotateObject;\n        if (b === a || b === a.path || b.isPanelMain) return;\n      }\n      if (a.isSelected && !this.diagram.isReadOnly && (b = a.rotateObject, null !== b && a.canRotate() && a.actualBounds.u() && a.isVisible() && b.actualBounds.u() && b.Ff())) {\n        var c = a.tk(this.name);\n        if (null === c || c.adornedObject !== b) c = this.makeAdornment(b);\n        if (null !== c) {\n          c.angle = b.lj();\n          null === c.placeholder && (c.location = this.computeAdornmentLocation(b));\n          a.Gh(this.name, c);\n          return;\n        }\n      }\n      a.Gf(this.name);\n    }\n  };\n  Bg.prototype.makeAdornment = function (a) {\n    var b = a.part.rotateAdornmentTemplate;\n    if (null === b) {\n      b = new He();\n      b.type = X.Position;\n      b.locationSpot = Bc;\n      var c = this.handleArchetype;\n      null !== c && b.add(c.copy());\n    } else if (xg(b), b = b.copy(), null === b) return null;\n    b.adornedObject = a;\n    return b;\n  };\n  Bg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.isReadOnly && a.allowRotate && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1;\n  };\n  Bg.prototype.doActivate = function () {\n    var a = this.diagram;\n    if (null === this.adornedObject) {\n      null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));\n      if (null === this.handle) return;\n      this.adornedObject = this.handle.part.adornedObject;\n    }\n    null !== this.adornedObject && (a.isMouseCaptured = !0, a.delaysLayout = !0, this.va(this.name), this.Cx = this.adornedObject.angle, this.mv = this.computeRotationPoint(this.adornedObject), this.mp = this.adornedObject.part.location.copy(), this.isActive = !0);\n  };\n  Bg.prototype.computeRotationPoint = function (a) {\n    var b = a.part,\n      c = b.locationObject;\n    return b.rotationSpot.ib() ? a.ga(b.rotationSpot) : a === b || a === c ? c.ga(b.locationSpot) : a.ga(Bc);\n  };\n  Bg.prototype.computeAdornmentLocation = function (a) {\n    var b = this.rotationPoint;\n    b.u() || (b = this.computeRotationPoint(a));\n    b = a.Nt(b);\n    var c = this.handleAngle;\n    0 > c ? c += 360 : 360 <= c && (c -= 360);\n    c = Math.round(45 * Math.round(c / 45));\n    var d = this.handleDistance;\n    0 === c ? b.x = a.naturalBounds.width + d : 45 === c ? (b.x = a.naturalBounds.width + d, b.y = a.naturalBounds.height + d) : 90 === c ? b.y = a.naturalBounds.height + d : 135 === c ? (b.x = -d, b.y = a.naturalBounds.height + d) : 180 === c ? b.x = -d : 225 === c ? (b.x = -d, b.y = -d) : 270 === c ? b.y = -d : 315 === c && (b.x = a.naturalBounds.width + d, b.y = -d);\n    return a.ga(b);\n  };\n  Bg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    this.Jg();\n    this.ee = this.handle = null;\n    this.mv = new J(NaN, NaN);\n    this.isActive = a.isMouseCaptured = !1;\n  };\n  Bg.prototype.doCancel = function () {\n    this.diagram.delaysLayout = !1;\n    this.rotate(this.originalAngle);\n    this.stopTool();\n  };\n  Bg.prototype.doMouseMove = function () {\n    var a = this.diagram;\n    this.isActive && (a = this.computeRotate(a.lastInput.documentPoint), this.rotate(a));\n  };\n  Bg.prototype.doMouseUp = function () {\n    var a = this.diagram;\n    if (this.isActive) {\n      a.delaysLayout = !1;\n      var b = this.computeRotate(a.lastInput.documentPoint);\n      this.rotate(b);\n      a.Oa();\n      this.transactionResult = this.name;\n      a.R(\"PartRotated\", this.adornedObject, this.originalAngle);\n    }\n    this.stopTool();\n  };\n  Bg.prototype.rotate = function (a) {\n    var b = this.adornedObject;\n    if (null !== b) {\n      b.angle = a;\n      b = b.part;\n      b.Ta();\n      var c = b.locationObject,\n        d = b.rotateObject;\n      if (c === d || c.Gg(d)) c = this.mp.copy(), b.location = c.ce(this.rotationPoint).rotate(a - this.originalAngle).add(this.rotationPoint);\n      this.diagram.cd();\n    }\n  };\n  Bg.prototype.computeRotate = function (a) {\n    a = this.rotationPoint.Sa(a) - this.handleAngle;\n    var b = this.adornedObject.panel;\n    null !== b && (a -= b.lj());\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    b = Math.min(Math.abs(this.snapAngleMultiple), 180);\n    var c = Math.min(Math.abs(this.snapAngleEpsilon), b / 2);\n    !this.diagram.lastInput.shift && 0 < b && 0 < c && (a % b < c ? a = Math.floor(a / b) * b : a % b > b - c && (a = (Math.floor(a / b) + 1) * b));\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    return a;\n  };\n  ma.Object.defineProperties(Bg.prototype, {\n    handleArchetype: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    handle: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        if (null !== a && !(a.part instanceof He)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.l = a;\n      }\n    },\n    adornedObject: {\n      get: function () {\n        return this.ee;\n      },\n      set: function (a) {\n        if (null !== a && a.part instanceof He) throw Error(\"new handle must not be in an Adornment: \" + a);\n        this.ee = a;\n      }\n    },\n    snapAngleMultiple: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka = a;\n      }\n    },\n    snapAngleEpsilon: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja = a;\n      }\n    },\n    originalAngle: {\n      get: function () {\n        return this.Cx;\n      }\n    },\n    rotationPoint: {\n      get: function () {\n        return this.mv;\n      }\n    },\n    handleAngle: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    handleDistance: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    }\n  });\n  Bg.className = \"RotatingTool\";\n  La(\"rotatingTool\", function () {\n    return this.findTool(\"Rotating\");\n  }, function (a) {\n    this.Xa(\"Rotating\", a, this.mouseDownTools);\n  });\n  function Cg() {\n    Ce.call(this);\n    this.name = \"ClickSelecting\";\n  }\n  la(Cg, Ce);\n  Cg.prototype.canStart = function () {\n    return !this.isEnabled || this.isBeyondDragSize() ? !1 : !0;\n  };\n  Cg.prototype.doMouseUp = function () {\n    this.isActive && (this.standardMouseSelect(), !this.standardMouseClick() && this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip());\n    this.stopTool();\n  };\n  Cg.className = \"ClickSelectingTool\";\n  function Dg() {\n    Ce.call(this);\n    this.name = \"Action\";\n    this.Pk = null;\n  }\n  la(Dg, Ce);\n  Dg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram,\n      b = a.lastInput,\n      c = a.Ub(b.documentPoint, function (a) {\n        for (; null !== a.panel && !a.isActionable;) a = a.panel;\n        return a;\n      });\n    if (null !== c) {\n      if (!c.isActionable) return !1;\n      this.Pk = c;\n      a.Bj = a.Ub(b.documentPoint, null, null);\n      return !0;\n    }\n    return !1;\n  };\n  Dg.prototype.doMouseDown = function () {\n    if (this.isActive) {\n      var a = this.diagram.lastInput,\n        b = this.Pk;\n      null !== b && (a.targetObject = b, null !== b.actionDown && b.actionDown(a, b));\n    } else this.canStart() && this.doActivate();\n  };\n  Dg.prototype.doMouseMove = function () {\n    if (this.isActive) {\n      var a = this.diagram.lastInput,\n        b = this.Pk;\n      null !== b && (a.targetObject = b, null !== b.actionMove && b.actionMove(a, b));\n    }\n  };\n  Dg.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram.lastInput,\n        b = this.Pk;\n      if (null === b) return;\n      a.targetObject = b;\n      null !== b.actionUp && b.actionUp(a, b);\n      this.standardMouseClick(function (a) {\n        for (; null !== a.panel && (!a.isActionable || a !== b);) a = a.panel;\n        return a;\n      }, function (a) {\n        return a === b;\n      });\n    }\n    this.stopTool();\n  };\n  Dg.prototype.doCancel = function () {\n    var a = this.diagram.lastInput,\n      b = this.Pk;\n    null !== b && (a.targetObject = b, null !== b.actionCancel && b.actionCancel(a, b), this.stopTool());\n  };\n  Dg.prototype.doStop = function () {\n    this.Pk = null;\n  };\n  Dg.className = \"ActionTool\";\n  function Eg() {\n    Ce.call(this);\n    this.name = \"ClickCreating\";\n    this.xj = null;\n    this.v = !0;\n    this.l = !1;\n    this.ux = new J(0, 0);\n  }\n  la(Eg, Ce);\n  Eg.prototype.canStart = function () {\n    if (!this.isEnabled || null === this.archetypeNodeData) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.lastInput.left || this.isBeyondDragSize()) return !1;\n    if (this.isDoubleClick) {\n      if (1 === a.lastInput.clickCount && (this.ux = a.lastInput.viewPoint.copy()), 2 !== a.lastInput.clickCount || this.isBeyondDragSize(this.ux)) return !1;\n    } else if (1 !== a.lastInput.clickCount) return !1;\n    return a.currentTool !== this && null !== a.um(a.lastInput.documentPoint, !0) ? !1 : !0;\n  };\n  Eg.prototype.doMouseUp = function () {\n    var a = this.diagram;\n    this.isActive && this.insertPart(a.lastInput.documentPoint);\n    this.stopTool();\n  };\n  Eg.prototype.insertPart = function (a) {\n    var b = this.diagram,\n      c = this.archetypeNodeData;\n    if (null === c) return null;\n    var d = null;\n    try {\n      b.R(\"ChangingSelection\", b.selection);\n      this.va(this.name);\n      if (c instanceof U) c.Wb() && (xg(c), d = c.copy(), null !== d && b.add(d));else if (null !== c) {\n        var e = b.model.copyNodeData(c);\n        ya(e) && (b.model.uf(e), d = b.yc(e));\n      }\n      if (null !== d) {\n        var f = J.allocAt(a.x, a.y);\n        this.isGridSnapEnabled && Fg(this.diagram, d, a, f);\n        d.location = f;\n        b.allowSelect && (b.clearSelection(!0), d.isSelected = !0);\n        J.free(f);\n      }\n      b.Oa();\n      this.transactionResult = this.name;\n      b.R(\"PartCreated\", d);\n    } finally {\n      this.Jg(), b.R(\"ChangedSelection\", b.selection);\n    }\n    return d;\n  };\n  ma.Object.defineProperties(Eg.prototype, {\n    archetypeNodeData: {\n      get: function () {\n        return this.xj;\n      },\n      set: function (a) {\n        this.xj = a;\n      }\n    },\n    isDoubleClick: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    isGridSnapEnabled: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    }\n  });\n  Eg.className = \"ClickCreatingTool\";\n  function Gg() {\n    Ce.call(this);\n    this.name = \"DragSelecting\";\n    this.il = 175;\n    this.v = !1;\n    var a = new U();\n    a.layerName = \"Tool\";\n    a.selectable = !1;\n    var b = new W();\n    b.name = \"SHAPE\";\n    b.figure = \"Rectangle\";\n    b.fill = null;\n    b.stroke = \"magenta\";\n    a.add(b);\n    this.l = a;\n  }\n  la(Gg, Ce);\n  Gg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (!a.allowSelect) return !1;\n    var b = a.lastInput;\n    return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.timestamp - a.firstInput.timestamp < this.delay || null !== a.um(b.documentPoint, !0)) ? !1 : !0;\n  };\n  Gg.prototype.doActivate = function () {\n    var a = this.diagram;\n    this.isActive = !0;\n    a.isMouseCaptured = !0;\n    a.skipsUndoManager = !0;\n    a.add(this.box);\n    this.doMouseMove();\n  };\n  Gg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    a.If();\n    a.remove(this.box);\n    a.skipsUndoManager = !1;\n    this.isActive = a.isMouseCaptured = !1;\n  };\n  Gg.prototype.doMouseMove = function () {\n    var a = this.diagram;\n    if (this.isActive && null !== this.box) {\n      var b = this.computeBoxBounds(),\n        c = this.box.$a(\"SHAPE\");\n      null === c && (c = this.box.pb());\n      var d = M.alloc().h(b.width, b.height);\n      b = J.allocAt(b.x, b.y);\n      c.desiredSize = d;\n      this.box.position = b;\n      M.free(d);\n      J.free(b);\n      (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Ft(a.lastInput.viewPoint);\n    }\n  };\n  Gg.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram;\n      a.remove(this.box);\n      try {\n        a.currentCursor = \"wait\", a.R(\"ChangingSelection\", a.selection), this.selectInRect(this.computeBoxBounds()), a.R(\"ChangedSelection\", a.selection);\n      } finally {\n        a.currentCursor = \"\";\n      }\n    }\n    this.stopTool();\n  };\n  Gg.prototype.computeBoxBounds = function () {\n    var a = this.diagram;\n    return new N(a.firstInput.documentPoint, a.lastInput.documentPoint);\n  };\n  Gg.prototype.selectInRect = function (a) {\n    var b = this.diagram,\n      c = b.lastInput;\n    a = b.py(a, this.isPartialInclusion);\n    if (Wa ? c.meta : c.control) {\n      if (c.shift) for (a = a.iterator; a.next();) b = a.value, b.isSelected && (b.isSelected = !1);else for (a = a.iterator; a.next();) b = a.value, b.isSelected = !b.isSelected;\n    } else if (c.shift) for (a = a.iterator; a.next();) b = a.value, b.isSelected || (b.isSelected = !0);else {\n      c = new E();\n      for (b = b.selection.iterator; b.next();) {\n        var d = b.value;\n        a.contains(d) || c.add(d);\n      }\n      for (b = c.iterator; b.next();) b.value.isSelected = !1;\n      for (a = a.iterator; a.next();) b = a.value, b.isSelected || (b.isSelected = !0);\n    }\n  };\n  ma.Object.defineProperties(Gg.prototype, {\n    delay: {\n      get: function () {\n        return this.il;\n      },\n      set: function (a) {\n        this.il = a;\n      }\n    },\n    isPartialInclusion: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    box: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    }\n  });\n  Gg.className = \"DragSelectingTool\";\n  function Hg() {\n    Ce.call(this);\n    this.name = \"Panning\";\n    this.jv = new J();\n    this.gz = new J();\n    this.Pg = !1;\n    var a = this;\n    this.Jx = function () {\n      var b = a.diagram;\n      null !== b && b.removeEventListener(x.document, \"scroll\", a.Jx, !1);\n      a.stopTool();\n    };\n  }\n  la(Hg, Ce);\n  Hg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.allowHorizontalScroll && !a.allowVerticalScroll || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : !0;\n  };\n  Hg.prototype.doActivate = function () {\n    var a = this.diagram;\n    this.Pg ? (a.lastInput.bubbles = !0, a.addEventListener(x.document, \"scroll\", this.Jx, !1)) : (a.currentCursor = \"move\", a.isMouseCaptured = !0, this.jv.assign(a.position));\n    this.isActive = !0;\n  };\n  Hg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    a.currentCursor = \"\";\n    this.isActive = a.isMouseCaptured = !1;\n  };\n  Hg.prototype.doCancel = function () {\n    var a = this.diagram;\n    a.position = this.jv;\n    a.isMouseCaptured = !1;\n    this.stopTool();\n  };\n  Hg.prototype.doMouseMove = function () {\n    this.move();\n  };\n  Hg.prototype.doMouseUp = function () {\n    this.move();\n    this.stopTool();\n  };\n  Hg.prototype.move = function () {\n    var a = this.diagram;\n    if (this.isActive && a) if (this.Pg) a.lastInput.bubbles = !0;else {\n      var b = a.position,\n        c = a.firstInput.documentPoint,\n        d = a.lastInput.documentPoint,\n        e = b.x + c.x - d.x;\n      c = b.y + c.y - d.y;\n      a.allowHorizontalScroll || (e = b.x);\n      a.allowVerticalScroll || (c = b.y);\n      a.position = this.gz.h(e, c);\n    }\n  };\n  ma.Object.defineProperties(Hg.prototype, {\n    bubbles: {\n      get: function () {\n        return this.Pg;\n      },\n      set: function (a) {\n        this.Pg = a;\n      }\n    },\n    originalPosition: {\n      get: function () {\n        return this.jv;\n      }\n    }\n  });\n  Hg.className = \"PanningTool\";\n  La(\"clickCreatingTool\", function () {\n    return this.findTool(\"ClickCreating\");\n  }, function (a) {\n    this.Xa(\"ClickCreating\", a, this.mouseUpTools);\n  });\n  La(\"clickSelectingTool\", function () {\n    return this.findTool(\"ClickSelecting\");\n  }, function (a) {\n    this.Xa(\"ClickSelecting\", a, this.mouseUpTools);\n  });\n  La(\"panningTool\", function () {\n    return this.findTool(\"Panning\");\n  }, function (a) {\n    this.Xa(\"Panning\", a, this.mouseMoveTools);\n  });\n  La(\"dragSelectingTool\", function () {\n    return this.findTool(\"DragSelecting\");\n  }, function (a) {\n    this.Xa(\"DragSelecting\", a, this.mouseMoveTools);\n  });\n  La(\"actionTool\", function () {\n    return this.findTool(\"Action\");\n  }, function (a) {\n    this.Xa(\"Action\", a, this.mouseDownTools);\n  });\n  function Qe() {\n    this.T = this.I = this.l = this.v = null;\n  }\n  ma.Object.defineProperties(Qe.prototype, {\n    mainElement: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    show: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v !== a && (this.v = a);\n      }\n    },\n    hide: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l !== a && (this.l = a);\n      }\n    },\n    valueFunction: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    }\n  });\n  Qe.className = \"HTMLInfo\";\n  function Ig(a, b, c) {\n    this.text = a;\n    this.$x = b;\n    this.visible = c;\n  }\n  Ig.className = \"ContextMenuButtonInfo\";\n  function Jg() {\n    Ce.call(this);\n    this.name = \"ContextMenu\";\n    this.v = this.Bu = this.l = null;\n    this.zx = new J();\n    this.Cu = null;\n    this.Xu = !1;\n    var a = this;\n    this.wv = function () {\n      a.stopTool();\n    };\n  }\n  la(Jg, Ce);\n  function Kg(a) {\n    var b = new Qe();\n    b.show = function (a, b, c) {\n      c.showDefaultContextMenu();\n    };\n    b.hide = function (a, b) {\n      b.hideDefaultContextMenu();\n    };\n    Lg = b;\n    a.wv = function () {\n      a.stopTool();\n    };\n    b = ta(\"div\");\n    var c = ta(\"div\");\n    b.style.cssText = \"top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px\";\n    c.style.cssText = \"z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;\";\n    var d = ta(\"style\");\n    x.document.getElementsByTagName(\"head\")[0].appendChild(d);\n    d.sheet.insertRule(\".goCXul { list-style: none; }\", 0);\n    d.sheet.insertRule(\".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }\", 0);\n    d.sheet.insertRule(\".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }\", 0);\n    d = a.diagram;\n    null !== d && (d.addEventListener(b, \"contextmenu\", Mg, !1), d.addEventListener(b, \"selectstart\", Mg, !1), d.addEventListener(c, \"contextmenu\", Mg, !1));\n    b.className = \"goCXforeground\";\n    c.className = \"goCXbackground\";\n    x.document.body && (x.document.body.appendChild(b), x.document.body.appendChild(c));\n    Ng = b;\n    Og = c;\n    Pg = !0;\n  }\n  function Mg(a) {\n    a.preventDefault();\n    return !1;\n  }\n  Jg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return this.isBeyondDragSize() || !a.lastInput.right || 1 < a.lastInput.clickCount ? !1 : a.lastInput.isTouchEvent && null !== this.defaultTouchContextMenu || null !== this.findObjectWithContextMenu() ? !0 : !1;\n  };\n  Jg.prototype.doStart = function () {\n    this.zx.set(this.diagram.firstInput.documentPoint);\n  };\n  Jg.prototype.doStop = function () {\n    this.hideContextMenu();\n    this.currentObject = null;\n  };\n  Jg.prototype.findObjectWithContextMenu = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram,\n      c = b.lastInput,\n      d = null;\n    a instanceof Q || (a instanceof Y ? d = a : d = b.Ub(c.documentPoint, null, function (a) {\n      return !a.layer.isTemporary;\n    }));\n    if (null !== d) {\n      for (a = d; null !== a;) {\n        if (null !== a.contextMenu) return a;\n        a = a.panel;\n      }\n      if (b.lastInput.isTouchEvent && this.defaultTouchContextMenu) return d.part;\n    } else if (null !== b.contextMenu) return b;\n    return null;\n  };\n  Jg.prototype.doActivate = function () {};\n  Jg.prototype.doMouseDown = function () {\n    Ce.prototype.doMouseDown.call(this);\n    if (this.isActive && this.currentContextMenu instanceof He) {\n      var a = this.diagram.toolManager.findTool(\"Action\");\n      null !== a && a.canStart() && (a.doActivate(), a.doMouseDown(), a.doDeactivate());\n    }\n    this.diagram.toolManager.mouseDownTools.contains(this) && Qg(this);\n  };\n  Jg.prototype.doMouseUp = function () {\n    if (this.isActive && this.currentContextMenu instanceof He) {\n      var a = this.diagram.toolManager.findTool(\"Action\");\n      null !== a && a.canStart() && (a.doActivate(), a.doCancel(), a.doDeactivate());\n    }\n    Qg(this);\n  };\n  function Qg(a) {\n    var b = a.diagram;\n    if (a.isActive) {\n      var c = a.currentContextMenu;\n      if (null !== c) {\n        if (!(c instanceof Qe)) {\n          var d = b.Ub(b.lastInput.documentPoint, null, null);\n          null !== d && d.Gg(c) && a.standardMouseClick(null, null);\n        }\n        a.stopTool();\n        a.canStart() && (b.currentTool = a, a.doMouseUp());\n      }\n    } else a.canStart() && (Rg(a, !0), a.isActive || a.stopTool());\n  }\n  function Rg(a, b, c) {\n    void 0 === c && (c = null);\n    if (!a.Xu && (a.Xu = !0, b && a.standardMouseSelect(), b = a.standardMouseClick(), a.Xu = !1, !b)) {\n      a.isActive = !0;\n      b = Lg;\n      null === c && (c = a.findObjectWithContextMenu());\n      if (null !== c) {\n        var d = c.contextMenu;\n        null !== d ? (a.currentObject = c instanceof Y ? c : null, a.showContextMenu(d, a.currentObject)) : null !== b && a.showContextMenu(b, a.currentObject);\n      } else null !== b && a.showContextMenu(b, null);\n      a.currentContextMenu instanceof He && !a.currentContextMenu.visible && a.stopTool();\n    }\n  }\n  Jg.prototype.doMouseMove = function () {\n    var a = this.diagram.toolManager.findTool(\"Action\");\n    null !== a && a.doMouseMove();\n    this.isActive && this.diagram.toolManager.doMouseMove();\n  };\n  Jg.prototype.showContextMenu = function (a, b) {\n    var c = this.diagram;\n    a !== this.currentContextMenu && this.hideContextMenu();\n    if (a instanceof He) {\n      a.layerName = \"Tool\";\n      a.selectable = !1;\n      a.scale = 1 / c.scale;\n      a.category = this.name;\n      null !== a.placeholder && (a.placeholder.scale = c.scale);\n      var d = a.diagram;\n      null !== d && d !== c && d.remove(a);\n      c.add(a);\n      null !== b ? a.adornedObject = b : a.data = c.model;\n      a.Ta();\n      this.positionContextMenu(a, b);\n    } else a instanceof Qe && a.show(b, c, this);\n    this.currentContextMenu = a;\n  };\n  Jg.prototype.positionContextMenu = function (a) {\n    if (null === a.placeholder) {\n      var b = this.diagram,\n        c = b.lastInput.documentPoint.copy(),\n        d = a.measuredBounds,\n        e = b.viewportBounds;\n      b.lastInput.isTouchEvent && (c.x -= d.width);\n      c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale);\n      c.x < e.x && (c.x = e.x);\n      c.y + d.height > e.bottom && (c.y -= d.height + 5 / b.scale);\n      c.y < e.y && (c.y = e.y);\n      a.position = c;\n    }\n  };\n  Jg.prototype.hideContextMenu = function () {\n    var a = this.diagram,\n      b = this.currentContextMenu;\n    null !== b && (b instanceof He ? (a.remove(b), null !== this.Bu && this.Bu.Gf(b.category), b.data = null, b.adornedObject = null) : b instanceof Qe && (null !== b.hide ? b.hide(a, this) : null !== b.mainElement && (b.mainElement.style.display = \"none\")), this.currentContextMenu = null, this.standardMouseOver());\n  };\n  function Sg(a) {\n    var b = new E();\n    b.add(new Ig(\"Copy\", function (a) {\n      a.commandHandler.copySelection();\n    }, function (a) {\n      return a.commandHandler.canCopySelection();\n    }));\n    b.add(new Ig(\"Cut\", function (a) {\n      a.commandHandler.cutSelection();\n    }, function (a) {\n      return a.commandHandler.canCutSelection();\n    }));\n    b.add(new Ig(\"Delete\", function (a) {\n      a.commandHandler.deleteSelection();\n    }, function (a) {\n      return a.commandHandler.canDeleteSelection();\n    }));\n    b.add(new Ig(\"Paste\", function (b) {\n      b.commandHandler.pasteSelection(a.mouseDownPoint);\n    }, function (b) {\n      return b.commandHandler.canPasteSelection(a.mouseDownPoint);\n    }));\n    b.add(new Ig(\"Select All\", function (a) {\n      a.commandHandler.selectAll();\n    }, function (a) {\n      return a.commandHandler.canSelectAll();\n    }));\n    b.add(new Ig(\"Undo\", function (a) {\n      a.commandHandler.undo();\n    }, function (a) {\n      return a.commandHandler.canUndo();\n    }));\n    b.add(new Ig(\"Redo\", function (a) {\n      a.commandHandler.redo();\n    }, function (a) {\n      return a.commandHandler.canRedo();\n    }));\n    b.add(new Ig(\"Scroll To Part\", function (a) {\n      a.commandHandler.scrollToPart();\n    }, function (a) {\n      return a.commandHandler.canScrollToPart();\n    }));\n    b.add(new Ig(\"Zoom To Fit\", function (a) {\n      a.commandHandler.zoomToFit();\n    }, function (a) {\n      return a.commandHandler.canZoomToFit();\n    }));\n    b.add(new Ig(\"Reset Zoom\", function (a) {\n      a.commandHandler.resetZoom();\n    }, function (a) {\n      return a.commandHandler.canResetZoom();\n    }));\n    b.add(new Ig(\"Group Selection\", function (a) {\n      a.commandHandler.groupSelection();\n    }, function (a) {\n      return a.commandHandler.canGroupSelection();\n    }));\n    b.add(new Ig(\"Ungroup Selection\", function (a) {\n      a.commandHandler.ungroupSelection();\n    }, function (a) {\n      return a.commandHandler.canUngroupSelection();\n    }));\n    b.add(new Ig(\"Edit Text\", function (a) {\n      a.commandHandler.editTextBlock();\n    }, function (a) {\n      return a.commandHandler.canEditTextBlock();\n    }));\n    return b;\n  }\n  Jg.prototype.showDefaultContextMenu = function () {\n    var a = this.diagram;\n    null === this.Cu && (this.Cu = Sg(this));\n    Ng.innerHTML = \"\";\n    Og.addEventListener(\"click\", this.wv, !1);\n    var b = this,\n      c = ta(\"ul\");\n    c.className = \"goCXul\";\n    Ng.appendChild(c);\n    c.innerHTML = \"\";\n    for (var d = this.Cu.iterator; d.next();) {\n      var e = d.value,\n        f = e.visible;\n      if (\"function\" === typeof e.$x && (\"function\" !== typeof f || f(a))) {\n        f = ta(\"li\");\n        f.className = \"goCXli\";\n        var g = ta(\"a\");\n        g.className = \"goCXa\";\n        g.href = \"#\";\n        g.az = e.$x;\n        g.addEventListener(\"click\", function (c) {\n          this.az(a);\n          b.stopTool();\n          c.preventDefault();\n          return !1;\n        }, !1);\n        g.textContent = e.text;\n        f.appendChild(g);\n        c.appendChild(f);\n      }\n    }\n    Ng.style.display = \"block\";\n    Og.style.display = \"block\";\n  };\n  Jg.prototype.hideDefaultContextMenu = function () {\n    if (null !== this.currentContextMenu && this.currentContextMenu === Lg) {\n      Ng.style.display = \"none\";\n      Og.style.display = \"none\";\n      var a = this.diagram;\n      null !== a && a.removeEventListener(Og, \"click\", this.wv, !1);\n      this.currentContextMenu = null;\n    }\n  };\n  ma.Object.defineProperties(Jg.prototype, {\n    currentContextMenu: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n        this.Bu = a instanceof He ? a.adornedPart : null;\n      }\n    },\n    defaultTouchContextMenu: {\n      get: function () {\n        !1 === Pg && null === Lg && Tg && Kg(this);\n        return Lg;\n      },\n      set: function (a) {\n        null === a && (Pg = !0);\n        Lg = a;\n      }\n    },\n    currentObject: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    mouseDownPoint: {\n      get: function () {\n        return this.zx;\n      }\n    }\n  });\n  var Lg = null,\n    Pg = !1,\n    Og = null,\n    Ng = null;\n  Jg.className = \"ContextMenuTool\";\n  La(\"contextMenuTool\", function () {\n    return this.findTool(\"ContextMenu\");\n  }, function (a) {\n    this.Xa(\"ContextMenu\", a, this.mouseUpTools);\n  });\n  function Ug() {\n    Ce.call(this);\n    this.name = \"TextEditing\";\n    this.zh = new Vg();\n    this.Ka = null;\n    this.Ja = Wg;\n    this.Wi = null;\n    this.ia = Xg;\n    this.I = 1;\n    this.T = !0;\n    this.v = null;\n    this.l = new Qe();\n    this.Gu = null;\n    Yg(this, this.l);\n  }\n  la(Ug, Ce);\n  function Yg(a, b) {\n    if (Tg) {\n      var c = ta(\"textarea\");\n      a.Gu = c;\n      c.addEventListener(\"input\", function () {\n        if (null !== a.textBlock) {\n          var b = a.Gy(this.value);\n          this.style.width = 20 + b.measuredBounds.width * this.YA + \"px\";\n          this.rows = b.lineCount;\n        }\n      }, !1);\n      c.addEventListener(\"keydown\", function (b) {\n        if (null !== a.textBlock) {\n          var c = b.which;\n          13 === c ? (!1 === a.textBlock.isMultiline && b.preventDefault(), a.acceptText(Zg)) : 9 === c ? (a.acceptText($g), b.preventDefault()) : 27 === c && (a.doCancel(), null !== a.diagram && a.diagram.doFocus());\n        }\n      }, !1);\n      c.addEventListener(\"focus\", function () {\n        if (null !== a.currentTextEditor && a.state !== Xg) {\n          var b = a.Gu;\n          a.ia === ah && (a.ia = bh);\n          \"function\" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999));\n        }\n      }, !1);\n      c.addEventListener(\"blur\", function () {\n        if (null !== a.currentTextEditor && a.state !== Xg) {\n          var b = a.Gu;\n          \"function\" === typeof b.focus && b.focus();\n          \"function\" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999));\n        }\n      }, !1);\n      b.valueFunction = function () {\n        return c.value;\n      };\n      b.mainElement = c;\n      b.show = function (a, b, f) {\n        if (a instanceof Vg && f instanceof Ug) if (f.state === ch) c.style.border = \"3px solid red\", c.focus();else {\n          var d = a.ga(Bc),\n            e = b.position,\n            k = b.scale,\n            l = a.Af() * k;\n          l < f.minimumEditorScale && (l = f.minimumEditorScale);\n          var m = a.naturalBounds.width * l + 6,\n            n = a.naturalBounds.height * l + 2,\n            p = (d.x - e.x) * k;\n          d = (d.y - e.y) * k;\n          c.value = a.text;\n          b.div.style.font = a.font;\n          c.style.position = \"absolute\";\n          c.style.zIndex = \"100\";\n          c.style.font = \"inherit\";\n          c.style.fontSize = 100 * l + \"%\";\n          c.style.lineHeight = \"normal\";\n          c.style.width = m + \"px\";\n          c.style.left = (p - m / 2 | 0) - 1 + \"px\";\n          c.style.top = (d - n / 2 | 0) - 1 + \"px\";\n          c.style.textAlign = a.textAlign;\n          c.style.margin = \"0\";\n          c.style.padding = \"1px\";\n          c.style.border = \"0\";\n          c.style.outline = \"none\";\n          c.style.whiteSpace = \"pre-wrap\";\n          c.style.overflow = \"hidden\";\n          c.rows = a.lineCount;\n          c.YA = l;\n          c.className = \"goTXarea\";\n          b.div.appendChild(c);\n          c.focus();\n          f.selectsTextOnActivate && (c.select(), c.setSelectionRange(0, 9999));\n        }\n      };\n      b.hide = function (a) {\n        a.div.removeChild(c);\n      };\n    }\n  }\n  Ug.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (null === a || a.isReadOnly || dh && dh !== this && (dh.acceptText(eh), dh && dh !== this) || !a.lastInput.left || this.isBeyondDragSize()) return !1;\n    var b = a.Ub(a.lastInput.documentPoint);\n    if (!(null !== b && b instanceof Vg && b.editable && b.part.canEdit())) return !1;\n    b = b.part;\n    return null === b || this.starting === Wg && !b.isSelected || this.starting === fh && 2 > a.lastInput.clickCount ? !1 : !0;\n  };\n  Ug.prototype.doStart = function () {\n    dh = this;\n    null !== this.textBlock && this.doActivate();\n  };\n  Ug.prototype.doActivate = function () {\n    if (!this.isActive) {\n      var a = this.diagram;\n      if (null !== a) {\n        var b = this.textBlock;\n        null === b && (b = a.Ub(a.lastInput.documentPoint));\n        if (null !== b && b instanceof Vg && (this.textBlock = b, null !== b.part)) {\n          this.isActive = !0;\n          this.ia = ah;\n          var c = this.defaultTextEditor;\n          null !== b.textEditor && (c = b.textEditor);\n          this.zh = this.textBlock.copy();\n          var d = new N(this.textBlock.ga(wc), this.textBlock.ga(Hc));\n          a.zw(d);\n          c.show(b, a, this);\n          this.currentTextEditor = c;\n        }\n      }\n    }\n  };\n  Ug.prototype.doCancel = function () {\n    this.stopTool();\n  };\n  Ug.prototype.doMouseUp = function () {\n    this.canStart() && this.doActivate();\n  };\n  Ug.prototype.doMouseDown = function () {\n    this.isActive && this.acceptText(eh);\n  };\n  Ug.prototype.acceptText = function (a) {\n    switch (a) {\n      case eh:\n        if (this.ia === gh) this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus();else if (this.ia === ah || this.ia === ch || this.ia === bh) this.ia = hh, ih(this);\n        break;\n      case jh:\n      case Zg:\n      case $g:\n        if (Zg !== a || !0 !== this.textBlock.isMultiline) if (this.ia === ah || this.ia === ch || this.ia === bh) this.ia = hh, ih(this);\n    }\n  };\n  function ih(a) {\n    var b = a.textBlock,\n      c = a.diagram,\n      d = a.currentTextEditor;\n    if (null !== b && null !== d) {\n      var e = b.text,\n        f = \"\";\n      null !== d.valueFunction && (f = d.valueFunction());\n      if (a.isValidText(b, e, f)) a.va(a.name), a.ia = gh, a.transactionResult = a.name, b.text = f, d = a.textBlock, null !== d.textEdited && d.textEdited(d, e, f), null !== c && c.R(\"TextEdited\", b, e), a.Jg(), a.stopTool(), null !== c && c.doFocus();else {\n        a.ia = ch;\n        var g = a.textBlock;\n        null !== g.errorFunction && g.errorFunction(a, e, f);\n        d.show(b, c, a);\n      }\n    }\n  }\n  Ug.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    null !== a && (this.ia = Xg, this.textBlock = null, null !== this.currentTextEditor && this.currentTextEditor.hide(a, this), this.isActive = !1);\n  };\n  Ug.prototype.doStop = function () {\n    dh = null;\n  };\n  Ug.prototype.isValidText = function (a, b, c) {\n    var d = this.textValidation;\n    if (null !== d && !d(a, b, c)) return !1;\n    d = a.textValidation;\n    return null === d || d(a, b, c) ? !0 : !1;\n  };\n  Ug.prototype.Gy = function (a) {\n    var b = this.zh;\n    b.text = a;\n    b.measure(this.textBlock.Di, Infinity);\n    return b;\n  };\n  ma.Object.defineProperties(Ug.prototype, {\n    textBlock: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka = a;\n      }\n    },\n    currentTextEditor: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    defaultTextEditor: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    },\n    starting: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja = a;\n      }\n    },\n    textValidation: {\n      get: function () {\n        return this.Wi;\n      },\n      set: function (a) {\n        this.Wi = a;\n      }\n    },\n    minimumEditorScale: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    selectsTextOnActivate: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    state: {\n      get: function () {\n        return this.ia;\n      },\n      set: function (a) {\n        this.ia !== a && (this.ia = a);\n      }\n    }\n  });\n  Ug.prototype.measureTemporaryTextBlock = Ug.prototype.Gy;\n  var jh = new D(Ug, \"LostFocus\", 0),\n    eh = new D(Ug, \"MouseDown\", 1),\n    $g = new D(Ug, \"Tab\", 2),\n    Zg = new D(Ug, \"Enter\", 3),\n    kh = new D(Ug, \"SingleClick\", 0),\n    Wg = new D(Ug, \"SingleClickSelected\", 1),\n    fh = new D(Ug, \"DoubleClick\", 2),\n    Xg = new D(Ug, \"StateNone\", 0),\n    ah = new D(Ug, \"StateActive\", 1),\n    bh = new D(Ug, \"StateEditing\", 2),\n    hh = new D(Ug, \"StateValidating\", 3),\n    ch = new D(Ug, \"StateInvalid\", 4),\n    gh = new D(Ug, \"StateValidated\", 5),\n    dh = null;\n  Ug.className = \"TextEditingTool\";\n  Ug.LostFocus = jh;\n  Ug.MouseDown = eh;\n  Ug.Tab = $g;\n  Ug.Enter = Zg;\n  Ug.SingleClick = kh;\n  Ug.SingleClickSelected = Wg;\n  Ug.DoubleClick = fh;\n  Ug.StateNone = Xg;\n  Ug.StateActive = ah;\n  Ug.StateEditing = bh;\n  Ug.StateValidating = hh;\n  Ug.StateInvalid = ch;\n  Ug.StateValidated = gh;\n  La(\"textEditingTool\", function () {\n    return this.findTool(\"TextEditing\");\n  }, function (a) {\n    this.Xa(\"TextEditing\", a, this.mouseUpTools);\n  });\n  function lh() {\n    mh || (nh(), mh = !0);\n    this.B = De;\n    this.tl = this.df = this.rc = this.rs = this.ic = !1;\n    this.Ox = !0;\n    this.ul = oh;\n    this.sn = !1;\n    this.yi = this.gd = !0;\n    this.Xg = 600;\n    this.mx = this.Nx = !1;\n    this.Pe = new F();\n    this.Jd = new ph();\n    this.Jd.Rc = this;\n    this.Qk = new F();\n    this.tv = new F();\n    this.ot = new F();\n  }\n  lh.prototype.ae = function (a) {\n    this.B = a;\n  };\n  lh.prototype.canStart = function () {\n    return !0;\n  };\n  function Ch(a, b) {\n    Dh(a, b) && (a.df = !0);\n  }\n  function Dh(a, b) {\n    if (!a.gd || !a.canStart(b)) return !1;\n    a.Pe.add(b);\n    a.defaultAnimation.isAnimating && a.Nc();\n    return a.rc = !0;\n  }\n  function Eh(a) {\n    if (a.gd && a.rc) {\n      var b = a.Jd,\n        c = a.B,\n        d = a.Pe.contains(\"Model\");\n      d && (a.tl = !0, a.ul === oh ? (b.isViewportUnconstrained = !0, b.lc.clear(), b.add(c, \"position\", c.position.copy().offset(0, -200), c.position), b.add(c, \"opacity\", 0, 1)) : a.ul === Fh && b.lc.clear(), a.Ox = a.ul === Gh && c.Vs.w(c.la) ? !0 : !1, c.R(\"InitialAnimationStarting\", a));\n      d && !a.yi || 0 === b.lc.count ? (a.Pe.clear(), a.rc = !1, a.df = !1, b.lc.clear(), Hh(b, c), a.tl = !1, c.M()) : (a.Pe.clear(), c.Ae = !1, d = b.lc.get(c), c.autoScale !== Ih && null !== d && (delete d.start.scale, delete d.end.scale), x.requestAnimationFrame(function () {\n        !1 === a.rc || b.ic || (c.Ge(\"temporaryPixelRatio\") && We(c), Jh(c), a.rc = !1, a.df = !1, b.start(), Kh(a), c.Oa(), Lh(b, 0), Jf(c, !0), Mh(a), c.R(\"AnimationStarting\", a));\n      }));\n    }\n  }\n  function Nh(a, b, c, d) {\n    b instanceof S && (null !== b.fromNode || null !== b.toNode) || a.Jd.add(b, \"position\", c, d, !1);\n  }\n  t = lh.prototype;\n  t.bu = function (a) {\n    return this.Jd.bu(a);\n  };\n  t.dw = function (a) {\n    return this.Jd.dw(a);\n  };\n  function Oh(a, b) {\n    function c() {\n      0 < e.ot.count && (d.addAll(e.ot), e.ot.clear(), e.ic = !0);\n      if (!1 !== e.ic && 0 !== d.count) {\n        e.tv.addAll(d);\n        for (var a = e.tv.iterator; a.next();) {\n          var b = a.value;\n          if (!1 !== b.ic) {\n            a: if (0 < b.km.count) var h = !0;else {\n              for (h = b.lc.iterator; h.next();) {\n                var k = h.key;\n                if (k instanceof Y && null !== k.diagram || k instanceof Q) {\n                  h = !0;\n                  break a;\n                }\n              }\n              h = !1;\n            }\n            h ? Ph(b, !1) : b.Cl = !0;\n          }\n        }\n        e.tv.clear();\n        Kh(e);\n        Jf(e.B);\n        Mh(e);\n        x.requestAnimationFrame(c);\n      }\n    }\n    var d = a.Qk,\n      e = a;\n    a.ic ? a.ot.add(b) : (a.ic = !0, d.add(b), x.requestAnimationFrame(function () {\n      c();\n    }));\n  }\n  function Qh(a) {\n    for (a = a.Qk.iterator; a.next();) a.value.Cl = !1;\n  }\n  function Kh(a) {\n    if (!a.rs) {\n      var b = a.B;\n      a.Nx = b.skipsUndoManager;\n      a.mx = b.skipsModelSourceBindings;\n      b.skipsUndoManager = !0;\n      b.skipsModelSourceBindings = !0;\n      a.rs = !0;\n    }\n  }\n  function Mh(a) {\n    var b = a.B;\n    b.skipsUndoManager = a.Nx;\n    b.skipsModelSourceBindings = a.mx;\n    a.rs = !1;\n  }\n  t.Nc = function (a) {\n    var b = this.Jd;\n    !0 === this.rc && (this.tl = this.df = this.rc = !1, this.Pe.clear(), 0 < b.lc.count && this.B.Db());\n    if (this.ic) {\n      if (b.rm(!0), b.lc.clear(), Hh(b, null), !0 === a) for (a = this.Qk.ma(), b = 0; b < a.length; b++) a[b].rm(!0);\n    } else b.lc.clear(), Hh(b, this.B);\n  };\n  t.rm = function (a) {\n    a === this.defaultAnimation && this.defaultAnimation.lc.clear();\n    this.Qk.remove(a);\n    0 === this.Qk.count && (this.ic = !1, this.B.Db());\n    a === this.defaultAnimation && (this.defaultAnimation.lc.clear(), this.B.R(\"AnimationFinished\", this));\n  };\n  t.ik = function (a, b) {\n    this.df && (this.Pe.contains(\"Expand Tree\") || this.Pe.contains(\"Expand SubGraph\")) && this.Jd.ik(a, b);\n  };\n  t.gk = function (a, b) {\n    this.df && (this.Pe.contains(\"Collapse Tree\") || this.Pe.contains(\"Collapse SubGraph\")) && (this.Jd.gk(a, b), Rh(this.Jd, b, \"position\", b.position, b.position));\n  };\n  function Sh(a, b, c) {\n    a.df && !b.w(c) && (a.B.oj || (b = c.copy()), Rh(a.Jd, a.B, \"position\", b, c));\n  }\n  function Th(a, b, c, d, e) {\n    null === a && (a = \"rgba(0,0,0,0)\");\n    null === b && (b = \"rgba(0,0,0,0)\");\n    Uh(a);\n    Vh();\n    var f = Wh.l,\n      g = Wh.I,\n      h = Wh.v;\n    a = Wh.T;\n    Uh(b);\n    Vh();\n    var k = Wh.I,\n      l = Wh.v;\n    b = Wh.T;\n    f = e(c, f, Wh.l - f, d);\n    g = e(c, g, k - g, d);\n    h = e(c, h, l - h, d);\n    c = e(c, a, b - a, d);\n    return \"hsla(\" + f + \", \" + g + \"%, \" + h + \"%, \" + c + \")\";\n  }\n  function nh() {\n    var a = new H();\n    a.add(\"position:diagram\", function (a, c, d, e, f, g) {\n      a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g));\n    });\n    a.add(\"position\", function (a, c, d, e, f, g) {\n      f < g ? a.fr(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g), !1) : a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g));\n    });\n    a.add(\"location\", function (a, c, d, e, f, g) {\n      f < g ? a.fr(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g), !0) : a.location = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g));\n    });\n    a.add(\"position:placeholder\", function (a, c, d, e, f, g) {\n      f < g ? a.fr(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g), !1) : a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g));\n    });\n    a.add(\"position:node\", function (a, c, d, e, f, g) {\n      var b = a.actualBounds,\n        k = d.actualBounds;\n      d = k.x + k.width / 2 - b.width / 2;\n      b = k.y + k.height / 2 - b.height / 2;\n      f < g ? a.fr(e(f, c.x, d - c.x, g), e(f, c.y, b - c.y, g), !1) : a.position = new J(e(f, c.x, d - c.x, g), e(f, c.y, b - c.y, g));\n    });\n    a.add(\"desiredSize\", function (a, c, d, e, f, g) {\n      a.desiredSize = new N(e(f, c.width, d.width - c.width, g), e(f, c.height, d.height - c.height, g));\n    });\n    a.add(\"width\", function (a, c, d, e, f, g) {\n      a.width = e(f, c, d - c, g);\n    });\n    a.add(\"height\", function (a, c, d, e, f, g) {\n      a.height = e(f, c, d - c, g);\n    });\n    a.add(\"fill\", function (a, c, d, e, f, g) {\n      a.fill = Th(c, d, f, g, e);\n    });\n    a.add(\"stroke\", function (a, c, d, e, f, g) {\n      a.stroke = Th(c, d, f, g, e);\n    });\n    a.add(\"strokeWidth\", function (a, c, d, e, f, g) {\n      a.strokeWidth = e(f, c, d - c, g);\n    });\n    a.add(\"strokeDashOffset\", function (a, c, d, e, f, g) {\n      a.strokeDashOffset = e(f, c, d - c, g);\n    });\n    a.add(\"background\", function (a, c, d, e, f, g) {\n      a.background = Th(c, d, f, g, e);\n    });\n    a.add(\"areaBackground\", function (a, c, d, e, f, g) {\n      a.areaBackground = Th(c, d, f, g, e);\n    });\n    a.add(\"opacity\", function (a, c, d, e, f, g) {\n      a.opacity = e(f, c, d - c, g);\n    });\n    a.add(\"scale\", function (a, c, d, e, f, g) {\n      a.scale = e(f, c, d - c, g);\n    });\n    a.add(\"angle\", function (a, c, d, e, f, g) {\n      a.angle = e(f, c, d - c, g);\n    });\n    Xh = a;\n  }\n  ma.Object.defineProperties(lh.prototype, {\n    animationReasons: {\n      get: function () {\n        return this.Pe;\n      }\n    },\n    isEnabled: {\n      get: function () {\n        return this.gd;\n      },\n      set: function (a) {\n        this.gd = a;\n      }\n    },\n    duration: {\n      get: function () {\n        return this.Xg;\n      },\n      set: function (a) {\n        1 > a && va(a, \">= 1\", lh, \"duration\");\n        this.Xg = a;\n      }\n    },\n    isAnimating: {\n      get: function () {\n        return this.ic;\n      }\n    },\n    isTicking: {\n      get: function () {\n        return this.rs;\n      }\n    },\n    isInitial: {\n      get: function () {\n        return this.yi;\n      },\n      set: function (a) {\n        this.yi = a;\n      }\n    },\n    defaultAnimation: {\n      get: function () {\n        return this.Jd;\n      }\n    },\n    activeAnimations: {\n      get: function () {\n        return this.Qk;\n      }\n    },\n    initialAnimationStyle: {\n      get: function () {\n        return this.ul;\n      },\n      set: function (a) {\n        this.ul = a;\n      }\n    }\n  });\n  lh.prototype.stopAnimation = lh.prototype.Nc;\n  var Xh = null,\n    mh = !1,\n    oh = new D(lh, \"Default\", 1),\n    Gh = new D(lh, \"AnimateLocations\", 2),\n    Fh = new D(lh, \"None\", 3);\n  lh.className = \"AnimationManager\";\n  lh.defineAnimationEffect = function (a, b) {\n    mh || (nh(), mh = !0);\n    Xh.add(a, b);\n  };\n  lh.Default = oh;\n  lh.AnimateLocations = Gh;\n  lh.None = Fh;\n  function ph() {\n    this.xv = this.Mx = this.Rc = this.B = null;\n    this.Cl = this.ic = this.l = !1;\n    this.Yn = this.yd = 0;\n    this.Kr = this.Ju = Yh;\n    this.Bl = this.Bp = !1;\n    this.nv = 1;\n    this.lv = 0;\n    this.qd = this.Xg = NaN;\n    this.px = 0;\n    this.Zn = null;\n    this.v = Hb;\n    this.lc = new H();\n    this.hv = new H();\n    this.km = new F();\n    this.iv = new F();\n    this.nx = Zh;\n  }\n  ph.prototype.suspend = function () {\n    this.Cl = !0;\n  };\n  ph.prototype.advanceTo = function (a, b) {\n    b && (this.Cl = !1);\n    this.Bp && a >= this.qd && (this.Bl = !0, a -= this.qd);\n    this.px = a;\n    Ph(this, !0);\n    Kh(this.Rc);\n    Jf(this.B);\n    Mh(this.Rc);\n    this.B.Je();\n  };\n  function Hh(a, b) {\n    a.hv.clear();\n    a.Bl = !1;\n    a.lv = 0;\n    a.qd = NaN;\n    0 < a.km.count && a.km.clear();\n    0 < a.iv.count && a.iv.clear();\n    if (null !== b) for (a = b.links; a.next();) a.value.qg = null;\n  }\n  t = ph.prototype;\n  t.start = function () {\n    if (0 !== this.lc.count && !this.ic) {\n      for (var a = this.B, b = this.lc.iterator; b.next();) {\n        var c = b.value.end,\n          d = b.key;\n        if (c[\"position:placeholder\"]) {\n          var e = d.findVisibleNode();\n          if (e instanceof vf && null !== e.placeholder) {\n            var f = e.placeholder;\n            e = f.ga(wc);\n            f = f.padding;\n            e.x += f.left;\n            e.y += f.top;\n            c[\"position:placeholder\"] = e;\n          }\n        }\n        null === a && (d instanceof Q ? a = d : d instanceof Y && (a = d.diagram));\n      }\n      null !== a && (this.B = a, b = this.Rc = a.animationManager, !1 !== b.isEnabled && (this.qd = isNaN(this.Xg) ? b.duration : this.Xg, this.Kr = this.Ju, b.tl && b.ul === oh && this === b.defaultAnimation && (this.Kr = $h, this.qd = isNaN(this.Xg) ? 600 === b.duration ? 900 : b.duration : this.Xg), this.nx = a.scrollMode, this.isViewportUnconstrained && (a.Ti = ai), Kh(b), this.km.each(function (b) {\n        b.data = null;\n        a.add(b);\n      }), Mh(b), this.ic = !0, this.yd = +new Date(), this.Yn = this.yd + this.qd, Oh(b, this)));\n    }\n  };\n  t.nz = function (a, b) {\n    a.Wb() && (this.km.add(a), this.B = b);\n  };\n  t.add = function (a, b, c, d, e) {\n    \"position\" === b && c.w(d) || (null === this.B && (a instanceof Q ? this.B = a : a instanceof Y && null !== a.diagram && (this.B = a.diagram)), a instanceof U && !a.isAnimated || Rh(this, a, b, c, d, e));\n  };\n  function Rh(a, b, c, d, e, f) {\n    var g = a.lc;\n    b instanceof Q && \"position\" === c && (c = \"position:diagram\");\n    if (g.contains(b)) {\n      var h = g.H(b);\n      var k = h.start;\n      var l = h.end;\n      void 0 === k[c] && (k[c] = bi(d));\n      l[c] = bi(e);\n    } else k = {}, l = {}, k[c] = bi(d), l[c] = bi(e), h = k.position, b instanceof Y && h instanceof J && !h.u() && b.diagram.animationManager.Pe.contains(\"Expand SubGraph\") && h.assign(l.position), h = new ci(k, l, f), g.add(b, h);\n    g = k[c];\n    g instanceof J && !g.u() && g.assign(a.v);\n    f && 0 === c.indexOf(\"position:\") && b instanceof U ? h.Pv.location = bi(b.location) : f && (h.Pv[c] = bi(d));\n  }\n  function bi(a) {\n    return a instanceof J ? a.copy() : a instanceof M ? a.copy() : a;\n  }\n  t.bu = function (a) {\n    if (!this.ic) return !1;\n    a = this.lc.H(a);\n    return null !== a && a.pw;\n  };\n  t.dw = function (a) {\n    if (!this.ic) return !1;\n    a = this.lc.H(a);\n    return null !== a && (a.start.position || a.start.location);\n  };\n  function Ph(a, b) {\n    if (!a.Cl || b) {\n      var c = a.Rc;\n      if (!1 !== a.ic) {\n        var d = +new Date(),\n          e = d > a.Yn ? a.qd : d - a.yd;\n        b && (e = a.px, e < a.qd ? (a.yd = +new Date() - e, a.Yn = a.yd + a.qd) : e = a.qd);\n        Kh(c);\n        Lh(a, e);\n        Jf(a.B, !0);\n        Mh(c);\n        d > a.Yn && (a.Bp && !a.Bl ? (a.yd = +new Date(), a.Yn = a.yd + a.qd, a.Bl = !0) : a.rm(!1));\n      }\n    }\n  }\n  function Lh(a, b) {\n    for (var c = a.qd, d = a.lc.iterator, e = a.Bl; d.next();) {\n      var f = d.key;\n      if (!(f instanceof Y && null === f.diagram)) {\n        var g = d.value,\n          h = e ? g.end : g.start;\n        g = e ? g.start : g.end;\n        var k = Xh,\n          l;\n        for (l in g) \"position\" === l && (g[\"position:placeholder\"] || g[\"position:node\"]) || null === k.get(l) || k.get(l)(f, h[l], g[l], a.Kr, b, c, a);\n      }\n    }\n  }\n  t.stop = function () {\n    this.ic && this.rm(!0);\n  };\n  t.rm = function (a) {\n    null !== this.xv && this.xv.Ip.remove(this.Mx);\n    if (this.ic) {\n      var b = this.B,\n        c = this.Rc;\n      this.Cl = this.ic = c.tl = !1;\n      Kh(c);\n      for (var d = this.lc, e = this.km.iterator; e.next();) b.remove(e.value);\n      for (e = this.iv.iterator; e.next();) e.value.o();\n      e = this.Bp;\n      d = d.iterator;\n      for (var f = Xh; d.next();) {\n        var g = d.key,\n          h = d.value,\n          k = e ? h.end : h.start,\n          l = e ? h.start : h.end,\n          m = h.Pv,\n          n;\n        for (n in l) if (null !== f.get(n)) {\n          var p = n;\n          !h.Jv || \"position:node\" !== p && \"position:placeholder\" !== p || (p = \"position\");\n          f.get(p)(g, k[n], void 0 !== m[n] ? m[n] : h.Jv ? k[n] : l[n], this.Kr, this.qd, this.qd, this);\n        }\n        h.Jv && void 0 !== m.location && g instanceof U && (g.location = m.location);\n        h.pw && g instanceof U && g.Ob(!1);\n      }\n      if (c.defaultAnimation === this) for (n = this.B.links; n.next();) e = n.value, null === e.qg ? (d = e.path, null !== d && (e.dd = !1, e.o(), d.o())) : (e.points = e.qg, e.qg = null);\n      b.Xt.clear();\n      kf(b, !1);\n      b.Oa();\n      b.M();\n      Jf(b, !0);\n      this.isViewportUnconstrained && (b.scrollMode = this.nx);\n      Mh(c);\n      this.lv++;\n      !a && this.nv > this.lv ? (this.Bl = !1, this.start()) : (this.Zn && this.Zn(this), Hh(this, null), c.rm(this), b.Db());\n    }\n  };\n  t.ik = function (a, b) {\n    var c = b.actualBounds,\n      d = null;\n    b instanceof vf && (d = b.placeholder);\n    null !== d ? (c = d.ga(wc), d = d.padding, c.x += d.left, c.y += d.top, this.add(a, \"position\", c, a.position, !1)) : this.add(a, \"position\", new J(c.x + c.width / 2, c.y + c.height / 2), a.position, !1);\n    this.add(a, \"scale\", .01, a.scale, !1);\n    if (a instanceof vf) for (a = a.memberParts; a.next();) d = a.value, d instanceof V && this.ik(d, b);\n  };\n  t.gk = function (a, b) {\n    if (a.isVisible()) {\n      var c = null;\n      b instanceof vf && (c = b.placeholder);\n      null !== c ? this.add(a, \"position:placeholder\", a.position, c, !0) : this.add(a, \"position:node\", a.position, b, !0);\n      this.add(a, \"scale\", a.scale, .01, !0);\n      c = this.lc;\n      c.contains(a) && (c.H(a).pw = !0);\n      if (a instanceof vf) for (a = a.memberParts; a.next();) c = a.value, c instanceof V && this.gk(c, b);\n    }\n  };\n  t.kA = function (a) {\n    var b = this.hv.get(a);\n    null === b && (b = {}, this.hv.add(a, b));\n    return b;\n  };\n  ma.Object.defineProperties(ph.prototype, {\n    duration: {\n      get: function () {\n        return this.Xg;\n      },\n      set: function (a) {\n        1 > a && va(a, \">= 1\", ph, \"duration\");\n        this.Xg = a;\n      }\n    },\n    reversible: {\n      get: function () {\n        return this.Bp;\n      },\n      set: function (a) {\n        this.Bp = a;\n      }\n    },\n    runCount: {\n      get: function () {\n        return this.nv;\n      },\n      set: function (a) {\n        0 < a ? this.nv = a : B(\"Animation.runCount value must be a positive integer.\");\n      }\n    },\n    finished: {\n      get: function () {\n        return this.Zn;\n      },\n      set: function (a) {\n        this.Zn !== a && (this.Zn = a);\n      }\n    },\n    easing: {\n      get: function () {\n        return this.Ju;\n      },\n      set: function (a) {\n        this.Ju = a;\n      }\n    },\n    isViewportUnconstrained: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    },\n    isAnimating: {\n      get: function () {\n        return this.ic;\n      }\n    }\n  });\n  ph.prototype.getTemporaryState = ph.prototype.kA;\n  ph.prototype.stop = ph.prototype.stop;\n  ph.prototype.add = ph.prototype.add;\n  ph.prototype.addTemporaryPart = ph.prototype.nz;\n  function Yh(a, b, c, d) {\n    a /= d / 2;\n    return 1 > a ? c / 2 * a * a + b : -c / 2 * (--a * (a - 2) - 1) + b;\n  }\n  function $h(a, b, c, d) {\n    return a === d ? b + c : c * (-Math.pow(2, -10 * a / d) + 1) + b;\n  }\n  ph.className = \"Animation\";\n  ph.EaseLinear = function (a, b, c, d) {\n    return c * a / d + b;\n  };\n  ph.EaseInOutQuad = Yh;\n  ph.EaseInQuad = function (a, b, c, d) {\n    return c * (a /= d) * a + b;\n  };\n  ph.EaseOutQuad = function (a, b, c, d) {\n    return -c * (a /= d) * (a - 2) + b;\n  };\n  ph.EaseInExpo = function (a, b, c, d) {\n    return 0 === a ? b : c * Math.pow(2, 10 * (a / d - 1)) + b;\n  };\n  ph.EaseOutExpo = $h;\n  function ci(a, b, c) {\n    this.start = a;\n    this.end = b;\n    this.Pv = {};\n    this.Jv = c;\n    this.pw = !1;\n  }\n  ci.className = \"AnimationState\";\n  function di(a, b, c) {\n    this.jd = null;\n    this.ff = a;\n    this.aq = c || ei;\n    this.Vk = null;\n    void 0 !== b && (this.Vk = b, void 0 === c && (this.aq = fi));\n  }\n  di.prototype.copy = function () {\n    var a = new di(this.ff);\n    a.aq = this.aq;\n    var b = this.Vk;\n    if (null !== b) {\n      var c = {};\n      void 0 !== b.duration && (c.ky = b.duration);\n      void 0 !== b.finished && (c.ky = b.finished);\n      void 0 !== b.easing && (c.ky = b.easing);\n      a.Vk = c;\n    }\n    return a;\n  };\n  function gi(a, b) {\n    a = a.Vk;\n    null !== a && (a.duration && (b.duration = a.duration), a.finished && (b.finished = a.finished), a.easing && (b.easing = a.easing));\n  }\n  ma.Object.defineProperties(di.prototype, {\n    propertyName: {\n      get: function () {\n        return this.ff;\n      },\n      set: function (a) {\n        this.ff = a;\n      }\n    },\n    animationSettings: {\n      get: function () {\n        return this.Vk;\n      },\n      set: function (a) {\n        this.Vk = a;\n      }\n    },\n    startCondition: {\n      get: function () {\n        return this.aq;\n      },\n      set: function (a) {\n        this.aq = a;\n      }\n    }\n  });\n  var ei = new D(di, \"Default\", 1),\n    fi = new D(di, \"Immediate\", 2),\n    hi = new D(di, \"Bundled\", 3);\n  di.className = \"AnimationTrigger\";\n  di.Default = ei;\n  di.Immediate = fi;\n  di.Bundled = hi;\n  function ii() {\n    Ya(this);\n    this.B = null;\n    this.Da = new E();\n    this.Qa = \"\";\n    this.tb = 1;\n    this.v = !1;\n    this.Oi = this.I = this.ii = this.hi = this.gi = this.fi = this.di = this.ei = this.ci = this.ki = this.bi = this.ji = this.ai = this.$h = !0;\n    this.l = !1;\n    this.np = [];\n  }\n  t = ii.prototype;\n  t.clear = function () {\n    this.Da.clear();\n    this.np.length = 0;\n  };\n  t.ae = function (a) {\n    this.B = a;\n  };\n  t.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = 'Layer \"' + this.name + '\"';\n    if (0 >= a) return b;\n    for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = this.Da.iterator; h.next();) {\n      var k = h.value;\n      k instanceof vf ? e++ : k instanceof V ? d++ : k instanceof S ? f++ : k instanceof He ? g++ : c++;\n    }\n    h = \"\";\n    0 < c && (h += c + \" Parts \");\n    0 < d && (h += d + \" Nodes \");\n    0 < e && (h += e + \" Groups \");\n    0 < f && (h += f + \" Links \");\n    0 < g && (h += g + \" Adornments \");\n    if (1 < a) for (a = this.Da.iterator; a.next();) c = a.value, h += \"\\n    \" + c.toString(), d = c.data, null !== d && mb(d) && (h += \" #\" + mb(d)), c instanceof V ? h += \" \" + Ja(d) : c instanceof S && (h += \" \" + Ja(c.fromNode) + \" \" + Ja(c.toNode));\n    return b + \" \" + this.Da.count + \": \" + h;\n  };\n  t.Ub = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    if (!1 === this.Oi) return null;\n    var d = !1;\n    null !== this.diagram && this.diagram.viewportBounds.aa(a) && (d = !0);\n    for (var e = J.alloc(), f = this.Da.j, g = f.length; g--;) {\n      var h = f[g];\n      if ((!0 !== d || !1 !== vg(h)) && h.isVisible() && (e.assign(a), Bb(e, h.Ad), h = h.Ub(e, b, c), null !== h && (null !== b && (h = b(h)), null !== h && (null === c || c(h))))) return J.free(e), h;\n    }\n    J.free(e);\n    return null;\n  };\n  t.hj = function (a, b, c, d) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    d instanceof E || d instanceof F || (d = new F());\n    if (!1 === this.Oi) return d;\n    var e = !1;\n    null !== this.diagram && this.diagram.viewportBounds.aa(a) && (e = !0);\n    for (var f = J.alloc(), g = this.Da.j, h = g.length; h--;) {\n      var k = g[h];\n      if ((!0 !== e || !1 !== vg(k)) && k.isVisible()) {\n        f.assign(a);\n        Bb(f, k.Ad);\n        var l = k;\n        k.hj(f, b, c, d) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || d.add(l));\n      }\n    }\n    J.free(f);\n    return d;\n  };\n  t.zf = function (a, b, c, d, e) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    void 0 === d && (d = !1);\n    e instanceof E || e instanceof F || (e = new F());\n    if (!1 === this.Oi) return e;\n    var f = !1;\n    null !== this.diagram && this.diagram.viewportBounds.De(a) && (f = !0);\n    for (var g = this.Da.j, h = g.length; h--;) {\n      var k = g[h];\n      if ((!0 !== f || !1 !== vg(k)) && k.isVisible()) {\n        var l = k;\n        k.zf(a, b, c, d, e) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || e.add(l));\n      }\n    }\n    return e;\n  };\n  t.Uv = function (a, b, c, d, e, f, g) {\n    if (!1 === this.Oi) return e;\n    for (var h = this.Da.j, k = h.length; k--;) {\n      var l = h[k];\n      if ((!0 !== g || !1 !== vg(l)) && f(l) && l.isVisible()) {\n        var m = l;\n        l.zf(a, b, c, d, e) && (null !== b && (m = b(m)), null === m || null !== c && !c(m) || e.add(m));\n      }\n    }\n    return e;\n  };\n  t.Eg = function (a, b, c, d, e, f) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    void 0 === e && (e = !0);\n    if (!1 !== e && !0 !== e) {\n      if (e instanceof E || e instanceof F) f = e;\n      e = !0;\n    }\n    f instanceof E || f instanceof F || (f = new F());\n    if (!1 === this.Oi) return f;\n    var g = !1;\n    null !== this.diagram && this.diagram.viewportBounds.aa(a) && (g = !0);\n    for (var h = J.alloc(), k = J.alloc(), l = this.Da.j, m = l.length; m--;) {\n      var n = l[m];\n      if ((!0 !== g || !1 !== vg(n)) && n.isVisible()) {\n        h.assign(a);\n        Bb(h, n.Ad);\n        k.h(a.x + b, a.y);\n        Bb(k, n.Ad);\n        var p = n;\n        n.Eg(h, k, c, d, e, f) && (null !== c && (p = c(p)), null === p || null !== d && !d(p) || f.add(p));\n      }\n    }\n    J.free(h);\n    J.free(k);\n    return f;\n  };\n  t.Fd = function (a, b) {\n    if (this.visible) {\n      var c = this.Da.j,\n        d = c.length;\n      if (0 !== d) {\n        a = Ea();\n        for (var e = Ea(), f = 0; f < d; f++) {\n          var g = c[f];\n          g.xx = f;\n          if (g instanceof S) {\n            if (!1 === g.dd) continue;\n          } else if (g instanceof He && null !== g.adornedPart) continue;\n          dc(g.actualBounds, b) ? (g.Fd(!0), a.push(g)) : (g.Fd(!1), null !== g.adornments && 0 < g.adornments.count && e.push(g));\n        }\n        for (b = 0; b < a.length; b++) for (c = a[b], ji(c), c = c.adornments; c.next();) d = c.value, d.measure(Infinity, Infinity), d.arrange(), d.Fd(!0);\n        for (b = 0; b < e.length; b++) ji(e[b]);\n        Ha(a);\n        Ha(e);\n      }\n    }\n  };\n  function ki(a, b) {\n    var c = 1;\n    1 !== a.tb && (c = b.globalAlpha, b.globalAlpha = c * a.tb);\n    return c;\n  }\n  t.bc = function (a, b, c) {\n    if (this.visible && 0 !== this.tb && (void 0 === c && (c = !0), c || !this.isTemporary)) {\n      c = this.Da.j;\n      var d = c.length;\n      if (0 !== d) {\n        var e = ki(this, a),\n          f = this.np;\n        f.length = 0;\n        for (var g = b.scale, h = N.alloc(), k = 0; k < d; k++) this.dj(a, c[k], b, f, g, h, !0);\n        N.free(h);\n        a.globalAlpha = e;\n      }\n    }\n  };\n  t.dj = function (a, b, c, d, e, f, g) {\n    if (!g || vg(b)) {\n      if (null !== d && b instanceof S && (b.isOrthogonal && d.push(b), !1 === b.dd)) return;\n      g = b.actualBounds;\n      d = !1;\n      var h = b.containingGroup;\n      if (null !== h && h.isClipping && h.type !== X.Spot && b.isVisible()) {\n        d = h.resizeObject;\n        d instanceof X && (d = d.pb());\n        d.wm(f);\n        d instanceof W && f.Ic(-d.strokeWidth, -d.strokeWidth);\n        if (!f.Lc(g)) return;\n        d = !f.De(g);\n      }\n      d && (a.save(), a.beginPath(), a.rect(f.x, f.y, f.width, f.height), a.clip());\n      g.width * e > c.To || g.height * e > c.To ? b.bc(a, c) : (e = b.actualBounds, f = b.naturalBounds, 0 === e.width || 0 === e.height || isNaN(e.x) || isNaN(e.y) || !b.isVisible() || (c = b.transform, null !== b.areaBackground && (li(b, a, b.areaBackground, !0, !0, f, e), a.fillRect(e.x, e.y, e.width, e.height)), null === b.areaBackground && null === b.background && (li(b, a, \"rgba(0,0,0,0.3)\", !0, !1, f, e), a.fillRect(e.x, e.y, e.width, e.height)), null !== b.background && (a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), li(b, a, b.background, !0, !1, f, e), a.fillRect(0, 0, f.width / 2, f.height / 2), c.Tt() || (b = 1 / (c.m11 * c.m22 - c.m12 * c.m21), a.transform(c.m22 * b, -c.m12 * b, -c.m21 * b, c.m11 * b, b * (c.m21 * c.dy - c.m22 * c.dx), b * (c.m12 * c.dx - c.m11 * c.dy))))));\n      d && (a.restore(), a.tc(!0));\n    }\n  };\n  t.g = function (a, b, c, d, e) {\n    var f = this.diagram;\n    null !== f && f.ab(ve, a, this, b, c, d, e);\n  };\n  t.nj = function (a, b, c) {\n    var d = this.Da;\n    b.Ei = this;\n    if (a >= d.count) a = d.count;else if (d.L(a) === b) return -1;\n    d.vb(a, b);\n    b.Kq(c);\n    d = this.diagram;\n    null !== d && (c ? d.M() : d.nj(b));\n    mi(this, a, b);\n    return a;\n  };\n  t.Kc = function (a, b, c) {\n    if (!c && b.layer !== this && null !== b.layer) return b.layer.Kc(a, b, c);\n    var d = this.Da;\n    if (0 > a || a >= d.length) {\n      if (a = d.indexOf(b), 0 > a) return -1;\n    } else if (d.L(a) !== b && (a = d.indexOf(b), 0 > a)) return -1;\n    b.Lq(c);\n    d.bb(a);\n    d = this.diagram;\n    null !== d && (c ? d.M() : d.Kc(b));\n    b.Ei = null;\n    return a;\n  };\n  function mi(a, b, c) {\n    b = ni(a, b, c);\n    if (c instanceof vf && null !== c && isNaN(c.zOrder)) {\n      if (0 !== c.memberParts.count) {\n        for (var d = -1, e = a.Da.j, f = e.length, g = 0; g < f; g++) {\n          var h = e[g];\n          if (h === c && (b = g, 0 <= d)) break;\n          if (0 > d && h.containingGroup === c && (d = g, 0 <= b)) break;\n        }\n        !(0 > d) && d < b && (e = a.Da, e.bb(b), e.vb(d, c));\n      }\n      c = c.containingGroup;\n      null !== c && mi(a, -1, c);\n    }\n  }\n  function ni(a, b, c) {\n    var d = c.zOrder;\n    if (isNaN(d)) return b;\n    a = a.Da;\n    var e = a.count;\n    if (1 >= e) return b;\n    0 > b && (b = a.indexOf(c));\n    if (0 > b) return -1;\n    for (var f = b - 1, g = NaN; 0 <= f;) {\n      g = a.L(f).zOrder;\n      if (!isNaN(g)) break;\n      f--;\n    }\n    for (var h = b + 1, k = NaN; h < e;) {\n      k = a.L(h).zOrder;\n      if (!isNaN(k)) break;\n      h++;\n    }\n    if (!isNaN(g) && g > d) for (;;) {\n      if (-1 === f || g <= d) {\n        f++;\n        if (f === b) break;\n        a.bb(b);\n        a.vb(f, c);\n        return f;\n      }\n      for (g = NaN; 0 <= --f && (g = a.L(f).zOrder, isNaN(g)););\n    } else if (!isNaN(k) && k < d) for (;;) {\n      if (h === e || k >= d) {\n        h--;\n        if (h === b) break;\n        a.bb(b);\n        a.vb(h, c);\n        return h;\n      }\n      for (k = NaN; ++h < e && (k = a.L(h).zOrder, isNaN(k)););\n    }\n    return b;\n  }\n  ma.Object.defineProperties(ii.prototype, {\n    parts: {\n      get: function () {\n        return this.Da.iterator;\n      }\n    },\n    partsBackwards: {\n      get: function () {\n        return this.Da.iteratorBackwards;\n      }\n    },\n    diagram: {\n      get: function () {\n        return this.B;\n      }\n    },\n    name: {\n      get: function () {\n        return this.Qa;\n      },\n      set: function (a) {\n        var b = this.Qa;\n        if (b !== a) {\n          var c = this.diagram;\n          if (null !== c) for (\"\" === b && B(\"Cannot rename default Layer to: \" + a), c = c.layers; c.next();) c.value.name === a && B(\"Layer.name is already present in this diagram: \" + a);\n          this.Qa = a;\n          this.g(\"name\", b, a);\n          for (a = this.Da.iterator; a.next();) a.value.layerName = this.Qa;\n        }\n      }\n    },\n    opacity: {\n      get: function () {\n        return this.tb;\n      },\n      set: function (a) {\n        var b = this.tb;\n        b !== a && ((0 > a || 1 < a) && va(a, \"0 <= value <= 1\", ii, \"opacity\"), this.tb = a, this.g(\"opacity\", b, a), a = this.diagram, null !== a && a.M());\n      }\n    },\n    isTemporary: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        var b = this.v;\n        b !== a && (this.v = a, this.g(\"isTemporary\", b, a));\n      }\n    },\n    visible: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        var b = this.I;\n        if (b !== a) {\n          this.I = a;\n          this.g(\"visible\", b, a);\n          for (b = this.Da.iterator; b.next();) b.value.Ob(a);\n          a = this.diagram;\n          null !== a && a.M();\n        }\n      }\n    },\n    pickable: {\n      get: function () {\n        return this.Oi;\n      },\n      set: function (a) {\n        var b = this.Oi;\n        b !== a && (this.Oi = a, this.g(\"pickable\", b, a));\n      }\n    },\n    isBoundsIncluded: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l !== a && (this.l = a, null !== this.diagram && this.diagram.Oa());\n      }\n    },\n    allowCopy: {\n      get: function () {\n        return this.$h;\n      },\n      set: function (a) {\n        var b = this.$h;\n        b !== a && (this.$h = a, this.g(\"allowCopy\", b, a));\n      }\n    },\n    allowDelete: {\n      get: function () {\n        return this.ai;\n      },\n      set: function (a) {\n        var b = this.ai;\n        b !== a && (this.ai = a, this.g(\"allowDelete\", b, a));\n      }\n    },\n    allowTextEdit: {\n      get: function () {\n        return this.ji;\n      },\n      set: function (a) {\n        var b = this.ji;\n        b !== a && (this.ji = a, this.g(\"allowTextEdit\", b, a));\n      }\n    },\n    allowGroup: {\n      get: function () {\n        return this.bi;\n      },\n      set: function (a) {\n        var b = this.bi;\n        b !== a && (this.bi = a, this.g(\"allowGroup\", b, a));\n      }\n    },\n    allowUngroup: {\n      get: function () {\n        return this.ki;\n      },\n      set: function (a) {\n        var b = this.ki;\n        b !== a && (this.ki = a, this.g(\"allowUngroup\", b, a));\n      }\n    },\n    allowLink: {\n      get: function () {\n        return this.ci;\n      },\n      set: function (a) {\n        var b = this.ci;\n        b !== a && (this.ci = a, this.g(\"allowLink\", b, a));\n      }\n    },\n    allowRelink: {\n      get: function () {\n        return this.ei;\n      },\n      set: function (a) {\n        var b = this.ei;\n        b !== a && (this.ei = a, this.g(\"allowRelink\", b, a));\n      }\n    },\n    allowMove: {\n      get: function () {\n        return this.di;\n      },\n      set: function (a) {\n        var b = this.di;\n        b !== a && (this.di = a, this.g(\"allowMove\", b, a));\n      }\n    },\n    allowReshape: {\n      get: function () {\n        return this.fi;\n      },\n      set: function (a) {\n        var b = this.fi;\n        b !== a && (this.fi = a, this.g(\"allowReshape\", b, a));\n      }\n    },\n    allowResize: {\n      get: function () {\n        return this.gi;\n      },\n      set: function (a) {\n        var b = this.gi;\n        b !== a && (this.gi = a, this.g(\"allowResize\", b, a));\n      }\n    },\n    allowRotate: {\n      get: function () {\n        return this.hi;\n      },\n      set: function (a) {\n        var b = this.hi;\n        b !== a && (this.hi = a, this.g(\"allowRotate\", b, a));\n      }\n    },\n    allowSelect: {\n      get: function () {\n        return this.ii;\n      },\n      set: function (a) {\n        var b = this.ii;\n        b !== a && (this.ii = a, this.g(\"allowSelect\", b, a));\n      }\n    }\n  });\n  ii.prototype.findObjectsNear = ii.prototype.Eg;\n  ii.prototype.findObjectsIn = ii.prototype.zf;\n  ii.prototype.findObjectsAt = ii.prototype.hj;\n  ii.prototype.findObjectAt = ii.prototype.Ub;\n  ii.className = \"Layer\";\n  function Q(a) {\n    1 < arguments.length && B(\"Diagram constructor can only take one optional argument, the DIV HTML element or its id.\");\n    oi || (pi(), oi = !0);\n    Ya(this);\n    De = this;\n    Qa = [];\n    this.Rb = !0;\n    this.Rc = new lh();\n    this.Rc.ae(this);\n    this.nb = 17;\n    this.Al = this.pv = !1;\n    this.Us = \"default\";\n    this.Ea = null;\n    if (Tg) {\n      var b = this,\n        c = function () {\n          b.removeEventListener(x.document, \"DOMContentLoaded\", c, !1);\n          b.setRTL();\n        };\n      null !== x.document.body ? this.setRTL() : b.addEventListener(x.document, \"DOMContentLoaded\", c, !1);\n    }\n    this.La = new E();\n    this.wa = this.xa = 0;\n    this.Sl = this.ta = null;\n    this.Ix = new H();\n    this.gf = this.Gb = null;\n    this.ww();\n    this.Kj = null;\n    this.vw();\n    this.tb = 1;\n    this.la = new J(NaN, NaN).freeze();\n    this.Vs = new J(NaN, NaN);\n    this.Pn = this.ya = 1;\n    this.gs = new J(NaN, NaN).freeze();\n    this.hs = NaN;\n    this.zs = 1E-4;\n    this.xs = 100;\n    this.ob = new rd();\n    this.xt = new J(NaN, NaN).freeze();\n    this.bs = new N(NaN, NaN, NaN, NaN).freeze();\n    this.Si = new pc(0, 0, 0, 0).freeze();\n    this.Ti = Zh;\n    this.ct = !1;\n    this.Ws = this.Qs = null;\n    this.Og = Ih;\n    this.Aj = ad;\n    this.Yf = Ih;\n    this.qo = ad;\n    this.js = this.fs = wc;\n    this.Dc = !0;\n    this.yl = !1;\n    this.rd = new F();\n    this.Vg = new H();\n    this.kl = !0;\n    this.pn = 250;\n    this.yj = -1;\n    this.rn = new pc(16, 16, 16, 16).freeze();\n    this.Ej = this.Ae = !1;\n    this.Hj = !0;\n    this.Vf = new re();\n    this.Vf.diagram = this;\n    this.Ud = new re();\n    this.Ud.diagram = this;\n    this.gh = new re();\n    this.gh.diagram = this;\n    this.se = this.Nf = null;\n    this.ek = !1;\n    this.Rr = this.Sr = null;\n    this.ln = x.PointerEvent && (Ta || Ua || Va) && x.navigator && !1 !== x.navigator.msPointerEnabled;\n    qi(this);\n    this.Dh = new F();\n    this.ss = !0;\n    this.rt = ri;\n    this.Tu = !1;\n    this.tt = Nf;\n    this.Ka = null;\n    si.add(\"Model\", ti);\n    this.Lr = this.Or = this.pt = null;\n    this.On = this.Jr = \"auto\";\n    this.gg = this.Cs = this.ig = this.jg = this.lg = this.Pf = this.Tf = this.Of = null;\n    this.es = !1;\n    this.Qf = this.wg = this.kg = this.hg = null;\n    this.Ds = !1;\n    this.Os = {};\n    this.Zj = [null, null];\n    this.Dr = null;\n    this.Pr = this.gt = this.rv = this.ug = !1;\n    this.$u = !0;\n    this.xi = this.jc = !1;\n    this.ac = null;\n    var d = this;\n    this.Bc = function (a) {\n      var b = d.partManager;\n      if (a.model === b.diagram.model && b.diagram.Z) {\n        b.diagram.Z = !1;\n        try {\n          var c = a.change;\n          \"\" === a.modelChange && c === ve && b.updateDataBindings(a.object, a.propertyName);\n        } finally {\n          b.diagram.Z = !0;\n        }\n      }\n    };\n    this.Qc = function (a) {\n      d.partManager.doModelChanged(a);\n    };\n    this.zv = !0;\n    this.Pd = -2;\n    this.Pi = new H();\n    this.Ns = new E();\n    this.$f = !1;\n    this.ai = this.$h = this.qr = this.gd = !0;\n    this.rr = !1;\n    this.xr = this.vr = this.ii = this.hi = this.gi = this.fi = this.di = this.ei = this.ci = this.ur = this.ki = this.bi = this.ji = this.sr = !0;\n    this.Zf = this.Wu = !1;\n    this.wr = this.tr = this.ql = this.pl = !0;\n    this.bt = this.Ys = 16;\n    this.Xs = this.Kp = !1;\n    this.Lp = this.$s = null;\n    this.Zs = this.at = 0;\n    this.gb = new pc(5).freeze();\n    this.qv = new F().freeze();\n    this.ys = 999999999;\n    this.Qu = new F().freeze();\n    this.wi = this.vi = this.ui = !0;\n    this.Xe = this.le = !1;\n    this.kc = null;\n    this.Ng = !0;\n    this.me = !1;\n    this.yx = new F();\n    this.Ru = new F();\n    this.Gc = null;\n    this.Pl = 1;\n    this.sv = 0;\n    this.Vd = {\n      scale: 1,\n      position: new J(),\n      bounds: new N(),\n      gw: !1\n    };\n    this.Px = new N(NaN, NaN, NaN, NaN).freeze();\n    this.mm = new M(NaN, NaN).freeze();\n    this.Qn = new N(NaN, NaN, NaN, NaN).freeze();\n    this.ts = !1;\n    this.Ho = this.oo = this.gp = this.Eu = this.Du = this.Fu = this.bg = this.eh = this.cf = this.Vr = null;\n    ui(this);\n    this.Ib = null;\n    this.no = !1;\n    this.Bj = null;\n    this.partManager = new ti();\n    this.toolManager = new Oa();\n    this.toolManager.initializeStandardTools();\n    this.currentTool = this.defaultTool = this.toolManager;\n    this.Ur = null;\n    this.dl = new Te();\n    this.Is = this.Hs = null;\n    this.cq = !1;\n    this.commandHandler = vi();\n    this.model = wi();\n    this.ug = !0;\n    xi(this);\n    this.layout = new yi();\n    this.ug = !1;\n    this.qx = this.Iu = null;\n    this.Sb = 1;\n    this.yh = null;\n    this.To = 1;\n    this.Zo = 0;\n    this.gv = [0, 0, 0, 0, 0];\n    this.$o = 0;\n    this.sd = 1;\n    this.Pj = 0;\n    this.Co = new J();\n    this.qt = 500;\n    this.qn = new J();\n    this.ne = !1;\n    this.Gm = this.Hm = this.Fm = this.Em = this.Ek = this.Gk = this.Fk = this.Ck = this.Dk = this.Uw = this.Lw = this.Mw = this.Nw = this.sh = this.Ul = this.rh = this.Tl = null;\n    this.Zq = function () {};\n    this.preventDefault = null;\n    this.so = !1;\n    this.ti = new zi();\n    this.eq = !1;\n    void 0 !== a && Hi(this, a);\n    this.$n = null;\n    this.ao = Lb;\n    this.Rb = !1;\n  }\n  Q.prototype.clear = function () {\n    this.animationManager.Nc();\n    this.model.clear();\n    Ii = null;\n    Ji = \"\";\n    Ki(this, !1);\n    this.Oa();\n    this.Ta();\n    this.M();\n  };\n  function Ki(a, b) {\n    a.animationManager.Nc(!0);\n    a.qv = new F().freeze();\n    a.Qu = new F().freeze();\n    var c = a.skipsUndoManager;\n    null !== a.model && (a.skipsUndoManager = !0);\n    var d = null;\n    null !== a.Ib && (d = a.Ib.part, null !== d && a.remove(d));\n    var e = [],\n      f = a.La.length;\n    if (b) {\n      for (b = 0; b < f; b++) for (var g = a.La.j[b].parts; g.next();) {\n        var h = g.value;\n        h !== d && null === h.data && e.push(h);\n      }\n      for (b = 0; b < e.length; b++) a.remove(e[b]);\n    }\n    for (b = 0; b < f; b++) a.La.j[b].clear();\n    a.partManager.clear();\n    a.rd.clear();\n    a.Vg.clear();\n    a.Dh.clear();\n    a.Bj = null;\n    Ga = [];\n    null !== d && (a.add(d), a.partManager.parts.remove(d));\n    null !== a.model && (a.skipsUndoManager = c);\n    return e;\n  }\n  function vi() {\n    return null;\n  }\n  Q.prototype.reset = function () {\n    this.clear();\n    this.Rb = !0;\n    this.Rc = new lh();\n    this.Rc.ae(this);\n    this.nb = 17;\n    this.Al = this.pv = !1;\n    this.Us = \"default\";\n    this.La = new E();\n    this.Ix = new H();\n    this.gf = null;\n    this.ww();\n    this.Kj = null;\n    this.vw();\n    this.tb = 1;\n    this.la = new J(NaN, NaN).freeze();\n    this.Vs = new J(NaN, NaN);\n    this.Pn = this.ya = 1;\n    this.gs = new J(NaN, NaN).freeze();\n    this.hs = NaN;\n    this.zs = 1E-4;\n    this.xs = 100;\n    this.ob = new rd();\n    this.xt = new J(NaN, NaN).freeze();\n    this.bs = new N(NaN, NaN, NaN, NaN).freeze();\n    this.Si = new pc(0, 0, 0, 0).freeze();\n    this.Ti = Zh;\n    this.ct = !1;\n    this.Ws = this.Qs = null;\n    this.Og = Ih;\n    this.Aj = ad;\n    this.Yf = Ih;\n    this.qo = ad;\n    this.js = this.fs = wc;\n    this.Dc = !0;\n    this.yl = !1;\n    this.rd = new F();\n    this.Vg = new H();\n    this.kl = !0;\n    this.pn = 250;\n    this.yj = -1;\n    this.rn = new pc(16, 16, 16, 16).freeze();\n    this.Ej = this.Ae = !1;\n    this.Hj = !0;\n    this.Vf = new re();\n    this.Vf.diagram = this;\n    this.Ud = new re();\n    this.Ud.diagram = this;\n    this.gh = new re();\n    this.gh.diagram = this;\n    this.se = this.Nf = null;\n    this.ek = !1;\n    this.Rr = this.Sr = null;\n    this.ln = x.PointerEvent && (Ta || Ua || Va) && x.navigator && !1 !== x.navigator.msPointerEnabled;\n    qi(this);\n    this.Dh = new F();\n    this.ss = !0;\n    this.rt = ri;\n    this.Tu = !1;\n    this.tt = Nf;\n    this.Lr = this.Or = this.pt = null;\n    this.On = this.Jr = \"auto\";\n    this.gg = this.Cs = this.ig = this.jg = this.lg = this.Pf = this.Tf = this.Of = null;\n    this.es = !1;\n    this.Qf = this.wg = this.kg = this.hg = null;\n    this.Ds = !1;\n    this.Os = {};\n    this.Zj = [null, null];\n    this.Dr = null;\n    this.Pr = this.gt = this.rv = this.ug = !1;\n    this.$u = !0;\n    this.xi = this.jc = !1;\n    this.zv = !0;\n    this.Pd = -2;\n    this.Pi = new H();\n    this.Ns = new E();\n    this.$f = !1;\n    this.ai = this.$h = this.qr = this.gd = !0;\n    this.rr = !1;\n    this.xr = this.vr = this.ii = this.hi = this.gi = this.fi = this.di = this.ei = this.ci = this.ur = this.ki = this.bi = this.ji = this.sr = !0;\n    this.Zf = this.Wu = !1;\n    this.wr = this.tr = this.ql = this.pl = !0;\n    this.bt = this.Ys = 16;\n    this.Xs = this.Kp = !1;\n    this.Zs = this.at = 0;\n    this.gb = new pc(5).freeze();\n    this.qv = new F().freeze();\n    this.ys = 999999999;\n    this.Qu = new F().freeze();\n    this.wi = this.vi = this.ui = !0;\n    this.Xe = this.le = !1;\n    this.kc = null;\n    this.Ng = !0;\n    this.me = !1;\n    this.yx = new F();\n    this.Ru = new F();\n    this.Gc = null;\n    this.Pl = 1;\n    this.sv = 0;\n    this.Vd = {\n      scale: 1,\n      position: new J(),\n      bounds: new N(),\n      gw: !1\n    };\n    this.Px = new N(NaN, NaN, NaN, NaN).freeze();\n    this.mm = new M(NaN, NaN).freeze();\n    this.Qn = new N(NaN, NaN, NaN, NaN).freeze();\n    this.ts = !1;\n    this.Ho = this.oo = this.gp = this.Eu = this.Du = this.Fu = this.bg = this.eh = this.cf = null;\n    ui(this);\n    this.Ib = null;\n    this.no = !1;\n    this.Bj = null;\n    this.partManager = new ti();\n    this.toolManager = new Oa();\n    this.toolManager.initializeStandardTools();\n    this.currentTool = this.defaultTool = this.toolManager;\n    this.Ur = null;\n    this.dl = new Te();\n    this.Is = this.Hs = null;\n    this.cq = !1;\n    this.commandHandler = vi();\n    this.ug = !0;\n    xi(this);\n    this.layout = new yi();\n    this.ug = !1;\n    this.model = wi();\n    this.model.undoManager = new Ae();\n    this.me = !1;\n    this.Hj = !0;\n    this.Ae = !1;\n    this.Sb = 1;\n    this.yh = null;\n    this.To = 1;\n    this.Zo = 0;\n    this.gv = [0, 0, 0, 0, 0];\n    this.$o = 0;\n    this.sd = 1;\n    this.Pj = 0;\n    this.Co = new J();\n    this.qt = 500;\n    this.qn = new J();\n    this.ne = !1;\n    this.sh = this.Ul = this.rh = this.Tl = null;\n    this.eq = this.so = !1;\n    this.$n = null;\n    this.ao = Lb;\n    this.Rb = !1;\n    this.M();\n  };\n  function ui(a) {\n    a.cf = new H();\n    var b = new V(),\n      c = new Vg();\n    c.bind(new Li(\"text\", \"\", Ja));\n    b.add(c);\n    a.Fu = b;\n    a.cf.add(\"\", b);\n    b = new V();\n    c = new Vg();\n    c.stroke = \"brown\";\n    c.bind(new Li(\"text\", \"\", Ja));\n    b.add(c);\n    a.cf.add(\"Comment\", b);\n    b = new V();\n    b.selectable = !1;\n    b.avoidable = !1;\n    c = new W();\n    c.figure = \"Ellipse\";\n    c.fill = \"black\";\n    c.stroke = null;\n    c.desiredSize = new M(3, 3).ca();\n    b.add(c);\n    a.cf.add(\"LinkLabel\", b);\n    a.eh = new H();\n    b = new vf();\n    b.selectionObjectName = \"GROUPPANEL\";\n    b.type = X.Vertical;\n    c = new Vg();\n    c.font = \"bold 12pt sans-serif\";\n    c.bind(new Li(\"text\", \"\", Ja));\n    b.add(c);\n    c = new X(X.Auto);\n    c.name = \"GROUPPANEL\";\n    var d = new W();\n    d.figure = \"Rectangle\";\n    d.fill = \"rgba(128,128,128,0.2)\";\n    d.stroke = \"black\";\n    c.add(d);\n    d = new wg();\n    d.padding = new pc(5, 5, 5, 5).ca();\n    c.add(d);\n    b.add(c);\n    a.Du = b;\n    a.eh.add(\"\", b);\n    a.bg = new H();\n    b = new S();\n    c = new W();\n    c.isPanelMain = !0;\n    b.add(c);\n    c = new W();\n    c.toArrow = \"Standard\";\n    c.fill = \"black\";\n    c.stroke = null;\n    c.strokeWidth = 0;\n    b.add(c);\n    a.Eu = b;\n    a.bg.add(\"\", b);\n    b = new S();\n    c = new W();\n    c.isPanelMain = !0;\n    c.stroke = \"brown\";\n    b.add(c);\n    a.bg.add(\"Comment\", b);\n    b = new He();\n    b.type = X.Auto;\n    c = new W();\n    c.fill = null;\n    c.stroke = \"dodgerblue\";\n    c.strokeWidth = 3;\n    b.add(c);\n    c = new wg();\n    c.margin = new pc(1.5, 1.5, 1.5, 1.5).ca();\n    b.add(c);\n    a.gp = b;\n    a.oo = b;\n    b = new He();\n    b.type = X.Link;\n    c = new W();\n    c.isPanelMain = !0;\n    c.fill = null;\n    c.stroke = \"dodgerblue\";\n    c.strokeWidth = 3;\n    b.add(c);\n    a.Ho = b;\n  }\n  Q.prototype.setRTL = function (a) {\n    a = void 0 === a ? this.div : a;\n    null === a && (a = x.document.body);\n    var b = ta(\"div\");\n    b.dir = \"rtl\";\n    b.style.cssText = \"font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;\";\n    b.textContent = \"A\";\n    a.appendChild(b);\n    var c = \"reverse\";\n    0 < b.scrollLeft ? c = \"default\" : (b.scrollLeft = 1, 0 === b.scrollLeft && (c = \"negative\"));\n    a.removeChild(b);\n    this.Us = c;\n  };\n  Q.prototype.setScrollWidth = function (a) {\n    a = void 0 === a ? this.div : a;\n    null === a && (a = x.document.body);\n    var b = 0;\n    if (Tg) {\n      var c = Mi;\n      b = Ni;\n      null === c && (c = Mi = ta(\"p\"), c.style.width = \"100%\", c.style.height = \"200px\", c.style.boxSizing = \"content-box\", b = Ni = ta(\"div\"), b.style.position = \"absolute\", b.style.visibility = \"hidden\", b.style.width = \"200px\", b.style.height = \"150px\", b.style.boxSizing = \"content-box\", b.appendChild(c));\n      b.style.overflow = \"hidden\";\n      a.appendChild(b);\n      var d = c.offsetWidth;\n      b.style.overflow = \"scroll\";\n      c = c.offsetWidth;\n      d === c && (c = b.clientWidth);\n      a.removeChild(b);\n      b = d - c;\n      0 !== b || Xa || (b = 11);\n    }\n    this.nb = b;\n    this.pv = !0;\n  };\n  Q.prototype.hb = function (a) {\n    a.classType === Q && (this.autoScale = a);\n  };\n  Q.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"\";\n    this.div && this.div.id && (b = this.div.id);\n    b = 'Diagram \"' + b + '\"';\n    if (0 >= a) return b;\n    for (var c = this.La.iterator; c.next();) b += \"\\n  \" + c.value.toString(a - 1);\n    return b;\n  };\n  Q.prototype.addEventListener = function (a, b, c, d) {\n    a.addEventListener(b, c, {\n      capture: d,\n      passive: !1\n    });\n  };\n  Q.prototype.removeEventListener = function (a, b, c, d) {\n    a.removeEventListener(b, c, {\n      capture: d\n    });\n  };\n  function Oi(a) {\n    var b = a.ta.Ga;\n    b instanceof HTMLCanvasElement && (a.ln ? (a.addEventListener(b, \"pointerdown\", a.Em, !1), a.addEventListener(b, \"pointermove\", a.Fm, !1), a.addEventListener(b, \"pointerup\", a.Hm, !1), a.addEventListener(b, \"pointerout\", a.Gm, !1)) : (a.addEventListener(b, \"touchstart\", a.Nw, !1), a.addEventListener(b, \"touchmove\", a.Mw, !1), a.addEventListener(b, \"touchend\", a.Lw, !1), a.addEventListener(b, \"mousemove\", a.Dk, !1), a.addEventListener(b, \"mousedown\", a.Ck, !1), a.addEventListener(b, \"mouseup\", a.Fk, !1), a.addEventListener(b, \"mouseout\", a.Ek, !1)), a.addEventListener(b, \"mouseenter\", a.Jz, !1), a.addEventListener(b, \"mouseleave\", a.Kz, !1), a.addEventListener(b, \"wheel\", a.Gk, !1), a.addEventListener(b, \"keydown\", a.xA, !1), a.addEventListener(b, \"keyup\", a.yA, !1), a.addEventListener(b, \"blur\", a.vz, !1), a.addEventListener(b, \"focus\", a.wz, !1), a.addEventListener(b, \"selectstart\", function (a) {\n      a.preventDefault();\n      return !1;\n    }, !1), a.addEventListener(b, \"contextmenu\", function (a) {\n      a.preventDefault();\n      return !1;\n    }, !1), a.addEventListener(b, \"gesturestart\", function (b) {\n      a.toolManager.gestureBehavior !== Oe && (a.toolManager.gestureBehavior === Ne ? b.preventDefault() : a.ne && a.lastInput.handled || (b.preventDefault(), a.Pl = a.scale, a.currentTool.doCancel()));\n    }, !1), a.addEventListener(b, \"gesturechange\", function (b) {\n      if (a.toolManager.gestureBehavior !== Oe) if (a.toolManager.gestureBehavior === Ne) b.preventDefault();else if (!a.ne || !a.lastInput.handled) {\n        b.preventDefault();\n        var c = b.scale;\n        if (null !== a.Pl) {\n          var e = a.ta.getBoundingClientRect();\n          b = new J(b.pageX - x.scrollX - a.xa / e.width * e.left, b.pageY - x.scrollY - a.wa / e.height * e.top);\n          c = a.Pl * c;\n          e = a.commandHandler;\n          if (c !== a.scale && e.canResetZoom(c)) {\n            var f = a.zoomPoint;\n            a.zoomPoint = b;\n            e.resetZoom(c);\n            a.zoomPoint = f;\n          }\n        }\n      }\n    }, !1), a.addEventListener(x, \"resize\", a.Uw, !1));\n  }\n  function We(a) {\n    30 < a.Zo && (a.yh = 1);\n  }\n  function kf(a, b) {\n    null !== a.yh && (a.yh = null, b && a.Zq(), eb && eb.jy || (a.Zo = 0, a.gv = [0, 0, 0, 0, 0], a.$o = 0));\n  }\n  Q.prototype.computePixelRatio = function () {\n    return null !== this.yh ? this.yh : x.devicePixelRatio || 1;\n  };\n  Q.prototype.doMouseMove = function () {\n    this.currentTool.doMouseMove();\n  };\n  Q.prototype.doMouseDown = function () {\n    this.currentTool.doMouseDown();\n  };\n  Q.prototype.doMouseUp = function () {\n    this.currentTool.doMouseUp();\n  };\n  Q.prototype.doMouseWheel = function () {\n    this.currentTool.doMouseWheel();\n  };\n  Q.prototype.doKeyDown = function () {\n    this.currentTool.doKeyDown();\n  };\n  Q.prototype.doKeyUp = function () {\n    this.currentTool.doKeyUp();\n  };\n  Q.prototype.doFocus = function () {\n    this.focus();\n  };\n  Q.prototype.focus = function () {\n    if (this.ta) if (this.scrollsPageOnFocus) this.ta.focus();else {\n      var a = x.scrollX || x.pageXOffset,\n        b = x.scrollY || x.pageYOffset;\n      this.ta.focus();\n      x.scrollTo(a, b);\n    }\n  };\n  Q.prototype.wz = function () {\n    this.B.R(\"GainedFocus\");\n  };\n  Q.prototype.vz = function () {\n    this.B.R(\"LostFocus\");\n  };\n  function Jh(a) {\n    if (null !== a.ta) {\n      var b = a.Ea;\n      if (0 !== b.clientWidth && 0 !== b.clientHeight) {\n        a.pv || a.setScrollWidth();\n        var c = a.Xe ? a.nb : 0,\n          d = a.le ? a.nb : 0,\n          e = a.Sb;\n        a.Sb = a.computePixelRatio();\n        a.Sb !== e && (a.yl = !0, a.Db());\n        if (b.clientWidth !== a.xa + c || b.clientHeight !== a.wa + d) a.vi = !0, a.Dc = !0, b = a.layout, null !== b && b.isViewportSized && a.autoScale === Ih && (a.Ej = !0, b.C()), a.jc || a.Db();\n      }\n    }\n  }\n  function xi(a) {\n    var b = new ii();\n    b.name = \"Background\";\n    a.om(b);\n    b = new ii();\n    b.name = \"\";\n    a.om(b);\n    b = new ii();\n    b.name = \"Foreground\";\n    a.om(b);\n    b = new ii();\n    b.name = \"Adornment\";\n    b.isTemporary = !0;\n    a.om(b);\n    b = new ii();\n    b.name = \"Tool\";\n    b.isTemporary = !0;\n    b.isBoundsIncluded = !0;\n    a.om(b);\n    b = new ii();\n    b.name = \"Grid\";\n    b.allowSelect = !1;\n    b.pickable = !1;\n    b.isTemporary = !0;\n    a.Sx(b, a.tm(\"Background\"));\n  }\n  function Pi(a) {\n    a.Ib = new X(X.Grid);\n    a.Ib.name = \"GRID\";\n    var b = new W();\n    b.figure = \"LineH\";\n    b.stroke = \"lightgray\";\n    b.strokeWidth = .5;\n    b.interval = 1;\n    a.Ib.add(b);\n    b = new W();\n    b.figure = \"LineH\";\n    b.stroke = \"gray\";\n    b.strokeWidth = .5;\n    b.interval = 5;\n    a.Ib.add(b);\n    b = new W();\n    b.figure = \"LineH\";\n    b.stroke = \"gray\";\n    b.strokeWidth = 1;\n    b.interval = 10;\n    a.Ib.add(b);\n    b = new W();\n    b.figure = \"LineV\";\n    b.stroke = \"lightgray\";\n    b.strokeWidth = .5;\n    b.interval = 1;\n    a.Ib.add(b);\n    b = new W();\n    b.figure = \"LineV\";\n    b.stroke = \"gray\";\n    b.strokeWidth = .5;\n    b.interval = 5;\n    a.Ib.add(b);\n    b = new W();\n    b.figure = \"LineV\";\n    b.stroke = \"gray\";\n    b.strokeWidth = 1;\n    b.interval = 10;\n    a.Ib.add(b);\n    b = new U();\n    b.add(a.Ib);\n    b.layerName = \"Grid\";\n    b.zOrder = 0;\n    b.isInDocumentBounds = !1;\n    b.isAnimated = !1;\n    b.pickable = !1;\n    b.locationObjectName = \"GRID\";\n    a.add(b);\n    a.partManager.parts.remove(b);\n    a.Ib.visible = !1;\n  }\n  function Qi() {\n    this.B.Xs ? this.B.Xs = !1 : this.B.isEnabled ? this.B.ey(this) : Ri(this.B);\n  }\n  function Si(a) {\n    this.B.isEnabled ? (this.B.at = a.target.scrollTop, this.B.Zs = a.target.scrollLeft) : Ri(this.B);\n  }\n  Q.prototype.ey = function (a) {\n    if (null !== this.ta) {\n      this.Kp = !0;\n      var b = this.documentBounds,\n        c = this.viewportBounds,\n        d = this.Si,\n        e = b.x - d.left,\n        f = b.y - d.top,\n        g = b.width + d.left + d.right,\n        h = b.height + d.top + d.bottom,\n        k = b.right + d.right;\n      d = b.bottom + d.bottom;\n      var l = c.x;\n      b = c.y;\n      var m = c.width,\n        n = c.height,\n        p = c.right,\n        r = c.bottom;\n      c = this.scale;\n      var q = a.scrollLeft;\n      if (this.Al) switch (this.Us) {\n        case \"negative\":\n          q = q + a.scrollWidth - a.clientWidth;\n          break;\n        case \"reverse\":\n          q = a.scrollWidth - q - a.clientWidth;\n      }\n      var u = q;\n      m < g || n < h ? (q = J.allocAt(this.position.x, this.position.y), this.allowHorizontalScroll && this.Zs !== u && (q.x = u / c + e, this.Zs = u), this.allowVerticalScroll && this.at !== a.scrollTop && (q.y = a.scrollTop / c + f, this.at = a.scrollTop), this.position = q, J.free(q), this.vi = this.Kp = !1) : (q = J.alloc(), a.dz && this.allowHorizontalScroll && (e < l && (this.position = q.h(u + e, this.position.y)), k > p && (this.position = q.h(-(this.$s.scrollWidth - this.xa) + u - this.xa / c + k, this.position.y))), a.ez && this.allowVerticalScroll && (f < b && (this.position = q.h(this.position.x, a.scrollTop + f)), d > r && (this.position = q.h(this.position.x, -(this.$s.scrollHeight - this.wa) + a.scrollTop - this.wa / c + d))), J.free(q), Ti(this), this.vi = this.Kp = !1, b = this.documentBounds, c = this.viewportBounds, k = b.right, p = c.right, d = b.bottom, r = c.bottom, e = b.x, l = c.x, f = b.y, b = c.y, m >= g && e >= l && k <= p && (this.Lp.style.width = \"1px\"), n >= h && f >= b && d <= r && (this.Lp.style.height = \"1px\"));\n    }\n  };\n  Q.prototype.computeBounds = function () {\n    0 < this.rd.count && Ui(this);\n    return Vi(this);\n  };\n  function Vi(a) {\n    if (a.fixedBounds.u()) {\n      var b = a.fixedBounds.copy();\n      b.sq(a.gb);\n      return b;\n    }\n    for (var c = !0, d = a.La.j, e = d.length, f = 0; f < e; f++) {\n      var g = d[f];\n      if (g.visible && (!g.isTemporary || g.isBoundsIncluded)) {\n        g = g.Da.j;\n        for (var h = g.length, k = 0; k < h; k++) {\n          var l = g[k];\n          l.isInDocumentBounds && l.isVisible() && (l = l.actualBounds, l.u() && (c ? (c = !1, b = l.copy()) : b.Oc(l)));\n        }\n      }\n    }\n    c && (b = new N(0, 0, 0, 0));\n    b.sq(a.gb);\n    return b;\n  }\n  Q.prototype.computePartsBounds = function (a, b) {\n    void 0 === b && (b = !1);\n    var c = null;\n    if (Aa(a)) for (var d = 0; d < a.length; d++) {\n      var e = a[d];\n      !b && e instanceof S || (e.Ta(), null === c ? c = e.actualBounds.copy() : c.Oc(e.actualBounds));\n    } else for (a = a.iterator; a.next();) d = a.value, !b && d instanceof S || (d.Ta(), null === c ? c = d.actualBounds.copy() : c.Oc(d.actualBounds));\n    return null === c ? new N(NaN, NaN, 0, 0) : c;\n  };\n  function Wi(a, b) {\n    if ((b || a.me) && !a.Rb && null !== a.ta && a.documentBounds.u()) {\n      if (b) {\n        var c = a.initialPosition;\n        if (c.u()) {\n          a.position = c;\n          return;\n        }\n        c = J.alloc();\n        c.sj(a.documentBounds, a.initialDocumentSpot);\n        var d = a.viewportBounds;\n        d = N.allocAt(0, 0, d.width, d.height);\n        var e = J.alloc();\n        e.sj(d, a.initialViewportSpot);\n        e.h(c.x - e.x, c.y - e.y);\n        a.position = e;\n        N.free(d);\n        J.free(e);\n        J.free(c);\n      }\n      a.Rb = !0;\n      c = a.Og;\n      b && a.Yf !== Ih && (c = a.Yf);\n      d = c !== Ih ? Xi(a, c) : a.scale;\n      c = a.viewportBounds.copy();\n      e = a.xa / d;\n      var f = a.wa / d,\n        g = a.Aj,\n        h = a.qo;\n      b && !g.ib() && (h.ib() || h.Mb()) && (g = h.Mb() ? Bc : h);\n      Yi(a, a.documentBounds, e, f, g, b);\n      b = a.scale;\n      a.scale = d;\n      a.Rb = !1;\n      d = a.viewportBounds;\n      d.Na(c) || a.Vq(c, d, b, !1);\n      Zi(a);\n      $i(a, !0, !1);\n    }\n  }\n  function Xi(a, b) {\n    var c = a.Pn;\n    if (null === a.ta) return c;\n    a.Ta();\n    var d = a.documentBounds;\n    if (!d.u()) return c;\n    var e = d.width;\n    d = d.height;\n    var f = a.xa + (a.Xe ? a.nb : 0),\n      g = a.wa + (a.le ? a.nb : 0),\n      h = f / e,\n      k = g / d;\n    return b === aj ? (b = Math.min(k, h), b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : b === bj ? (b = k > h ? (g - a.nb) / d : (f - a.nb) / e, b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : a.scale;\n  }\n  Q.prototype.zoomToFit = function () {\n    var a = this.Ti;\n    this.Ti = Zh;\n    this.scale = Xi(this, aj);\n    a !== Zh && (Wi(this, !1), Yi(this, this.documentBounds, this.xa / this.ya, this.wa / this.ya, this.Aj, !1));\n    this.Ti = a;\n  };\n  t = Q.prototype;\n  t.fB = function (a, b) {\n    void 0 === b && (b = aj);\n    var c = a.width,\n      d = a.height;\n    if (!(0 === c || 0 === d || isNaN(c) && isNaN(d))) {\n      var e = 1;\n      if (b === aj || b === bj) if (isNaN(c)) e = this.viewportBounds.height * this.scale / d;else if (isNaN(d)) e = this.viewportBounds.width * this.scale / c;else {\n        e = this.xa;\n        var f = this.wa;\n        e = b === bj ? f / d > e / c ? (f - (this.le ? this.nb : 0)) / d : (e - (this.Xe ? this.nb : 0)) / c : Math.min(f / d, e / c);\n      }\n      this.scale = e;\n      this.position = new J(a.x, a.y);\n    }\n  };\n  t.oz = function (a, b) {\n    this.Ta();\n    var c = this.documentBounds,\n      d = this.viewportBounds;\n    this.position = new J(c.x + (a.x * c.width + a.offsetX) - (b.x * d.width - b.offsetX), c.y + (a.y * c.height + a.offsetY) - (b.y * d.height - b.offsetY));\n  };\n  t.fA = function (a) {\n    if (a instanceof Y) {\n      this.$n = a;\n      var b = J.alloc();\n      this.ao = this.ir(a.ga(wc, b));\n      J.free(b);\n    } else this.$n = null, this.ao = Lb;\n  };\n  function Yi(a, b, c, d, e, f) {\n    var g = J.allocAt(a.la.x, a.la.y),\n      h = g.x,\n      k = g.y;\n    if (null !== a.$n) {\n      var l = J.alloc();\n      l = a.$n.ga(wc, l);\n      h = l.x - a.ao.x / a.scale;\n      k = l.y - a.ao.y / a.scale;\n      e = vc;\n      J.free(l);\n    }\n    if (f || a.scrollMode === Zh) e.ib() && (c > b.width && (h = b.x + (e.x * b.width + e.offsetX) - (e.x * c - e.offsetX)), d > b.height && (k = b.y + (e.y * b.height + e.offsetY) - (e.y * d - e.offsetY))), e = a.Si, f = c - b.width, c < b.width + e.left + e.right ? (h = Math.min(h + c / 2, b.right + Math.max(f, e.right) - c / 2), h = Math.max(h, b.left - Math.max(f, e.left) + c / 2), h -= c / 2) : h > b.left ? h = b.left : h < b.right - c && (h = b.right - c), c = d - b.height, d < b.height + e.top + e.bottom ? (k = Math.min(k + d / 2, b.bottom + Math.max(c, e.bottom) - d / 2), k = Math.max(k, b.top - Math.max(c, e.top) + d / 2), k -= d / 2) : k > b.top ? k = b.top : k < b.bottom - d && (k = b.bottom - d);\n    g.x = isFinite(h) ? h : -a.gb.left;\n    g.y = isFinite(k) ? k : -a.gb.top;\n    null !== a.positionComputation && (b = a.positionComputation(a, g), g.x = b.x, g.y = b.y);\n    a.Rc.rc && Sh(a.Rc, a.la, g);\n    a.la.h(g.x, g.y);\n    J.free(g);\n  }\n  t.um = function (a, b) {\n    void 0 === b && (b = !0);\n    if (b) {\n      if (a = wf(this, a, function (a) {\n        return a.part;\n      }, function (a) {\n        return a.canSelect();\n      }), a instanceof U) return a;\n    } else if (a = wf(this, a, function (a) {\n      return a.part;\n    }), a instanceof U) return a;\n    return null;\n  };\n  t.Ub = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    Ui(this);\n    for (var d = this.La.iteratorBackwards; d.next();) {\n      var e = d.value;\n      if (e.visible && (e = e.Ub(a, b, c), null !== e)) return e;\n    }\n    return null;\n  };\n  function wf(a, b, c, d) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    Ui(a);\n    for (a = a.La.iteratorBackwards; a.next();) {\n      var e = a.value;\n      if (e.visible && !e.isTemporary && (e = e.Ub(b, c, d), null !== e)) return e;\n    }\n    return null;\n  }\n  t.Uz = function (a, b, c) {\n    void 0 === b && (b = !0);\n    return cj(this, a, function (a) {\n      return a.part;\n    }, b ? function (a) {\n      return a instanceof U && a.canSelect();\n    } : null, c);\n  };\n  function cj(a, b, c, d, e) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    e instanceof E || e instanceof F || (e = new F());\n    Ui(a);\n    for (a = a.La.iteratorBackwards; a.next();) {\n      var f = a.value;\n      f.visible && !f.isTemporary && f.hj(b, c, d, e);\n    }\n    return e;\n  }\n  t.hj = function (a, b, c, d) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    d instanceof E || d instanceof F || (d = new F());\n    Ui(this);\n    for (var e = this.La.iteratorBackwards; e.next();) {\n      var f = e.value;\n      f.visible && f.hj(a, b, c, d);\n    }\n    return d;\n  };\n  t.py = function (a, b, c, d) {\n    void 0 === b && (b = !1);\n    void 0 === c && (c = !0);\n    return dj(this, a, function (a) {\n      return a instanceof U && (!c || a.canSelect());\n    }, b, d);\n  };\n  t.zf = function (a, b, c, d, e) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    void 0 === d && (d = !1);\n    e instanceof E || e instanceof F || (e = new F());\n    Ui(this);\n    for (var f = this.La.iteratorBackwards; f.next();) {\n      var g = f.value;\n      g.visible && g.zf(a, b, c, d, e);\n    }\n    return e;\n  };\n  t.Uv = function (a, b, c, d, e, f) {\n    var g = new F();\n    Ui(this);\n    for (var h = this.La.iteratorBackwards; h.next();) {\n      var k = h.value;\n      k.visible && k.Uv(a, b, c, d, g, e, f);\n    }\n    return g;\n  };\n  function dj(a, b, c, d, e) {\n    var f = null;\n    void 0 === f && (f = null);\n    void 0 === c && (c = null);\n    void 0 === d && (d = !1);\n    e instanceof E || e instanceof F || (e = new F());\n    Ui(a);\n    for (a = a.La.iteratorBackwards; a.next();) {\n      var g = a.value;\n      g.visible && !g.isTemporary && g.zf(b, f, c, d, e);\n    }\n    return e;\n  }\n  t.Vz = function (a, b, c, d, e) {\n    void 0 === c && (c = !0);\n    void 0 === d && (d = !0);\n    return ej(this, a, b, function (a) {\n      return a instanceof U && (!d || a.canSelect());\n    }, c, e);\n  };\n  t.Eg = function (a, b, c, d, e, f) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    void 0 === e && (e = !0);\n    if (!1 !== e && !0 !== e) {\n      if (e instanceof E || e instanceof F) f = e;\n      e = !0;\n    }\n    f instanceof E || f instanceof F || (f = new F());\n    Ui(this);\n    for (var g = this.La.iteratorBackwards; g.next();) {\n      var h = g.value;\n      h.visible && h.Eg(a, b, c, d, e, f);\n    }\n    return f;\n  };\n  function ej(a, b, c, d, e, f) {\n    var g = null;\n    void 0 === g && (g = null);\n    void 0 === d && (d = null);\n    void 0 === e && (e = !0);\n    if (!1 !== e && !0 !== e) {\n      if (e instanceof E || e instanceof F) f = e;\n      e = !0;\n    }\n    f instanceof E || f instanceof F || (f = new F());\n    Ui(a);\n    for (a = a.La.iteratorBackwards; a.next();) {\n      var h = a.value;\n      h.visible && !h.isTemporary && h.Eg(b, c, g, d, e, f);\n    }\n    return f;\n  }\n  Q.prototype.acceptEvent = function (a) {\n    return fj(this, a, a instanceof MouseEvent);\n  };\n  function fj(a, b, c) {\n    var d = a.Ud;\n    a.Ud = a.gh;\n    a.gh = d;\n    d.diagram = a;\n    d.event = b;\n    c ? gj(a, b, d) : (d.viewPoint = a.Ud.viewPoint, d.documentPoint = a.Ud.documentPoint);\n    a = 0;\n    b.ctrlKey && (a += 1);\n    b.altKey && (a += 2);\n    b.shiftKey && (a += 4);\n    b.metaKey && (a += 8);\n    d.modifiers = a;\n    d.button = b.button;\n    void 0 === b.buttons || Sa || (d.buttons = b.buttons);\n    Wa && 0 === b.button && b.ctrlKey && (d.button = 2);\n    d.down = !1;\n    d.up = !1;\n    d.clickCount = 1;\n    d.delta = 0;\n    d.handled = !1;\n    d.bubbles = !1;\n    d.timestamp = b.timeStamp;\n    d.isMultiTouch = !1;\n    d.targetDiagram = hj(b);\n    d.targetObject = null;\n    return d;\n  }\n  function hj(a) {\n    var b = a.target.B;\n    if (!b) {\n      var c = a.path;\n      c || \"function\" !== typeof a.composedPath || (c = a.composedPath());\n      c && c[0] && (b = c[0].B);\n    }\n    return b ? b : null;\n  }\n  function ij(a, b, c, d) {\n    var e = jj(a, b, !0, !1, !0, d);\n    gj(a, c, e);\n    e.targetDiagram = hj(b);\n    e.targetObject = null;\n    d || e.clone(a.Vf);\n    return e;\n  }\n  function kj(a, b, c, d) {\n    var e;\n    d = jj(a, b, !1, !1, !1, d);\n    null !== c ? ((e = x.document.elementFromPoint(c.clientX, c.clientY)) && e.B ? (b = c, c = e.B) : (b = void 0 !== b.targetTouches ? b.targetTouches[0] : b, c = a), d.targetDiagram = c, gj(a, b, d)) : null !== a.Ud ? (d.documentPoint = a.Ud.documentPoint, d.viewPoint = a.Ud.viewPoint, d.targetDiagram = a.Ud.targetDiagram) : null !== a.Vf && (d.documentPoint = a.Vf.documentPoint, d.viewPoint = a.Vf.viewPoint, d.targetDiagram = a.Vf.targetDiagram);\n    d.targetObject = null;\n    return d;\n  }\n  function jj(a, b, c, d, e, f) {\n    var g = a.Ud;\n    a.Ud = a.gh;\n    a.gh = g;\n    g.diagram = a;\n    g.clickCount = 1;\n    var h = g.delta = 0;\n    b.ctrlKey && (h += 1);\n    b.altKey && (h += 2);\n    b.shiftKey && (h += 4);\n    b.metaKey && (h += 8);\n    g.modifiers = h;\n    g.button = 0;\n    g.buttons = 1;\n    g.event = b;\n    g.timestamp = b.timeStamp;\n    a.ln && b instanceof x.PointerEvent && \"touch\" !== b.pointerType && (g.button = b.button, void 0 === b.buttons || Sa || (g.buttons = b.buttons), Wa && 0 === b.button && b.ctrlKey && (g.button = 2));\n    g.down = c;\n    g.up = d;\n    g.handled = !1;\n    g.bubbles = e;\n    g.isMultiTouch = f;\n    return g;\n  }\n  function lj(a, b) {\n    if (a.bubbles) return !0;\n    void 0 !== b.stopPropagation && b.stopPropagation();\n    !1 !== b.cancelable && b.preventDefault();\n    b.cancelBubble = !0;\n    return !1;\n  }\n  Q.prototype.xA = function (a) {\n    var b = this.B;\n    if (!this.B.isEnabled) return !1;\n    var c = fj(b, a, !1);\n    c.key = String.fromCharCode(a.which);\n    c.down = !0;\n    switch (a.which) {\n      case 8:\n        c.key = \"Backspace\";\n        break;\n      case 33:\n        c.key = \"PageUp\";\n        break;\n      case 34:\n        c.key = \"PageDown\";\n        break;\n      case 35:\n        c.key = \"End\";\n        break;\n      case 36:\n        c.key = \"Home\";\n        break;\n      case 37:\n        c.key = \"Left\";\n        break;\n      case 38:\n        c.key = \"Up\";\n        break;\n      case 39:\n        c.key = \"Right\";\n        break;\n      case 40:\n        c.key = \"Down\";\n        break;\n      case 45:\n        c.key = \"Insert\";\n        break;\n      case 46:\n        c.key = \"Del\";\n        break;\n      case 48:\n        c.key = \"0\";\n        break;\n      case 187:\n      case 61:\n      case 107:\n        c.key = \"Add\";\n        break;\n      case 189:\n      case 173:\n      case 109:\n        c.key = \"Subtract\";\n        break;\n      case 27:\n        c.key = \"Esc\";\n    }\n    b.doKeyDown();\n    return lj(c, a);\n  };\n  Q.prototype.yA = function (a) {\n    var b = this.B;\n    if (!b.isEnabled) return !1;\n    var c = fj(b, a, !1);\n    c.key = String.fromCharCode(a.which);\n    c.up = !0;\n    switch (a.which) {\n      case 8:\n        c.key = \"Backspace\";\n        break;\n      case 33:\n        c.key = \"PageUp\";\n        break;\n      case 34:\n        c.key = \"PageDown\";\n        break;\n      case 35:\n        c.key = \"End\";\n        break;\n      case 36:\n        c.key = \"Home\";\n        break;\n      case 37:\n        c.key = \"Left\";\n        break;\n      case 38:\n        c.key = \"Up\";\n        break;\n      case 39:\n        c.key = \"Right\";\n        break;\n      case 40:\n        c.key = \"Down\";\n        break;\n      case 45:\n        c.key = \"Insert\";\n        break;\n      case 46:\n        c.key = \"Del\";\n    }\n    b.doKeyUp();\n    return lj(c, a);\n  };\n  Q.prototype.Jz = function (a) {\n    var b = this.B;\n    if (!b.isEnabled) return !1;\n    var c = fj(b, a, !0);\n    null !== b.mouseEnter && b.mouseEnter(c);\n    return lj(c, a);\n  };\n  Q.prototype.Kz = function (a) {\n    var b = this.B;\n    if (!b.isEnabled) return !1;\n    var c = fj(b, a, !0);\n    null !== b.mouseLeave && b.mouseLeave(c);\n    return lj(c, a);\n  };\n  Q.prototype.getMouse = function (a) {\n    var b = this.ta;\n    if (null === b) return new J(0, 0);\n    var c = b.getBoundingClientRect();\n    b = a.clientX - this.xa / c.width * c.left;\n    a = a.clientY - this.wa / c.height * c.top;\n    return null !== this.ob ? Bb(new J(b, a), this.ob) : new J(b, a);\n  };\n  function gj(a, b, c) {\n    var d = a.ta,\n      e = a.xa,\n      f = a.wa,\n      g = 0,\n      h = 0;\n    null !== d && (d = d.getBoundingClientRect(), g = b.clientX - e / d.width * d.left, h = b.clientY - f / d.height * d.top);\n    c.viewPoint.h(g, h);\n    null !== a.ob ? (b = J.allocAt(g, h), a.ob.Zd(b), c.documentPoint.assign(b), J.free(b)) : c.documentPoint.h(g, h);\n  }\n  function se(a, b, c, d) {\n    if (void 0 !== b.targetTouches) {\n      if (2 > b.targetTouches.length) return;\n      b = b.targetTouches[c];\n    } else if (null !== a.Zj[0]) b = a.Zj[c];else return;\n    c = a.ta;\n    null !== c && (c = c.getBoundingClientRect(), d.h(b.clientX - a.xa / c.width * c.left, b.clientY - a.wa / c.height * c.top));\n  }\n  t = Q.prototype;\n  t.Oa = function () {\n    this.ui || (this.ui = !0, this.Db(!0));\n  };\n  function mj(a) {\n    a.jc || Ui(a);\n    a.Ta();\n  }\n  t.Je = function () {\n    this.Rb || this.jc || (this.M(), Zi(this), Ti(this), this.Oa(), this.cd());\n  };\n  t.wA = function () {\n    return this.Ae;\n  };\n  t.Ez = function (a) {\n    void 0 === a && (a = null);\n    var b = this.animationManager,\n      c = b.isEnabled;\n    b.Nc();\n    b.isEnabled = !1;\n    Jf(this);\n    this.me = !1;\n    this.Vs = new J(NaN, NaN);\n    b.isEnabled = c;\n    this.jc = !0;\n    var d = this;\n    null !== a && sa(function () {\n      d.jc = !1;\n      Ch(b, \"Model\");\n      a();\n    }, 1);\n  };\n  t.Db = function (a) {\n    void 0 === a && (a = !1);\n    if (!0 !== this.Ae && !(this.Rb || !1 === a && this.jc)) {\n      this.Ae = !0;\n      var b = this;\n      x.requestAnimationFrame(function () {\n        b.Ae && b.cd();\n      });\n    }\n  };\n  t.cd = function () {\n    if (!this.Hj || this.Ae) this.Hj && (this.Hj = !1), Jf(this);\n  };\n  function $i(a, b, c) {\n    a.animationManager.defaultAnimation.isAnimating || a.Rb || !a.vi || Ri(a) || (b && Ui(a), c && Wi(a, !1));\n  }\n  function Jf(a, b) {\n    if (!a.jc && (a.Ae = !1, null !== a.Ea || a.mm.u())) {\n      a.jc = !0;\n      var c = a.animationManager,\n        d = a.Ns;\n      if (!c.isAnimating && 0 !== d.length) {\n        for (var e = d.j, f = e.length, g = 0; g < f; g++) {\n          var h = e[g];\n          nj(h, !1);\n          h.o();\n        }\n        d.clear();\n      }\n      d = a.Ru;\n      0 < d.count && (d.each(function (a) {\n        a.Tw();\n      }), d.clear());\n      e = d = !1;\n      c.isAnimating && (e = !0, d = a.skipsUndoManager, a.skipsUndoManager = !0);\n      c.rc || Jh(a);\n      $i(a, !1, !0);\n      null !== a.Ib && (a.Ib.visible && !a.no && (oj(a), a.no = !0), !a.Ib.visible && a.no && (a.no = !1));\n      Ui(a);\n      f = !1;\n      if (!a.me || a.Ng) a.me ? pj(a, !a.Ej) : (a.va(\"Initial Layout\"), !1 === c.isEnabled && c.Nc(), pj(a, !1)), f = !0;\n      a.Ej = !1;\n      Ui(a);\n      a.gt || mj(a);\n      $i(a, !0, !1);\n      g = !1;\n      f ? (c = N.alloc(), c.assign(a.viewportBounds), a.me || (g = a.me = !0, a.skipsUndoManager || (a.undoManager.isPendingClear = !0), a.undoManager.isPendingUnmodified = !0, qj(a)), a.R(\"LayoutCompleted\"), c.w(a.viewportBounds) || $i(a, !0, !1), N.free(c)) : c.tl && c.Ox && (a.Yf !== Ih ? a.scale = Xi(a, a.Yf) : a.Og !== Ih ? a.scale = Xi(a, a.Og) : (c = a.initialScale, isFinite(c) && 0 < c && (a.scale = c)), Wi(a, !0));\n      Ui(a);\n      f && g && a.Wa(\"Initial Layout\");\n      a.Gv();\n      b || a.bc(a.Gb);\n      e && (a.skipsUndoManager = d);\n      a.jc = !1;\n    }\n  }\n  function qj(a) {\n    var b = a.ya;\n    if (a.Yf !== Ih) a.scale = Xi(a, a.Yf);else if (a.Og !== Ih) a.scale = Xi(a, a.Og);else {\n      var c = a.initialScale;\n      isFinite(c) && 0 < c && (a.scale = c);\n    }\n    a.ya !== b && (Zi(a), $i(a, !0, !1));\n    Wi(a, !0);\n    b = a.La.j;\n    a.Fd(b, b.length, a);\n    a.R(\"InitialLayoutCompleted\");\n    a.Vs.assign(a.la);\n    oj(a);\n  }\n  function Ui(a) {\n    if ((a.jc || !a.animationManager.isTicking) && 0 !== a.rd.count) {\n      for (var b = 0; 23 > b; b++) {\n        var c = a.rd.iterator;\n        if (null === c || 0 === a.rd.count) break;\n        a.rd = new F();\n        a.Tw(c, a.rd);\n      }\n      a.nodes.each(function (a) {\n        a instanceof vf && 0 !== (a.P & 65536) !== !1 && (a.P = a.P ^ 65536);\n      });\n    }\n  }\n  t.Tw = function (a, b) {\n    for (a.reset(); a.next();) {\n      var c = a.value;\n      !c.Wb() || c instanceof vf || (c.qj() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));\n    }\n    for (a.reset(); a.next();) c = a.value, c instanceof vf && c.isVisible() && rj(this, c);\n    for (a.reset(); a.next();) c = a.value, c instanceof S && c.isVisible() && (c.qj() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));\n    for (a.reset(); a.next();) c = a.value, c instanceof He && c.isVisible() && (c.qj() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));\n  };\n  function rj(a, b) {\n    for (var c = Ea(), d = Ea(), e = b.memberParts; e.next();) {\n      var f = e.value;\n      f.isVisible() && (f instanceof vf ? (sj(f) || tj(f) || uj(f)) && rj(a, f) : f instanceof S ? f.fromNode === b || f.toNode === b ? d.push(f) : c.push(f) : (f.measure(Infinity, Infinity), f.arrange()));\n    }\n    a = c.length;\n    for (e = 0; e < a; e++) f = c[e], f.measure(Infinity, Infinity), f.arrange();\n    Ha(c);\n    b.measure(Infinity, Infinity);\n    b.arrange();\n    a = d.length;\n    for (b = 0; b < a; b++) c = d[b], c.measure(Infinity, Infinity), c.arrange();\n    Ha(d);\n  }\n  t.Fd = function (a, b, c, d) {\n    if (this.wi || this.animationManager.isAnimating) {\n      void 0 === d && (d = c.viewportBounds);\n      for (var e = 0; e < b; e++) a[e].Fd(c, d);\n    }\n  };\n  t.bc = function (a, b) {\n    void 0 === b && (b = null);\n    if (null !== this.Ea) {\n      null === this.ta && B(\"No canvas specified\");\n      var c = this.animationManager;\n      if (!c.rc && (!c.isAnimating || c.isTicking)) {\n        var d = new Date();\n        vj(this);\n        if (\"0\" !== this.Ea.style.opacity) {\n          var e = a !== this.Gb,\n            f = this.La.j,\n            g = f.length,\n            h = this;\n          this.Fd(f, g, h);\n          if (e) a.tc(!0), Ti(this);else if (!this.Dc && null === b && !c.isAnimating) return;\n          g = this.la;\n          var k = this.ya,\n            l = Math.round(g.x * k) / k,\n            m = Math.round(g.y * k) / k;\n          c = this.ob;\n          c.reset();\n          1 !== k && c.scale(k);\n          0 === g.x && 0 === g.y || c.translate(-l, -m);\n          k = this.Sb;\n          a.setTransform(1, 0, 0, 1, 0, 0);\n          a.scale(k, k);\n          a.clearRect(0, 0, this.xa, this.wa);\n          a.setTransform(1, 0, 0, 1, 0, 0);\n          a.scale(k, k);\n          a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy);\n          wj(this, a);\n          a.globalAlpha = this.tb;\n          l = null !== b ? function (c) {\n            var d = b;\n            if (c.visible && 0 !== c.tb) {\n              var e = c.Da.j,\n                f = e.length;\n              if (0 !== f) {\n                var g = ki(c, a),\n                  k = c.np;\n                k.length = 0;\n                for (var l = h.scale, m = N.alloc(), n = 0; n < f; n++) {\n                  var A = e[n];\n                  d.contains(A) || c.dj(a, A, h, k, l, m, !0);\n                }\n                N.free(m);\n                a.globalAlpha = g;\n              }\n            }\n          } : function (b) {\n            b.bc(a, h);\n          };\n          g = f.length;\n          for (m = 0; m < g; m++) a.setTransform(1, 0, 0, 1, 0, 0), a.scale(k, k), a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), l(f[m]);\n          this.ti && xj(this.ti, this) && this.Vr();\n          e ? (this.Gb.tc(!0), Ti(this)) : this.Dc = this.wi = !1;\n          f = +new Date() - +d;\n          e = eb && eb.jy;\n          d = this.gv;\n          if (e || null === this.yh) {\n            d[this.$o] = f;\n            this.$o = (this.$o + 1) % d.length;\n            for (c = f = 0; c < d.length; c++) f += d[c];\n            this.Zo = f / d.length;\n          }\n          if (e) for (a.setTransform(1, 0, 0, 1, 0, 0), e = 0; e < d.length; e++) a.fillText(d[e].toString(), 20, 150 + +(20 * e));\n        }\n      }\n    }\n  };\n  function yj(a, b, c, d, e, f, g, h, k, l) {\n    if (null !== a.Ea) {\n      null === a.ta && B(\"No canvas specified\");\n      void 0 === g && (g = null);\n      void 0 === h && (h = null);\n      void 0 === k && (k = !1);\n      void 0 === l && (l = !1);\n      vj(a);\n      a.Gb.tc(!0);\n      Ti(a);\n      a.xi = !0;\n      var m = a.ya;\n      a.ya = e;\n      var n = a.La.j,\n        p = n.length;\n      try {\n        var r = new N(f.x, f.y, d.width / e, d.height / e),\n          q = r.copy();\n        q.sq(c);\n        oj(a, q);\n        Ui(a);\n        a.Fd(n, p, a, r);\n        b.setTransform(1, 0, 0, 1, 0, 0);\n        b.clearRect(0, 0, d.width, d.height);\n        null !== h && \"\" !== h && (b.fillStyle = h, b.fillRect(0, 0, d.width, d.height));\n        var u = a.Sb;\n        b.scale(u, u);\n        var v = rd.alloc();\n        v.reset();\n        v.translate(c.left, c.top);\n        v.scale(e);\n        0 === f.x && 0 === f.y || v.translate(-f.x, -f.y);\n        b.setTransform(v.m11, v.m12, v.m21, v.m22, v.dx, v.dy);\n        rd.free(v);\n        wj(a, b);\n        b.globalAlpha = a.tb;\n        if (null !== g) {\n          var w = new F(),\n            y = g.iterator;\n          for (y.reset(); y.next();) {\n            var z = y.value;\n            !1 === l && \"Grid\" === z.layer.name || null === z || w.add(z);\n          }\n          var A = function (c) {\n            if (c.visible && 0 !== c.tb && (k || !c.isTemporary)) {\n              var d = c.Da.j,\n                e = d.length;\n              if (0 !== e) {\n                var f = ki(c, b),\n                  g = c.np;\n                g.length = 0;\n                for (var h = a.scale, l = N.alloc(), m = 0; m < e; m++) {\n                  var n = d[m];\n                  w.contains(n) && c.dj(b, n, a, g, h, l, !1);\n                }\n                N.free(l);\n                b.globalAlpha = f;\n              }\n            }\n          };\n        } else if (!k && l) {\n          var C = a.grid.part,\n            G = C.layer;\n          A = function (c) {\n            c === G ? C.bc(b, a) : c.bc(b, a, k);\n          };\n        } else A = function (c) {\n          c.bc(b, a, k);\n        };\n        for (c = 0; c < p; c++) A(n[c]);\n        a.xi = !1;\n        a.ti && xj(a.ti, a) && a.Vr();\n      } finally {\n        a.ya = m, a.Gb.tc(!0), Ti(a), a.Fd(n, p, a), oj(a);\n      }\n    }\n  }\n  t.Ge = function (a) {\n    return this.gf[a];\n  };\n  t.Qy = function (a, b) {\n    \"minDrawingLength\" === a && (this.To = b);\n    this.gf[a] = b;\n    this.Je();\n  };\n  t.ww = function () {\n    this.gf = new ab();\n    this.gf.drawShadows = !0;\n    this.gf.textGreeking = !0;\n    this.gf.viewportOptimizations = Xa || Ta || Ua ? !1 : !0;\n    this.gf.temporaryPixelRatio = !0;\n    this.gf.pictureRatioOptimization = !0;\n    this.To = this.gf.minDrawingLength = 1;\n  };\n  function wj(a, b) {\n    a = a.gf;\n    null !== a && (void 0 !== a.imageSmoothingEnabled && b.Py(!!a.imageSmoothingEnabled), a = a.defaultFont, void 0 !== a && null !== a && (b.font = a));\n  }\n  t.xm = function (a) {\n    return this.Kj[a];\n  };\n  t.UA = function (a, b) {\n    this.Kj[a] = b;\n  };\n  t.vw = function () {\n    this.Kj = new ab();\n    this.Kj.extraTouchArea = 10;\n    this.Kj.extraTouchThreshold = 10;\n    this.Kj.hasGestureZoom = !0;\n  };\n  t.Ew = function (a) {\n    zj(this, a);\n  };\n  function zj(a, b) {\n    var c = a instanceof X,\n      d = a instanceof Q,\n      e;\n    for (e in b) {\n      \"\" === e && B(\"Setting properties requires non-empty property names\");\n      var f = a,\n        g = e;\n      if (c || d) {\n        var h = e.indexOf(\".\");\n        if (0 < h) {\n          var k = e.substring(0, h);\n          if (c) f = a.$a(k);else if (f = a[k], void 0 === f || null === f) f = a.toolManager[k];\n          ya(f) ? g = e.substr(h + 1) : B(\"Unable to find object named: \" + k + \" in \" + a.toString() + \" when trying to set property: \" + e);\n        }\n      }\n      if (\"_\" !== g[0] && !Ka(f, g)) if (d && \"ModelChanged\" === g) {\n        a.Vx(b[g]);\n        continue;\n      } else if (d && \"Changed\" === g) {\n        a.Hh(b[g]);\n        continue;\n      } else if (d && Ka(a.toolManager, g)) f = a.toolManager;else if (d && Aj(a, g)) {\n        a.hk(g, b[g]);\n        continue;\n      } else if (a instanceof Z && \"Changed\" === g) {\n        a.Hh(b[g]);\n        continue;\n      } else B('Trying to set undefined property \"' + g + '\" on object: ' + f.toString());\n      f[g] = b[e];\n      \"_\" === g[0] && f instanceof Y && f.Rx(g);\n    }\n  }\n  t.Gv = function () {\n    if (0 === this.undoManager.transactionLevel && 0 !== this.Vg.count) {\n      for (; 0 < this.Vg.count;) {\n        var a = this.Vg;\n        this.Vg = new H();\n        for (a = a.iterator; a.next();) {\n          var b = a.key;\n          b.Nq(a.value);\n          b.cc();\n        }\n      }\n      this.M();\n    }\n  };\n  t.M = function (a) {\n    void 0 === a && (a = null);\n    if (null === a) this.Dc = !0, this.Db();else {\n      var b = this.viewportBounds;\n      null !== a && a.u() && b.Lc(a) && (this.Dc = !0, this.Db());\n    }\n    this.R(\"InvalidateDraw\");\n  };\n  t.By = function (a, b) {\n    if (!0 !== this.Dc) {\n      this.Dc = !0;\n      var c = !0 === this.Ge(\"temporaryPixelRatio\");\n      if (!0 === this.Ge(\"viewportOptimizations\") && this.scrollMode !== ai && this.Si.fj(0, 0, 0, 0) && b.width === a.width && b.height === a.height) {\n        var d = this.scale,\n          e = Math.max(a.x, b.x),\n          f = Math.max(a.y, b.y);\n        d = N.allocAt(e, f, Math.max(0, Math.min(a.x + a.width, b.x + b.width) - e) * d, Math.max(0, Math.min(a.y + a.height, b.y + b.height) - f) * d);\n        if (!this.eq && 0 < d.width && 0 < d.height) {\n          if (!(this.jc || (this.Ae = !1, null === this.Ea || (this.jc = !0, this.Gv(), this.documentBounds.u() || Bj(this, this.computeBounds()), e = this.ta, null === e || e instanceof Cj)))) {\n            var g = this.Sb;\n            f = this.xa * g;\n            var h = this.wa * g,\n              k = this.scale * g,\n              l = Math.round(Math.round(b.x * k) - Math.round(a.x * k));\n            b = Math.round(Math.round(b.y * k) - Math.round(a.y * k));\n            k = this.Iu;\n            a = this.qx;\n            k.width !== f && (k.width = f);\n            k.height !== h && (k.height = h);\n            a.clearRect(0, 0, f, h);\n            k = 190 * g;\n            var m = 70 * g,\n              n = Math.max(l, 0),\n              p = Math.max(b, 0),\n              r = Math.floor(f - n),\n              q = Math.floor(h - p);\n            a.drawImage(e.Ga, n, p, r, q, 0, 0, r, q);\n            xj(this.ti, this) && a.clearRect(0, 0, k, m);\n            e = Ea();\n            a = Ea();\n            q = Math.abs(l);\n            r = Math.abs(b);\n            var u = 0 === n ? 0 : f - q;\n            n = J.allocAt(u, 0);\n            q = J.allocAt(q + u, h);\n            a.push(new N(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            var v = this.ob;\n            v.reset();\n            v.scale(g, g);\n            1 !== this.ya && v.scale(this.ya);\n            g = this.la;\n            (0 !== g.x || 0 !== g.y) && isFinite(g.x) && isFinite(g.y) && v.translate(-g.x, -g.y);\n            Bb(n, v);\n            Bb(q, v);\n            e.push(new N(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            u = 0 === p ? 0 : h - r;\n            n.h(0, u);\n            q.h(f, r + u);\n            a.push(new N(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            Bb(n, v);\n            Bb(q, v);\n            e.push(new N(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            xj(this.ti, this) && (f = 0 < l ? 0 : -l, h = 0 < b ? 0 : -b, n.h(f, h), q.h(k + f, m + h), a.push(new N(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y))), Bb(n, v), Bb(q, v), e.push(new N(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y))));\n            J.free(n);\n            J.free(q);\n            $i(this, !1, !0);\n            null === this.Ea && B(\"No div specified\");\n            null === this.ta && B(\"No canvas specified\");\n            if (!this.animationManager.rc && (f = this.Gb, this.Dc)) {\n              vj(this);\n              h = this.Sb;\n              f.setTransform(1, 0, 0, 1, 0, 0);\n              f.clearRect(0, 0, this.xa * h, this.wa * h);\n              f.drawImage(this.Iu.Ga, 0 < l ? 0 : Math.round(-l), 0 < b ? 0 : Math.round(-b));\n              l = this.la;\n              g = this.ya;\n              k = Math.round(l.x * g) / g;\n              m = Math.round(l.y * g) / g;\n              b = this.ob;\n              b.reset();\n              1 !== g && b.scale(g);\n              0 === l.x && 0 === l.y || b.translate(-k, -m);\n              f.save();\n              f.beginPath();\n              l = a.length;\n              for (g = 0; g < l; g++) k = a[g], 0 !== k.width && 0 !== k.height && f.rect(Math.floor(k.x), Math.floor(k.y), Math.ceil(k.width), Math.ceil(k.height));\n              f.clip();\n              f.setTransform(1, 0, 0, 1, 0, 0);\n              f.scale(h, h);\n              f.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy);\n              b = this.La.j;\n              l = b.length;\n              this.Fd(b, l, this);\n              wj(this, f);\n              f.globalAlpha = this.tb;\n              for (h = 0; h < l; h++) if (g = b[h], k = e, g.visible && 0 !== g.tb) {\n                m = ki(g, f);\n                p = g.np;\n                p.length = 0;\n                n = this.scale;\n                r = N.alloc();\n                q = g.Da.j;\n                v = q.length;\n                u = k.length;\n                for (var w = 0; w < v; w++) {\n                  var y = q[w],\n                    z = Dj(y, y.actualBounds);\n                  a: {\n                    for (var A = 2 / n, C = 4 / n, G = 0; G < u; G++) {\n                      var L = k[G];\n                      if (0 !== L.width && 0 !== L.height && z.bw(L.x - A, L.y - A, L.width + C, L.height + C)) {\n                        z = !0;\n                        break a;\n                      }\n                    }\n                    z = !1;\n                  }\n                  z && g.dj(f, y, this, p, n, r, !0);\n                }\n                N.free(r);\n                f.globalAlpha = m;\n              }\n              f.restore();\n              f.tc(!0);\n              this.ti && xj(this.ti, this) && this.Vr();\n              this.Dc = this.wi = !1;\n              this.Zq();\n            }\n            Ha(e);\n            Ha(a);\n            this.jc = !1;\n          }\n        } else this.cd();\n        N.free(d);\n        c && (We(this), this.cd(), kf(this, !0));\n      } else c ? (We(this), this.cd(), kf(this, !0)) : this.cd();\n    }\n  };\n  function Zi(a) {\n    !1 === a.vi && (a.vi = !0);\n  }\n  function Ti(a) {\n    !1 === a.wi && (a.wi = !0);\n  }\n  function vj(a) {\n    !1 !== a.yl && (a.yl = !1, Ej(a, a.xa, a.wa));\n  }\n  function Ej(a, b, c) {\n    var d = a.Sb;\n    a.ta.resize(b * d, c * d, b, c) && (a.Dc = !0, a.Gb.tc(!0));\n  }\n  function Ri(a) {\n    var b = a.ta;\n    if (null === b) return !0;\n    var c = a.Ea,\n      d = a.xa,\n      e = a.wa,\n      f = a.viewportBounds.copy();\n    if (!f.u()) return !0;\n    var g = !1,\n      h = a.Xe ? a.nb : 0,\n      k = a.le ? a.nb : 0,\n      l = c.clientWidth || d + h,\n      m = c.clientHeight || e + k;\n    if (l !== d + h || m !== e + k) a.Xe = !1, a.le = !1, k = h = 0, a.xa = l, a.wa = m, g = a.yl = !0;\n    if (!(g || a.Xe || a.le || a.pl || a.ql)) return !0;\n    a.vi = !1;\n    var n = a.viewportBounds,\n      p = a.documentBounds,\n      r = 0,\n      q = 0,\n      u = 0,\n      v = 0;\n    c = n.width;\n    var w = n.height,\n      y = a.Si;\n    a.contentAlignment.ib() ? (p.width > c && (r = y.left, q = y.right), p.height > w && (u = y.top, v = y.bottom)) : (r = y.left, q = y.right, u = y.top, v = y.bottom);\n    y = p.width + r + q;\n    var z = p.height + u + v;\n    r = p.x - r;\n    var A = n.x;\n    q = p.right + q;\n    var C = n.right + h;\n    u = p.y - u;\n    var G = n.y;\n    p = p.bottom + v;\n    n = n.bottom + k;\n    var L = \"1px\",\n      I = \"1px\";\n    v = a.scale;\n    l = y > l / v;\n    m = z > m / v;\n    a.scrollMode === Zh && (l || m) && (l && a.hasHorizontalScrollbar && a.allowHorizontalScroll && (l = 1, r + 1 < A && (l = Math.max((A - r) * v + a.xa, l)), q > C + 1 && (l = Math.max((q - C) * v + a.xa, l)), c + h + 1 < y && (l = Math.max((y - c) * v + a.xa, l)), L = l.toString() + \"px\"), m && a.hasVerticalScrollbar && a.allowVerticalScroll && (l = 1, u + 1 < G && (l = Math.max((G - u) * v + a.wa, l)), p > n + 1 && (l = Math.max((p - n) * v + a.wa, l)), w + k + 1 < z && (l = Math.max((z - w) * v + a.wa, l)), I = l.toString() + \"px\"));\n    l = \"1px\" !== L;\n    m = \"1px\" !== I;\n    l && m || !l && !m || (m && (C -= a.nb), l && (n -= a.nb), y < c + h || !a.hasHorizontalScrollbar || !a.allowHorizontalScroll || (h = 1, r + 1 < A && (h = Math.max((A - r) * v + a.xa, h)), q > C + 1 && (h = Math.max((q - C) * v + a.xa, h)), c + 1 < y && (h = Math.max((y - c) * v + a.xa, h)), L = h.toString() + \"px\"), l = \"1px\" !== L, h = a.wa, l !== a.le && (h = l ? a.wa - a.nb : a.wa + a.nb), z < w + k || !a.hasVerticalScrollbar || !a.allowVerticalScroll || (k = 1, u + 1 < G && (k = Math.max((G - u) * v + h, k)), p > n + 1 && (k = Math.max((p - n) * v + h, k)), w + 1 < z && (k = Math.max((z - w) * v + h, k)), I = k.toString() + \"px\"), m = \"1px\" !== I);\n    if (a.Kp && l === a.le && m === a.Xe) return d === a.xa && e === a.wa || a.cd(), !1;\n    l !== a.le && (\"1px\" === L ? a.wa = a.wa + a.nb : a.wa = Math.max(a.wa - a.nb, 1), g = !0);\n    a.le = l;\n    a.Lp.style.width = L;\n    m !== a.Xe && (\"1px\" === I ? a.xa = a.xa + a.nb : a.xa = Math.max(a.xa - a.nb, 1), g = !0, a.Al && (k = J.alloc(), m ? (b.style.left = a.nb + \"px\", a.position = k.h(a.la.x + a.nb / a.scale, a.la.y)) : (b.style.left = \"0px\", a.position = k.h(a.la.x - a.nb / a.scale, a.la.y)), J.free(k)));\n    a.Xe = m;\n    a.Lp.style.height = I;\n    a.Xs = !0;\n    g && (a.yl = !0);\n    b = a.$s;\n    k = b.scrollLeft;\n    a.hasHorizontalScrollbar && a.allowHorizontalScroll && (c + 1 < y ? k = (a.position.x - r) * v : r + 1 < A ? k = b.scrollWidth - b.clientWidth : q > C + 1 && (k = a.position.x * v));\n    if (a.Al) switch (a.Us) {\n      case \"negative\":\n        k = -(b.scrollWidth - k - b.clientWidth);\n        break;\n      case \"reverse\":\n        k = b.scrollWidth - k - b.clientWidth;\n    }\n    b.scrollLeft = k;\n    a.hasVerticalScrollbar && a.allowVerticalScroll && (w + 1 < z ? b.scrollTop = (a.position.y - u) * v : u + 1 < G ? b.scrollTop = b.scrollHeight - b.clientHeight : p > n + 1 && (b.scrollTop = a.position.y * v));\n    l = a.xa;\n    m = a.wa;\n    b.style.width = l + (a.Xe ? a.nb : 0) + \"px\";\n    b.style.height = m + (a.le ? a.nb : 0) + \"px\";\n    return d !== l || e !== m || a.animationManager.rc ? (a.Vq(f, a.viewportBounds, v, g), !1) : !0;\n  }\n  t.add = function (a) {\n    var b = a.diagram;\n    if (b !== this && (null !== b && B(\"Cannot add part \" + a.toString() + \" to \" + this.toString() + \". It is already a part of \" + b.toString()), b = this.tm(a.layerName), null === b && (b = this.tm(\"\")), null === b && B('Cannot add a Part when unable find a Layer named \"' + a.layerName + '\" and there is no default Layer'), a.layer !== b)) {\n      var c = b.nj(99999999, a, a.diagram === this);\n      0 <= c && this.ab(xe, \"parts\", b, null, a, null, c);\n      b.isTemporary || this.Oa();\n      a.C(1);\n      c = a.layerChanged;\n      null !== c && c(a, null, b);\n    }\n  };\n  t.nj = function (a) {\n    this.partManager.nj(a);\n    var b = this;\n    Fj(a, function (a) {\n      Gj(b, a);\n    });\n    (a instanceof He || a instanceof vf && null !== a.placeholder) && a.o();\n    null !== a.data && Fj(a, function (a) {\n      Hj(b.partManager, a);\n    });\n    !0 !== tj(a) && !0 !== uj(a) || this.rd.add(a);\n    Ij(a, !0, this);\n    Jj(a) ? (a.actualBounds.u() && this.M(Dj(a, a.actualBounds)), this.Oa()) : a.isVisible() && a.actualBounds.u() && this.M(Dj(a, a.actualBounds));\n    this.Db();\n  };\n  t.Kc = function (a) {\n    a.kk();\n    this.partManager.Kc(a);\n    var b = this;\n    null !== a.data && Fj(a, function (a) {\n      Kj(b.partManager, a, b);\n    });\n    this.rd.remove(a);\n    Jj(a) ? (a.actualBounds.u() && this.M(Dj(a, a.actualBounds)), this.Oa()) : a.isVisible() && a.actualBounds.u() && this.M(Dj(a, a.actualBounds));\n    this.Db();\n  };\n  t.remove = function (a) {\n    Lj(this, a, !0);\n  };\n  function Lj(a, b, c) {\n    var d = b.layer;\n    null !== d && d.diagram === a && (b.isSelected = !1, b.isHighlighted = !1, b.C(2), c && b.rk(), c = d.Kc(-1, b, !1), 0 <= c && a.ab(ye, \"parts\", d, b, null, c, null), a = b.layerChanged, null !== a && a(b, d, null));\n  }\n  t.gu = function (a, b) {\n    if (Aa(a)) for (var c = a.length, d = 0; d < c; d++) {\n      var e = a[d];\n      b && !e.canDelete() || this.remove(e);\n    } else for (c = new F(), c.addAll(a), a = c.iterator; a.next();) c = a.value, b && !c.canDelete() || this.remove(c);\n  };\n  t.qk = function (a, b, c) {\n    return this.partManager.qk(a, b, c);\n  };\n  Q.prototype.moveParts = function (a, b, c, d) {\n    void 0 === d && (d = Mj(this));\n    if (null !== this.toolManager) {\n      var e = new H();\n      if (null !== a) {\n        if (Aa(a)) for (var f = 0; f < a.length; f++) Nj(this, e, a[f], c, d);else for (a = a.iterator; a.next();) Nj(this, e, a.value, c, d);\n      } else {\n        for (a = this.parts; a.next();) Nj(this, e, a.value, c, d);\n        for (a = this.nodes; a.next();) Nj(this, e, a.value, c, d);\n        for (a = this.links; a.next();) Nj(this, e, a.value, c, d);\n      }\n      sf(this, e, b, d, c);\n    }\n  };\n  function Nj(a, b, c, d, e, f) {\n    if (!b.contains(c) && (void 0 === f && (f = !1), !d || f || c.canMove() || c.canCopy())) if (void 0 === e && (e = Mj(a)), c instanceof V) {\n      b.add(c, a.xd(e, c, c.location));\n      if (c instanceof vf && (null !== c.placeholder || e.dragsMembers)) for (f = c.memberParts; f.next();) Nj(a, b, f.value, d, e, e.groupsAlwaysMove);\n      for (f = c.linksConnected; f.next();) {\n        var g = f.value;\n        if (!b.contains(g)) {\n          var h = g.fromNode,\n            k = g.toNode;\n          null !== h && b.contains(h) && null !== k && b.contains(k) && Nj(a, b, g, d, e);\n        }\n      }\n      if (e.dragsTree) for (c = c.Vv(); c.next();) Nj(a, b, c.value, d, e);\n    } else if (c instanceof S) for (b.add(c, a.xd(e, c)), c = c.labelNodes; c.next();) Nj(a, b, c.value, d, e);else c instanceof He || b.add(c, a.xd(e, c, c.location));\n  }\n  function sf(a, b, c, d, e) {\n    if (null !== b && 0 !== b.count) {\n      var f = J.alloc(),\n        g = J.alloc();\n      g.assign(c);\n      isNaN(g.x) && (g.x = 0);\n      isNaN(g.y) && (g.y = 0);\n      (c = a.cq) || Xe(a, b);\n      for (var h = Ea(), k = Ea(), l = b.iterator, m = J.alloc(); l.next();) {\n        var n = l.key,\n          p = l.value;\n        if (n.Wb()) {\n          var r = Oj(a, n, b);\n          if (null !== r) h.push(new Pj(n, p, r));else if (!e || n.canMove()) r = p.point, f.assign(r), a.computeMove(n, f.add(g), d, m), n.location = m, void 0 === p.shifted && (p.shifted = new J()), p.shifted.assign(m.ce(r));\n        } else l.key instanceof S && k.push(l.ka);\n      }\n      J.free(m);\n      e = h.length;\n      for (l = 0; l < e; l++) n = h[l], f.assign(n.info.point), void 0 === n.Zv.shifted && (n.Zv.shifted = new J()), n.node.location = f.add(n.Zv.shifted);\n      e = J.alloc();\n      l = J.alloc();\n      n = k.length;\n      for (p = 0; p < n; p++) {\n        var q = k[p];\n        r = q.key;\n        if (r instanceof S) if (r.suspendsRouting) {\n          r.qg = null;\n          m = r.fromNode;\n          var u = r.toNode;\n          if (null !== a.draggedLink && d.dragsLink) {\n            if (u = q.value.point, null === r.dragComputation) b.add(r, a.xd(d, r, g)), qf(r, g.x - u.x, g.y - u.y);else {\n              q = J.allocAt(0, 0);\n              (m = r.i(0)) && m.u() && q.assign(m);\n              var v = m = J.alloc().assign(q).add(g);\n              d.isGridSnapEnabled && (d.isGridSnapRealtime || a.lastInput.up) && (v = J.alloc(), Fg(a, r, m, v, d));\n              m.assign(r.dragComputation(r, m, v)).ce(q);\n              b.add(r, a.xd(d, r, m));\n              qf(r, m.x - u.x, m.y - u.y);\n              J.free(q);\n              J.free(m);\n              v !== m && J.free(v);\n            }\n          } else null !== m && (e.assign(m.location), v = b.H(m), null !== v && e.ce(v.point)), null !== u && (l.assign(u.location), v = b.H(u), null !== v && l.ce(v.point)), null !== m && null !== u ? e.Na(l) ? (m = q.value.point, u = f, u.assign(e), u.ce(m), b.add(r, a.xd(d, r, e)), qf(r, u.x, u.y)) : (r.suspendsRouting = !1, r.Ua()) : (q = q.value.point, m = null !== m ? e : null !== u ? l : g, b.add(r, a.xd(d, r, m)), qf(r, m.x - q.x, m.y - q.y));\n        } else if (null === r.fromNode || null === r.toNode) m = q.value.point, b.add(r, a.xd(d, r, g)), qf(r, g.x - m.x, g.y - m.y);\n      }\n      J.free(f);\n      J.free(g);\n      J.free(e);\n      J.free(l);\n      Ha(h);\n      Ha(k);\n      c || (Ui(a), ff(a, b));\n    }\n  }\n  Q.prototype.computeMove = function (a, b, c, d) {\n    void 0 === d && (d = new J());\n    d.assign(b);\n    if (null === a) return d;\n    var e = b,\n      f = c.isGridSnapEnabled;\n    f && (c.isGridSnapRealtime || this.lastInput.up) && (e = J.alloc(), Fg(this, a, b, e, c));\n    c = null !== a.dragComputation ? a.dragComputation(a, b, e) : e;\n    var g = a.minLocation,\n      h = g.x;\n    isNaN(h) && (h = f ? Math.round(1E3 * a.location.x) / 1E3 : a.location.x);\n    g = g.y;\n    isNaN(g) && (g = f ? Math.round(1E3 * a.location.y) / 1E3 : a.location.y);\n    var k = a.maxLocation,\n      l = k.x;\n    isNaN(l) && (l = f ? Math.round(1E3 * a.location.x) / 1E3 : a.location.x);\n    k = k.y;\n    isNaN(k) && (k = f ? Math.round(1E3 * a.location.y) / 1E3 : a.location.y);\n    d.h(Math.max(h, Math.min(c.x, l)), Math.max(g, Math.min(c.y, k)));\n    e !== b && J.free(e);\n    return d;\n  };\n  function Mj(a) {\n    var b = a.toolManager.findTool(\"Dragging\");\n    return null !== b ? b.dragOptions : a.dl;\n  }\n  function Fg(a, b, c, d, e) {\n    void 0 === e && (e = Mj(a));\n    d.assign(c);\n    if (null !== b) {\n      var f = a.grid;\n      b = e.gridSnapCellSize;\n      a = b.width;\n      b = b.height;\n      var g = e.gridSnapOrigin,\n        h = g.x;\n      g = g.y;\n      e = e.gridSnapCellSpot;\n      if (null !== f) {\n        var k = f.gridCellSize;\n        isNaN(a) && (a = k.width);\n        isNaN(b) && (b = k.height);\n        f = f.gridOrigin;\n        isNaN(h) && (h = f.x);\n        isNaN(g) && (g = f.y);\n      }\n      f = J.allocAt(0, 0);\n      f.Lk(0, 0, a, b, e);\n      K.Eq(c.x, c.y, h + f.x, g + f.y, a, b, d);\n      J.free(f);\n    }\n  }\n  function Xe(a, b) {\n    if (null !== b) for (a.cq = !0, a = b.iterator; a.next();) b = a.key, b instanceof S && (b.suspendsRouting = !0);\n  }\n  function ff(a, b) {\n    if (null !== b) {\n      for (b = b.iterator; b.next();) {\n        var c = b.key;\n        c instanceof S && (c.suspendsRouting = !1, Qj(c) && c.Ua());\n      }\n      a.cq = !1;\n    }\n  }\n  function Oj(a, b, c) {\n    b = b.containingGroup;\n    if (null !== b) {\n      a = Oj(a, b, c);\n      if (null !== a) return a;\n      a = c.H(b);\n      if (null !== a) return a;\n    }\n    return null;\n  }\n  t = Q.prototype;\n  t.xd = function (a, b, c) {\n    if (void 0 === c) return new $e(Hb);\n    var d = a.isGridSnapEnabled;\n    a.groupsSnapMembers || null === b.containingGroup || (d = !1);\n    return d ? new $e(new J(Math.round(1E3 * c.x) / 1E3, Math.round(1E3 * c.y) / 1E3)) : new $e(c.copy());\n  };\n  function Rj(a, b, c) {\n    null !== b.diagram && b.diagram !== a && B(\"Cannot share a Layer with another Diagram: \" + b + \" of \" + b.diagram);\n    null === c ? null !== b.diagram && B(\"Cannot add an existing Layer to this Diagram again: \" + b) : (c.diagram !== a && B(\"Existing Layer must be in this Diagram: \" + c + \" not in \" + c.diagram), b === c && B(\"Cannot move a Layer before or after itself: \" + b));\n    if (b.diagram !== a) {\n      b = b.name;\n      a = a.La;\n      c = a.count;\n      for (var d = 0; d < c; d++) a.L(d).name === b && B(\"Cannot add Layer with the name '\" + b + \"'; a Layer with the same name is already present in this Diagram.\");\n    }\n  }\n  t.om = function (a) {\n    Rj(this, a, null);\n    a.ae(this);\n    var b = this.La,\n      c = b.count - 1;\n    if (!a.isTemporary) for (; 0 <= c && b.L(c).isTemporary;) c--;\n    b.vb(c + 1, a);\n    null !== this.ac && this.ab(xe, \"layers\", this, null, a, null, c + 1);\n    this.M();\n    this.Oa();\n  };\n  t.Sx = function (a, b) {\n    Rj(this, a, b);\n    a.ae(this);\n    var c = this.La,\n      d = c.indexOf(a);\n    0 <= d && (c.remove(a), null !== this.ac && this.ab(ye, \"layers\", this, a, null, d, null));\n    var e = c.count,\n      f;\n    for (f = 0; f < e; f++) if (c.L(f) === b) {\n      c.vb(f, a);\n      break;\n    }\n    null !== this.ac && this.ab(xe, \"layers\", this, null, a, null, f);\n    this.M();\n    0 > d && this.Oa();\n  };\n  t.jz = function (a, b) {\n    Rj(this, a, b);\n    a.ae(this);\n    var c = this.La,\n      d = c.indexOf(a);\n    0 <= d && (c.remove(a), null !== this.ac && this.ab(ye, \"layers\", this, a, null, d, null));\n    var e = c.count,\n      f;\n    for (f = 0; f < e; f++) if (c.L(f) === b) {\n      c.vb(f + 1, a);\n      break;\n    }\n    null !== this.ac && this.ab(xe, \"layers\", this, null, a, null, f + 1);\n    this.M();\n    0 > d && this.Oa();\n  };\n  t.NA = function (a) {\n    a.diagram !== this && B(\"Cannot remove a Layer from another Diagram: \" + a + \" of \" + a.diagram);\n    if (\"\" !== a.name) {\n      var b = this.La,\n        c = b.indexOf(a);\n      if (b.remove(a)) {\n        for (b = a.Da.copy().iterator; b.next();) {\n          var d = b.value,\n            e = d.layerName;\n          e !== a.name ? d.layerName = e : d.layerName = \"\";\n        }\n        null !== this.ac && this.ab(ye, \"layers\", this, a, null, c, null);\n        this.M();\n        this.Oa();\n      }\n    }\n  };\n  t.tm = function (a) {\n    for (var b = this.layers; b.next();) {\n      var c = b.value;\n      if (c.name === a) return c;\n    }\n    return null;\n  };\n  t.Vx = function (a) {\n    null === this.se && (this.se = new E());\n    this.se.add(a);\n    this.model.Hh(a);\n  };\n  t.PA = function (a) {\n    null !== this.se && (this.se.remove(a), 0 === this.se.count && (this.se = null));\n    this.model.Kk(a);\n  };\n  t.Hh = function (a) {\n    null === this.Nf && (this.Nf = new E());\n    this.Nf.add(a);\n  };\n  t.Kk = function (a) {\n    null !== this.Nf && (this.Nf.remove(a), 0 === this.Nf.count && (this.Nf = null));\n  };\n  t.zt = function (a) {\n    this.skipsUndoManager || this.model.skipsUndoManager || this.model.undoManager.$v(a);\n    a.change !== we && (this.isModified = !0);\n    if (null !== this.Nf) for (var b = this.Nf, c = b.length, d = 0; d < c; d++) b.L(d)(a);\n  };\n  t.ab = function (a, b, c, d, e, f, g) {\n    void 0 === f && (f = null);\n    void 0 === g && (g = null);\n    var h = new ue();\n    h.diagram = this;\n    h.change = a;\n    h.propertyName = b;\n    h.object = c;\n    h.oldValue = d;\n    h.oldParam = f;\n    h.newValue = e;\n    h.newParam = g;\n    this.zt(h);\n  };\n  t.g = function (a, b, c, d, e) {\n    this.ab(ve, a, this, b, c, d, e);\n  };\n  Q.prototype.changeState = function (a, b) {\n    if (null !== a && a.diagram === this) {\n      var c = this.skipsModelSourceBindings;\n      try {\n        this.skipsModelSourceBindings = !0;\n        var d = a.change;\n        if (d === ve) {\n          var e = a.object;\n          Sj(e, a.propertyName, a.H(b));\n          if (e instanceof Y) {\n            var f = e.part;\n            null !== f && f.Lb();\n          }\n          this.isModified = !0;\n        } else if (d === xe) {\n          var g = a.object,\n            h = a.newParam,\n            k = a.newValue;\n          if (g instanceof X) {\n            if (\"number\" === typeof h && k instanceof Y) {\n              b ? g.Kc(h) : g.vb(h, k);\n              var l = g.part;\n              null !== l && l.Lb();\n            } else {\n              if (\"number\" === typeof h && k instanceof Tj) if (b) k.isRow ? g.tw(h) : g.rw(h);else {\n                var m = k.isRow ? g.getRowDefinition(k.index) : g.getColumnDefinition(k.index);\n                m.Dt(k);\n              }\n            }\n          } else if (g instanceof ii) {\n            var n = !0 === a.oldParam;\n            \"number\" === typeof h && k instanceof U && (b ? (k.isSelected = !1, k.isHighlighted = !1, k.Lb(), g.Kc(n ? h : -1, k, n)) : g.nj(h, k, n));\n          } else g instanceof Q ? \"number\" === typeof h && k instanceof ii && (b ? this.La.bb(h) : (k.ae(this), this.La.vb(h, k))) : B(\"unknown ChangedEvent.Insert object: \" + a.toString());\n          this.isModified = !0;\n        } else if (d === ye) {\n          var p = a.object,\n            r = a.oldParam,\n            q = a.oldValue;\n          if (p instanceof X) \"number\" === typeof r && q instanceof Y ? b ? p.vb(r, q) : p.Kc(r) : \"number\" === typeof r && q instanceof Tj && (b ? (m = q.isRow ? p.getRowDefinition(q.index) : p.getColumnDefinition(q.index), m.Dt(q)) : q.isRow ? p.tw(r) : p.rw(r));else if (p instanceof ii) {\n            var u = !0 === a.newParam;\n            \"number\" === typeof r && q instanceof U && (b ? 0 > p.Da.indexOf(q) && p.nj(r, q, u) : (q.isSelected = !1, q.isHighlighted = !1, q.Lb(), p.Kc(u ? r : -1, q, u)));\n          } else p instanceof Q ? \"number\" === typeof r && q instanceof ii && (b ? (q.ae(this), this.La.vb(r, q)) : this.La.bb(r)) : B(\"unknown ChangedEvent.Remove object: \" + a.toString());\n          this.isModified = !0;\n        } else d !== we && B(\"unknown ChangedEvent: \" + a.toString());\n      } finally {\n        this.skipsModelSourceBindings = c;\n      }\n    }\n  };\n  Q.prototype.va = function (a) {\n    return this.undoManager.va(a);\n  };\n  Q.prototype.Wa = function (a) {\n    return this.undoManager.Wa(a);\n  };\n  Q.prototype.Hf = function () {\n    return this.undoManager.Hf();\n  };\n  Q.prototype.commit = function (a, b) {\n    void 0 === b && (b = \"\");\n    var c = this.skipsUndoManager;\n    null === b && (this.skipsUndoManager = !0, b = \"\");\n    this.undoManager.va(b);\n    var d = !1;\n    try {\n      a(this), d = !0;\n    } finally {\n      d ? this.undoManager.Wa(b) : this.undoManager.Hf(), this.skipsUndoManager = c;\n    }\n  };\n  Q.prototype.updateAllTargetBindings = function (a) {\n    this.partManager.updateAllTargetBindings(a);\n  };\n  Q.prototype.kr = function () {\n    this.partManager.kr();\n  };\n  function Uj(a, b, c) {\n    var d = a.animationManager;\n    if (a.Rb || a.jc) a.ya = c, d.df && d.Jd.add(d.B, \"scale\", b, a.ya);else if (null === a.ta) a.ya = c;else {\n      a.Rb = !0;\n      var e = a.viewportBounds.copy(),\n        f = a.xa,\n        g = a.wa;\n      e.width = a.xa / b;\n      e.height = a.wa / b;\n      var h = a.zoomPoint.x,\n        k = a.zoomPoint.y,\n        l = a.contentAlignment;\n      isNaN(h) && (l.Mc() ? l.Df(Jc) ? h = 0 : l.Df(Kc) && (h = f - 1) : h = l.ib() ? l.x * (f - 1) : f / 2);\n      isNaN(k) && (l.Mc() ? l.Df(Ic) ? k = 0 : l.Df(Lc) && (k = g - 1) : k = l.ib() ? l.y * (g - 1) : g / 2);\n      null === a.scaleComputation || a.animationManager.isAnimating || (c = a.scaleComputation(a, c));\n      c < a.minScale && (c = a.minScale);\n      c > a.maxScale && (c = a.maxScale);\n      f = J.allocAt(a.la.x + h / b - h / c, a.la.y + k / b - k / c);\n      a.position = f;\n      J.free(f);\n      a.ya = c;\n      a.Vq(e, a.viewportBounds, b, !1);\n      a.Rb = !1;\n      Wi(a, !1);\n      d.df && d.Jd.add(d.B, \"scale\", b, a.ya);\n      a.M();\n      Zi(a);\n    }\n  }\n  Q.prototype.Vq = function (a, b, c, d) {\n    if (!a.w(b)) {\n      void 0 === d && (d = !1);\n      d || Zi(this);\n      Ti(this);\n      var e = this.layout;\n      null === e || !e.isViewportSized || this.autoScale !== Ih || d || a.width === b.width && a.height === b.height || e.C();\n      e = this.currentTool;\n      !0 === this.Zf && e instanceof Oa && (this.lastInput.documentPoint = this.nu(this.lastInput.viewPoint), Pe(e, this));\n      this.Rb || this.By(a, b);\n      oj(this);\n      this.Vd.scale = c;\n      this.Vd.position.x = a.x;\n      this.Vd.position.y = a.y;\n      this.Vd.bounds.assign(a);\n      this.Vd.gw = d;\n      this.R(\"ViewportBoundsChanged\", this.Vd, a);\n      this.isVirtualized && this.links.each(function (a) {\n        a.isAvoiding && a.actualBounds.Lc(b) && a.Ua();\n      });\n    }\n  };\n  function oj(a, b) {\n    void 0 === b && (b = null);\n    var c = a.Ib;\n    if (null !== c && c.visible) {\n      for (var d = M.alloc(), e = 1, f = 1, g = c.W.j, h = g.length, k = 0; k < h; k++) {\n        var l = g[k],\n          m = l.interval;\n        2 > m || (Vj(l.figure) ? f = f * m / K.qy(f, m) : e = e * m / K.qy(e, m));\n      }\n      g = c.gridCellSize;\n      d.h(f * g.width, e * g.height);\n      if (null !== b) e = b.width, f = b.height, a = b.x, g = b.y;else {\n        b = N.alloc();\n        a = a.viewportBounds;\n        b.h(a.x, a.y, a.width, a.height);\n        if (!b.u()) {\n          N.free(b);\n          return;\n        }\n        e = b.width;\n        f = b.height;\n        a = b.x;\n        g = b.y;\n        N.free(b);\n      }\n      c.width = e + 2 * d.width;\n      c.height = f + 2 * d.height;\n      b = J.alloc();\n      K.Eq(a, g, 0, 0, d.width, d.height, b);\n      b.offset(-d.width, -d.height);\n      M.free(d);\n      c.part.location = b;\n      J.free(b);\n    }\n  }\n  Q.prototype.clearSelection = function (a) {\n    void 0 === a && (a = !1);\n    var b = this.selection;\n    if (0 !== b.count) {\n      a || this.R(\"ChangingSelection\", b);\n      for (var c = b.ma(), d = c.length, e = 0; e < d; e++) c[e].isSelected = !1;\n      b.ea();\n      b.clear();\n      b.freeze();\n      a || this.R(\"ChangedSelection\", b);\n    }\n  };\n  Q.prototype.select = function (a) {\n    null !== a && a.layer.diagram === this && (!a.isSelected || 1 < this.selection.count) && (this.R(\"ChangingSelection\", this.selection), this.clearSelection(!0), a.isSelected = !0, this.R(\"ChangedSelection\", this.selection));\n  };\n  Q.prototype.TA = function (a) {\n    this.R(\"ChangingSelection\", this.selection);\n    this.clearSelection(!0);\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n      d instanceof U || B(\"Diagram.selectCollection given something that is not a Part: \" + d);\n      d.isSelected = !0;\n    } else for (a = a.iterator; a.next();) b = a.value, b instanceof U || B(\"Diagram.selectCollection given something that is not a Part: \" + b), b.isSelected = !0;\n    this.R(\"ChangedSelection\", this.selection);\n  };\n  Q.prototype.clearHighlighteds = function () {\n    var a = this.highlighteds;\n    if (0 < a.count) {\n      for (var b = a.ma(), c = b.length, d = 0; d < c; d++) b[d].isHighlighted = !1;\n      a.ea();\n      a.clear();\n      a.freeze();\n    }\n  };\n  t = Q.prototype;\n  t.pA = function (a) {\n    null !== a && a.layer.diagram === this && (!a.isHighlighted || 1 < this.highlighteds.count) && (this.clearHighlighteds(), a.isHighlighted = !0);\n  };\n  t.qA = function (a) {\n    a = new F().addAll(a);\n    for (var b = this.highlighteds.copy().$q(a).iterator; b.next();) b.value.isHighlighted = !1;\n    for (a = a.iterator; a.next();) b = a.value, b instanceof U || B(\"Diagram.highlightCollection given something that is not a Part: \" + b), b.isHighlighted = !0;\n  };\n  t.scroll = function (a, b, c) {\n    void 0 === c && (c = 1);\n    var d = \"up\" === b || \"down\" === b,\n      e = 0;\n    if (\"pixel\" === a) e = c;else if (\"line\" === a) e = c * (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange);else if (\"page\" === a) a = d ? this.viewportBounds.height : this.viewportBounds.width, a *= this.scale, 0 !== a && (e = c * Math.max(a - (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0));else {\n      if (\"document\" === a) {\n        e = this.documentBounds;\n        c = this.viewportBounds;\n        d = J.alloc();\n        \"up\" === b ? this.position = d.h(c.x, e.y) : \"left\" === b ? this.position = d.h(e.x, c.y) : \"down\" === b ? this.position = d.h(c.x, e.bottom - c.height) : \"right\" === b && (this.position = d.h(e.right - c.width, c.y));\n        J.free(d);\n        return;\n      }\n      B(\"scrolling unit must be 'pixel', 'line', 'page', or 'document', not: \" + a);\n    }\n    e /= this.scale;\n    c = this.position.copy();\n    \"up\" === b ? c.y = this.position.y - e : \"down\" === b ? c.y = this.position.y + e : \"left\" === b ? c.x = this.position.x - e : \"right\" === b ? c.x = this.position.x + e : B(\"scrolling direction must be 'up', 'down', 'left', or 'right', not: \" + b);\n    this.position = c;\n  };\n  t.zw = function (a) {\n    var b = this.viewportBounds;\n    b.De(a) || (a = a.center, a.x -= b.width / 2, a.y -= b.height / 2, this.position = a);\n  };\n  t.At = function (a) {\n    var b = this.viewportBounds;\n    a = a.center;\n    a.x -= b.width / 2;\n    a.y -= b.height / 2;\n    this.position = a;\n  };\n  t.ir = function (a) {\n    var b = this.ob;\n    b.reset();\n    1 !== this.ya && b.scale(this.ya);\n    var c = this.la;\n    (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y);\n    return a.copy().transform(this.ob);\n  };\n  t.bB = function (a) {\n    var b = this.ob,\n      c = a.x,\n      d = a.y,\n      e = c + a.width,\n      f = d + a.height,\n      g = b.m11,\n      h = b.m12,\n      k = b.m21,\n      l = b.m22,\n      m = b.dx,\n      n = b.dy,\n      p = c * g + d * k + m;\n    b = c * h + d * l + n;\n    var r = e * g + d * k + m;\n    a = e * h + d * l + n;\n    d = c * g + f * k + m;\n    c = c * h + f * l + n;\n    g = e * g + f * k + m;\n    e = e * h + f * l + n;\n    f = Math.min(p, r);\n    p = Math.max(p, r);\n    r = Math.min(b, a);\n    b = Math.max(b, a);\n    f = Math.min(f, d);\n    p = Math.max(p, d);\n    r = Math.min(r, c);\n    b = Math.max(b, c);\n    f = Math.min(f, g);\n    p = Math.max(p, g);\n    r = Math.min(r, e);\n    b = Math.max(b, e);\n    return new N(f, r, p - f, b - r);\n  };\n  t.nu = function (a) {\n    var b = this.ob;\n    b.reset();\n    1 !== this.ya && b.scale(this.ya);\n    var c = this.la;\n    (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y);\n    return Bb(a.copy(), this.ob);\n  };\n  function Wj(a) {\n    var b = a.isModified;\n    a.zv !== b && (a.zv = b, a.R(\"Modified\"));\n  }\n  function Xj(a) {\n    a = si.get(a);\n    return null !== a ? new a() : new ti();\n  }\n  Q.prototype.doModelChanged = function (a) {\n    var b = this;\n    if (a.model === this.model) {\n      var c = a.change,\n        d = a.propertyName;\n      if (c === we && \"S\" === d[0]) {\n        if (\"StartingFirstTransaction\" === d) {\n          var e = this;\n          a = this.toolManager;\n          a.mouseDownTools.each(function (a) {\n            a.diagram = e;\n          });\n          a.mouseMoveTools.each(function (a) {\n            a.diagram = e;\n          });\n          a.mouseUpTools.each(function (a) {\n            a.diagram = e;\n          });\n          this.jc || this.me || (this.Ej = !0, this.Hj && (this.Ae = !0));\n        } else \"StartingUndo\" === d || \"StartingRedo\" === d ? (a = this.animationManager, a.defaultAnimation.isAnimating && !this.skipsUndoManager && a.Nc(), this.R(\"ChangingSelection\", this.selection)) : \"StartedTransaction\" === d && (a = this.animationManager, a.defaultAnimation.isAnimating && !this.skipsUndoManager && a.Nc());\n      } else if (this.Z) {\n        this.Z = !1;\n        try {\n          if (\"\" === a.modelChange && c === we) {\n            if (\"FinishedUndo\" === d || \"FinishedRedo\" === d) this.R(\"ChangedSelection\", this.selection), Ui(this);\n            var f = this.animationManager;\n            \"RolledBackTransaction\" === d && f.Nc();\n            this.Ej = !0;\n            this.cd();\n            0 !== this.undoManager.transactionLevel && 1 !== this.undoManager.transactionLevel || Eh(f);\n            \"CommittedTransaction\" === d && this.undoManager.isJustDiscarded && (this.Pd = Math.min(this.Pd, this.undoManager.historyIndex - 1));\n            \"CommittedTransaction\" !== d && \"RolledBackTransaction\" !== d || !this.undoManager.isPendingUnmodified || setTimeout(function () {\n              b.isModified = !1;\n            }, 1);\n            var g = a.isTransactionFinished;\n            g && (Wj(this), this.Xt.clear(), Qh(this.animationManager));\n            if (!this.Ds && g && this.lastInput.targetDiagram) {\n              this.Ds = !0;\n              var h = this;\n              sa(function () {\n                h.currentTool.standardMouseOver();\n                h.Ds = !1;\n              }, 10);\n            }\n          }\n        } finally {\n          this.Z = !0;\n        }\n      }\n    }\n  };\n  function Gj(a, b) {\n    b = b.W.j;\n    for (var c = b.length, d = 0; d < c; d++) Yj(a, b[d]);\n  }\n  function Yj(a, b) {\n    if (b instanceof Zj) {\n      var c = b.element;\n      if (null !== c && c instanceof HTMLImageElement) {\n        var d = b.Yg;\n        null !== d && (d.ol instanceof Event && null !== b.Cc && b.Cc(b, d.ol), !0 === d.ns && (null !== b.qf && b.qf(b, d.ov), null !== b.diagram && b.diagram.Ns.add(b)));\n        c = c.getAttribute(\"src\");\n        d = a.Pi.H(c);\n        if (null === d) d = [], d.push(b), a.Pi.add(c, d);else {\n          for (a = 0; a < d.length; a++) if (d[a] === b) return;\n          d.push(b);\n        }\n      }\n    }\n  }\n  function ak(a, b) {\n    if (b instanceof Zj) {\n      var c = b.element;\n      if (null !== c && c instanceof HTMLImageElement) {\n        c = c.getAttribute(\"src\");\n        var d = a.Pi.H(c);\n        if (null !== d) for (var e = 0; e < d.length; e++) if (d[e] === b) {\n          d.splice(e, 1);\n          0 === d.length && (a.Pi.remove(c), kk(c));\n          break;\n        }\n      }\n    }\n  }\n  Q.prototype.Ed = function () {\n    this.partManager.Ed();\n  };\n  Q.prototype.gk = function (a, b) {\n    this.Rc.gk(a, b);\n  };\n  Q.prototype.ik = function (a, b) {\n    this.Rc.ik(a, b);\n  };\n  Q.prototype.findPartForKey = function (a) {\n    return this.partManager.findPartForKey(a);\n  };\n  Q.prototype.Cb = function (a) {\n    return this.partManager.Cb(a);\n  };\n  Q.prototype.findLinkForKey = function (a) {\n    return this.partManager.findLinkForKey(a);\n  };\n  t = Q.prototype;\n  t.yc = function (a) {\n    return this.partManager.yc(a);\n  };\n  t.gj = function (a) {\n    return this.partManager.gj(a);\n  };\n  t.xc = function (a) {\n    return this.partManager.xc(a);\n  };\n  t.Jt = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n    return this.partManager.Jt.apply(this.partManager, b instanceof Array ? b : da(ba(b)));\n  };\n  t.It = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n    return this.partManager.It.apply(this.partManager, b instanceof Array ? b : da(ba(b)));\n  };\n  function Bj(a, b) {\n    a.ui = !1;\n    var c = a.Qn;\n    c.w(b) || (b = b.G(), a.Qn = b, Wi(a, !1), a.R(\"DocumentBoundsChanged\", null, c.copy()), Zi(a));\n  }\n  t.Ta = function () {\n    this.ui && Bj(this, this.computeBounds());\n  };\n  t.Zz = function () {\n    for (var a = new F(), b = this.nodes; b.next();) {\n      var c = b.value;\n      c.isTopLevel && a.add(c);\n    }\n    for (b = this.links; b.next();) c = b.value, c.isTopLevel && a.add(c);\n    return a.iterator;\n  };\n  t.Yz = function () {\n    return this.Dh.iterator;\n  };\n  t.AA = function (a) {\n    Ui(this);\n    a && ok(this, !0);\n    this.Ej = !0;\n    Jf(this);\n  };\n  function ok(a, b) {\n    for (var c = a.Dh.iterator; c.next();) pk(a, c.value, b);\n    null !== a.layout && (b ? a.layout.isValidLayout = !1 : a.layout.C());\n  }\n  function pk(a, b, c) {\n    if (null !== b) {\n      for (var d = b.Ml.iterator; d.next();) pk(a, d.value, c);\n      null !== b.layout && (c ? b.layout.isValidLayout = !1 : b.layout.C());\n    }\n  }\n  function pj(a, b) {\n    if (a.Ng && !a.Pr) {\n      var c = a.Z;\n      a.Z = !0;\n      var d = a.undoManager.transactionLevel,\n        e = a.layout,\n        f = a.animationManager;\n      try {\n        0 === d && (a.undoManager.isInternalTransaction = !0, a.va(\"Layout\"));\n        1 >= d && !f.isAnimating && !f.rc && (b || Ch(f, \"Layout\"));\n        a.Ng = !1;\n        for (var g = a.Dh.iterator; g.next();) qk(a, g.value, b, d);\n        e.isValidLayout || (!b || e.isRealtime || null === e.isRealtime || 0 === d ? (e.doLayout(a), Ui(a), e.isValidLayout = !0) : a.Ng = !0);\n      } finally {\n        b = a.undoManager.isInternalTransaction, 0 === d && (a.Wa(\"Layout\"), a.undoManager.isInternalTransaction = !1), !b || 0 !== d && 1 !== d || Eh(f), a.Z = c;\n      }\n    }\n  }\n  function qk(a, b, c, d) {\n    if (null !== b) {\n      for (var e = b.Ml.iterator; e.next();) qk(a, e.value, c, d);\n      e = b.layout;\n      null === e || e.isValidLayout || (!c || e.isRealtime || 0 === d ? (b.Rh = !b.location.u(), e.doLayout(b), b.C(32), rj(a, b), e.isValidLayout = !0) : a.Ng = !0);\n    }\n  }\n  t.eA = function () {\n    for (var a = new E(), b = this.nodes; b.next();) {\n      var c = b.value;\n      c.isTopLevel && null === c.jj() && a.add(c);\n    }\n    return a.iterator;\n  };\n  function qi(a) {\n    function b(a) {\n      var b = a.toLowerCase(),\n        e = new E();\n      c.add(a, e);\n      c.add(b, e);\n      d.add(a, a);\n      d.add(b, a);\n    }\n    var c = new H(),\n      d = new H();\n    b(\"InitialAnimationStarting\");\n    b(\"AnimationStarting\");\n    b(\"AnimationFinished\");\n    b(\"BackgroundSingleClicked\");\n    b(\"BackgroundDoubleClicked\");\n    b(\"BackgroundContextClicked\");\n    b(\"ClipboardChanged\");\n    b(\"ClipboardPasted\");\n    b(\"DocumentBoundsChanged\");\n    b(\"ExternalObjectsDropped\");\n    b(\"GainedFocus\");\n    b(\"InitialLayoutCompleted\");\n    b(\"LayoutCompleted\");\n    b(\"LinkDrawn\");\n    b(\"LinkRelinked\");\n    b(\"LinkReshaped\");\n    b(\"LostFocus\");\n    b(\"Modified\");\n    b(\"ObjectSingleClicked\");\n    b(\"ObjectDoubleClicked\");\n    b(\"ObjectContextClicked\");\n    b(\"PartCreated\");\n    b(\"PartResized\");\n    b(\"PartRotated\");\n    b(\"SelectionMoved\");\n    b(\"SelectionCopied\");\n    b(\"SelectionDeleting\");\n    b(\"SelectionDeleted\");\n    b(\"SelectionGrouped\");\n    b(\"SelectionUngrouped\");\n    b(\"ChangingSelection\");\n    b(\"ChangedSelection\");\n    b(\"SubGraphCollapsed\");\n    b(\"SubGraphExpanded\");\n    b(\"TextEdited\");\n    b(\"TreeCollapsed\");\n    b(\"TreeExpanded\");\n    b(\"ViewportBoundsChanged\");\n    b(\"InvalidateDraw\");\n    a.Sr = c;\n    a.Rr = d;\n  }\n  function Aj(a, b) {\n    var c = a.Rr.H(b);\n    return null !== c ? c : a.Rr.H(b.toLowerCase());\n  }\n  function rk(a, b) {\n    var c = a.Sr.H(b);\n    if (null !== c) return c;\n    c = a.Sr.H(b.toLowerCase());\n    if (null !== c) return c;\n    B(\"Unknown DiagramEvent name: \" + b);\n  }\n  t.hk = function (a, b) {\n    a = rk(this, a);\n    null !== a && a.add(b);\n  };\n  t.Km = function (a, b) {\n    a = rk(this, a);\n    null !== a && a.remove(b);\n  };\n  t.R = function (a, b, c) {\n    var d = rk(this, a),\n      e = new te();\n    e.diagram = this;\n    a = Aj(this, a);\n    null !== a && (e.name = a);\n    void 0 !== b && (e.subject = b);\n    void 0 !== c && (e.parameter = c);\n    b = d.length;\n    if (1 === b) d.L(0)(e);else if (0 !== b) for (d = d.ma(), c = 0; c < b; c++) (0, d[c])(e);\n  };\n  function sk(a) {\n    if (a.animationManager.isTicking) return !1;\n    var b = a.currentTool;\n    return b === a.toolManager.findTool(\"Dragging\") ? !a.cq || b.isComplexRoutingRealtime : !0;\n  }\n  t.zk = function (a, b) {\n    void 0 === b && (b = null);\n    return tk(this, !1, null, b).zk(a.x, a.y, a.width, a.height);\n  };\n  Q.prototype.computeOccupiedArea = function () {\n    return this.isVirtualized ? this.viewportBounds.copy() : this.ui ? Vi(this) : this.documentBounds.copy();\n  };\n  function tk(a, b, c, d) {\n    null === a.Gc && (a.Gc = new uk());\n    if (a.Gc.Rt || a.Gc.group !== c || a.Gc.Sy !== d) {\n      if (null === c) {\n        b = a.computeOccupiedArea();\n        b.Ic(100, 100);\n        a.Gc.initialize(b);\n        b = N.alloc();\n        for (var e = a.nodes; e.next();) {\n          var f = e.value,\n            g = f.layer;\n          null !== g && g.visible && !g.isTemporary && vk(a, f, d, b);\n        }\n        N.free(b);\n      } else {\n        0 < c.memberParts.count && (b = a.computePartsBounds(c.memberParts, !1), b.Ic(20, 20), a.Gc.initialize(b));\n        b = N.alloc();\n        for (e = c.memberParts; e.next();) f = e.value, f instanceof V && vk(a, f, d, b);\n        N.free(b);\n      }\n      a.Gc.group = c;\n      a.Gc.Sy = d;\n      a.Gc.Rt = !1;\n    } else b && wk(a.Gc);\n    return a.Gc;\n  }\n  function vk(a, b, c, d) {\n    if (b !== c) if (b.isVisible() && b.avoidable && !b.isLinkLabel) {\n      b = b.getAvoidableRect(d);\n      a = a.Gc;\n      var e = b.x,\n        f = b.y;\n      if (xk(a, e, f)) for (c = (f - a.wd) / a.fc | 0, d = Math.min((e + b.width - a.vd) / a.ec | 0, a.Zi), b = Math.min((f + b.height - a.wd) / a.fc | 0, a.$i), e = (e - a.vd) / a.ec | 0; e <= d; e++) if (f = a.Qb[e], f.fill) f.fill(yk, c, b + 1);else for (var g = c; g <= b; g++) f[g] = yk;\n    } else if (b instanceof vf) for (b = b.memberParts; b.next();) e = b.value, e instanceof V && vk(a, e, c, d);\n  }\n  function zk(a, b) {\n    null !== a.Gc && !a.Gc.Rt && (void 0 === b && (b = null), null === b || b.avoidable && !b.isLinkLabel) && (a.Gc.Rt = !0);\n  }\n  Q.prototype.Ft = function (a) {\n    this.qn.assign(a);\n    this.computeAutoScrollPosition(this.qn).Na(this.position) ? this.If() : Ak(this);\n  };\n  function Ak(a) {\n    -1 === a.yj && (a.yj = sa(function () {\n      if (-1 !== a.yj && (a.If(), null !== a.lastInput.event)) {\n        var b = a.computeAutoScrollPosition(a.qn);\n        b.Na(a.position) || (a.position = b, a.lastInput.documentPoint = a.nu(a.qn), a.doMouseMove(), a.ui = !0, Bj(a, a.documentBounds.copy().Oc(a.computeBounds())), a.Dc = !0, a.cd(), Ak(a));\n      }\n    }, a.pn));\n  }\n  Q.prototype.If = function () {\n    -1 !== this.yj && (x.clearTimeout(this.yj), this.yj = -1);\n  };\n  Q.prototype.computeAutoScrollPosition = function (a) {\n    var b = this.position,\n      c = this.rn;\n    if (0 >= c.top && 0 >= c.left && 0 >= c.right && 0 >= c.bottom) return b;\n    var d = this.viewportBounds,\n      e = this.scale;\n    d = N.allocAt(0, 0, d.width * e, d.height * e);\n    var f = J.allocAt(0, 0);\n    if (a.x >= d.x && a.x < d.x + c.left && this.allowHorizontalScroll) {\n      var g = Math.max(this.scrollHorizontalLineChange, 1);\n      g |= 0;\n      f.x -= g;\n      a.x < d.x + c.left / 2 && (f.x -= g);\n      a.x < d.x + c.left / 4 && (f.x -= 4 * g);\n    } else a.x <= d.x + d.width && a.x > d.x + d.width - c.right && this.allowHorizontalScroll && (g = Math.max(this.scrollHorizontalLineChange, 1), g |= 0, f.x += g, a.x > d.x + d.width - c.right / 2 && (f.x += g), a.x > d.x + d.width - c.right / 4 && (f.x += 4 * g));\n    a.y >= d.y && a.y < d.y + c.top && this.allowVerticalScroll ? (g = Math.max(this.scrollVerticalLineChange, 1), g |= 0, f.y -= g, a.y < d.y + c.top / 2 && (f.y -= g), a.y < d.y + c.top / 4 && (f.y -= 4 * g)) : a.y <= d.y + d.height && a.y > d.y + d.height - c.bottom && this.allowVerticalScroll && (g = Math.max(this.scrollVerticalLineChange, 1), g |= 0, f.y += g, a.y > d.y + d.height - c.bottom / 2 && (f.y += g), a.y > d.y + d.height - c.bottom / 4 && (f.y += 4 * g));\n    f.Na(Hb) || (b = new J(b.x + f.x / e, b.y + f.y / e));\n    N.free(d);\n    J.free(f);\n    return b;\n  };\n  t = Q.prototype;\n  t.Zt = function () {\n    return null;\n  };\n  t.hw = function () {\n    return null;\n  };\n  t.mz = function (a, b) {\n    this.Ix.add(a, b);\n  };\n  function Bk(a, b, c) {\n    function d() {\n      var a = +new Date();\n      f = !0;\n      for (g.reset(); g.next();) if (!g.value[0].Il) {\n        f = !1;\n        break;\n      }\n      f || a - l > k ? b(c, e, h) : x.requestAnimationFrame(d);\n    }\n    for (var e = c.callback, f = !0, g = a.Pi.iterator; g.next();) if (!g.value[0].Il) {\n      f = !1;\n      break;\n    }\n    if (\"function\" !== typeof e || f) return b(c, e, a);\n    var h = a,\n      k = c.callbackTimeout || 300,\n      l = +new Date();\n    x.requestAnimationFrame(function () {\n      d();\n    });\n    return null;\n  }\n  t.CA = function (a) {\n    if (!Tg) return null;\n    void 0 === a && (a = new ab());\n    a.returnType = \"Image\";\n    return this.Ey(a);\n  };\n  t.Ey = function (a) {\n    void 0 === a && (a = new ab());\n    return Bk(this, this.DA, a);\n  };\n  t.DA = function (a, b, c) {\n    var d = Ck(c, a, \"canvas\", null);\n    if (null === d) return null;\n    c = d.Y.canvas;\n    var e = null;\n    if (null !== c) switch (e = a.returnType, void 0 === e ? e = \"string\" : e = e.toLowerCase(), e) {\n      case \"imagedata\":\n        e = d.getImageData(0, 0, c.width, c.height);\n        break;\n      case \"image\":\n        d = (a.document || document).createElement(\"img\");\n        d.src = c.toDataURL(a.type, a.details);\n        e = d;\n        break;\n      case \"blob\":\n        \"function\" !== typeof b && B('Error: Diagram.makeImageData called with \"returnType: toBlob\", but no required \"callback\" function property defined.');\n        if (\"function\" === typeof c.toBlob) return c.toBlob(b, a.type, a.details), \"toBlob\";\n        if (\"function\" === typeof c.msToBlob) return b(c.msToBlob()), \"msToBlob\";\n        b(null);\n        return null;\n      default:\n        e = c.toDataURL(a.type, a.details);\n    }\n    return \"function\" === typeof b ? (b(e), null) : e;\n  };\n  function Ck(a, b, c, d) {\n    a.animationManager.Nc();\n    a.cd();\n    if (null === a.ta) return null;\n    \"object\" !== typeof b && B(\"properties argument must be an Object.\");\n    var e = b.size || null,\n      f = b.scale || null;\n    void 0 !== b.scale && isNaN(b.scale) && (f = \"NaN\");\n    var g = b.maxSize;\n    void 0 === b.maxSize && (g = \"SVG\" === c ? new M(Infinity, Infinity) : new M(2E3, 2E3));\n    var h = b.position || null,\n      k = b.parts || null,\n      l = void 0 === b.padding ? 1 : b.padding,\n      m = b.background || null,\n      n = b.omitTemporary;\n    void 0 === n && (n = !0);\n    var p = b.document || document,\n      r = b.elementFinished || null,\n      q = b.showTemporary;\n    void 0 === q && (q = !n);\n    b = b.showGrid;\n    void 0 === b && (b = q);\n    null !== e && isNaN(e.width) && isNaN(e.height) && (e = null);\n    \"number\" === typeof l ? l = new pc(l) : l instanceof pc || B(\"MakeImage padding must be a Margin or a number.\");\n    l.left = Math.max(l.left, 0);\n    l.right = Math.max(l.right, 0);\n    l.top = Math.max(l.top, 0);\n    l.bottom = Math.max(l.bottom, 0);\n    a.Gb.tc(!0);\n    n = new Dk(null, p);\n    var u = n.context;\n    if (!(e || f || k || h)) {\n      n.width = a.xa + Math.ceil(l.left + l.right);\n      n.height = a.wa + Math.ceil(l.top + l.bottom);\n      if (\"SVG\" === c) {\n        if (null === d) return null;\n        d.resize(n.width, n.height, n.width, n.height);\n        d.ownerDocument = p;\n        d.Bq = r;\n        yj(a, d.context, l, new M(n.width, n.height), a.ya, a.la, k, m, q, b);\n        return d.context;\n      }\n      a.kl = !1;\n      yj(a, u, l, new M(n.width, n.height), a.ya, a.la, k, m, q, b);\n      a.kl = !0;\n      return n.context;\n    }\n    var v = a.Pn,\n      w = a.documentBounds.copy();\n    w.Iw(a.gb);\n    if (q) for (var y = a.La.j, z = y.length, A = 0; A < z; A++) {\n      var C = y[A];\n      if (C.visible && C.isTemporary) {\n        C = C.Da.j;\n        for (var G = C.length, L = 0; L < G; L++) {\n          var I = C[L];\n          I.isInDocumentBounds && I.isVisible() && (I = I.actualBounds, I.u() && w.Oc(I));\n        }\n      }\n    }\n    y = new J(w.x, w.y);\n    if (null !== k) {\n      z = !0;\n      A = k.iterator;\n      for (A.reset(); A.next();) if (C = A.value, C instanceof U && (G = C.layer, (null === G || G.visible) && (null === G || q || !G.isTemporary) && C.isVisible() && (C = C.actualBounds, C.u()))) if (z) {\n        z = !1;\n        var T = C.copy();\n      } else T.Oc(C);\n      z && (T = new N(0, 0, 0, 0));\n      w.width = T.width;\n      w.height = T.height;\n      y.x = T.x;\n      y.y = T.y;\n    }\n    null !== h && h.u() && (y = h, f || (f = v));\n    T = h = 0;\n    null !== l && (h = l.left + l.right, T = l.top + l.bottom);\n    z = A = 0;\n    null !== e && (A = e.width, z = e.height, isFinite(A) && (A = Math.max(0, A - h)), isFinite(z) && (z = Math.max(0, z - T)));\n    null !== e && null !== f ? (\"NaN\" === f && (f = v), e.u() ? (e = A, w = z) : isNaN(z) ? (e = A, w = w.height * f) : (e = w.width * f, w = z)) : null !== e ? e.u() ? (f = Math.min(A / w.width, z / w.height), e = A, w = z) : isNaN(z) ? (f = A / w.width, e = A, w = w.height * f) : (f = z / w.height, e = w.width * f, w = z) : null !== f ? \"NaN\" === f && g.u() ? (f = Math.min((g.width - h) / w.width, (g.height - T) / w.height), f > v ? (f = v, e = w.width, w = w.height) : (e = g.width, w = g.height)) : (e = w.width * f, w = w.height * f) : (f = v, e = w.width, w = w.height);\n    null !== l ? (e += h, w += T) : l = new pc(0);\n    null !== g && (v = g.width, g = g.height, isNaN(v) && (v = 2E3), isNaN(g) && (g = 2E3), isFinite(v) && (e = Math.min(e, v)), isFinite(g) && (w = Math.min(w, g)));\n    n.width = Math.ceil(e);\n    n.height = Math.ceil(w);\n    if (\"SVG\" === c) {\n      if (null === d) return null;\n      d.resize(n.width, n.height, n.width, n.height);\n      d.ownerDocument = p;\n      d.Bq = r;\n      yj(a, d.context, l, new M(Math.ceil(e), Math.ceil(w)), f, y, k, m, q, b);\n      return d.context;\n    }\n    a.kl = !1;\n    yj(a, u, l, new M(Math.ceil(e), Math.ceil(w)), f, y, k, m, q, b);\n    a.kl = !0;\n    return n.context;\n  }\n  ma.Object.defineProperties(Q.prototype, {\n    div: {\n      get: function () {\n        return this.Ea;\n      },\n      set: function (a) {\n        if (this.Ea !== a) {\n          Qa = [];\n          var b = this.Ea;\n          null !== b ? (b.B = void 0, b.goDiagram = void 0, b.innerHTML = \"\", null !== this.ta && (b = this.ta.Ga, this.removeEventListener(b, \"touchstart\", this.Nw, !1), this.removeEventListener(b, \"touchmove\", this.Mw, !1), this.removeEventListener(b, \"touchend\", this.Lw, !1), this.ta.hy()), this.Sl && (this.Sl.disconnect(), this.Sl = null), b = this.toolManager, null !== b && (b.mouseDownTools.each(function (a) {\n            a.cancelWaitAfter();\n          }), b.mouseMoveTools.each(function (a) {\n            a.cancelWaitAfter();\n          }), b.mouseUpTools.each(function (a) {\n            a.cancelWaitAfter();\n          })), b.cancelWaitAfter(), this.currentTool.doCancel(), this.Gb = this.ta = null, this.removeEventListener(x, \"resize\", this.Uw, !1), this.removeEventListener(x, \"mousemove\", this.Dk, !0), this.removeEventListener(x, \"mousedown\", this.Ck, !0), this.removeEventListener(x, \"mouseup\", this.Fk, !0), this.removeEventListener(x, \"wheel\", this.Gk, !0), this.removeEventListener(x, \"mouseout\", this.Ek, !0), De === this && (De = null)) : this.me = !1;\n          this.Ea = null;\n          if (null !== a) {\n            if (b = a.B) b.div = null;\n            Hi(this, a);\n            this.Je();\n          }\n        }\n      }\n    },\n    Xx: {\n      get: function () {\n        return this.Zo;\n      }\n    },\n    oj: {\n      get: function () {\n        return this.me;\n      }\n    },\n    draggedLink: {\n      get: function () {\n        return this.Ur;\n      },\n      set: function (a) {\n        this.Ur !== a && (this.Ur = a, null !== a && (this.Hs = a.fromPort, this.Is = a.toPort));\n      }\n    },\n    Hy: {\n      get: function () {\n        return this.Hs;\n      },\n      set: function (a) {\n        this.Hs = a;\n      }\n    },\n    Iy: {\n      get: function () {\n        return this.Is;\n      },\n      set: function (a) {\n        this.Is = a;\n      }\n    },\n    animationManager: {\n      get: function () {\n        return this.Rc;\n      }\n    },\n    undoManager: {\n      get: function () {\n        return this.ac.undoManager;\n      }\n    },\n    skipsUndoManager: {\n      get: function () {\n        return this.ug;\n      },\n      set: function (a) {\n        this.ug = a;\n        this.ac.skipsUndoManager = a;\n      }\n    },\n    delaysLayout: {\n      get: function () {\n        return this.Pr;\n      },\n      set: function (a) {\n        this.Pr = a;\n      }\n    },\n    opacity: {\n      get: function () {\n        return this.tb;\n      },\n      set: function (a) {\n        var b = this.tb;\n        b !== a && ((0 > a || 1 < a) && va(a, \"0 <= value <= 1\", Q, \"opacity\"), this.tb = a, this.g(\"opacity\", b, a), this.M());\n      }\n    },\n    validCycle: {\n      get: function () {\n        return this.tt;\n      },\n      set: function (a) {\n        var b = this.tt;\n        b !== a && (this.tt = a, this.g(\"validCycle\", b, a));\n      }\n    },\n    layers: {\n      get: function () {\n        return this.La.iterator;\n      }\n    },\n    isModelReadOnly: {\n      get: function () {\n        var a = this.ac;\n        return null === a ? !1 : a.isReadOnly;\n      },\n      set: function (a) {\n        var b = this.ac;\n        null !== b && (b.isReadOnly = a);\n      }\n    },\n    isReadOnly: {\n      get: function () {\n        return this.$f;\n      },\n      set: function (a) {\n        var b = this.$f;\n        b !== a && (this.$f = a, this.g(\"isReadOnly\", b, a));\n      }\n    },\n    isEnabled: {\n      get: function () {\n        return this.gd;\n      },\n      set: function (a) {\n        var b = this.gd;\n        b !== a && (this.gd = a, this.g(\"isEnabled\", b, a));\n      }\n    },\n    allowClipboard: {\n      get: function () {\n        return this.qr;\n      },\n      set: function (a) {\n        var b = this.qr;\n        b !== a && (this.qr = a, this.g(\"allowClipboard\", b, a));\n      }\n    },\n    allowCopy: {\n      get: function () {\n        return this.$h;\n      },\n      set: function (a) {\n        var b = this.$h;\n        b !== a && (this.$h = a, this.g(\"allowCopy\", b, a));\n      }\n    },\n    allowDelete: {\n      get: function () {\n        return this.ai;\n      },\n      set: function (a) {\n        var b = this.ai;\n        b !== a && (this.ai = a, this.g(\"allowDelete\", b, a));\n      }\n    },\n    allowDragOut: {\n      get: function () {\n        return this.rr;\n      },\n      set: function (a) {\n        var b = this.rr;\n        b !== a && (this.rr = a, this.g(\"allowDragOut\", b, a));\n      }\n    },\n    allowDrop: {\n      get: function () {\n        return this.sr;\n      },\n      set: function (a) {\n        var b = this.sr;\n        b !== a && (this.sr = a, this.g(\"allowDrop\", b, a));\n      }\n    },\n    allowTextEdit: {\n      get: function () {\n        return this.ji;\n      },\n      set: function (a) {\n        var b = this.ji;\n        b !== a && (this.ji = a, this.g(\"allowTextEdit\", b, a));\n      }\n    },\n    allowGroup: {\n      get: function () {\n        return this.bi;\n      },\n      set: function (a) {\n        var b = this.bi;\n        b !== a && (this.bi = a, this.g(\"allowGroup\", b, a));\n      }\n    },\n    allowUngroup: {\n      get: function () {\n        return this.ki;\n      },\n      set: function (a) {\n        var b = this.ki;\n        b !== a && (this.ki = a, this.g(\"allowUngroup\", b, a));\n      }\n    },\n    allowInsert: {\n      get: function () {\n        return this.ur;\n      },\n      set: function (a) {\n        var b = this.ur;\n        b !== a && (this.ur = a, this.g(\"allowInsert\", b, a));\n      }\n    },\n    allowLink: {\n      get: function () {\n        return this.ci;\n      },\n      set: function (a) {\n        var b = this.ci;\n        b !== a && (this.ci = a, this.g(\"allowLink\", b, a));\n      }\n    },\n    allowRelink: {\n      get: function () {\n        return this.ei;\n      },\n      set: function (a) {\n        var b = this.ei;\n        b !== a && (this.ei = a, this.g(\"allowRelink\", b, a));\n      }\n    },\n    allowMove: {\n      get: function () {\n        return this.di;\n      },\n      set: function (a) {\n        var b = this.di;\n        b !== a && (this.di = a, this.g(\"allowMove\", b, a));\n      }\n    },\n    allowReshape: {\n      get: function () {\n        return this.fi;\n      },\n      set: function (a) {\n        var b = this.fi;\n        b !== a && (this.fi = a, this.g(\"allowReshape\", b, a));\n      }\n    },\n    allowResize: {\n      get: function () {\n        return this.gi;\n      },\n      set: function (a) {\n        var b = this.gi;\n        b !== a && (this.gi = a, this.g(\"allowResize\", b, a));\n      }\n    },\n    allowRotate: {\n      get: function () {\n        return this.hi;\n      },\n      set: function (a) {\n        var b = this.hi;\n        b !== a && (this.hi = a, this.g(\"allowRotate\", b, a));\n      }\n    },\n    allowSelect: {\n      get: function () {\n        return this.ii;\n      },\n      set: function (a) {\n        var b = this.ii;\n        b !== a && (this.ii = a, this.g(\"allowSelect\", b, a));\n      }\n    },\n    allowUndo: {\n      get: function () {\n        return this.vr;\n      },\n      set: function (a) {\n        var b = this.vr;\n        b !== a && (this.vr = a, this.g(\"allowUndo\", b, a));\n      }\n    },\n    allowZoom: {\n      get: function () {\n        return this.xr;\n      },\n      set: function (a) {\n        var b = this.xr;\n        b !== a && (this.xr = a, this.g(\"allowZoom\", b, a));\n      }\n    },\n    hasVerticalScrollbar: {\n      get: function () {\n        return this.ql;\n      },\n      set: function (a) {\n        var b = this.ql;\n        b !== a && (this.ql = a, Zi(this), this.M(), this.g(\"hasVerticalScrollbar\", b, a), Wi(this, !1));\n      }\n    },\n    hasHorizontalScrollbar: {\n      get: function () {\n        return this.pl;\n      },\n      set: function (a) {\n        var b = this.pl;\n        b !== a && (this.pl = a, Zi(this), this.M(), this.g(\"hasHorizontalScrollbar\", b, a), Wi(this, !1));\n      }\n    },\n    allowHorizontalScroll: {\n      get: function () {\n        return this.tr;\n      },\n      set: function (a) {\n        var b = this.tr;\n        b !== a && (this.tr = a, this.g(\"allowHorizontalScroll\", b, a), Wi(this, !1));\n      }\n    },\n    allowVerticalScroll: {\n      get: function () {\n        return this.wr;\n      },\n      set: function (a) {\n        var b = this.wr;\n        b !== a && (this.wr = a, this.g(\"allowVerticalScroll\", b, a), Wi(this, !1));\n      }\n    },\n    scrollHorizontalLineChange: {\n      get: function () {\n        return this.Ys;\n      },\n      set: function (a) {\n        var b = this.Ys;\n        b !== a && (0 > a && va(a, \">= 0\", Q, \"scrollHorizontalLineChange\"), this.Ys = a, this.g(\"scrollHorizontalLineChange\", b, a));\n      }\n    },\n    scrollVerticalLineChange: {\n      get: function () {\n        return this.bt;\n      },\n      set: function (a) {\n        var b = this.bt;\n        b !== a && (0 > a && va(a, \">= 0\", Q, \"scrollVerticalLineChange\"), this.bt = a, this.g(\"scrollVerticalLineChange\", b, a));\n      }\n    },\n    lastInput: {\n      get: function () {\n        return this.gh;\n      },\n      set: function (a) {\n        this.gh = a;\n      }\n    },\n    firstInput: {\n      get: function () {\n        return this.Vf;\n      },\n      set: function (a) {\n        this.Vf = a;\n      }\n    },\n    currentCursor: {\n      get: function () {\n        return this.Jr;\n      },\n      set: function (a) {\n        \"\" === a && (a = this.On);\n        if (this.Jr !== a) {\n          var b = this.ta,\n            c = this.Ea;\n          if (null !== b) {\n            this.Jr = a;\n            var d = b.style.cursor;\n            b.style.cursor = a;\n            c.style.cursor = a;\n            b.style.cursor === d && (b.style.cursor = \"-webkit-\" + a, c.style.cursor = \"-webkit-\" + a, b.style.cursor === d && (b.style.cursor = \"-moz-\" + a, c.style.cursor = \"-moz-\" + a, b.style.cursor === d && (b.style.cursor = a, c.style.cursor = a)));\n          }\n        }\n      }\n    },\n    defaultCursor: {\n      get: function () {\n        return this.On;\n      },\n      set: function (a) {\n        \"\" === a && (a = \"auto\");\n        var b = this.On;\n        b !== a && (this.On = a, this.g(\"defaultCursor\", b, a));\n      }\n    },\n    click: {\n      get: function () {\n        return this.Of;\n      },\n      set: function (a) {\n        var b = this.Of;\n        b !== a && (this.Of = a, this.g(\"click\", b, a));\n      }\n    },\n    doubleClick: {\n      get: function () {\n        return this.Tf;\n      },\n      set: function (a) {\n        var b = this.Tf;\n        b !== a && (this.Tf = a, this.g(\"doubleClick\", b, a));\n      }\n    },\n    contextClick: {\n      get: function () {\n        return this.Pf;\n      },\n      set: function (a) {\n        var b = this.Pf;\n        b !== a && (this.Pf = a, this.g(\"contextClick\", b, a));\n      }\n    },\n    mouseOver: {\n      get: function () {\n        return this.lg;\n      },\n      set: function (a) {\n        var b = this.lg;\n        b !== a && (this.lg = a, this.g(\"mouseOver\", b, a));\n      }\n    },\n    mouseHover: {\n      get: function () {\n        return this.jg;\n      },\n      set: function (a) {\n        var b = this.jg;\n        b !== a && (this.jg = a, this.g(\"mouseHover\", b, a));\n      }\n    },\n    mouseHold: {\n      get: function () {\n        return this.ig;\n      },\n      set: function (a) {\n        var b = this.ig;\n        b !== a && (this.ig = a, this.g(\"mouseHold\", b, a));\n      }\n    },\n    mouseDragOver: {\n      get: function () {\n        return this.Cs;\n      },\n      set: function (a) {\n        var b = this.Cs;\n        b !== a && (this.Cs = a, this.g(\"mouseDragOver\", b, a));\n      }\n    },\n    mouseDrop: {\n      get: function () {\n        return this.gg;\n      },\n      set: function (a) {\n        var b = this.gg;\n        b !== a && (this.gg = a, this.g(\"mouseDrop\", b, a));\n      }\n    },\n    handlesDragDropForTopLevelParts: {\n      get: function () {\n        return this.es;\n      },\n      set: function (a) {\n        var b = this.es;\n        b !== a && (this.es = a, this.g(\"handlesDragDropForTopLevelParts\", b, a));\n      }\n    },\n    mouseEnter: {\n      get: function () {\n        return this.hg;\n      },\n      set: function (a) {\n        var b = this.hg;\n        b !== a && (this.hg = a, this.g(\"mouseEnter\", b, a));\n      }\n    },\n    mouseLeave: {\n      get: function () {\n        return this.kg;\n      },\n      set: function (a) {\n        var b = this.kg;\n        b !== a && (this.kg = a, this.g(\"mouseLeave\", b, a));\n      }\n    },\n    toolTip: {\n      get: function () {\n        return this.wg;\n      },\n      set: function (a) {\n        var b = this.wg;\n        b !== a && (this.wg = a, this.g(\"toolTip\", b, a));\n      }\n    },\n    contextMenu: {\n      get: function () {\n        return this.Qf;\n      },\n      set: function (a) {\n        var b = this.Qf;\n        b !== a && (this.Qf = a, this.g(\"contextMenu\", b, a));\n      }\n    },\n    commandHandler: {\n      get: function () {\n        return this.Dr;\n      },\n      set: function (a) {\n        this.Dr !== a && (this.Dr = a, a.ae(this));\n      }\n    },\n    toolManager: {\n      get: function () {\n        return this.pt;\n      },\n      set: function (a) {\n        this.pt !== a && (this.pt = a, a.diagram = this);\n      }\n    },\n    defaultTool: {\n      get: function () {\n        return this.Or;\n      },\n      set: function (a) {\n        var b = this.Or;\n        b !== a && (this.Or = a, a.diagram = this, this.currentTool === b && (this.currentTool = a));\n      }\n    },\n    currentTool: {\n      get: function () {\n        return this.Lr;\n      },\n      set: function (a) {\n        var b = this.Lr;\n        null !== b && (b.isActive && b.doDeactivate(), b.cancelWaitAfter(), b.doStop());\n        null === a && (a = this.defaultTool);\n        null !== a && (this.Lr = a, a.diagram = this, a.doStart());\n      }\n    },\n    selection: {\n      get: function () {\n        return this.qv;\n      }\n    },\n    maxSelectionCount: {\n      get: function () {\n        return this.ys;\n      },\n      set: function (a) {\n        var b = this.ys;\n        if (b !== a) if (0 <= a && !isNaN(a)) {\n          if (this.ys = a, this.g(\"maxSelectionCount\", b, a), !this.undoManager.isUndoingRedoing && (a = this.selection.count - a, 0 < a)) {\n            this.R(\"ChangingSelection\", this.selection);\n            b = this.selection.ma();\n            for (var c = 0; c < a; c++) b[c].isSelected = !1;\n            this.R(\"ChangedSelection\", this.selection);\n          }\n        } else va(a, \">= 0\", Q, \"maxSelectionCount\");\n      }\n    },\n    nodeSelectionAdornmentTemplate: {\n      get: function () {\n        return this.gp;\n      },\n      set: function (a) {\n        var b = this.gp;\n        b !== a && (this.gp = a, this.g(\"nodeSelectionAdornmentTemplate\", b, a));\n      }\n    },\n    groupSelectionAdornmentTemplate: {\n      get: function () {\n        return this.oo;\n      },\n      set: function (a) {\n        var b = this.oo;\n        b !== a && (this.oo = a, this.g(\"groupSelectionAdornmentTemplate\", b, a));\n      }\n    },\n    linkSelectionAdornmentTemplate: {\n      get: function () {\n        return this.Ho;\n      },\n      set: function (a) {\n        var b = this.Ho;\n        b !== a && (this.Ho = a, this.g(\"linkSelectionAdornmentTemplate\", b, a));\n      }\n    },\n    highlighteds: {\n      get: function () {\n        return this.Qu;\n      }\n    },\n    isModified: {\n      get: function () {\n        var a = this.undoManager;\n        return a.isEnabled ? null !== a.currentTransaction ? !0 : this.so && this.Pd !== a.historyIndex : this.so;\n      },\n      set: function (a) {\n        if (this.so !== a) {\n          this.so = a;\n          var b = this.undoManager;\n          !a && b.isEnabled && (this.Pd = b.historyIndex);\n          a || Wj(this);\n        }\n      }\n    },\n    model: {\n      get: function () {\n        return this.ac;\n      },\n      set: function (a) {\n        var b = this.ac;\n        if (b !== a) {\n          this.currentTool.doCancel();\n          null !== b && b.undoManager !== a.undoManager && b.undoManager.isInTransaction && B(\"Do not replace a Diagram.model while a transaction is in progress.\");\n          this.animationManager.Nc(!0);\n          var c = Ki(this, !0);\n          this.me = !1;\n          this.Hj = !0;\n          this.Pd = -2;\n          this.Ae = !1;\n          var d = this.jc;\n          this.jc = !0;\n          Ch(this.animationManager, \"Model\");\n          null !== b && (null !== this.se && this.se.each(function (a) {\n            b.Kk(a);\n          }), b.Kk(this.Qc));\n          this.ac = a;\n          this.partManager = Xj(this.ac.type);\n          for (var e = 0; e < c.length; e++) this.add(c[e]);\n          a.Hh(this.Bc);\n          this.partManager.addAllModeledParts();\n          a.Kk(this.Bc);\n          a.Hh(this.Qc);\n          null !== this.se && this.se.each(function (b) {\n            a.Hh(b);\n          });\n          this.jc = d;\n          this.Rb || this.M();\n          null !== b && a.undoManager.copyProperties(b.undoManager);\n        }\n      }\n    },\n    Z: {\n      get: function () {\n        return this.$u;\n      },\n      set: function (a) {\n        this.$u = a;\n      }\n    },\n    Xt: {\n      get: function () {\n        return this.yx;\n      }\n    },\n    skipsModelSourceBindings: {\n      get: function () {\n        return this.rv;\n      },\n      set: function (a) {\n        this.rv = a;\n      }\n    },\n    mu: {\n      get: function () {\n        return this.gt;\n      },\n      set: function (a) {\n        this.gt = a;\n      }\n    },\n    nodeTemplate: {\n      get: function () {\n        return this.cf.H(\"\");\n      },\n      set: function (a) {\n        var b = this.cf.H(\"\");\n        b !== a && (this.cf.add(\"\", a), this.g(\"nodeTemplate\", b, a), this.undoManager.isUndoingRedoing || this.Ed());\n      }\n    },\n    nodeTemplateMap: {\n      get: function () {\n        return this.cf;\n      },\n      set: function (a) {\n        var b = this.cf;\n        b !== a && (this.cf = a, this.g(\"nodeTemplateMap\", b, a), this.undoManager.isUndoingRedoing || this.Ed());\n      }\n    },\n    groupTemplate: {\n      get: function () {\n        return this.eh.H(\"\");\n      },\n      set: function (a) {\n        var b = this.eh.H(\"\");\n        b !== a && (this.eh.add(\"\", a), this.g(\"groupTemplate\", b, a), this.undoManager.isUndoingRedoing || this.Ed());\n      }\n    },\n    groupTemplateMap: {\n      get: function () {\n        return this.eh;\n      },\n      set: function (a) {\n        var b = this.eh;\n        b !== a && (this.eh = a, this.g(\"groupTemplateMap\", b, a), this.undoManager.isUndoingRedoing || this.Ed());\n      }\n    },\n    linkTemplate: {\n      get: function () {\n        return this.bg.H(\"\");\n      },\n      set: function (a) {\n        var b = this.bg.H(\"\");\n        b !== a && (this.bg.add(\"\", a), this.g(\"linkTemplate\", b, a), this.undoManager.isUndoingRedoing || this.Ed());\n      }\n    },\n    linkTemplateMap: {\n      get: function () {\n        return this.bg;\n      },\n      set: function (a) {\n        var b = this.bg;\n        b !== a && (this.bg = a, this.g(\"linkTemplateMap\", b, a), this.undoManager.isUndoingRedoing || this.Ed());\n      }\n    },\n    isMouseCaptured: {\n      get: function () {\n        return this.Wu;\n      },\n      set: function (a) {\n        var b = this.ta;\n        null !== b && (b = b.Ga, b instanceof SVGElement || (a ? (this.lastInput.bubbles = !1, this.ln ? (this.removeEventListener(b, \"pointermove\", this.Fm, !1), this.removeEventListener(b, \"pointerdown\", this.Em, !1), this.removeEventListener(b, \"pointerup\", this.Hm, !1), this.removeEventListener(b, \"pointerout\", this.Gm, !1), this.addEventListener(x, \"pointermove\", this.Fm, !0), this.addEventListener(x, \"pointerdown\", this.Em, !0), this.addEventListener(x, \"pointerup\", this.Hm, !0), this.addEventListener(x, \"pointerout\", this.Gm, !0)) : (this.removeEventListener(b, \"mousemove\", this.Dk, !1), this.removeEventListener(b, \"mousedown\", this.Ck, !1), this.removeEventListener(b, \"mouseup\", this.Fk, !1), this.removeEventListener(b, \"mouseout\", this.Ek, !1), this.addEventListener(x, \"mousemove\", this.Dk, !0), this.addEventListener(x, \"mousedown\", this.Ck, !0), this.addEventListener(x, \"mouseup\", this.Fk, !0), this.addEventListener(x, \"mouseout\", this.Ek, !0)), this.removeEventListener(b, \"wheel\", this.Gk, !1), this.addEventListener(x, \"wheel\", this.Gk, !0), this.addEventListener(x, \"selectstart\", this.preventDefault, !1)) : (this.ln ? (this.removeEventListener(x, \"pointermove\", this.Fm, !0), this.removeEventListener(x, \"pointerdown\", this.Em, !0), this.removeEventListener(x, \"pointerup\", this.Hm, !0), this.removeEventListener(x, \"pointerout\", this.Gm, !0), this.addEventListener(b, \"pointermove\", this.Fm, !1), this.addEventListener(b, \"pointerdown\", this.Em, !1), this.addEventListener(b, \"pointerup\", this.Hm, !1), this.addEventListener(b, \"pointerout\", this.Gm, !1)) : (this.removeEventListener(x, \"mousemove\", this.Dk, !0), this.removeEventListener(x, \"mousedown\", this.Ck, !0), this.removeEventListener(x, \"mouseup\", this.Fk, !0), this.removeEventListener(x, \"mouseout\", this.Ek, !0), this.addEventListener(b, \"mousemove\", this.Dk, !1), this.addEventListener(b, \"mousedown\", this.Ck, !1), this.addEventListener(b, \"mouseup\", this.Fk, !1), this.addEventListener(b, \"mouseout\", this.Ek, !1)), this.removeEventListener(x, \"wheel\", this.Gk, !0), this.removeEventListener(x, \"selectstart\", this.preventDefault, !1), this.addEventListener(b, \"wheel\", this.Gk, !1)), this.Wu = a));\n      }\n    },\n    position: {\n      get: function () {\n        return this.la;\n      },\n      set: function (a) {\n        var b = J.alloc().assign(this.la);\n        if (!b.w(a)) {\n          var c = this.viewportBounds.copy();\n          this.la.assign(a);\n          Sh(this.animationManager, b, this.la);\n          this.Rb || null === this.ta && !this.mm.u() || (this.Rb = !0, a = this.scale, Yi(this, this.Qn, this.xa / a, this.wa / a, this.Aj, !1), this.Rb = !1);\n          this.Rb || this.Vq(c, this.viewportBounds, this.ya, !1);\n        }\n        J.free(b);\n      }\n    },\n    initialPosition: {\n      get: function () {\n        return this.gs;\n      },\n      set: function (a) {\n        this.gs.w(a) || (this.gs = a.G());\n      }\n    },\n    initialScale: {\n      get: function () {\n        return this.hs;\n      },\n      set: function (a) {\n        this.hs !== a && (this.hs = a);\n      }\n    },\n    grid: {\n      get: function () {\n        null === this.Ib && Pi(this);\n        return this.Ib;\n      },\n      set: function (a) {\n        var b = this.Ib;\n        if (b !== a) {\n          null === b && (Pi(this), b = this.Ib);\n          a.type !== X.Grid && B(\"Diagram.grid must be a Panel of type Panel.Grid\");\n          var c = b.panel;\n          null !== c && c.remove(b);\n          this.Ib = a;\n          a.name = \"GRID\";\n          null !== c && c.add(a);\n          oj(this);\n          this.M();\n          this.g(\"grid\", b, a);\n        }\n      }\n    },\n    viewportBounds: {\n      get: function () {\n        var a = this.Px,\n          b = this.la,\n          c = this.ya;\n        if (null === this.ta) return this.mm.u() && a.h(b.x, b.y, this.xa / c, this.wa / c), a;\n        a.h(b.x, b.y, Math.max(this.xa, 0) / c, Math.max(this.wa, 0) / c);\n        return a;\n      }\n    },\n    viewSize: {\n      get: function () {\n        return this.mm;\n      },\n      set: function (a) {\n        var b = this.viewSize;\n        b.w(a) || (this.mm = a = a.G(), this.xa = a.width, this.wa = a.height, this.Oa(), this.g(\"viewSize\", b, a));\n      }\n    },\n    fixedBounds: {\n      get: function () {\n        return this.bs;\n      },\n      set: function (a) {\n        var b = this.bs;\n        b.w(a) || (-Infinity !== a.width && Infinity !== a.height && -Infinity !== a.height || B(\"fixedBounds width/height must not be Infinity\"), this.bs = a = a.G(), this.Oa(), this.g(\"fixedBounds\", b, a));\n      }\n    },\n    scrollMargin: {\n      get: function () {\n        return this.Si;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.Si;\n        b.w(a) || (this.Si = a = a.G(), this.g(\"scrollMargin\", b, a), this.Zq());\n      }\n    },\n    scrollMode: {\n      get: function () {\n        return this.Ti;\n      },\n      set: function (a) {\n        var b = this.Ti;\n        b !== a && (this.Ti = a, a === Zh && Wi(this, !1), this.g(\"scrollMode\", b, a), this.M());\n      }\n    },\n    scrollsPageOnFocus: {\n      get: function () {\n        return this.ct;\n      },\n      set: function (a) {\n        var b = this.ct;\n        b !== a && (this.ct = a, this.g(\"scrollsPageOnFocus\", b, a));\n      }\n    },\n    positionComputation: {\n      get: function () {\n        return this.Qs;\n      },\n      set: function (a) {\n        var b = this.Qs;\n        b !== a && (this.Qs = a, Wi(this, !1), this.g(\"positionComputation\", b, a));\n      }\n    },\n    scaleComputation: {\n      get: function () {\n        return this.Ws;\n      },\n      set: function (a) {\n        var b = this.Ws;\n        b !== a && (this.Ws = a, Uj(this, this.scale, this.scale), this.g(\"scaleComputation\", b, a));\n      }\n    },\n    documentBounds: {\n      get: function () {\n        return this.Qn;\n      }\n    },\n    isVirtualized: {\n      get: function () {\n        return this.ts;\n      },\n      set: function (a) {\n        var b = this.ts;\n        b !== a && (this.ts = a, this.g(\"isVirtualized\", b, a));\n      }\n    },\n    scale: {\n      get: function () {\n        return this.ya;\n      },\n      set: function (a) {\n        var b = this.ya;\n        b !== a && Uj(this, b, a);\n      }\n    },\n    defaultScale: {\n      get: function () {\n        return this.Pn;\n      },\n      set: function (a) {\n        this.Pn = a;\n      }\n    },\n    autoScale: {\n      get: function () {\n        return this.Og;\n      },\n      set: function (a) {\n        var b = this.Og;\n        b !== a && (this.Og = a, this.g(\"autoScale\", b, a), a !== Ih && Wi(this, !1));\n      }\n    },\n    initialAutoScale: {\n      get: function () {\n        return this.Yf;\n      },\n      set: function (a) {\n        var b = this.Yf;\n        b !== a && (this.Yf = a, this.g(\"initialAutoScale\", b, a));\n      }\n    },\n    initialViewportSpot: {\n      get: function () {\n        return this.js;\n      },\n      set: function (a) {\n        var b = this.js;\n        b !== a && (a.ib() || B(\"initialViewportSpot must be a specific Spot: \" + a), this.js = a, this.g(\"initialViewportSpot\", b, a));\n      }\n    },\n    initialDocumentSpot: {\n      get: function () {\n        return this.fs;\n      },\n      set: function (a) {\n        var b = this.fs;\n        b !== a && (a.ib() || B(\"initialViewportSpot must be a specific Spot: \" + a), this.fs = a, this.g(\"initialDocumentSpot\", b, a));\n      }\n    },\n    minScale: {\n      get: function () {\n        return this.zs;\n      },\n      set: function (a) {\n        var b = this.zs;\n        b !== a && (0 < a ? (this.zs = a, this.g(\"minScale\", b, a), a > this.scale && (this.scale = a)) : va(a, \"> 0\", Q, \"minScale\"));\n      }\n    },\n    maxScale: {\n      get: function () {\n        return this.xs;\n      },\n      set: function (a) {\n        var b = this.xs;\n        b !== a && (0 < a ? (this.xs = a, this.g(\"maxScale\", b, a), a < this.scale && (this.scale = a)) : va(a, \"> 0\", Q, \"maxScale\"));\n      }\n    },\n    zoomPoint: {\n      get: function () {\n        return this.xt;\n      },\n      set: function (a) {\n        this.xt.w(a) || (this.xt = a = a.G());\n      }\n    },\n    contentAlignment: {\n      get: function () {\n        return this.Aj;\n      },\n      set: function (a) {\n        var b = this.Aj;\n        b.w(a) || (this.Aj = a = a.G(), this.g(\"contentAlignment\", b, a), Wi(this, !1));\n      }\n    },\n    initialContentAlignment: {\n      get: function () {\n        return this.qo;\n      },\n      set: function (a) {\n        var b = this.qo;\n        b.w(a) || (this.qo = a = a.G(), this.g(\"initialContentAlignment\", b, a));\n      }\n    },\n    padding: {\n      get: function () {\n        return this.gb;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.gb;\n        b.w(a) || (this.gb = a = a.G(), this.Oa(), this.g(\"padding\", b, a));\n      }\n    },\n    partManager: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        var b = this.Ka;\n        b !== a && (null !== a.diagram && B(\"Cannot share PartManagers between Diagrams: \" + a.toString()), null !== b && b.ae(null), this.Ka = a, a.ae(this));\n      }\n    },\n    nodes: {\n      get: function () {\n        return this.partManager.nodes.iterator;\n      }\n    },\n    links: {\n      get: function () {\n        return this.partManager.links.iterator;\n      }\n    },\n    parts: {\n      get: function () {\n        return this.partManager.parts.iterator;\n      }\n    },\n    layout: {\n      get: function () {\n        return this.kc;\n      },\n      set: function (a) {\n        var b = this.kc;\n        b !== a && (this.kc = a, a.diagram = this, a.group = null, this.Ng = !0, this.g(\"layout\", b, a), this.Db());\n      }\n    },\n    isTreePathToChildren: {\n      get: function () {\n        return this.ss;\n      },\n      set: function (a) {\n        var b = this.ss;\n        if (b !== a && (this.ss = a, this.g(\"isTreePathToChildren\", b, a), !this.undoManager.isUndoingRedoing)) for (a = this.nodes; a.next();) Ek(a.value);\n      }\n    },\n    treeCollapsePolicy: {\n      get: function () {\n        return this.rt;\n      },\n      set: function (a) {\n        var b = this.rt;\n        b !== a && (a !== ri && a !== Fk && a !== Gk && B(\"Unknown Diagram.treeCollapsePolicy: \" + a), this.rt = a, this.g(\"treeCollapsePolicy\", b, a));\n      }\n    },\n    He: {\n      get: function () {\n        return this.Tu;\n      },\n      set: function (a) {\n        this.Tu = a;\n      }\n    },\n    autoScrollInterval: {\n      get: function () {\n        return this.pn;\n      },\n      set: function (a) {\n        var b = this.pn;\n        b !== a && (this.pn = a, this.g(\"autoScrollInterval\", b, a));\n      }\n    },\n    autoScrollRegion: {\n      get: function () {\n        return this.rn;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.rn;\n        b.w(a) || (this.rn = a = a.G(), this.Oa(), this.g(\"autoScrollRegion\", b, a));\n      }\n    }\n  });\n  ma.Object.defineProperties(Q, {\n    licenseKey: {\n      get: function () {\n        return Hk.Xb();\n      },\n      set: function (a) {\n        Hk.add(a);\n      }\n    },\n    version: {\n      get: function () {\n        return Ik;\n      }\n    }\n  });\n  Q.prototype.makeImageData = Q.prototype.Ey;\n  Q.prototype.makeImage = Q.prototype.CA;\n  Q.prototype.addRenderer = Q.prototype.mz;\n  Q.prototype.makeSVG = Q.prototype.hw;\n  Q.prototype.makeSvg = Q.prototype.Zt;\n  Q.prototype.stopAutoScroll = Q.prototype.If;\n  Q.prototype.doAutoScroll = Q.prototype.Ft;\n  Q.prototype.isUnoccupied = Q.prototype.zk;\n  Q.prototype.raiseDiagramEvent = Q.prototype.R;\n  Q.prototype.removeDiagramListener = Q.prototype.Km;\n  Q.prototype.addDiagramListener = Q.prototype.hk;\n  Q.prototype.findTreeRoots = Q.prototype.eA;\n  Q.prototype.layoutDiagram = Q.prototype.AA;\n  Q.prototype.findTopLevelGroups = Q.prototype.Yz;\n  Q.prototype.findTopLevelNodesAndLinks = Q.prototype.Zz;\n  Q.prototype.ensureBounds = Q.prototype.Ta;\n  Q.prototype.findLinksByExample = Q.prototype.It;\n  Q.prototype.findNodesByExample = Q.prototype.Jt;\n  Q.prototype.findLinkForData = Q.prototype.xc;\n  Q.prototype.findNodeForData = Q.prototype.gj;\n  Q.prototype.findPartForData = Q.prototype.yc;\n  Q.prototype.findLinkForKey = Q.prototype.findLinkForKey;\n  Q.prototype.findNodeForKey = Q.prototype.Cb;\n  Q.prototype.findPartForKey = Q.prototype.findPartForKey;\n  Q.prototype.rebuildParts = Q.prototype.Ed;\n  Q.prototype.transformViewToDoc = Q.prototype.nu;\n  Q.prototype.transformRectDocToView = Q.prototype.bB;\n  Q.prototype.transformDocToView = Q.prototype.ir;\n  Q.prototype.centerRect = Q.prototype.At;\n  Q.prototype.scrollToRect = Q.prototype.zw;\n  Q.prototype.scroll = Q.prototype.scroll;\n  Q.prototype.highlightCollection = Q.prototype.qA;\n  Q.prototype.highlight = Q.prototype.pA;\n  Q.prototype.selectCollection = Q.prototype.TA;\n  Q.prototype.select = Q.prototype.select;\n  Q.prototype.updateAllRelationshipsFromData = Q.prototype.kr;\n  Q.prototype.updateAllTargetBindings = Q.prototype.updateAllTargetBindings;\n  Q.prototype.commit = Q.prototype.commit;\n  Q.prototype.rollbackTransaction = Q.prototype.Hf;\n  Q.prototype.commitTransaction = Q.prototype.Wa;\n  Q.prototype.startTransaction = Q.prototype.va;\n  Q.prototype.raiseChanged = Q.prototype.g;\n  Q.prototype.raiseChangedEvent = Q.prototype.ab;\n  Q.prototype.removeChangedListener = Q.prototype.Kk;\n  Q.prototype.addChangedListener = Q.prototype.Hh;\n  Q.prototype.removeModelChangedListener = Q.prototype.PA;\n  Q.prototype.addModelChangedListener = Q.prototype.Vx;\n  Q.prototype.findLayer = Q.prototype.tm;\n  Q.prototype.removeLayer = Q.prototype.NA;\n  Q.prototype.addLayerAfter = Q.prototype.jz;\n  Q.prototype.addLayerBefore = Q.prototype.Sx;\n  Q.prototype.addLayer = Q.prototype.om;\n  Q.prototype.moveParts = Q.prototype.moveParts;\n  Q.prototype.copyParts = Q.prototype.qk;\n  Q.prototype.removeParts = Q.prototype.gu;\n  Q.prototype.remove = Q.prototype.remove;\n  Q.prototype.add = Q.prototype.add;\n  Q.prototype.clearDelayedGeometries = Q.prototype.Gv;\n  Q.prototype.setProperties = Q.prototype.Ew;\n  Q.prototype.resetInputOptions = Q.prototype.vw;\n  Q.prototype.setInputOption = Q.prototype.UA;\n  Q.prototype.getInputOption = Q.prototype.xm;\n  Q.prototype.resetRenderingHints = Q.prototype.ww;\n  Q.prototype.setRenderingHint = Q.prototype.Qy;\n  Q.prototype.getRenderingHint = Q.prototype.Ge;\n  Q.prototype.maybeUpdate = Q.prototype.cd;\n  Q.prototype.requestUpdate = Q.prototype.Db;\n  Q.prototype.delayInitialization = Q.prototype.Ez;\n  Q.prototype.isUpdateRequested = Q.prototype.wA;\n  Q.prototype.redraw = Q.prototype.Je;\n  Q.prototype.invalidateDocumentBounds = Q.prototype.Oa;\n  Q.prototype.findObjectsNear = Q.prototype.Eg;\n  Q.prototype.findPartsNear = Q.prototype.Vz;\n  Q.prototype.findObjectsIn = Q.prototype.zf;\n  Q.prototype.findPartsIn = Q.prototype.py;\n  Q.prototype.findObjectsAt = Q.prototype.hj;\n  Q.prototype.findPartsAt = Q.prototype.Uz;\n  Q.prototype.findObjectAt = Q.prototype.Ub;\n  Q.prototype.findPartAt = Q.prototype.um;\n  Q.prototype.focusObject = Q.prototype.fA;\n  Q.prototype.alignDocument = Q.prototype.oz;\n  Q.prototype.zoomToRect = Q.prototype.fB;\n  Q.prototype.zoomToFit = Q.prototype.zoomToFit;\n  Q.prototype.diagramScroll = Q.prototype.ey;\n  Q.prototype.focus = Q.prototype.focus;\n  Q.prototype.reset = Q.prototype.reset;\n  Q.useDOM = function (a) {\n    Tg = a ? void 0 !== x.document : !1;\n  };\n  Q.isUsingDOM = function () {\n    return Tg;\n  };\n  var De = null,\n    si = new H(),\n    Ni = null,\n    Mi = null,\n    Tg = void 0 !== x.document,\n    Ii = null,\n    Ji = \"\",\n    Ih = new D(Q, \"None\", 0),\n    aj = new D(Q, \"Uniform\", 1),\n    bj = new D(Q, \"UniformToFill\", 2),\n    Nf = new D(Q, \"CycleAll\", 10),\n    Rf = new D(Q, \"CycleNotDirected\", 11),\n    Tf = new D(Q, \"CycleNotDirectedFast\", 12),\n    Uf = new D(Q, \"CycleNotUndirected\", 13),\n    Of = new D(Q, \"CycleDestinationTree\", 14),\n    Qf = new D(Q, \"CycleSourceTree\", 15),\n    Zh = new D(Q, \"DocumentScroll\", 1),\n    ai = new D(Q, \"InfiniteScroll\", 2),\n    ri = new D(Q, \"TreeParentCollapsed\", 21),\n    Fk = new D(Q, \"AllParentsCollapsed\", 22),\n    Gk = new D(Q, \"AnyParentsCollapsed\", 23),\n    Hk = new E(),\n    Ik = \"2.1.34\",\n    Jk = null,\n    oi = !1;\n  function pi() {\n    if (Tg) {\n      var a = x.document.createElement(\"canvas\"),\n        b = a.getContext(\"2d\"),\n        c = Ra(\"7ca11abfd022028846\");\n      b[c] = Ra(\"398c3597c01238\");\n      for (var d = [\"5da73c80a36455d5038e4972187c3cae51fd22\", pa.Dx + \"4ae6247590da4bb21c324ba3a84e385776\", rd.xF + \"fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387\", K.za], e = 1; 5 > e; e++) b[Ra(\"7ca11abfd7330390\")](Ra(d[e - 1]), 10, 15 * e);\n      b[c] = Ra(\"39f046ebb36e4b\");\n      for (c = 1; 5 > c; c++) b[Ra(\"7ca11abfd7330390\")](Ra(d[c - 1]), 10, 15 * c);\n      Jk = a;\n    }\n  }\n  Q.className = \"Diagram\";\n  Q.fromDiv = function (a) {\n    var b = a;\n    \"string\" === typeof a && (b = x.document.getElementById(a));\n    return b instanceof HTMLDivElement && b.B instanceof Q ? b.B : null;\n  };\n  Q.inherit = function (a, b) {\n    function c() {}\n    if (Object.getPrototypeOf(a).prototype) throw Error(\"Used go.Diagram.inherit defining already defined class \\n\" + a);\n    c.prototype = b.prototype;\n    a.prototype = new c();\n    a.prototype.constructor = a;\n  };\n  Q.None = Ih;\n  Q.Uniform = aj;\n  Q.UniformToFill = bj;\n  Q.CycleAll = Nf;\n  Q.CycleNotDirected = Rf;\n  Q.CycleNotDirectedFast = Tf;\n  Q.CycleNotUndirected = Uf;\n  Q.CycleDestinationTree = Of;\n  Q.CycleSourceTree = Qf;\n  Q.DocumentScroll = Zh;\n  Q.InfiniteScroll = ai;\n  Q.TreeParentCollapsed = ri;\n  Q.AllParentsCollapsed = Fk;\n  Q.AnyParentsCollapsed = Gk;\n  function zi() {\n    this.fz = null;\n    this.l = \"zz@orderNum\";\n    \"63ad05bbe23a1786468a4c741b6d2\" === this._tk ? this.Ue = this.l = !0 : this.Ue = null;\n  }\n  function xj(a, b) {\n    b.Gb.setTransform(b.Sb, 0, 0, b.Sb, 0, 0);\n    if (null === a.Ue) {\n      b = \"f\";\n      var c = x[Ra(\"76a715b2f73f148a\")][Ra(\"72ba13b5\")];\n      a.Ue = !0;\n      if (Tg) {\n        var d = Q[Ra(\"76a115b6ed251eaf4692\")];\n        if (d) for (var e = Hk.iterator; e.next();) {\n          d = e.value;\n          d = Ra(d).split(Ra(\"39e9\"));\n          if (6 > d.length) break;\n          var f = Ra(d[1]).split(\".\");\n          if (\"7da71ca0\" !== d[4]) break;\n          var g = Ra(pa[Ra(\"6cae19\")]).split(\".\");\n          if (f[0] > g[0] || f[0] === g[0] && f[1] >= g[1]) {\n            f = c[Ra(\"76ad18b4f73e\")];\n            for (g = c[Ra(\"73a612b6fb191d\")](Ra(\"35e7\")) + 2; g < f; g++) b += c[g];\n            f = b[Ra(\"73a612b6fb191d\")](Ra(d[2]));\n            0 > f && Ra(d[2]) !== Ra(\"7da71ca0ad381e90\") && (f = b[Ra(\"73a612b6fb191d\")](Ra(\"76a715b2ef3e149757\")));\n            0 > f && (f = b[Ra(\"73a612b6fb191d\")](Ra(\"76a715b2ef3e149757\")));\n            0 > f && (f = c[Ra(\"73a612b6fb191d\")](Ra(\"7baa19a6f76c1988428554\")));\n            a.Ue = !(0 <= f && f < b[Ra(\"73a612b6fb191d\")](Ra(\"35\")) || -1 === b[Ra(\"73a612b6fb191d\")](Ra(\"35\")));\n            if (!a.Ue) break;\n            f = Ra(d[2]);\n            if (\"#\" !== f[0]) break;\n            g = x.document.createElement(\"div\");\n            for (var h = d[0].replace(/[A-Za-z]/g, \"\"); 4 > h.length;) h += \"9\";\n            h = h.substr(h.length - 4);\n            d = \"\";\n            d += [\"gsh\", \"gsf\"][parseInt(h.substr(0, 1), 10) % 2];\n            d += [\"Header\", \"Background\", \"Display\", \"Feedback\"][parseInt(h.substr(0, 1), 10) % 4];\n            g[Ra(\"79a417a0f0181a8946\")] = d;\n            if (x.document[Ra(\"78a712aa\")]) {\n              x.document[Ra(\"78a712aa\")][Ra(\"7bb806b6ed32388c4a875b\")](g);\n              h = x.getComputedStyle(g).getPropertyValue(Ra(\"78a704b7e62456904c9b12701b6532a8\"));\n              x.document[Ra(\"78a712aa\")][Ra(\"68ad1bbcf533388c4a875b\")](g);\n              if (!h) break;\n              if (-1 !== h.indexOf(parseInt(f[1] + f[2], 16)) && -1 !== h.indexOf(parseInt(f[3] + f[4], 16))) {\n                a.Ue = !1;\n                break;\n              } else if (Sa || Ta || Ua || Va) for (d = \".\" + d, f = 0; f < document.styleSheets.length; f++) {\n                g = document.styleSheets[f].rules || document.styleSheets[f].cssRules;\n                for (var k in g) if (d === g[k].selectorText) {\n                  a.Ue = !1;\n                  break;\n                }\n              }\n            } else a.Ue = null, a.Ue = !1;\n          }\n        } else {\n          k = c[Ra(\"76ad18b4f73e\")];\n          for (e = c[Ra(\"73a612b6fb191d\")](Ra(\"35e7\")) + 2; e < k; e++) b += c[e];\n          c = b[Ra(\"73a612b6fb191d\")](Ra(\"7da71ca0ad381e90\"));\n          a.Ue = !(0 <= c && c < b[Ra(\"73a612b6fb191d\")](Ra(\"35\")));\n        }\n      }\n    }\n    return 0 < a.Ue && a !== a.fz ? !0 : !1;\n  }\n  function Hi(a, b) {\n    if (Tg) {\n      void 0 !== b && null !== b || B(\"Diagram setup requires an argument DIV.\");\n      null !== a.Ea && B(\"Diagram has already completed setup.\");\n      \"string\" === typeof b ? a.Ea = x.document.getElementById(b) : b instanceof HTMLDivElement ? a.Ea = b : B(\"No DIV or DIV id supplied: \" + b);\n      null === a.Ea && B(\"Invalid DIV id; could not get element with id: \" + b);\n      void 0 !== a.Ea.B && B(\"Invalid div id; div already has a Diagram associated with it.\");\n      if (!a.Sl && x.ResizeObserver) {\n        var c = ra(function () {\n          a.Db();\n        }, 250);\n        a.Sl = new x.ResizeObserver(function () {\n          c();\n        });\n        a.Sl.observe(a.Ea);\n      }\n      \"static\" === x.getComputedStyle(a.Ea, null).position && (a.Ea.style.position = \"relative\");\n      a.Ea.style[\"-webkit-tap-highlight-color\"] = \"rgba(255, 255, 255, 0)\";\n      a.Ea.style[\"-ms-touch-action\"] = \"none\";\n      a.Ea.innerHTML = \"\";\n      a.Ea.B = a;\n      a.Ea.goDiagram = a;\n      a.Ea.go = x.go;\n      var d = a.eq ? new Cj(a) : new Dk(a);\n      void 0 !== d.style && (d.style.position = \"absolute\", d.style.top = \"0px\", d.style.left = \"0px\", \"rtl\" === x.getComputedStyle(a.Ea, null).getPropertyValue(\"direction\") && (a.Al = !0), d.style.zIndex = \"2\", d.style.userSelect = \"none\", d.style.webkitUserSelect = \"none\", d.style.MozUserSelect = \"none\");\n      a.ta = d;\n      a.Gb = d.context;\n      b = a.Gb;\n      a.Sb = a.computePixelRatio();\n      a.xa = a.Ea.clientWidth || 1;\n      a.wa = a.Ea.clientHeight || 1;\n      Ej(a, a.xa, a.wa);\n      a.Vr = b.Y[Ra(\"7eba17a4ca3b1a8346\")][Ra(\"78a118b7\")](b.Y, Jk, 4, 4);\n      a.Ea.insertBefore(d.Ga, a.Ea.firstChild);\n      d = new Dk(null);\n      d.width = 1;\n      d.height = 1;\n      a.Iu = d;\n      a.qx = d.context;\n      if (Tg) {\n        d = ta(\"div\");\n        var e = ta(\"div\");\n        d.style.position = \"absolute\";\n        d.style.overflow = \"auto\";\n        d.style.width = a.xa + \"px\";\n        d.style.height = a.wa + \"px\";\n        d.style.zIndex = \"1\";\n        e.style.position = \"absolute\";\n        e.style.width = \"1px\";\n        e.style.height = \"1px\";\n        a.Ea.appendChild(d);\n        d.appendChild(e);\n        d.onscroll = Qi;\n        d.addEventListener(\"mousedown\", Si);\n        d.addEventListener(\"touchstart\", Si, {\n          passive: !0\n        });\n        d.B = a;\n        d.dz = !0;\n        d.ez = !0;\n        a.$s = d;\n        a.Lp = e;\n      }\n      a.Zq = ra(function () {\n        a.yh = null;\n        a.M();\n      }, 300);\n      a.Uw = ra(function () {\n        Jh(a);\n      }, 250);\n      a.preventDefault = function (a) {\n        a.preventDefault();\n        return !1;\n      };\n      a.Dk = function (b) {\n        if (a.isEnabled) {\n          a.Zf = !0;\n          var c = fj(a, b, !0);\n          a.doMouseMove();\n          a.currentTool.isBeyondDragSize() && (a.sd = 0);\n          lj(c, b);\n        }\n      };\n      a.Ck = function (b) {\n        if (a.isEnabled) if (a.Zf = !0, a.ne) b.preventDefault();else {\n          var c = fj(a, b, !0);\n          c.down = !0;\n          c.clickCount = b.detail;\n          if (Ta || Ua) b.timeStamp - a.Pj < a.qt && !a.currentTool.isBeyondDragSize() ? a.sd++ : a.sd = 1, a.Pj = b.timeStamp, c.clickCount = a.sd;\n          c.clone(a.firstInput);\n          a.doMouseDown();\n          1 === b.button ? b.preventDefault() : lj(c, b);\n        }\n      };\n      a.Fk = function (b) {\n        if (a.isEnabled) if (a.ne && 2 === b.button) b.preventDefault();else if (a.ne && 0 === b.button && (a.ne = !1), a.ek) b.preventDefault();else {\n          a.Zf = !0;\n          var c = fj(a, b, !0);\n          c.up = !0;\n          c.clickCount = b.detail;\n          if (Ta || Ua) c.clickCount = a.sd;\n          c.bubbles = b.bubbles;\n          c.targetDiagram = hj(b);\n          a.doMouseUp();\n          a.If();\n          lj(c, b);\n        }\n      };\n      a.Gk = function (b) {\n        if (a.isEnabled) {\n          var c = fj(a, b, !0);\n          c.bubbles = !0;\n          var d = 0,\n            e = 0;\n          c.delta = 0;\n          void 0 !== b.deltaX ? (0 !== b.deltaX && (d = 0 < b.deltaX ? 1 : -1), 0 !== b.deltaY && (e = 0 < b.deltaY ? 1 : -1), c.delta = Math.abs(b.deltaX) > Math.abs(b.deltaY) ? -d : -e) : void 0 !== b.wheelDeltaX ? (0 !== b.wheelDeltaX && (d = 0 < b.wheelDeltaX ? -1 : 1), 0 !== b.wheelDeltaY && (e = 0 < b.wheelDeltaY ? -1 : 1), c.delta = Math.abs(b.wheelDeltaX) > Math.abs(b.wheelDeltaY) ? -d : -e) : void 0 !== b.wheelDelta && 0 !== b.wheelDelta && (c.delta = 0 < b.wheelDelta ? 1 : -1);\n          a.doMouseWheel();\n          lj(c, b);\n        }\n      };\n      a.Ek = function (b) {\n        a.isEnabled && (a.Zf = !1, fj(a, b, !0), b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver());\n      };\n      a.Nw = function (b) {\n        if (a.isEnabled) {\n          a.ek = !1;\n          a.ne = !0;\n          var c = ij(a, b, b.targetTouches[0], 1 < b.touches.length),\n            d = null;\n          0 < b.targetTouches.length ? d = b.targetTouches[0] : 0 < b.changedTouches.length && (d = b.changedTouches[0]);\n          if (null !== d) {\n            var e = d.screenX;\n            d = d.screenY;\n            var f = a.Co;\n            b.timeStamp - a.Pj < a.qt && !(25 < Math.abs(f.x - e) || 25 < Math.abs(f.y - d)) ? a.sd++ : a.sd = 1;\n            c.clickCount = a.sd;\n            a.Pj = b.timeStamp;\n            a.Co.h(e, d);\n          }\n          a.doMouseDown();\n          lj(c, b);\n        }\n      };\n      a.Mw = function (b) {\n        if (a.isEnabled) {\n          var c = null;\n          0 < b.targetTouches.length ? c = b.targetTouches[0] : 0 < b.changedTouches.length && (c = b.changedTouches[0]);\n          c = kj(a, b, c, 1 < b.touches.length);\n          a.doMouseMove();\n          lj(c, b);\n        }\n      };\n      a.Lw = function (b) {\n        if (a.isEnabled) if (a.ek) b.preventDefault();else if (!(1 < b.touches.length)) {\n          var c = null,\n            d = null;\n          0 < b.targetTouches.length ? d = b.targetTouches[0] : 0 < b.changedTouches.length && (d = b.changedTouches[0]);\n          var e = jj(a, b, !1, !0, !1, !1);\n          null !== d && (c = x.document.elementFromPoint(d.clientX, d.clientY), null !== c && c.B instanceof Q && c.B !== a && gj(c.B, d, e), gj(a, d, e), e.clickCount = a.sd);\n          null === c ? e.targetDiagram = hj(b) : c.B ? e.targetDiagram = c.B : e.targetDiagram = null;\n          e.targetObject = null;\n          a.doMouseUp();\n          lj(e, b);\n          a.ne = !1;\n        }\n      };\n      a.Em = function (b) {\n        if (a.isEnabled) {\n          a.Zf = !0;\n          var c = a.Os;\n          void 0 === c[b.pointerId] && (c[b.pointerId] = b);\n          c = a.Zj;\n          var d = !1;\n          if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b;else if (null !== c[1] && c[1].pointerId === b.pointerId) c[1] = b, d = !0;else if (null === c[0]) c[0] = b;else if (null === c[1]) c[1] = b, d = !0;else {\n            b.preventDefault();\n            return;\n          }\n          if (\"touch\" === b.pointerType || \"pen\" === b.pointerType) a.ek = !1, a.ne = !0;\n          c = ij(a, b, b, d);\n          d = a.Co;\n          var e = \"touch\" === b.pointerType || \"pen\" === b.pointerType ? 25 : 10;\n          b.timeStamp - a.Pj < a.qt && !(Math.abs(d.x - b.screenX) > e || Math.abs(d.y - b.screenY) > e) ? a.sd++ : a.sd = 1;\n          c.clickCount = a.sd;\n          a.Pj = b.timeStamp;\n          a.Co.Ig(b.screenX, b.screenY);\n          a.doMouseDown();\n          1 === b.button ? b.preventDefault() : lj(c, b);\n        }\n      };\n      a.Fm = function (b) {\n        if (a.isEnabled) {\n          a.Zf = !0;\n          var c = a.Zj;\n          if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b;else {\n            if (null !== c[1] && c[1].pointerId === b.pointerId) {\n              c[1] = b;\n              return;\n            }\n            if (null === c[0]) c[0] = b;else return;\n          }\n          c[0].pointerId === b.pointerId && (c = kj(a, b, b, null !== c[1]), c.targetDiagram = hj(b), a.doMouseMove(), lj(c, b));\n        }\n      };\n      a.Hm = function (b) {\n        if (a.isEnabled) {\n          a.Zf = !0;\n          var c = \"touch\" === b.pointerType || \"pen\" === b.pointerType,\n            d = a.Os;\n          if (c && a.ek) delete d[b.pointerId], b.preventDefault();else if (d = a.Zj, null !== d[0] && d[0].pointerId === b.pointerId) {\n            d[0] = null;\n            d = jj(a, b, !1, !0, !0, !1);\n            var e = x.document.elementFromPoint(b.clientX, b.clientY);\n            null !== e && e.B instanceof Q && e.B !== a && gj(e.B, b, d);\n            gj(a, b, d);\n            d.clickCount = a.sd;\n            null === e ? d.targetDiagram = hj(b) : e.B ? d.targetDiagram = e.B : d.targetDiagram = null;\n            d.targetObject = null;\n            a.doMouseUp();\n            lj(d, b);\n            c && (a.ne = !1);\n          } else null !== d[1] && d[1].pointerId === b.pointerId && (d[1] = null);\n        }\n      };\n      a.Gm = function (b) {\n        if (a.isEnabled) {\n          a.Zf = !1;\n          var c = a.Os;\n          c[b.pointerId] && delete c[b.pointerId];\n          c = a.Zj;\n          null !== c[0] && c[0].pointerId === b.pointerId && (c[0] = null);\n          null !== c[1] && c[1].pointerId === b.pointerId && (c[1] = null);\n          \"touch\" !== b.pointerType && \"pen\" !== b.pointerType && (b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver());\n        }\n      };\n      b.tc(!0);\n      Oi(a);\n    }\n  }\n  zi.className = \"DiagramHelper\";\n  function $e(a) {\n    this.l = void 0 === a ? new J() : a;\n    this.v = new J();\n  }\n  ma.Object.defineProperties($e.prototype, {\n    point: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    },\n    shifted: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    }\n  });\n  $e.className = \"DraggingInfo\";\n  function Pj(a, b, c) {\n    this.node = a;\n    this.info = b;\n    this.Zv = c;\n  }\n  Pj.className = \"DraggingNodeInfoPair\";\n  function Te() {\n    this.reset();\n  }\n  Te.prototype.reset = function () {\n    this.isGridSnapEnabled = !1;\n    this.isGridSnapRealtime = !0;\n    this.gridSnapCellSize = new M(NaN, NaN).freeze();\n    this.gridSnapCellSpot = wc;\n    this.gridSnapOrigin = new J(NaN, NaN).freeze();\n    this.groupsSnapMembers = this.dragsTree = this.dragsLink = !1;\n    this.dragsMembers = this.groupsAlwaysMove = !0;\n  };\n  Te.className = \"DraggingOptions\";\n  function Kk(a) {\n    1 < arguments.length && B(\"Palette constructor can only take one optional argument, the DIV HTML element or its id.\");\n    Q.call(this, a);\n    Lk(this);\n  }\n  la(Kk, Q);\n  function Lk(a) {\n    a.allowDragOut = !0;\n    a.allowMove = !1;\n    a.isReadOnly = !0;\n    a.contentAlignment = yc;\n    a.layout = new Mk();\n  }\n  Kk.prototype.reset = function () {\n    Q.prototype.reset.call(this);\n    Lk(this);\n  };\n  Kk.className = \"Palette\";\n  function Nk(a) {\n    1 < arguments.length && B(\"Overview constructor can only take one optional argument, the DIV HTML element or its id.\");\n    Q.call(this, a);\n    var b = this;\n    this.animationManager.isEnabled = !1;\n    this.Rb = !0;\n    this.Ja = null;\n    this.ql = this.pl = !1;\n    this.v = this.I = !0;\n    this.cb = 0;\n    this.T = !1;\n    this.$l = null;\n    this.Qy(\"drawShadows\", !1);\n    var c = new U(),\n      d = new W();\n    d.stroke = \"magenta\";\n    d.strokeWidth = 2;\n    d.fill = \"transparent\";\n    d.name = \"BOXSHAPE\";\n    c.selectable = !0;\n    c.selectionAdorned = !1;\n    c.selectionObjectName = \"BOXSHAPE\";\n    c.locationObjectName = \"BOXSHAPE\";\n    c.resizeObjectName = \"BOXSHAPE\";\n    c.cursor = \"move\";\n    c.add(d);\n    this.l = c;\n    this.allowDelete = this.allowCopy = !1;\n    this.allowSelect = !0;\n    this.autoScrollRegion = new pc(0, 0, 0, 0);\n    this.la.h(0, 0);\n    this.toolManager.Xa(\"Dragging\", new Ok(), this.toolManager.mouseMoveTools);\n    this.click = function () {\n      var a = b.observed;\n      if (null !== a) {\n        var c = a.viewportBounds,\n          d = b.lastInput.documentPoint;\n        a.position = new J(d.x - c.width / 2, d.y - c.height / 2);\n      }\n    };\n    this.Xh = function () {\n      b.Oa();\n      Pk(b);\n    };\n    this.Wh = function () {\n      null !== b.observed && (b.Oa(), b.M());\n    };\n    this.Pc = function () {\n      1 > b.updateDelay ? b.M() : b.T || (b.T = !0, setTimeout(function () {\n        b.T = !1;\n        var a = b.ta,\n          c = b.Gb;\n        if (null !== a && null !== c) {\n          vj(b);\n          if (null === b.$l) {\n            var d = new Dk(null);\n            d.width = a.width;\n            d.height = a.height;\n            b.$l = d;\n          }\n          try {\n            b.ta = b.$l, b.Gb = b.ta.context, b.Gb.tc(!0), b.Gb.setTransform(1, 0, 0, 1, 0, 0), b.Gb.clearRect(0, 0, b.ta.width, b.ta.height), Qk(b);\n          } finally {\n            b.ta = a, b.Gb = c;\n          }\n        }\n        b.M();\n      }, b.updateDelay));\n    };\n    this.Gd = function () {\n      null !== b.observed && Pk(b);\n    };\n    this.autoScale = aj;\n    this.Rb = !1;\n  }\n  la(Nk, Q);\n  Nk.prototype.computePixelRatio = function () {\n    return 1;\n  };\n  Nk.prototype.bc = function () {\n    null === this.Ea && B(\"No div specified\");\n    null === this.ta && B(\"No canvas specified\");\n    if (!(this.ta instanceof Cj) && (ji(this.box), this.Dc)) {\n      var a = this.observed;\n      if (null !== a && !a.animationManager.isAnimating && a.oj) {\n        vj(this);\n        var b = this.ta;\n        a = this.Gb;\n        a.tc(!0);\n        a.setTransform(1, 0, 0, 1, 0, 0);\n        a.clearRect(0, 0, b.width, b.height);\n        1 > this.updateDelay ? Qk(this) : null !== this.$l && (a.drawImage(this.$l.Ga, 0, 0), b = this.ob, b.reset(), 1 !== this.scale && b.scale(this.scale), 0 === this.position.x && 0 === this.position.y || b.translate(-this.position.x, -this.position.y), a.scale(this.Sb, this.Sb), a.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy));\n        b = this.La.j;\n        for (var c = b.length, d = 0; d < c; d++) b[d].bc(a, this);\n        this.Dc = this.wi = !1;\n      }\n    }\n  };\n  function Qk(a) {\n    var b = a.observed;\n    if (null !== b) {\n      var c = a.drawsTemporaryLayers,\n        d = a.drawsGrid && c,\n        e = b.grid;\n      d && null !== e && e.visible && !isNaN(e.width) && !isNaN(e.height) && (e = N.alloc().assign(a.viewportBounds).Oc(b.viewportBounds), oj(b, e), N.free(e), Ui(b));\n      var f = a.ob;\n      f.reset();\n      1 !== a.scale && f.scale(a.scale);\n      0 === a.position.x && 0 === a.position.y || f.translate(-a.position.x, -a.position.y);\n      e = a.Gb;\n      e.scale(a.Sb, a.Sb);\n      e.transform(f.m11, f.m12, f.m21, f.m22, f.dx, f.dy);\n      b = b.La.j;\n      f = b.length;\n      for (var g = 0; g < f; g++) {\n        var h = b[g],\n          k = a;\n        if (h.visible && 0 !== h.opacity) {\n          var l = h.diagram.grid.part;\n          if (!c && h.isTemporary) d && l.layer === h && (h = ki(h, e), l.bc(e, k), e.globalAlpha = h);else {\n            for (var m = ki(h, e), n = k.scale, p = N.alloc(), r = h.Da.j, q = r.length, u = 0; u < q; u++) {\n              var v = r[u];\n              (d || v !== l) && h.dj(e, v, k, null, n, p, !1);\n            }\n            N.free(p);\n            e.globalAlpha = m;\n          }\n        }\n      }\n    }\n  }\n  function Pk(a) {\n    var b = a.box;\n    if (null !== b) {\n      var c = a.observed;\n      if (null !== c) {\n        a.Dc = !0;\n        c = c.viewportBounds;\n        var d = b.selectionObject,\n          e = M.alloc();\n        e.h(c.width, c.height);\n        d.desiredSize = e;\n        M.free(e);\n        a = 2 / a.scale;\n        d instanceof W && (d.strokeWidth = a);\n        b.location = new J(c.x - a / 2, c.y - a / 2);\n        b.isSelected = !0;\n      }\n    }\n  }\n  Nk.prototype.computeBounds = function () {\n    var a = this.observed;\n    if (null === a) return jc;\n    var b = a.documentBounds.copy();\n    b.Oc(a.viewportBounds);\n    return b;\n  };\n  Nk.prototype.By = function () {\n    !0 !== this.Dc && (this.Dc = !0, this.Db());\n  };\n  Nk.prototype.Vq = function (a, b, c, d) {\n    this.Rb || (Ti(this), this.M(), Zi(this), this.Oa(), Pk(this), this.Vd.scale = c, this.Vd.position.x = a.x, this.Vd.position.y = a.y, this.Vd.bounds.assign(a), this.Vd.gw = d, this.R(\"ViewportBoundsChanged\", this.Vd, a));\n  };\n  ma.Object.defineProperties(Nk.prototype, {\n    observed: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        var b = this.Ja;\n        a instanceof Nk && B(\"Overview.observed Diagram may not be an Overview itself: \" + a);\n        if (b !== a) {\n          null !== b && (this.remove(this.box), b.Km(\"ViewportBoundsChanged\", this.Xh), b.Km(\"DocumentBoundsChanged\", this.Wh), b.Km(\"InvalidateDraw\", this.Pc), b.Km(\"AnimationFinished\", this.Gd));\n          this.Ja = a;\n          null !== a && (a.hk(\"ViewportBoundsChanged\", this.Xh), a.hk(\"DocumentBoundsChanged\", this.Wh), a.hk(\"InvalidateDraw\", this.Pc), a.hk(\"AnimationFinished\", this.Gd), this.add(this.box));\n          this.Oa();\n          if (null === a) {\n            this.$l = null;\n            var c = this.ta,\n              d = this.Gb;\n            c && d && (d.setTransform(1, 0, 0, 1, 0, 0), d.clearRect(0, 0, c.width, c.height));\n          } else this.Pc(null), Pk(this), this.M();\n          this.g(\"observed\", b, a);\n        }\n      }\n    },\n    box: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        var b = this.l;\n        b !== a && (this.l = a, this.remove(b), this.add(this.l), Pk(this), this.g(\"box\", b, a));\n      }\n    },\n    drawsTemporaryLayers: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I !== a && (this.I = a, this.Je());\n      }\n    },\n    drawsGrid: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v !== a && (this.v = a, this.Je());\n      }\n    },\n    updateDelay: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        0 > a && (a = 0);\n        this.cb !== a && (this.cb = a);\n      }\n    }\n  });\n  Nk.className = \"Overview\";\n  function Ok() {\n    Se.call(this);\n    this.l = null;\n  }\n  la(Ok, Se);\n  Ok.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (null === a || !a.allowMove || !a.allowSelect) return !1;\n    var b = a.observed;\n    if (null === b) return !1;\n    var c = a.lastInput;\n    if (!c.left || a.currentTool !== this && (!this.isBeyondDragSize() || c.isTouchEvent && c.timestamp - a.firstInput.timestamp < this.delay)) return !1;\n    null === this.findDraggablePart() && (c = b.viewportBounds, this.l = new J(c.width / 2, c.height / 2), a = a.firstInput.documentPoint, b.position = new J(a.x - this.l.x, a.y - this.l.y));\n    return !0;\n  };\n  Ok.prototype.doActivate = function () {\n    this.l = null;\n    Se.prototype.doActivate.call(this);\n  };\n  Ok.prototype.doUpdateCursor = function () {\n    var a = this.diagram,\n      b = a.box;\n    null !== b && b.cursor && (a.currentCursor = b.cursor);\n  };\n  Ok.prototype.moveParts = function () {\n    var a = this.diagram,\n      b = a.observed;\n    if (null !== b) {\n      var c = a.box;\n      if (null !== c) {\n        if (null === this.l) {\n          var d = a.firstInput.documentPoint;\n          c = c.location;\n          this.l = new J(d.x - c.x, d.y - c.y);\n        }\n        a = a.lastInput.documentPoint;\n        b.position = new J(a.x - this.l.x, a.y - this.l.y);\n      }\n    }\n  };\n  Ok.className = \"OverviewDraggingTool\";\n  function Rk() {\n    Ya(this);\n    this.B = De;\n    this.cb = this.I = this.v = !0;\n    this.T = this.Ja = this.Pc = this.Ka = !1;\n    this.Ji = this.l = null;\n    this.Gd = 1.05;\n    this.av = NaN;\n    this.wx = null;\n    this.Bv = NaN;\n    this.Av = jc;\n    this.Bc = !0;\n    this.rg = null;\n    this.Qc = 200;\n  }\n  Rk.prototype.toString = function () {\n    return \"CommandHandler\";\n  };\n  Rk.prototype.ae = function (a) {\n    this.B = a;\n  };\n  Rk.prototype.doKeyDown = function () {\n    var a = this.diagram,\n      b = a.lastInput,\n      c = Wa ? b.meta : b.control,\n      d = b.shift,\n      e = b.alt,\n      f = b.key;\n    !c || \"C\" !== f && \"Insert\" !== f ? c && \"X\" === f || d && \"Del\" === f ? this.canCutSelection() && this.cutSelection() : c && \"V\" === f || d && \"Insert\" === f ? this.canPasteSelection() && this.pasteSelection() : c && \"Y\" === f || e && d && \"Backspace\" === f ? this.canRedo() && this.redo() : c && \"Z\" === f || e && \"Backspace\" === f ? this.canUndo() && this.undo() : \"Del\" === f || \"Backspace\" === f ? this.canDeleteSelection() && this.deleteSelection() : c && \"A\" === f ? this.canSelectAll() && this.selectAll() : \"Esc\" === f ? this.canStopCommand() && this.stopCommand() : \"Up\" === f ? a.allowVerticalScroll && (c ? a.scroll(\"pixel\", \"up\") : a.scroll(\"line\", \"up\")) : \"Down\" === f ? a.allowVerticalScroll && (c ? a.scroll(\"pixel\", \"down\") : a.scroll(\"line\", \"down\")) : \"Left\" === f ? a.allowHorizontalScroll && (c ? a.scroll(\"pixel\", \"left\") : a.scroll(\"line\", \"left\")) : \"Right\" === f ? a.allowHorizontalScroll && (c ? a.scroll(\"pixel\", \"right\") : a.scroll(\"line\", \"right\")) : \"PageUp\" === f ? d && a.allowHorizontalScroll ? a.scroll(\"page\", \"left\") : a.allowVerticalScroll && a.scroll(\"page\", \"up\") : \"PageDown\" === f ? d && a.allowHorizontalScroll ? a.scroll(\"page\", \"right\") : a.allowVerticalScroll && a.scroll(\"page\", \"down\") : \"Home\" === f ? c && a.allowVerticalScroll ? a.scroll(\"document\", \"up\") : !c && a.allowHorizontalScroll && a.scroll(\"document\", \"left\") : \"End\" === f ? c && a.allowVerticalScroll ? a.scroll(\"document\", \"down\") : !c && a.allowHorizontalScroll && a.scroll(\"document\", \"right\") : \" \" === f ? this.canScrollToPart() && this.scrollToPart() : \"Subtract\" === f ? this.canDecreaseZoom() && this.decreaseZoom() : \"Add\" === f ? this.canIncreaseZoom() && this.increaseZoom() : c && \"0\" === f ? this.canResetZoom() && this.resetZoom() : d && \"Z\" === f ? this.canZoomToFit() && this.zoomToFit() : c && !d && \"G\" === f ? this.canGroupSelection() && this.groupSelection() : c && d && \"G\" === f ? this.canUngroupSelection() && this.ungroupSelection() : b.event && 113 === b.event.which ? this.canEditTextBlock() && this.editTextBlock() : b.event && 93 === b.event.which ? this.canShowContextMenu() && this.showContextMenu() : b.bubbles = !0 : this.canCopySelection() && this.copySelection();\n  };\n  Rk.prototype.doKeyUp = function () {\n    this.diagram.lastInput.bubbles = !0;\n  };\n  Rk.prototype.stopCommand = function () {\n    var a = this.diagram,\n      b = a.currentTool;\n    b instanceof Oa && a.allowSelect && a.clearSelection();\n    null !== b && b.doCancel();\n  };\n  Rk.prototype.canStopCommand = function () {\n    return !0;\n  };\n  Rk.prototype.selectAll = function () {\n    var a = this.diagram;\n    a.M();\n    try {\n      a.currentCursor = \"wait\";\n      a.R(\"ChangingSelection\", a.selection);\n      for (var b = a.parts; b.next();) b.value.isSelected = !0;\n      for (var c = a.nodes; c.next();) c.value.isSelected = !0;\n      for (var d = a.links; d.next();) d.value.isSelected = !0;\n    } finally {\n      a.R(\"ChangedSelection\", a.selection), a.currentCursor = \"\";\n    }\n  };\n  Rk.prototype.canSelectAll = function () {\n    return this.diagram.allowSelect;\n  };\n  Rk.prototype.deleteSelection = function () {\n    var a = this.diagram;\n    try {\n      a.currentCursor = \"wait\";\n      a.R(\"ChangingSelection\", a.selection);\n      a.va(\"Delete\");\n      a.R(\"SelectionDeleting\", a.selection);\n      for (var b = new F(), c = a.selection.iterator; c.next();) Sk(b, c.value, !0, this.deletesTree ? Infinity : 0, this.deletesConnectedLinks ? null : !1, function (a) {\n        return a.canDelete();\n      });\n      a.gu(b, !0);\n      a.R(\"SelectionDeleted\", b);\n    } finally {\n      a.Wa(\"Delete\"), a.R(\"ChangedSelection\", a.selection), a.currentCursor = \"\";\n    }\n  };\n  Rk.prototype.canDeleteSelection = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly || !a.allowDelete || 0 === a.selection.count ? !1 : !0;\n  };\n  Rk.prototype.copySelection = function () {\n    var a = this.diagram,\n      b = new F();\n    for (a = a.selection.iterator; a.next();) Sk(b, a.value, !0, this.copiesTree ? Infinity : 0, this.copiesConnectedLinks, function (a) {\n      return a.canCopy();\n    });\n    this.copyToClipboard(b);\n  };\n  Rk.prototype.canCopySelection = function () {\n    var a = this.diagram;\n    return a.allowCopy && a.allowClipboard && 0 !== a.selection.count ? !0 : !1;\n  };\n  Rk.prototype.cutSelection = function () {\n    this.copySelection();\n    this.deleteSelection();\n  };\n  Rk.prototype.canCutSelection = function () {\n    var a = this.diagram;\n    return !a.isReadOnly && !a.isModelReadOnly && a.allowCopy && a.allowDelete && a.allowClipboard && 0 !== a.selection.count ? !0 : !1;\n  };\n  Rk.prototype.copyToClipboard = function (a) {\n    var b = this.diagram,\n      c = null;\n    if (null === a) Ii = null, Ji = \"\";else {\n      c = b.model;\n      var d = !1,\n        e = !1,\n        f = null;\n      try {\n        c.Am() && (d = c.pk, c.pk = this.copiesParentKey), c.xk() && (e = c.nk, c.nk = this.copiesGroupKey), f = b.qk(a, null, !0);\n      } finally {\n        c.Am() && (c.pk = d), c.xk() && (c.nk = e), c = new E(), c.addAll(f), Ii = c, Ji = b.model.dataFormat;\n      }\n    }\n    b.R(\"ClipboardChanged\", c);\n  };\n  Rk.prototype.pasteFromClipboard = function () {\n    var a = new F(),\n      b = Ii;\n    if (null === b) return a;\n    var c = this.diagram;\n    if (Ji !== c.model.dataFormat) return a;\n    var d = c.model,\n      e = !1,\n      f = !1,\n      g = null;\n    try {\n      d.Am() && (e = d.pk, d.pk = this.copiesParentKey), d.xk() && (f = d.nk, d.nk = this.copiesGroupKey), g = c.qk(b, c, !1);\n    } finally {\n      for (d.Am() && (d.pk = e), d.xk() && (d.nk = f), b = g.iterator; b.next();) c = b.value, d = b.key, c.location.u() || (d.location.u() ? c.location = d.location : !c.position.u() && d.position.u() && (c.position = d.position)), a.add(c);\n    }\n    return a;\n  };\n  Rk.prototype.pasteSelection = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    try {\n      b.currentCursor = \"wait\";\n      b.R(\"ChangingSelection\", b.selection);\n      b.va(\"Paste\");\n      var c = this.pasteFromClipboard();\n      0 < c.count && b.clearSelection(!0);\n      for (var d = c.iterator; d.next();) d.value.isSelected = !0;\n      if (null !== a) {\n        var e = b.computePartsBounds(b.selection);\n        if (e.u()) {\n          var f = this.computeEffectiveCollection(b.selection, b.dl);\n          sf(b, f, new J(a.x - e.centerX, a.y - e.centerY), b.dl, !1);\n        }\n      }\n      b.R(\"ClipboardPasted\", c);\n    } finally {\n      b.Wa(\"Paste\"), b.R(\"ChangedSelection\", b.selection), b.currentCursor = \"\";\n    }\n  };\n  Rk.prototype.canPasteSelection = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowClipboard || null === Ii || 0 === Ii.count || Ji !== a.model.dataFormat ? !1 : !0;\n  };\n  Rk.prototype.undo = function () {\n    this.diagram.undoManager.undo();\n  };\n  Rk.prototype.canUndo = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canUndo();\n  };\n  Rk.prototype.redo = function () {\n    this.diagram.undoManager.redo();\n  };\n  Rk.prototype.canRedo = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canRedo();\n  };\n  Rk.prototype.decreaseZoom = function (a) {\n    void 0 === a && (a = 1 / this.zoomFactor);\n    var b = this.diagram;\n    b.autoScale === Ih && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a));\n  };\n  Rk.prototype.canDecreaseZoom = function (a) {\n    void 0 === a && (a = 1 / this.zoomFactor);\n    var b = this.diagram;\n    if (b.autoScale !== Ih) return !1;\n    a = b.scale * a;\n    return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom;\n  };\n  Rk.prototype.increaseZoom = function (a) {\n    void 0 === a && (a = this.zoomFactor);\n    var b = this.diagram;\n    b.autoScale === Ih && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a));\n  };\n  Rk.prototype.canIncreaseZoom = function (a) {\n    void 0 === a && (a = this.zoomFactor);\n    var b = this.diagram;\n    if (b.autoScale !== Ih) return !1;\n    a = b.scale * a;\n    return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom;\n  };\n  Rk.prototype.resetZoom = function (a) {\n    void 0 === a && (a = this.defaultScale);\n    var b = this.diagram;\n    a < b.minScale || a > b.maxScale || (b.scale = a);\n  };\n  Rk.prototype.canResetZoom = function (a) {\n    void 0 === a && (a = this.defaultScale);\n    var b = this.diagram;\n    return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom;\n  };\n  Rk.prototype.zoomToFit = function () {\n    var a = this.diagram,\n      b = a.animationManager;\n    b.Nc();\n    a.Je();\n    var c = a.position,\n      d = a.scale;\n    Ch(b, \"Zoom To Fit\");\n    this.isZoomToFitRestoreEnabled && d === this.Bv && !isNaN(this.av) && a.documentBounds.w(this.Av) ? (a.scale = this.av, a.position = this.wx, this.Bv = NaN, this.Av = jc) : (this.av = d, this.wx = c.copy(), a.zoomToFit(), this.Bv = a.scale, this.Av = a.documentBounds.copy());\n    Eh(b);\n  };\n  Rk.prototype.canZoomToFit = function () {\n    return this.diagram.allowZoom;\n  };\n  Rk.prototype.scrollToPart = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    b.Ta();\n    if (null === a) {\n      try {\n        null !== this.rg && (this.rg.next() ? a = this.rg.value : this.rg = null);\n      } catch (k) {\n        this.rg = null;\n      }\n      null === a && (0 < b.highlighteds.count ? this.rg = b.highlighteds.iterator : 0 < b.selection.count && (this.rg = b.selection.iterator), null !== this.rg && this.rg.next() && (a = this.rg.value));\n    }\n    if (null !== a) {\n      var c = b.animationManager;\n      Ch(c, \"Scroll To Part\");\n      var d = this.scrollToPartPause;\n      if (0 < d) {\n        var e = Tk(this, a, [a]);\n        if (1 === e.length) b.va(), b.At(a.actualBounds), b.Wa(\"Scroll To Part\");else {\n          var f = function () {\n              b.va();\n              for (var a = e.pop(); 0 < e.length && a instanceof V && a.isTreeExpanded && (!(a instanceof vf) || a.isSubGraphExpanded);) a = e.pop();\n              0 < e.length ? (a instanceof U && b.zw(a.actualBounds), a instanceof V && !a.isTreeExpanded && (a.isTreeExpanded = !0), a instanceof vf && !a.isSubGraphExpanded && (a.isSubGraphExpanded = !0)) : (a instanceof U && b.At(a.actualBounds), b.Km(\"LayoutCompleted\", g));\n              b.Wa(\"Scroll To Part\");\n            },\n            g = function () {\n              sa(f, (c.isEnabled ? c.duration : 0) + d);\n            };\n          b.hk(\"LayoutCompleted\", g);\n          f();\n        }\n      } else {\n        var h = b.position.copy();\n        b.At(a.actualBounds);\n        h.Na(b.position) && c.Nc();\n      }\n    }\n  };\n  function Tk(a, b, c) {\n    if (b.isVisible()) return c;\n    if (b instanceof He) Tk(a, b.adornedPart, c);else if (b instanceof S) {\n      var d = b.fromNode;\n      null !== d && Tk(a, d, c);\n      b = b.toNode;\n      null !== b && Tk(a, b, c);\n    } else b instanceof V && (d = b.labeledLink, null !== d && Tk(a, d, c), d = b.Fg(), null !== d && (d.isTreeExpanded || d.wasTreeExpanded || c.push(d), Tk(a, d, c))), b = b.containingGroup, null !== b && (b.isSubGraphExpanded || b.wasSubGraphExpanded || c.push(b), Tk(a, b, c));\n    return c;\n  }\n  Rk.prototype.canScrollToPart = function (a) {\n    void 0 === a && (a = null);\n    if (null !== a && !(a instanceof U)) return !1;\n    a = this.diagram;\n    return 0 === a.selection.count && 0 === a.highlighteds.count ? !1 : a.allowHorizontalScroll && a.allowVerticalScroll;\n  };\n  Rk.prototype.collapseTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    try {\n      b.va(\"Collapse Tree\");\n      Ch(b.animationManager, \"Collapse Tree\");\n      var c = new E();\n      if (null !== a && a.isTreeExpanded) a.collapseTree(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof V && e.isTreeExpanded && (e.collapseTree(), c.add(e));\n      }\n      b.R(\"TreeCollapsed\", c);\n    } finally {\n      b.Wa(\"Collapse Tree\");\n    }\n  };\n  Rk.prototype.canCollapseTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n    if (null !== a) {\n      if (!(a instanceof V && a.isTreeExpanded)) return !1;\n      if (0 < a.Fq().count) return !0;\n    } else for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof V && b.isTreeExpanded && 0 < b.Fq().count) return !0;\n    return !1;\n  };\n  Rk.prototype.expandTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    try {\n      b.va(\"Expand Tree\");\n      Ch(b.animationManager, \"Expand Tree\");\n      var c = new E();\n      if (null !== a && !a.isTreeExpanded) a.expandTree(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof V && !e.isTreeExpanded && (e.expandTree(), c.add(e));\n      }\n      b.R(\"TreeExpanded\", c);\n    } finally {\n      b.Wa(\"Expand Tree\");\n    }\n  };\n  Rk.prototype.canExpandTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n    if (null !== a) {\n      if (!(a instanceof V) || a.isTreeExpanded) return !1;\n      if (0 < a.Fq().count) return !0;\n    } else for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof V && !b.isTreeExpanded && 0 < b.Fq().count) return !0;\n    return !1;\n  };\n  Rk.prototype.groupSelection = function () {\n    var a = this.diagram,\n      b = a.model;\n    if (b.yk()) {\n      var c = this.archetypeGroupData;\n      if (null !== c) {\n        var d = null;\n        try {\n          a.currentCursor = \"wait\";\n          a.R(\"ChangingSelection\", a.selection);\n          a.va(\"Group\");\n          for (var e = new E(), f = a.selection.iterator; f.next();) {\n            var g = f.value;\n            g.Wb() && g.canGroup() && e.add(g);\n          }\n          for (var h = new E(), k = e.iterator; k.next();) {\n            var l = k.value;\n            f = !1;\n            for (var m = e.iterator; m.next();) if (l.Cd(m.value)) {\n              f = !0;\n              break;\n            }\n            f || h.add(l);\n          }\n          if (0 < h.count) {\n            var n = h.first().containingGroup;\n            if (null !== n) for (; null !== n;) {\n              e = !1;\n              for (var p = h.iterator; p.next();) if (!p.value.Cd(n)) {\n                e = !0;\n                break;\n              }\n              if (e) n = n.containingGroup;else break;\n            }\n            if (c instanceof vf) xg(c), d = c.copy(), null !== d && a.add(d);else if (b.ew(c)) {\n              var r = b.copyNodeData(c);\n              ya(r) && (b.uf(r), d = a.gj(r));\n            }\n            if (null !== d) {\n              null !== n && this.isValidMember(n, d) && (d.containingGroup = n);\n              for (var q = h.iterator; q.next();) {\n                var u = q.value;\n                this.isValidMember(d, u) && (u.containingGroup = d);\n              }\n              a.clearSelection(!0);\n              d.isSelected = !0;\n            }\n          }\n          a.R(\"SelectionGrouped\", d);\n        } finally {\n          a.Wa(\"Group\"), a.R(\"ChangedSelection\", a.selection), a.currentCursor = \"\";\n        }\n      }\n    }\n  };\n  Rk.prototype.canGroupSelection = function () {\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowGroup || !a.model.yk() || null === this.archetypeGroupData) return !1;\n    for (a = a.selection.iterator; a.next();) {\n      var b = a.value;\n      if (b.Wb() && b.canGroup()) return !0;\n    }\n    return !1;\n  };\n  function Uk(a) {\n    var b = Ea();\n    for (a = a.iterator; a.next();) {\n      var c = a.value;\n      c instanceof S || b.push(c);\n    }\n    a = new F();\n    c = b.length;\n    for (var d = 0; d < c; d++) {\n      for (var e = b[d], f = !0, g = 0; g < c; g++) if (e.Cd(b[g])) {\n        f = !1;\n        break;\n      }\n      f && a.add(e);\n    }\n    Ha(b);\n    return a;\n  }\n  Rk.prototype.isValidMember = function (a, b) {\n    if (null === b || a === b || b instanceof S) return !1;\n    if (null !== a) {\n      if (a === b || a.Cd(b)) return !1;\n      var c = a.memberValidation;\n      if (null !== c && !c(a, b) || null === a.data && null !== b.data || null !== a.data && null === b.data) return !1;\n    }\n    c = this.memberValidation;\n    return null !== c ? c(a, b) : !0;\n  };\n  Rk.prototype.ungroupSelection = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram,\n      c = b.model;\n    if (c.yk()) try {\n      b.currentCursor = \"wait\";\n      b.R(\"ChangingSelection\", b.selection);\n      b.va(\"Ungroup\");\n      var d = new E();\n      if (null !== a) d.add(a);else for (var e = b.selection.iterator; e.next();) {\n        var f = e.value;\n        f instanceof vf && f.canUngroup() && d.add(f);\n      }\n      var g = new E();\n      if (0 < d.count) {\n        b.clearSelection(!0);\n        for (var h = d.iterator; h.next();) {\n          var k = h.value;\n          k.expandSubGraph();\n          var l = k.containingGroup,\n            m = null !== l && null !== l.data ? c.ja(l.data) : void 0;\n          g.addAll(k.memberParts);\n          for (var n = g.iterator; n.next();) {\n            var p = n.value;\n            p.isSelected = !0;\n            if (!(p instanceof S)) {\n              var r = p.data;\n              null !== r ? c.er(r, m) : p.containingGroup = l;\n            }\n          }\n          b.remove(k);\n        }\n      }\n      b.R(\"SelectionUngrouped\", d, g);\n    } finally {\n      b.Wa(\"Ungroup\"), b.R(\"ChangedSelection\", b.selection), b.currentCursor = \"\";\n    }\n  };\n  Rk.prototype.canUngroupSelection = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly || b.isModelReadOnly || !b.allowDelete || !b.allowUngroup || !b.model.yk()) return !1;\n    if (null !== a) {\n      if (!(a instanceof vf)) return !1;\n      if (a.canUngroup()) return !0;\n    } else for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof vf && b.canUngroup()) return !0;\n    return !1;\n  };\n  Rk.prototype.addTopLevelParts = function (a, b) {\n    var c = !0;\n    for (a = Uk(a).iterator; a.next();) {\n      var d = a.value;\n      null !== d.containingGroup && (!b || this.isValidMember(null, d) ? d.containingGroup = null : c = !1);\n    }\n    return c;\n  };\n  Rk.prototype.collapseSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    try {\n      b.va(\"Collapse SubGraph\");\n      Ch(b.animationManager, \"Collapse SubGraph\");\n      var c = new E();\n      if (null !== a && a.isSubGraphExpanded) a.collapseSubGraph(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof vf && e.isSubGraphExpanded && (e.collapseSubGraph(), c.add(e));\n      }\n      b.R(\"SubGraphCollapsed\", c);\n    } finally {\n      b.Wa(\"Collapse SubGraph\");\n    }\n  };\n  Rk.prototype.canCollapseSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n    if (null !== a) return a instanceof vf && a.isSubGraphExpanded ? !0 : !1;\n    for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof vf && b.isSubGraphExpanded) return !0;\n    return !1;\n  };\n  Rk.prototype.expandSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    try {\n      b.va(\"Expand SubGraph\");\n      Ch(b.animationManager, \"Expand SubGraph\");\n      var c = new E();\n      if (null !== a && !a.isSubGraphExpanded) a.expandSubGraph(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof vf && !e.isSubGraphExpanded && (e.expandSubGraph(), c.add(e));\n      }\n      b.R(\"SubGraphExpanded\", c);\n    } finally {\n      b.Wa(\"Expand SubGraph\");\n    }\n  };\n  Rk.prototype.canExpandSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n    if (null !== a) return a instanceof vf && !a.isSubGraphExpanded ? !0 : !1;\n    for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof vf && !b.isSubGraphExpanded) return !0;\n    return !1;\n  };\n  Rk.prototype.editTextBlock = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram,\n      c = b.toolManager.findTool(\"TextEditing\");\n    if (null !== c) {\n      if (null === a) {\n        a = null;\n        for (var d = b.selection.iterator; d.next();) {\n          var e = d.value;\n          if (e.canEdit()) {\n            a = e;\n            break;\n          }\n        }\n        if (null === a) return;\n        a = a.sm(function (a) {\n          return a instanceof Vg && a.editable;\n        });\n      }\n      null !== a && (b.currentTool = null, c.textBlock = a, b.currentTool = c);\n    }\n  };\n  Rk.prototype.canEditTextBlock = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly || b.isModelReadOnly || !b.allowTextEdit || null === b.toolManager.findTool(\"TextEditing\")) return !1;\n    if (null !== a) {\n      if (!(a instanceof Vg)) return !1;\n      a = a.part;\n      if (null !== a && a.canEdit()) return !0;\n    } else for (b = b.selection.iterator; b.next();) if (a = b.value, a.canEdit() && (a = a.sm(function (a) {\n      return a instanceof Vg && a.editable;\n    }), null !== a)) return !0;\n    return !1;\n  };\n  Rk.prototype.showContextMenu = function (a) {\n    var b = this.diagram,\n      c = b.toolManager.findTool(\"ContextMenu\");\n    if (null !== c && (void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b), a = c.findObjectWithContextMenu(a), null !== a)) {\n      var d = b.lastInput,\n        e = null;\n      a instanceof Y ? e = a.ga(Bc) : b.viewportBounds.aa(d.documentPoint) || (e = b.viewportBounds, e = new J(e.x + e.width / 2, e.y + e.height / 2));\n      null !== e && (d.viewPoint = b.ir(e), d.documentPoint = e, d.left = !1, d.right = !0, d.up = !0);\n      b.currentTool = c;\n      Rg(c, !1, a);\n    }\n  };\n  Rk.prototype.canShowContextMenu = function (a) {\n    var b = this.diagram,\n      c = b.toolManager.findTool(\"ContextMenu\");\n    if (null === c) return !1;\n    void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b);\n    return null === c.findObjectWithContextMenu(a) ? !1 : !0;\n  };\n  Rk.prototype.computeEffectiveCollection = function (a, b) {\n    var c = this.diagram,\n      d = c.toolManager.findTool(\"Dragging\"),\n      e = c.currentTool === d;\n    void 0 === b && (b = e ? d.dragOptions : c.dl);\n    d = new H();\n    if (null === a) return d;\n    for (var f = a.iterator; f.next();) Nj(c, d, f.value, e, b);\n    if (null !== c.draggedLink && b.dragsLink) return d;\n    for (f = a.iterator; f.next();) a = f.value, a instanceof S && (b = a.fromNode, null === b || d.contains(b) ? (b = a.toNode, null === b || d.contains(b) || d.remove(a)) : d.remove(a));\n    return d;\n  };\n  ma.Object.defineProperties(Rk.prototype, {\n    diagram: {\n      get: function () {\n        return this.B;\n      }\n    },\n    copiesClipboardData: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a;\n      }\n    },\n    copiesConnectedLinks: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    deletesConnectedLinks: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb = a;\n      }\n    },\n    copiesTree: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka = a;\n      }\n    },\n    deletesTree: {\n      get: function () {\n        return this.Pc;\n      },\n      set: function (a) {\n        this.Pc = a;\n      }\n    },\n    copiesParentKey: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja = a;\n      }\n    },\n    copiesGroupKey: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T = a;\n      }\n    },\n    archetypeGroupData: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l = a;\n      }\n    },\n    memberValidation: {\n      get: function () {\n        return this.Ji;\n      },\n      set: function (a) {\n        this.Ji = a;\n      }\n    },\n    defaultScale: {\n      get: function () {\n        return this.diagram.defaultScale;\n      },\n      set: function (a) {\n        this.diagram.defaultScale = a;\n      }\n    },\n    zoomFactor: {\n      get: function () {\n        return this.Gd;\n      },\n      set: function (a) {\n        1 < a || B(\"zoomFactor must be larger than 1.0, not: \" + a);\n        this.Gd = a;\n      }\n    },\n    isZoomToFitRestoreEnabled: {\n      get: function () {\n        return this.Bc;\n      },\n      set: function (a) {\n        this.Bc = a;\n      }\n    },\n    scrollToPartPause: {\n      get: function () {\n        return this.Qc;\n      },\n      set: function (a) {\n        this.Qc = a;\n      }\n    }\n  });\n  Rk.className = \"CommandHandler\";\n  vi = function () {\n    return new Rk();\n  };\n  function Y() {\n    Ya(this);\n    this.F = 4225027;\n    this.tb = 1;\n    this.og = null;\n    this.Qa = \"\";\n    this.dc = this.kb = null;\n    this.la = new J(NaN, NaN).freeze();\n    this.Uc = Sb;\n    this.fg = Mb;\n    this.eg = Rb;\n    this.ob = new rd();\n    this.Zh = new rd();\n    this.cg = new rd();\n    this.ya = this.jl = 1;\n    this.Yb = 0;\n    this.ze = Vk;\n    this.ih = tc;\n    this.pc = new N(NaN, NaN, NaN, NaN).freeze();\n    this.xb = new N(NaN, NaN, NaN, NaN).freeze();\n    this.qc = new N(0, 0, NaN, NaN).freeze();\n    this.O = this.sp = this.tp = null;\n    this.Tk = this.yb = ad;\n    this.Fp = 0;\n    this.Gp = 1;\n    this.Rg = 0;\n    this.yn = 1;\n    this.Zp = null;\n    this.Mp = -Infinity;\n    this.Vl = 0;\n    this.Wl = Hb;\n    this.Xl = bg;\n    this.oi = \"\";\n    this.eb = this.N = null;\n    this.Xk = -1;\n    this.Zl = this.pd = this.ni = this.cm = null;\n    this.Rs = yg;\n    this.Ip = this.Mg = this.Yj = null;\n  }\n  var vd, yg, Ag, Vk, Wk, Xk, Yk, Zk, $k, al;\n  Y.prototype.cloneProtected = function (a) {\n    a.F = this.F | 6144;\n    a.tb = this.tb;\n    a.Qa = this.Qa;\n    a.kb = this.kb;\n    a.dc = this.dc;\n    a.Mg = this.Mg;\n    a.la.assign(this.la);\n    a.Uc = this.Uc.G();\n    a.fg = this.fg.G();\n    a.eg = this.eg.G();\n    a.cg = this.cg.copy();\n    a.ya = this.ya;\n    a.Yb = this.Yb;\n    a.ze = this.ze;\n    a.ih = this.ih.G();\n    a.pc.assign(this.pc);\n    a.xb.assign(this.xb);\n    a.qc.assign(this.qc);\n    a.sp = this.sp;\n    null !== this.O && (a.O = this.O.copy());\n    a.yb = this.yb.G();\n    a.Tk = this.Tk.G();\n    a.Fp = this.Fp;\n    a.Gp = this.Gp;\n    a.Rg = this.Rg;\n    a.yn = this.yn;\n    a.Zp = this.Zp;\n    a.Mp = this.Mp;\n    a.Vl = this.Vl;\n    a.Wl = this.Wl.G();\n    a.Xl = this.Xl;\n    a.oi = this.oi;\n    null !== this.N && (a.N = this.N.copy());\n    a.eb = this.eb;\n    a.Xk = this.Xk;\n    null !== this.ni && (a.ni = Ba(this.ni));\n    null !== this.pd && (a.pd = this.pd.copy());\n    a.Zl = this.Zl;\n  };\n  Y.prototype.Rx = function (a) {\n    var b = this.ni;\n    if (Aa(b)) for (var c = 0; c < b.length; c++) {\n      if (b[c] === a) return;\n    } else this.ni = b = [];\n    b.push(a);\n  };\n  Y.prototype.yf = function (a) {\n    a.tp = null;\n    a.Yj = null;\n    a.o();\n  };\n  Y.prototype.clone = function () {\n    var a = new this.constructor();\n    this.cloneProtected(a);\n    if (null !== this.ni) for (var b = 0; b < this.ni.length; b++) {\n      var c = this.ni[b];\n      a[c] = this[c];\n    }\n    return a;\n  };\n  Y.prototype.copy = function () {\n    return this.clone();\n  };\n  t = Y.prototype;\n  t.hb = function (a) {\n    a.classType === S ? 0 === a.name.indexOf(\"Orient\") ? this.segmentOrientation = a : B(\"Unknown Link enum value for GraphObject.segmentOrientation property: \" + a) : a.classType === Y && (this.stretch = a);\n  };\n  t.toString = function () {\n    return Ia(this.constructor) + \"#\" + mb(this);\n  };\n  function bl(a) {\n    null === a.N && (a.N = new cl());\n  }\n  t.Jc = function () {\n    if (null === this.O) {\n      var a = new dl();\n      a.ah = vc;\n      a.Ch = vc;\n      a.Zg = 10;\n      a.Ah = 10;\n      a.$g = 0;\n      a.Bh = 0;\n      this.O = a;\n    }\n  };\n  t.ab = function (a, b, c, d, e, f, g) {\n    var h = this.part;\n    if (null !== h && (h.Jk(a, b, c, d, e, f, g), c === this && a === ve && el(this) && fl(this, h, b), f = this.diagram, null === this.Mg || null === f || !f.oj || f.undoManager.isUndoingRedoing || f.currentTool !== f.toolManager || f.animationManager.sn || (a = this.Mg.get(b), null !== a && f.animationManager.isEnabled && !f.animationManager.isTicking && (null === this.Ip && (this.Ip = new H()), g = 0 === f.undoManager.transactionLevel, a.startCondition === fi ? g = !0 : a.startCondition === hi && (g = !1), g ? (f = new ph(), gi(a, f), g = this.Ip.get(a), null !== g && g.stop(), this.Ip.add(a, f), f.xv = this, f.Mx = a, f.add(this, b, d, e), f.start()) : (Dh(f.animationManager, \"Trigger\"), f.animationManager.defaultAnimation.add(this, b, d, e)))), this instanceof X && c === h && 0 !== (h.F & 16777216) && null !== h.data)) for (c = this.W.j, d = c.length, e = 0; e < d; e++) h = c[e], h instanceof X && Fj(h, function (a) {\n      null !== a.data && 0 !== (a.F & 16777216) && a.Ca(b);\n    });\n  };\n  function fl(a, b, c) {\n    var d = a.ij();\n    if (null !== d) for (var e = a.eb.iterator; e.next();) {\n      var f = e.value,\n        g = null;\n      if (null !== f.sourceName) {\n        g = gl(f, d, a);\n        if (null === g) continue;\n        f.lr(a, g, c, null);\n      } else if (f.isToModel) {\n        var h = b.diagram;\n        null === h || h.skipsModelSourceBindings || f.lr(a, h.model.modelData, c, d);\n      } else {\n        h = d.data;\n        if (null === h) continue;\n        var k = b.diagram;\n        null === k || k.skipsModelSourceBindings || f.lr(a, h, c, d);\n      }\n      g === a && (h = d.Ht(f.vj), null !== h && f.Rw(h, g, c));\n    }\n  }\n  t.Ht = function (a) {\n    return this.Xk === a ? this : null;\n  };\n  t.g = function (a, b, c) {\n    this.ab(ve, a, this, b, c);\n  };\n  function hl(a, b, c, d, e) {\n    var f = a.pc,\n      g = a.cg;\n    g.reset();\n    il(a, g, b, c, d, e);\n    a.cg = g;\n    f.h(b, c, d, e);\n    g.Tt() || g.Ow(f);\n  }\n  function jl(a, b, c, d) {\n    if (!1 === a.pickable) return !1;\n    d.multiply(a.transform);\n    return c ? a.Lc(b, d) : a.Jh(b, d);\n  }\n  t.oy = function (a, b, c) {\n    if (!1 === this.pickable) return !1;\n    var d = this.naturalBounds;\n    b = a.Fe(b);\n    return c ? Cb(a.x, a.y, 0, 0, 0, d.height) <= b || Cb(a.x, a.y, 0, d.height, d.width, d.height) <= b || Cb(a.x, a.y, d.width, d.height, d.width, 0) <= b || Cb(a.x, a.y, d.width, 0, 0, 0) <= b : a.kd(0, 0) <= b && a.kd(0, d.height) <= b && a.kd(d.width, 0) <= b && a.kd(d.width, d.height) <= b;\n  };\n  t.de = function () {\n    return !0;\n  };\n  t.aa = function (a) {\n    var b = J.alloc();\n    b.assign(a);\n    this.transform.sa(b);\n    var c = this.actualBounds;\n    if (!c.u()) return J.free(b), !1;\n    var d = this.diagram;\n    if (null !== d && d.ne) {\n      var e = d.xm(\"extraTouchThreshold\"),\n        f = d.xm(\"extraTouchArea\"),\n        g = f / 2,\n        h = this.naturalBounds;\n      d = this.Af() * d.scale;\n      var k = 1 / d;\n      if (h.width * d < e && h.height * d < e) return a = gc(c.x - g * k, c.y - g * k, c.width + f * k, c.height + f * k, b.x, b.y), J.free(b), a;\n    }\n    e = !1;\n    if (this instanceof He || this instanceof W ? gc(c.x - 5, c.y - 5, c.width + 10, c.height + 10, b.x, b.y) : c.aa(b)) this.pd && !this.pd.aa(b) ? e = !1 : null !== this.dc && c.aa(b) ? e = !0 : null !== this.kb && this.qc.aa(a) ? e = !0 : e = this.Kh(a);\n    J.free(b);\n    return e;\n  };\n  t.Kh = function (a) {\n    var b = this.naturalBounds;\n    return gc(0, 0, b.width, b.height, a.x, a.y);\n  };\n  t.De = function (a) {\n    if (0 === this.angle) return this.actualBounds.De(a);\n    var b = this.naturalBounds;\n    b = N.allocAt(0, 0, b.width, b.height);\n    var c = this.transform,\n      d = !1,\n      e = J.allocAt(a.x, a.y);\n    b.aa(c.Zd(e)) && (e.h(a.x, a.bottom), b.aa(c.Zd(e)) && (e.h(a.right, a.bottom), b.aa(c.Zd(e)) && (e.h(a.right, a.y), b.aa(c.Zd(e)) && (d = !0))));\n    J.free(e);\n    N.free(b);\n    return d;\n  };\n  t.Jh = function (a, b) {\n    if (void 0 === b) return a.De(this.actualBounds);\n    var c = this.naturalBounds,\n      d = !1,\n      e = J.allocAt(0, 0);\n    a.aa(b.sa(e)) && (e.h(0, c.height), a.aa(b.sa(e)) && (e.h(c.width, c.height), a.aa(b.sa(e)) && (e.h(c.width, 0), a.aa(b.sa(e)) && (d = !0))));\n    J.free(e);\n    return d;\n  };\n  t.Lc = function (a, b) {\n    if (void 0 === b && (b = this.transform, 0 === this.angle)) return a.Lc(this.actualBounds);\n    var c = this.naturalBounds,\n      d = J.allocAt(0, 0),\n      e = J.allocAt(0, c.height),\n      f = J.allocAt(c.width, c.height),\n      g = J.allocAt(c.width, 0),\n      h = !1;\n    if (a.aa(b.sa(d)) || a.aa(b.sa(e)) || a.aa(b.sa(f)) || a.aa(b.sa(g))) h = !0;else {\n      c = N.allocAt(0, 0, c.width, c.height);\n      var k = J.allocAt(a.x, a.y);\n      c.aa(b.Zd(k)) ? h = !0 : (k.h(a.x, a.bottom), c.aa(b.Zd(k)) ? h = !0 : (k.h(a.right, a.bottom), c.aa(b.Zd(k)) ? h = !0 : (k.h(a.right, a.y), c.aa(b.Zd(k)) && (h = !0))));\n      J.free(k);\n      N.free(c);\n      !h && (K.Qt(a, d, e) || K.Qt(a, e, f) || K.Qt(a, f, g) || K.Qt(a, g, d)) && (h = !0);\n    }\n    J.free(d);\n    J.free(e);\n    J.free(f);\n    J.free(g);\n    return h;\n  };\n  t.ga = function (a, b) {\n    void 0 === b && (b = new J());\n    if (a instanceof P) {\n      var c = this.naturalBounds;\n      b.h(a.x * c.width + a.offsetX, a.y * c.height + a.offsetY);\n    } else b.set(a);\n    this.Ad.sa(b);\n    return b;\n  };\n  t.wm = function (a) {\n    void 0 === a && (a = new N());\n    var b = this.naturalBounds,\n      c = this.Ad,\n      d = J.allocAt(0, 0).transform(c);\n    a.h(d.x, d.y, 0, 0);\n    d.h(b.width, 0).transform(c);\n    fc(a, d.x, d.y, 0, 0);\n    d.h(b.width, b.height).transform(c);\n    fc(a, d.x, d.y, 0, 0);\n    d.h(0, b.height).transform(c);\n    fc(a, d.x, d.y, 0, 0);\n    J.free(d);\n    return a;\n  };\n  t.lj = function () {\n    var a = this.Ad;\n    1 === a.m11 && 0 === a.m12 ? a = 0 : (a = 180 * Math.atan2(a.m12, a.m11) / Math.PI, 0 > a && (a += 360));\n    return a;\n  };\n  t.Af = function () {\n    if (0 !== (this.F & 4096) === !1) return this.jl;\n    var a = this.ya;\n    return null !== this.panel ? a * this.panel.Af() : a;\n  };\n  t.Nt = function (a, b) {\n    void 0 === b && (b = new J());\n    b.assign(a);\n    this.Ad.Zd(b);\n    return b;\n  };\n  t.bd = function (a, b, c) {\n    return this.vk(a.x, a.y, b.x, b.y, c);\n  };\n  t.vk = function (a, b, c, d, e) {\n    var f = this.transform,\n      g = 1 / (f.m11 * f.m22 - f.m12 * f.m21),\n      h = f.m22 * g,\n      k = -f.m12 * g,\n      l = -f.m21 * g,\n      m = f.m11 * g,\n      n = g * (f.m21 * f.dy - f.m22 * f.dx),\n      p = g * (f.m12 * f.dx - f.m11 * f.dy);\n    if (null !== this.areaBackground) return f = this.actualBounds, K.bd(f.left, f.top, f.right, f.bottom, a, b, c, d, e);\n    g = a * h + b * l + n;\n    a = a * k + b * m + p;\n    b = c * h + d * l + n;\n    c = c * k + d * m + p;\n    e.h(0, 0);\n    d = this.naturalBounds;\n    c = K.bd(0, 0, d.width, d.height, g, a, b, c, e);\n    e.transform(f);\n    return c;\n  };\n  Y.prototype.measure = function (a, b, c, d) {\n    if (!1 !== sj(this)) {\n      var e = this.ih,\n        f = e.right + e.left;\n      e = e.top + e.bottom;\n      a = Math.max(a - f, 0);\n      b = Math.max(b - e, 0);\n      c = Math.max((c || 0) - f, 0);\n      d = Math.max((d || 0) - e, 0);\n      f = this.angle;\n      e = this.desiredSize;\n      var g = 0;\n      this instanceof W && (g = this.strokeWidth);\n      90 === f || 270 === f ? (a = isFinite(e.height) ? e.height + g : a, b = isFinite(e.width) ? e.width + g : b) : (a = isFinite(e.width) ? e.width + g : a, b = isFinite(e.height) ? e.height + g : b);\n      e = c || 0;\n      g = d || 0;\n      var h = this instanceof X;\n      switch (kl(this, !0)) {\n        case yg:\n          g = e = 0;\n          h && (b = a = Infinity);\n          break;\n        case vd:\n          isFinite(a) && a > c && (e = a);\n          isFinite(b) && b > d && (g = b);\n          break;\n        case Wk:\n          isFinite(a) && a > c && (e = a);\n          g = 0;\n          h && (b = Infinity);\n          break;\n        case Xk:\n          isFinite(b) && b > d && (g = b), e = 0, h && (a = Infinity);\n      }\n      h = this.maxSize;\n      var k = this.minSize;\n      e > h.width && k.width < h.width && (e = h.width);\n      g > h.height && k.height < h.height && (g = h.height);\n      c = Math.max(e / this.scale, k.width);\n      d = Math.max(g / this.scale, k.height);\n      h.width < c && (c = Math.min(k.width, c));\n      h.height < d && (d = Math.min(k.height, d));\n      a = Math.min(h.width, a);\n      b = Math.min(h.height, b);\n      a = Math.max(c, a);\n      b = Math.max(d, b);\n      if (90 === f || 270 === f) f = a, a = b, b = f, f = c, c = d, d = f;\n      this.pc.ea();\n      this.Dm(a, b, c, d);\n      this.pc.freeze();\n      this.pc.u() || B(\"Non-real measuredBounds has been set. Object \" + this + \", measuredBounds: \" + this.pc.toString());\n      nj(this, !1);\n    }\n  };\n  Y.prototype.Dm = function () {};\n  Y.prototype.Ef = function () {\n    return !1;\n  };\n  Y.prototype.arrange = function (a, b, c, d, e) {\n    this.zl();\n    var f = N.alloc();\n    f.assign(this.xb);\n    this.xb.ea();\n    !1 === tj(this) ? this.xb.h(a, b, c, d) : this.Ih(a, b, c, d);\n    this.xb.freeze();\n    void 0 === e ? this.pd = null : this.pd = e;\n    c = !1;\n    if (void 0 !== e) c = !0;else if (e = this.panel, null === e || e.type !== X.TableRow && e.type !== X.TableColumn || (e = e.panel), null !== e && (e = e.qc, d = this.measuredBounds, null !== this.areaBackground && (d = this.xb), c = b + d.height, d = a + d.width, c = !(0 <= a + .05 && d <= e.width + .05 && 0 <= b + .05 && c <= e.height + .05), this instanceof Vg && (a = this.naturalBounds, this.ws > a.height || this.sb > a.width))) c = !0;\n    this.F = c ? this.F | 256 : this.F & -257;\n    this.xb.u() || B(\"Non-real actualBounds has been set. Object \" + this + \", actualBounds: \" + this.xb.toString());\n    this.cu(f, this.xb);\n    ll(this, !1);\n    N.free(f);\n  };\n  t = Y.prototype;\n  t.Ih = function () {};\n  function ml(a, b, c, d, e) {\n    a.xb.h(b, c, d, e);\n    if (!a.desiredSize.u()) {\n      var f = a.pc;\n      c = a.ih;\n      b = c.right + c.left;\n      var g = c.top + c.bottom;\n      c = f.width + b;\n      f = f.height + g;\n      d += b;\n      e += g;\n      b = kl(a, !0);\n      c === d && f === e && (b = yg);\n      switch (b) {\n        case yg:\n          if (c > d || f > e) nj(a, !0), a.measure(c > d ? d : c, f > e ? e : f, 0, 0);\n          break;\n        case vd:\n          nj(a, !0);\n          a.measure(d, e, 0, 0);\n          break;\n        case Wk:\n          nj(a, !0);\n          a.measure(d, f, 0, 0);\n          break;\n        case Xk:\n          nj(a, !0), a.measure(c, e, 0, 0);\n      }\n    }\n  }\n  t.cu = function (a, b) {\n    var c = this.part;\n    null !== c && null !== c.diagram && (c.selectionObject !== this && c.resizeObject !== this && c.rotateObject !== this || nl(c, !0), this.M(), ac(a, b) || (c.Oh(), this.ip(c)));\n  };\n  t.ip = function (a) {\n    null !== this.portId && (nl(a, !0), a instanceof V && ol(a, this));\n  };\n  t.bc = function (a, b) {\n    if (this.visible) {\n      var c = this instanceof X && (this.type === X.TableRow || this.type === X.TableColumn),\n        d = this.xb;\n      if (c || 0 !== d.width && 0 !== d.height && !isNaN(d.x) && !isNaN(d.y)) {\n        var e = this.opacity;\n        if (0 !== e) {\n          var f = 1;\n          1 !== e && (f = a.globalAlpha, a.globalAlpha = f * e);\n          if (!this.iy(a, b)) if (c) pl(this, a, b);else {\n            this instanceof S && this.Bk(!1);\n            c = this.transform;\n            var g = this.panel;\n            0 !== (this.F & 4096) === !0 && ql(this);\n            var h = this.part,\n              k = !1,\n              l = 0;\n            if (h && b.Ge(\"drawShadows\") && (k = h.isShadowed)) {\n              var m = h.shadowOffset;\n              l = Math.max(m.y, m.x) * b.scale * b.Sb;\n            }\n            if (!(m = b.xi || !this.Ef())) {\n              var n = this.naturalBounds;\n              m = this.Zh;\n              var p = m.m11,\n                r = m.m21,\n                q = m.dx,\n                u = m.m12,\n                v = m.m22,\n                w = m.dy,\n                y,\n                z = y = 0;\n              m = y * p + z * r + q;\n              var A = y * u + z * v + w;\n              y = n.width + l;\n              z = 0;\n              var C = y * p + z * r + q;\n              y = y * u + z * v + w;\n              z = Math.min(m, C);\n              var G = Math.min(A, y);\n              var L = Math.max(m + 0, C) - z;\n              var I = Math.max(A + 0, y) - G;\n              m = z;\n              A = G;\n              y = n.width + l;\n              z = n.height + l;\n              C = y * p + z * r + q;\n              y = y * u + z * v + w;\n              z = Math.min(m, C);\n              G = Math.min(A, y);\n              L = Math.max(m + L, C) - z;\n              I = Math.max(A + I, y) - G;\n              m = z;\n              A = G;\n              y = 0;\n              z = n.height + l;\n              C = y * p + z * r + q;\n              y = y * u + z * v + w;\n              z = Math.min(m, C);\n              G = Math.min(A, y);\n              L = Math.max(m + L, C) - z;\n              I = Math.max(A + I, y) - G;\n              m = z;\n              A = G;\n              l = b.viewportBounds;\n              n = l.x;\n              p = l.y;\n              m = !(m > l.width + n || n > L + m || A > l.height + p || p > I + A);\n            }\n            if (m) {\n              m = 0 !== (this.F & 256);\n              a.clipInsteadOfFill && (m = !1);\n              this instanceof Vg && (a.font = this.font);\n              if (m) {\n                A = g.de() ? g.naturalBounds : g.actualBounds;\n                null !== this.pd ? (n = this.pd, L = n.x, I = n.y, l = n.width, n = n.height) : (L = Math.max(d.x, A.x), I = Math.max(d.y, A.y), l = Math.min(d.right, A.right) - L, n = Math.min(d.bottom, A.bottom) - I);\n                if (L > d.width + d.x || d.x > A.width + A.x) {\n                  1 !== e && (a.globalAlpha = f);\n                  return;\n                }\n                a.save();\n                a.beginPath();\n                a.rect(L, I, l, n);\n                a.clip();\n              }\n              if (this.Ef()) {\n                if (!h.isVisible()) {\n                  1 !== e && (a.globalAlpha = f);\n                  return;\n                }\n                k && (A = h.shadowOffset, a.Hw(A.x * b.scale * b.Sb, A.y * b.scale * b.Sb, h.shadowBlur), rl(a), a.shadowColor = h.shadowColor);\n              }\n              !0 === this.shadowVisible ? rl(a) : !1 === this.shadowVisible && sl(a);\n              h = this.naturalBounds;\n              null !== this.dc && (li(this, a, this.dc, !0, !0, h, d), this.dc instanceof tl && this.dc.type === ul ? (a.beginPath(), a.rect(d.x, d.y, d.width, d.height), a.Yd(this.dc)) : a.fillRect(d.x, d.y, d.width, d.height));\n              a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy);\n              k && (null !== g && 0 !== (g.F & 512) || null !== g && (g.type === X.Auto || g.type === X.Spot) && g.pb() !== this) && null === this.shadowVisible && sl(a);\n              null !== this.kb && (l = this.naturalBounds, L = A = 0, I = l.width, l = l.height, n = 0, this instanceof W && (l = this.na.bounds, A = l.x, L = l.y, I = l.width, l = l.height, n = this.strokeWidth), li(this, a, this.kb, !0, !1, h, d), this.kb instanceof tl && this.kb.type === ul ? (a.beginPath(), a.rect(A - n / 2, L - n / 2, I + n, l + n), a.Yd(this.kb)) : a.fillRect(A - n / 2, L - n / 2, I + n, l + n));\n              k && (null !== this.kb || null !== this.dc || null !== g && 0 !== (g.F & 512) || null !== g && (g.type === X.Auto || g.type === X.Spot) && g.pb() !== this) ? (vl(this, !0), null === this.shadowVisible && sl(a)) : vl(this, !1);\n              this.ej(a, b);\n              k && 0 !== (this.F & 512) === !0 && rl(a);\n              this.Ef() && k && sl(a);\n              m ? (a.restore(), this instanceof X ? a.tc(!0) : a.tc(!1)) : c.Tt() || (b = 1 / (c.m11 * c.m22 - c.m12 * c.m21), a.transform(c.m22 * b, -c.m12 * b, -c.m21 * b, c.m11 * b, b * (c.m21 * c.dy - c.m22 * c.dx), b * (c.m12 * c.dx - c.m11 * c.dy)));\n            }\n          }\n          1 !== e && (a.globalAlpha = f);\n        }\n      }\n    }\n  };\n  t.iy = function () {\n    return !1;\n  };\n  function pl(a, b, c) {\n    var d = a.xb,\n      e = a.qc;\n    null !== a.dc && (li(a, b, a.dc, !0, !0, e, d), a.dc instanceof tl && a.dc.type === ul ? (b.beginPath(), b.rect(d.x, d.y, d.width, d.height), b.Yd(a.dc)) : b.fillRect(d.x, d.y, d.width, d.height));\n    null !== a.kb && (li(a, b, a.kb, !0, !1, e, d), a.kb instanceof tl && a.kb.type === ul ? (b.beginPath(), b.rect(d.x, d.y, d.width, d.height), b.Yd(a.kb)) : b.fillRect(d.x, d.y, d.width, d.height));\n    a.ej(b, c);\n  }\n  t.ej = function () {};\n  function li(a, b, c, d, e, f, g) {\n    if (null !== c) {\n      var h = 1,\n        k = 1;\n      if (\"string\" === typeof c) d ? b.fillStyle = c : b.strokeStyle = c;else if (c.type === wl) d ? b.fillStyle = c.color : b.strokeStyle = c.color;else {\n        var l = 0;\n        a instanceof W && (l = a.strokeWidth);\n        h = f.width;\n        k = f.height;\n        e ? (h = g.width, k = g.height) : d || (h += l, k += l);\n        if ((f = b instanceof xl) && c.ge && (c.type === yl || c.$k === h && c.zu === k)) var m = c.ge;else {\n          var n = 0,\n            p = 0,\n            r = 0,\n            q = 0,\n            u = 0,\n            v = 0;\n          v = u = 0;\n          e ? (u = g.x, v = g.y) : d || (u -= l / 2, v -= l / 2);\n          n = c.start.x * h + c.start.offsetX;\n          p = c.start.y * k + c.start.offsetY;\n          r = c.end.x * h + c.end.offsetX;\n          q = c.end.y * k + c.end.offsetY;\n          n += u;\n          r += u;\n          p += v;\n          q += v;\n          if (c.type === zl) m = b.createLinearGradient(n, p, r, q);else if (c.type === ul) v = isNaN(c.endRadius) ? Math.max(h, k) / 2 : c.endRadius, isNaN(c.startRadius) ? (u = 0, v = Math.max(h, k) / 2) : u = c.startRadius, m = b.createRadialGradient(n, p, u, r, q, v);else if (c.type === yl) try {\n            m = b.createPattern(c.pattern, \"repeat\");\n          } catch (y) {\n            m = null;\n          }\n          if (c.type !== yl && (e = c.colorStops, null !== e)) for (e = e.iterator; e.next();) m.addColorStop(e.key, e.value);\n          if (f && (c.ge = m, null !== m && (c.$k = h, c.zu = k), null === m && c.type === yl && -1 !== c.$k)) {\n            c.$k = -1;\n            var w = a.diagram;\n            null !== w && -1 === c.$k && sa(function () {\n              w.Je();\n            }, 600);\n          }\n        }\n        d ? b.fillStyle = m : b.strokeStyle = m;\n      }\n    }\n  }\n  t.Gg = function (a) {\n    if (a instanceof X) a: {\n      if (this !== a && null !== a) for (var b = this.panel; null !== b;) {\n        if (b === a) {\n          a = !0;\n          break a;\n        }\n        b = b.panel;\n      }\n      a = !1;\n    } else a = !1;\n    return a;\n  };\n  t.Ff = function () {\n    if (!this.visible) return !1;\n    var a = this.panel;\n    return null !== a ? a.Ff() : !0;\n  };\n  t.Hg = function () {\n    for (var a = this instanceof X ? this : this.panel; null !== a && a.isEnabled;) a = a.panel;\n    return null === a;\n  };\n  function ql(a) {\n    if (0 !== (a.F & 2048) === !0) {\n      var b = a.ob;\n      b.reset();\n      if (!a.xb.u() || !a.pc.u()) {\n        Al(a, !1);\n        return;\n      }\n      b.translate(a.xb.x - a.pc.x, a.xb.y - a.pc.y);\n      if (1 !== a.scale || 0 !== a.angle) {\n        var c = a.naturalBounds;\n        il(a, b, c.x, c.y, c.width, c.height);\n      }\n      Al(a, !1);\n      Bl(a, !0);\n    }\n    0 !== (a.F & 4096) === !0 && (b = a.panel, null === b ? (a.Zh.set(a.ob), a.jl = a.scale, Bl(a, !1)) : null !== b.Ad && (c = a.Zh, c.reset(), b.de() ? c.multiply(b.Zh) : null !== b.panel && c.multiply(b.panel.Zh), c.multiply(a.ob), a.jl = a.scale * b.jl, Bl(a, !1)));\n  }\n  function il(a, b, c, d, e, f) {\n    1 !== a.scale && b.scale(a.scale);\n    if (0 !== a.Yb) {\n      var g = Bc;\n      a.Ef() && a.locationSpot.ib() && (g = a.locationSpot);\n      var h = J.alloc();\n      if (a instanceof U && a.locationObject !== a) for (c = a.locationObject, d = c.naturalBounds, h.Lk(d.x, d.y, d.width, d.height, g), c.cg.sa(h), h.offset(-c.measuredBounds.x, -c.measuredBounds.y), g = c.panel; null !== g && g !== a;) g.cg.sa(h), h.offset(-g.measuredBounds.x, -g.measuredBounds.y), g = g.panel;else h.Lk(c, d, e, f, g);\n      b.rotate(a.Yb, h.x, h.y);\n      J.free(h);\n    }\n  }\n  t.o = function (a) {\n    void 0 === a && (a = !1);\n    if (!0 !== sj(this)) {\n      nj(this, !0);\n      ll(this, !0);\n      var b = this.panel;\n      null === b || a || b.o();\n    }\n  };\n  t.zm = function () {\n    !0 !== sj(this) && (nj(this, !0), ll(this, !0));\n  };\n  function Cl(a) {\n    if (!1 === tj(a)) {\n      var b = a.panel;\n      null !== b ? b.o() : a.Ef() && (b = a.diagram, null !== b && (b.rd.add(a), a instanceof V && a.md(), b.Db()));\n      ll(a, !0);\n    }\n  }\n  t.zl = function () {\n    0 !== (this.F & 2048) === !1 && (Al(this, !0), Bl(this, !0));\n  };\n  t.cw = function () {\n    Bl(this, !0);\n  };\n  t.M = function () {\n    var a = this.part;\n    null !== a && a.M();\n  };\n  function kl(a, b) {\n    var c = a.stretch,\n      d = a.panel;\n    if (null !== d && d.type === X.Table) return Dl(a, d.getRowDefinition(a.row), d.getColumnDefinition(a.column), b);\n    if (null !== d && d.type === X.Auto && d.pb() === a) return El(a, vd, b);\n    if (c === Vk) {\n      if (null !== d) {\n        if (d.type === X.Spot && d.pb() === a) return El(a, vd, b);\n        c = d.defaultStretch;\n        return c === Vk ? El(a, yg, b) : El(a, c, b);\n      }\n      return El(a, yg, b);\n    }\n    return El(a, c, b);\n  }\n  function Dl(a, b, c, d) {\n    var e = a.stretch;\n    if (e !== Vk) return El(a, e, d);\n    var f = e = null;\n    switch (b.stretch) {\n      case Xk:\n        f = !0;\n        break;\n      case vd:\n        f = !0;\n    }\n    switch (c.stretch) {\n      case Wk:\n        e = !0;\n        break;\n      case vd:\n        e = !0;\n    }\n    b = a.panel.defaultStretch;\n    null === e && (e = b === Wk || b === vd);\n    null === f && (f = b === Xk || b === vd);\n    return !0 === e && !0 === f ? El(a, vd, d) : !0 === e ? El(a, Wk, d) : !0 === f ? El(a, Xk, d) : El(a, yg, d);\n  }\n  function El(a, b, c) {\n    if (c) return b;\n    if (b === yg) return yg;\n    c = a.desiredSize;\n    if (c.u()) return yg;\n    a = a.angle;\n    if (!isNaN(c.width)) if (90 !== a && 270 !== a) {\n      if (b === Wk) return yg;\n      if (b === vd) return Xk;\n    } else {\n      if (b === Xk) return yg;\n      if (b === vd) return Wk;\n    }\n    if (!isNaN(c.height)) if (90 !== a && 270 !== a) {\n      if (b === Xk) return yg;\n      if (b === vd) return Wk;\n    } else {\n      if (b === Wk) return yg;\n      if (b === vd) return Xk;\n    }\n    return b;\n  }\n  function vl(a, b) {\n    a.F = b ? a.F | 512 : a.F & -513;\n  }\n  function el(a) {\n    return 0 !== (a.F & 1024);\n  }\n  function Fl(a, b) {\n    a.F = b ? a.F | 1024 : a.F & -1025;\n  }\n  function Al(a, b) {\n    a.F = b ? a.F | 2048 : a.F & -2049;\n  }\n  function Bl(a, b) {\n    a.F = b ? a.F | 4096 : a.F & -4097;\n  }\n  function sj(a) {\n    return 0 !== (a.F & 8192);\n  }\n  function nj(a, b) {\n    a.F = b ? a.F | 8192 : a.F & -8193;\n  }\n  function tj(a) {\n    return 0 !== (a.F & 16384);\n  }\n  function ll(a, b) {\n    a.F = b ? a.F | 16384 : a.F & -16385;\n  }\n  t.rj = function (a) {\n    this.og = a;\n  };\n  t.lu = function () {};\n  t.Dw = function (a) {\n    this.la.assign(a);\n    Cl(this);\n    return !0;\n  };\n  t.fr = function (a, b) {\n    if (this.la.x !== a || this.la.y !== b) this.la.h(a, b), this.zl();\n  };\n  function Gl(a) {\n    var b = a.part;\n    if (b instanceof V && (null !== a.portId || a === b.port)) {\n      var c = b.diagram;\n      null === c || c.undoManager.isUndoingRedoing || ol(b, a);\n    }\n  }\n  function Hl(a) {\n    var b = a.diagram;\n    null === b || b.undoManager.isUndoingRedoing || (a instanceof X ? a instanceof V ? a.md() : a.Zm(a, function (a) {\n      Gl(a);\n    }) : Gl(a));\n  }\n  t.bind = function (a) {\n    a.jd = this;\n    var b = this.ij();\n    null !== b && Il(b) && B(\"Cannot add a Binding to a template that has already been copied: \" + a);\n    null === this.eb && (this.eb = new E());\n    this.eb.add(a);\n  };\n  t.ij = function () {\n    for (var a = this instanceof X ? this : this.panel; null !== a;) {\n      if (null !== a.li) return a;\n      a = a.panel;\n    }\n    return null;\n  };\n  t.Ew = function (a) {\n    zj(this, a);\n  };\n  function Jl(a, b) {\n    b.jd = a;\n    null === a.Mg && (a.Mg = new H());\n    a.Mg.add(b.propertyName, b);\n  }\n  function Kl(a, b) {\n    for (var c = 1; c < arguments.length; ++c);\n    c = arguments;\n    var d = null,\n      e = null;\n    if (\"function\" === typeof a) e = a;else if (\"string\" === typeof a) {\n      var f = Ll.H(a);\n      \"function\" === typeof f ? (c = Ba(arguments), d = f(c), ya(d) || B('GraphObject.make invoked object builder \"' + a + '\", but it did not return an Object')) : e = x.go[a];\n    }\n    null === d && (void 0 !== e && null !== e && e.constructor || B(\"GraphObject.make requires a class function or GoJS class name or name of an object builder, not: \" + a), d = new e());\n    e = 1;\n    if (d instanceof Q && 1 < c.length) {\n      f = d;\n      var g = c[1];\n      if (\"string\" === typeof g || g instanceof HTMLDivElement) Hi(f, g), e++;\n    }\n    for (; e < c.length; e++) f = c[e], void 0 === f ? B(\"Undefined value at argument \" + e + \" for object being constructed by GraphObject.make: \" + d) : Ml(d, f);\n    return d;\n  }\n  function Ml(a, b) {\n    if (\"string\" === typeof b) {\n      if (a instanceof Vg) a.text = b;else if (a instanceof W) a.figure = b;else if (a instanceof Zj) a.source = b;else if (a instanceof X) b = Nl.H(b), null !== b && (a.type = b);else if (a instanceof tl) {\n        var c = Za(tl, b);\n        null !== c ? a.type = c : B(\"Unknown Brush type as an argument to GraphObject.make: \" + b);\n      } else a instanceof td ? (b = Za(td, b), null !== b && (a.type = b)) : a instanceof pe && (b = Za(pe, b), null !== b && (a.type = b));\n    } else if (b instanceof Y) a instanceof X || B(\"A GraphObject can only be added to a Panel, not to: \" + a), a.add(b);else if (b instanceof Tj) {\n      var d;\n      b.isRow && \"function\" === typeof a.getRowDefinition ? d = a.getRowDefinition(b.index) : b.isRow || \"function\" !== typeof a.getColumnDefinition || (d = a.getColumnDefinition(b.index));\n      d instanceof Tj ? d.Dt(b) : B(\"A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: \" + a);\n    } else if (b instanceof D) \"function\" === typeof a.hb && a.hb(b);else if (b instanceof Ol) a.type = b;else if (b instanceof Li) a instanceof Y ? a.bind(b) : a instanceof Tj ? a.bind(b) : B(\"A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: \" + a);else if (b instanceof di) a instanceof Y ? Jl(a, b) : B(\"An AnimationTrigger can only be applied to a GraphObject, not to: \" + a);else if (b instanceof he) a instanceof td ? a.figures.add(b) : B(\"A PathFigure can only be added to a Geometry, not to: \" + a);else if (b instanceof pe) a instanceof he ? a.segments.add(b) : B(\"A PathSegment can only be added to a PathFigure, not to: \" + a);else if (b instanceof yi) a instanceof Q ? a.layout = b : a instanceof vf ? a.layout = b : B(\"A Layout can only be assigned to a Diagram or a Group, not to: \" + a);else if (Array.isArray(b)) for (c = 0; c < b.length; c++) Ml(a, b[c]);else if (\"object\" === typeof b && null !== b) {\n      if (a instanceof tl) {\n        c = new ab();\n        for (var e in b) d = parseFloat(e), isNaN(d) ? c[e] = b[e] : a.addColorStop(d, b[e]);\n        zj(a, c);\n      } else if (a instanceof Tj) {\n        void 0 !== b.row ? (e = b.row, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && B(\"Must specify non-negative integer row for RowColumnDefinition \" + b + \", not: \" + e), a.isRow = !0, a.index = e) : void 0 !== b.column && (e = b.column, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && B(\"Must specify non-negative integer column for RowColumnDefinition \" + b + \", not: \" + e), a.isRow = !1, a.index = e);\n        e = new ab();\n        for (c in b) \"row\" !== c && \"column\" !== c && (e[c] = b[c]);\n        zj(a, e);\n      } else zj(a, b);\n    } else B('Unknown initializer \"' + b + '\" for object being constructed by GraphObject.make: ' + a);\n  }\n  function Pl(a, b) {\n    Ll.add(a, b);\n  }\n  function Ql(a, b, c) {\n    void 0 === c && (c = null);\n    var d = a[1];\n    if (\"function\" === typeof c ? c(d) : \"string\" === typeof d) return a.splice(1, 1), d;\n    if (void 0 === b) throw Error(\"no \" + (\"function\" === typeof c ? \"satisfactory\" : \"string\") + \" argument for GraphObject builder \" + a[0]);\n    return b;\n  }\n  ma.Object.defineProperties(Y.prototype, {\n    shadowVisible: {\n      get: function () {\n        return this.Zl;\n      },\n      set: function (a) {\n        var b = this.Zl;\n        b !== a && (this.Zl = a, this.M(), this.g(\"shadowVisible\", b, a));\n      }\n    },\n    enabledChanged: {\n      get: function () {\n        return null !== this.N ? this.N.Vn : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Vn;\n        b !== a && (this.N.Vn = a, this.g(\"enabledChanged\", b, a));\n      }\n    },\n    segmentOrientation: {\n      get: function () {\n        return this.Xl;\n      },\n      set: function (a) {\n        var b = this.Xl;\n        b !== a && (this.Xl = a, this.o(), this.g(\"segmentOrientation\", b, a), a === bg && (this.angle = 0));\n      }\n    },\n    segmentIndex: {\n      get: function () {\n        return this.Mp;\n      },\n      set: function (a) {\n        a = Math.round(a);\n        var b = this.Mp;\n        b !== a && (this.Mp = a, this.o(), this.g(\"segmentIndex\", b, a));\n      }\n    },\n    segmentFraction: {\n      get: function () {\n        return this.Vl;\n      },\n      set: function (a) {\n        isNaN(a) ? a = 0 : 0 > a ? a = 0 : 1 < a && (a = 1);\n        var b = this.Vl;\n        b !== a && (this.Vl = a, this.o(), this.g(\"segmentFraction\", b, a));\n      }\n    },\n    segmentOffset: {\n      get: function () {\n        return this.Wl;\n      },\n      set: function (a) {\n        var b = this.Wl;\n        b.w(a) || (this.Wl = a = a.G(), this.o(), this.g(\"segmentOffset\", b, a));\n      }\n    },\n    stretch: {\n      get: function () {\n        return this.ze;\n      },\n      set: function (a) {\n        var b = this.ze;\n        b !== a && (this.ze = a, this.o(), this.g(\"stretch\", b, a));\n      }\n    },\n    name: {\n      get: function () {\n        return this.Qa;\n      },\n      set: function (a) {\n        var b = this.Qa;\n        b !== a && (this.Qa = a, null !== this.part && (this.part.Uj = null), this.g(\"name\", b, a));\n      }\n    },\n    opacity: {\n      get: function () {\n        return this.tb;\n      },\n      set: function (a) {\n        var b = this.tb;\n        b !== a && ((0 > a || 1 < a) && va(a, \"0 <= value <= 1\", Y, \"opacity\"), this.tb = a, this.g(\"opacity\", b, a), a = this.diagram, b = this.part, null !== a && null !== b && a.M(Dj(b, b.actualBounds)));\n      }\n    },\n    visible: {\n      get: function () {\n        return 0 !== (this.F & 1);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 1);\n        b !== a && (this.F ^= 1, this.g(\"visible\", b, a), b = this.panel, null !== b ? b.o() : this.Ef() && this.Ob(a), this.M(), Hl(this));\n      }\n    },\n    pickable: {\n      get: function () {\n        return 0 !== (this.F & 2);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 2);\n        b !== a && (this.F ^= 2, this.g(\"pickable\", b, a));\n      }\n    },\n    fromLinkableDuplicates: {\n      get: function () {\n        return 0 !== (this.F & 4);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 4);\n        b !== a && (this.F ^= 4, this.g(\"fromLinkableDuplicates\", b, a));\n      }\n    },\n    fromLinkableSelfNode: {\n      get: function () {\n        return 0 !== (this.F & 8);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 8);\n        b !== a && (this.F ^= 8, this.g(\"fromLinkableSelfNode\", b, a));\n      }\n    },\n    toLinkableDuplicates: {\n      get: function () {\n        return 0 !== (this.F & 16);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 16);\n        b !== a && (this.F ^= 16, this.g(\"toLinkableDuplicates\", b, a));\n      }\n    },\n    toLinkableSelfNode: {\n      get: function () {\n        return 0 !== (this.F & 32);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 32);\n        b !== a && (this.F ^= 32, this.g(\"toLinkableSelfNode\", b, a));\n      }\n    },\n    isPanelMain: {\n      get: function () {\n        return 0 !== (this.F & 64);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 64);\n        b !== a && (this.F ^= 64, this.o(), this.g(\"isPanelMain\", b, a));\n      }\n    },\n    isActionable: {\n      get: function () {\n        return 0 !== (this.F & 128);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 128);\n        b !== a && (this.F ^= 128, this.g(\"isActionable\", b, a));\n      }\n    },\n    areaBackground: {\n      get: function () {\n        return this.dc;\n      },\n      set: function (a) {\n        var b = this.dc;\n        b !== a && (null !== a && Rl(a, \"GraphObject.areaBackground\"), a instanceof tl && a.freeze(), this.dc = a, this.M(), this.g(\"areaBackground\", b, a));\n      }\n    },\n    background: {\n      get: function () {\n        return this.kb;\n      },\n      set: function (a) {\n        var b = this.kb;\n        b !== a && (null !== a && Rl(a, \"GraphObject.background\"), a instanceof tl && a.freeze(), this.kb = a, this.M(), this.g(\"background\", b, a));\n      }\n    },\n    part: {\n      get: function () {\n        if (this.Ef()) return this;\n        if (null !== this.Yj) return this.Yj;\n        var a;\n        for (a = this.panel; a;) {\n          if (a instanceof U) return this.Yj = a;\n          a = a.panel;\n        }\n        return null;\n      }\n    },\n    svg: {\n      get: function () {\n        return this.eq;\n      },\n      set: function (a) {\n        this.eq = a;\n      }\n    },\n    panel: {\n      get: function () {\n        return this.og;\n      }\n    },\n    layer: {\n      get: function () {\n        var a = this.part;\n        return null !== a ? a.layer : null;\n      }\n    },\n    diagram: {\n      get: function () {\n        var a = this.part;\n        return null !== a ? a.diagram : null;\n      }\n    },\n    position: {\n      get: function () {\n        return this.la;\n      },\n      set: function (a) {\n        var b = a.x,\n          c = a.y,\n          d = this.la,\n          e = d.x,\n          f = d.y;\n        (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) ? this.lu() : (a = a.copy(), this.Dw(a, d) && this.g(\"position\", d.copy(), a.copy()));\n      }\n    },\n    actualBounds: {\n      get: function () {\n        return this.xb;\n      }\n    },\n    scale: {\n      get: function () {\n        return this.ya;\n      },\n      set: function (a) {\n        var b = this.ya;\n        b !== a && (0 >= a && B(\"GraphObject.scale for \" + this + \" must be greater than zero, not: \" + a), this.ya = a, this.o(), this.g(\"scale\", b, a));\n      }\n    },\n    angle: {\n      get: function () {\n        return this.Yb;\n      },\n      set: function (a) {\n        var b = this.Yb;\n        b !== a && (a %= 360, 0 > a && (a += 360), b !== a && (this.Yb = a, Hl(this), this.o(), this.g(\"angle\", b, a)));\n      }\n    },\n    desiredSize: {\n      get: function () {\n        return this.Uc;\n      },\n      set: function (a) {\n        var b = a.width,\n          c = a.height,\n          d = this.Uc,\n          e = d.width,\n          f = d.height;\n        (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (this.Uc = a = a.G(), this.o(), this instanceof W && this.cc(), this.g(\"desiredSize\", d, a), el(this) && (a = this.part, null !== a && (fl(this, a, \"width\"), fl(this, a, \"height\"))));\n      }\n    },\n    width: {\n      get: function () {\n        return this.Uc.width;\n      },\n      set: function (a) {\n        var b = this.Uc.width;\n        b === a || isNaN(b) && isNaN(a) || (b = this.Uc, this.Uc = a = new M(a, this.Uc.height).freeze(), this.o(), this instanceof W && this.cc(), this.g(\"desiredSize\", b, a), el(this) && (a = this.part, null !== a && fl(this, a, \"width\")));\n      }\n    },\n    height: {\n      get: function () {\n        return this.Uc.height;\n      },\n      set: function (a) {\n        var b = this.Uc.height;\n        b === a || isNaN(b) && isNaN(a) || (b = this.Uc, this.Uc = a = new M(this.Uc.width, a).freeze(), this.o(), this instanceof W && this.cc(), this.g(\"desiredSize\", b, a), el(this) && (a = this.part, null !== a && fl(this, a, \"height\")));\n      }\n    },\n    minSize: {\n      get: function () {\n        return this.fg;\n      },\n      set: function (a) {\n        var b = this.fg;\n        b.w(a) || (a = a.copy(), isNaN(a.width) && (a.width = 0), isNaN(a.height) && (a.height = 0), a.freeze(), this.fg = a, this.o(), this.g(\"minSize\", b, a));\n      }\n    },\n    maxSize: {\n      get: function () {\n        return this.eg;\n      },\n      set: function (a) {\n        var b = this.eg;\n        b.w(a) || (a = a.copy(), isNaN(a.width) && (a.width = Infinity), isNaN(a.height) && (a.height = Infinity), a.freeze(), this.eg = a, this.o(), this.g(\"maxSize\", b, a));\n      }\n    },\n    measuredBounds: {\n      get: function () {\n        return this.pc;\n      }\n    },\n    naturalBounds: {\n      get: function () {\n        return this.qc;\n      }\n    },\n    margin: {\n      get: function () {\n        return this.ih;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.ih;\n        b.w(a) || (this.ih = a = a.G(), this.o(), this.g(\"margin\", b, a));\n      }\n    },\n    transform: {\n      get: function () {\n        0 !== (this.F & 2048) === !0 && ql(this);\n        return this.ob;\n      }\n    },\n    Ad: {\n      get: function () {\n        0 !== (this.F & 4096) === !0 && ql(this);\n        return this.Zh;\n      }\n    },\n    alignment: {\n      get: function () {\n        return this.yb;\n      },\n      set: function (a) {\n        var b = this.yb;\n        b.w(a) || (a.mc() && !a.Mb() && B(\"GraphObject.alignment for \" + this + \" must be a real Spot or Spot.Default, not: \" + a), this.yb = a = a.G(), Cl(this), this.g(\"alignment\", b, a));\n      }\n    },\n    column: {\n      get: function () {\n        return this.Rg;\n      },\n      set: function (a) {\n        a = Math.round(a);\n        var b = this.Rg;\n        b !== a && (0 > a && va(a, \">= 0\", Y, \"column\"), this.Rg = a, this.o(), this.g(\"column\", b, a));\n      }\n    },\n    columnSpan: {\n      get: function () {\n        return this.yn;\n      },\n      set: function (a) {\n        a = Math.round(a);\n        var b = this.yn;\n        b !== a && (1 > a && va(a, \">= 1\", Y, \"columnSpan\"), this.yn = a, this.o(), this.g(\"columnSpan\", b, a));\n      }\n    },\n    row: {\n      get: function () {\n        return this.Fp;\n      },\n      set: function (a) {\n        a = Math.round(a);\n        var b = this.Fp;\n        b !== a && (0 > a && va(a, \">= 0\", Y, \"row\"), this.Fp = a, this.o(), this.g(\"row\", b, a));\n      }\n    },\n    rowSpan: {\n      get: function () {\n        return this.Gp;\n      },\n      set: function (a) {\n        a = Math.round(a);\n        var b = this.Gp;\n        b !== a && (1 > a && va(a, \">= 1\", Y, \"rowSpan\"), this.Gp = a, this.o(), this.g(\"rowSpan\", b, a));\n      }\n    },\n    spanAllocation: {\n      get: function () {\n        return this.Zp;\n      },\n      set: function (a) {\n        var b = this.Zp;\n        b !== a && (this.Zp = a, this.o(), this.g(\"spanAllocation\", b, a));\n      }\n    },\n    alignmentFocus: {\n      get: function () {\n        return this.Tk;\n      },\n      set: function (a) {\n        var b = this.Tk;\n        b.w(a) || (this.Tk = a = a.G(), this.o(), this.g(\"alignmentFocus\", b, a));\n      }\n    },\n    portId: {\n      get: function () {\n        return this.sp;\n      },\n      set: function (a) {\n        var b = this.sp;\n        if (b !== a) {\n          var c = this.part;\n          null === c || c instanceof V || (B(\"Cannot set portID on a Link: \" + a), c = null);\n          null !== b && null !== c && Sl(c, this);\n          this.sp = a;\n          null !== a && null !== c && (c.Nh = !0, Tl(c, this));\n          this.g(\"portId\", b, a);\n        }\n      }\n    },\n    toSpot: {\n      get: function () {\n        return null !== this.O ? this.O.Ch : vc;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Ch;\n        b.w(a) || (a = a.G(), this.O.Ch = a, this.g(\"toSpot\", b, a), Gl(this));\n      }\n    },\n    toEndSegmentLength: {\n      get: function () {\n        return null !== this.O ? this.O.Ah : 10;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Ah;\n        b !== a && (0 > a && va(a, \">= 0\", Y, \"toEndSegmentLength\"), this.O.Ah = a, this.g(\"toEndSegmentLength\", b, a), Gl(this));\n      }\n    },\n    toShortLength: {\n      get: function () {\n        return null !== this.O ? this.O.Bh : 0;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Bh;\n        b !== a && (this.O.Bh = a, this.g(\"toShortLength\", b, a), Gl(this));\n      }\n    },\n    toLinkable: {\n      get: function () {\n        return null !== this.O ? this.O.iq : null;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.iq;\n        b !== a && (this.O.iq = a, this.g(\"toLinkable\", b, a));\n      }\n    },\n    toMaxLinks: {\n      get: function () {\n        return null !== this.O ? this.O.jq : Infinity;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.jq;\n        b !== a && (0 > a && va(a, \">= 0\", Y, \"toMaxLinks\"), this.O.jq = a, this.g(\"toMaxLinks\", b, a));\n      }\n    },\n    fromSpot: {\n      get: function () {\n        return null !== this.O ? this.O.ah : vc;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.ah;\n        b.w(a) || (a = a.G(), this.O.ah = a, this.g(\"fromSpot\", b, a), Gl(this));\n      }\n    },\n    fromEndSegmentLength: {\n      get: function () {\n        return null !== this.O ? this.O.Zg : 10;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Zg;\n        b !== a && (0 > a && va(a, \">= 0\", Y, \"fromEndSegmentLength\"), this.O.Zg = a, this.g(\"fromEndSegmentLength\", b, a), Gl(this));\n      }\n    },\n    fromShortLength: {\n      get: function () {\n        return null !== this.O ? this.O.$g : 0;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.$g;\n        b !== a && (this.O.$g = a, this.g(\"fromShortLength\", b, a), Gl(this));\n      }\n    },\n    fromLinkable: {\n      get: function () {\n        return null !== this.O ? this.O.bo : null;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.bo;\n        b !== a && (this.O.bo = a, this.g(\"fromLinkable\", b, a));\n      }\n    },\n    fromMaxLinks: {\n      get: function () {\n        return null !== this.O ? this.O.co : Infinity;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.co;\n        b !== a && (0 > a && va(a, \">= 0\", Y, \"fromMaxLinks\"), this.O.co = a, this.g(\"fromMaxLinks\", b, a));\n      }\n    },\n    cursor: {\n      get: function () {\n        return this.oi;\n      },\n      set: function (a) {\n        var b = this.oi;\n        b !== a && (this.oi = a, this.g(\"cursor\", b, a));\n      }\n    },\n    click: {\n      get: function () {\n        return null !== this.N ? this.N.Of : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Of;\n        b !== a && (this.N.Of = a, this.g(\"click\", b, a));\n      }\n    },\n    doubleClick: {\n      get: function () {\n        return null !== this.N ? this.N.Tf : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Tf;\n        b !== a && (this.N.Tf = a, this.g(\"doubleClick\", b, a));\n      }\n    },\n    contextClick: {\n      get: function () {\n        return null !== this.N ? this.N.Pf : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Pf;\n        b !== a && (this.N.Pf = a, this.g(\"contextClick\", b, a));\n      }\n    },\n    mouseEnter: {\n      get: function () {\n        return null !== this.N ? this.N.hg : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.hg;\n        b !== a && (this.N.hg = a, this.g(\"mouseEnter\", b, a));\n      }\n    },\n    mouseLeave: {\n      get: function () {\n        return null !== this.N ? this.N.kg : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.kg;\n        b !== a && (this.N.kg = a, this.g(\"mouseLeave\", b, a));\n      }\n    },\n    mouseOver: {\n      get: function () {\n        return null !== this.N ? this.N.lg : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.lg;\n        b !== a && (this.N.lg = a, this.g(\"mouseOver\", b, a));\n      }\n    },\n    mouseHover: {\n      get: function () {\n        return null !== this.N ? this.N.jg : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.jg;\n        b !== a && (this.N.jg = a, this.g(\"mouseHover\", b, a));\n      }\n    },\n    mouseHold: {\n      get: function () {\n        return null !== this.N ? this.N.ig : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.ig;\n        b !== a && (this.N.ig = a, this.g(\"mouseHold\", b, a));\n      }\n    },\n    mouseDragEnter: {\n      get: function () {\n        return null !== this.N ? this.N.Wo : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Wo;\n        b !== a && (this.N.Wo = a, this.g(\"mouseDragEnter\", b, a));\n      }\n    },\n    mouseDragLeave: {\n      get: function () {\n        return null !== this.N ? this.N.Xo : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Xo;\n        b !== a && (this.N.Xo = a, this.g(\"mouseDragLeave\", b, a));\n      }\n    },\n    mouseDrop: {\n      get: function () {\n        return null !== this.N ? this.N.gg : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.gg;\n        b !== a && (this.N.gg = a, this.g(\"mouseDrop\", b, a));\n      }\n    },\n    actionDown: {\n      get: function () {\n        return null !== this.N ? this.N.en : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.en;\n        b !== a && (this.N.en = a, this.g(\"actionDown\", b, a));\n      }\n    },\n    actionMove: {\n      get: function () {\n        return null !== this.N ? this.N.fn : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.fn;\n        b !== a && (this.N.fn = a, this.g(\"actionMove\", b, a));\n      }\n    },\n    actionUp: {\n      get: function () {\n        return null !== this.N ? this.N.gn : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.gn;\n        b !== a && (this.N.gn = a, this.g(\"actionUp\", b, a));\n      }\n    },\n    actionCancel: {\n      get: function () {\n        return null !== this.N ? this.N.dn : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.dn;\n        b !== a && (this.N.dn = a, this.g(\"actionCancel\", b, a));\n      }\n    },\n    toolTip: {\n      get: function () {\n        return null !== this.N ? this.N.wg : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.wg;\n        b !== a && (this.N.wg = a, this.g(\"toolTip\", b, a));\n      }\n    },\n    contextMenu: {\n      get: function () {\n        return null !== this.N ? this.N.Qf : null;\n      },\n      set: function (a) {\n        bl(this);\n        var b = this.N.Qf;\n        b !== a && (this.N.Qf = a, this.g(\"contextMenu\", b, a));\n      }\n    }\n  });\n  Y.prototype.setProperties = Y.prototype.Ew;\n  Y.prototype.findTemplateBinder = Y.prototype.ij;\n  Y.prototype.bind = Y.prototype.bind;\n  Y.prototype.isEnabledObject = Y.prototype.Hg;\n  Y.prototype.isVisibleObject = Y.prototype.Ff;\n  Y.prototype.isContainedBy = Y.prototype.Gg;\n  Y.prototype.getNearestIntersectionPoint = Y.prototype.bd;\n  Y.prototype.getLocalPoint = Y.prototype.Nt;\n  Y.prototype.getDocumentScale = Y.prototype.Af;\n  Y.prototype.getDocumentAngle = Y.prototype.lj;\n  Y.prototype.getDocumentBounds = Y.prototype.wm;\n  Y.prototype.getDocumentPoint = Y.prototype.ga;\n  Y.prototype.intersectsRect = Y.prototype.Lc;\n  Y.prototype.containedInRect = Y.prototype.Jh;\n  Y.prototype.containsRect = Y.prototype.De;\n  Y.prototype.containsPoint = Y.prototype.aa;\n  Y.prototype.raiseChanged = Y.prototype.g;\n  Y.prototype.raiseChangedEvent = Y.prototype.ab;\n  Y.prototype.addCopyProperty = Y.prototype.Rx;\n  var Ll = null;\n  Y.className = \"GraphObject\";\n  Ll = new H();\n  Pl(\"Button\", function () {\n    function a(a, b) {\n      return null !== a.diagram.Ub(a.documentPoint, function (a) {\n        for (; null !== a.panel && !a.isActionable;) a = a.panel;\n        return a;\n      }, function (a) {\n        return a === b;\n      });\n    }\n    var b = Kl(X, X.Auto, {\n      isActionable: !0,\n      enabledChanged: function (a, b) {\n        if (a instanceof X) {\n          var c = a.$a(\"ButtonBorder\");\n          null !== c && (c.fill = b ? a._buttonFillNormal : a._buttonFillDisabled);\n        }\n      },\n      cursor: \"pointer\",\n      _buttonFillNormal: \"#F5F5F5\",\n      _buttonStrokeNormal: \"#BDBDBD\",\n      _buttonFillOver: \"#E0E0E0\",\n      _buttonStrokeOver: \"#9E9E9E\",\n      _buttonFillPressed: \"#BDBDBD\",\n      _buttonStrokePressed: \"#9E9E9E\",\n      _buttonFillDisabled: \"#E5E5E5\"\n    }, Kl(W, {\n      name: \"ButtonBorder\",\n      figure: \"RoundedRectangle\",\n      spot1: new P(0, 0, 2.76142374915397, 2.761423749153969),\n      spot2: new P(1, 1, -2.76142374915397, -2.761423749153969),\n      parameter1: 2,\n      parameter2: 2,\n      fill: \"#F5F5F5\",\n      stroke: \"#BDBDBD\"\n    }));\n    b.mouseEnter = function (a, b) {\n      if (b.Hg() && b instanceof X && (a = b.$a(\"ButtonBorder\"), a instanceof W)) {\n        var c = b._buttonFillOver;\n        b._buttonFillNormal = a.fill;\n        a.fill = c;\n        c = b._buttonStrokeOver;\n        b._buttonStrokeNormal = a.stroke;\n        a.stroke = c;\n      }\n    };\n    b.mouseLeave = function (a, b) {\n      b.Hg() && b instanceof X && (a = b.$a(\"ButtonBorder\"), a instanceof W && (a.fill = b._buttonFillNormal, a.stroke = b._buttonStrokeNormal));\n    };\n    b.actionDown = function (a, b) {\n      if (b.Hg() && b instanceof X && null !== b._buttonFillPressed && 0 === a.button) {\n        var c = b.$a(\"ButtonBorder\");\n        if (c instanceof W) {\n          a = a.diagram;\n          var d = a.skipsUndoManager;\n          a.skipsUndoManager = !0;\n          var g = b._buttonFillPressed;\n          b._buttonFillOver = c.fill;\n          c.fill = g;\n          g = b._buttonStrokePressed;\n          b._buttonStrokeOver = c.stroke;\n          c.stroke = g;\n          a.skipsUndoManager = d;\n        }\n      }\n    };\n    b.actionUp = function (b, d) {\n      if (d.Hg() && d instanceof X && null !== d._buttonFillPressed && 0 === b.button) {\n        var c = d.$a(\"ButtonBorder\");\n        if (c instanceof W) {\n          var f = b.diagram,\n            g = f.skipsUndoManager;\n          f.skipsUndoManager = !0;\n          a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal);\n          f.skipsUndoManager = g;\n        }\n      }\n    };\n    b.actionCancel = function (b, d) {\n      if (d.Hg() && d instanceof X && null !== d._buttonFillPressed) {\n        var c = d.$a(\"ButtonBorder\");\n        if (c instanceof W) {\n          var f = b.diagram,\n            g = f.skipsUndoManager;\n          f.skipsUndoManager = !0;\n          a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal);\n          f.skipsUndoManager = g;\n        }\n      }\n    };\n    b.actionMove = function (b, d) {\n      if (d.Hg() && d instanceof X && null !== d._buttonFillPressed) {\n        var c = b.diagram;\n        if (0 === c.firstInput.button && (c.currentTool.standardMouseOver(), a(b, d) && (b = d.$a(\"ButtonBorder\"), b instanceof W))) {\n          var f = c.skipsUndoManager;\n          c.skipsUndoManager = !0;\n          var g = d._buttonFillPressed;\n          b.fill !== g && (b.fill = g);\n          g = d._buttonStrokePressed;\n          b.stroke !== g && (b.stroke = g);\n          c.skipsUndoManager = f;\n        }\n      }\n    };\n    return b;\n  });\n  Pl(\"TreeExpanderButton\", function () {\n    var a = Kl(\"Button\", {\n      _treeExpandedFigure: \"MinusLine\",\n      _treeCollapsedFigure: \"PlusLine\"\n    }, Kl(W, {\n      name: \"ButtonIcon\",\n      figure: \"MinusLine\",\n      stroke: \"#424242\",\n      strokeWidth: 2,\n      desiredSize: Pb\n    }, new Li(\"figure\", \"isTreeExpanded\", function (a, c) {\n      c = c.panel;\n      return a ? c._treeExpandedFigure : c._treeCollapsedFigure;\n    }).Uq()), {\n      visible: !1\n    }, new Li(\"visible\", \"isTreeLeaf\", function (a) {\n      return !a;\n    }).Uq());\n    a.click = function (a, c) {\n      c = c.part;\n      c instanceof He && (c = c.adornedPart);\n      if (c instanceof V) {\n        var b = c.diagram;\n        if (null !== b) {\n          b = b.commandHandler;\n          if (c.isTreeExpanded) {\n            if (!b.canCollapseTree(c)) return;\n          } else if (!b.canExpandTree(c)) return;\n          a.handled = !0;\n          c.isTreeExpanded ? b.collapseTree(c) : b.expandTree(c);\n        }\n      }\n    };\n    return a;\n  });\n  Pl(\"SubGraphExpanderButton\", function () {\n    var a = Kl(\"Button\", {\n      _subGraphExpandedFigure: \"MinusLine\",\n      _subGraphCollapsedFigure: \"PlusLine\"\n    }, Kl(W, {\n      name: \"ButtonIcon\",\n      figure: \"MinusLine\",\n      stroke: \"#424242\",\n      strokeWidth: 2,\n      desiredSize: Pb\n    }, new Li(\"figure\", \"isSubGraphExpanded\", function (a, c) {\n      c = c.panel;\n      return a ? c._subGraphExpandedFigure : c._subGraphCollapsedFigure;\n    }).Uq()));\n    a.click = function (a, c) {\n      c = c.part;\n      c instanceof He && (c = c.adornedPart);\n      if (c instanceof vf) {\n        var b = c.diagram;\n        if (null !== b) {\n          b = b.commandHandler;\n          if (c.isSubGraphExpanded) {\n            if (!b.canCollapseSubGraph(c)) return;\n          } else if (!b.canExpandSubGraph(c)) return;\n          a.handled = !0;\n          c.isSubGraphExpanded ? b.collapseSubGraph(c) : b.expandSubGraph(c);\n        }\n      }\n    };\n    return a;\n  });\n  Pl(\"ToolTip\", function () {\n    return Kl(He, X.Auto, {\n      isShadowed: !0,\n      shadowColor: \"rgba(0, 0, 0, .4)\",\n      shadowOffset: new J(0, 3),\n      shadowBlur: 5\n    }, Kl(W, {\n      name: \"Border\",\n      figure: \"RoundedRectangle\",\n      parameter1: 1,\n      parameter2: 1,\n      fill: \"#F5F5F5\",\n      stroke: \"#F0F0F0\",\n      spot1: new P(0, 0, 4, 6),\n      spot2: new P(1, 1, -4, -4)\n    }));\n  });\n  Pl(\"ContextMenu\", function () {\n    return Kl(He, X.Vertical, {\n      background: \"#F5F5F5\",\n      isShadowed: !0,\n      shadowColor: \"rgba(0, 0, 0, .4)\",\n      shadowOffset: new J(0, 3),\n      shadowBlur: 5\n    }, new Li(\"background\", \"\", function (a) {\n      return null !== a.adornedPart && null !== a.placeholder ? null : \"#F5F5F5\";\n    }));\n  });\n  Pl(\"ContextMenuButton\", function () {\n    var a = Kl(\"Button\");\n    a.stretch = Wk;\n    var b = a.$a(\"ButtonBorder\");\n    b instanceof W && (b.figure = \"Rectangle\", b.strokeWidth = 0, b.spot1 = new P(0, 0, 2, 3), b.spot2 = new P(1, 1, -2, -2));\n    return a;\n  });\n  Pl(\"PanelExpanderButton\", function (a) {\n    var b = Ql(a, \"COLLAPSIBLE\"),\n      c = Kl(\"Button\", {\n        _buttonExpandedFigure: \"M0 0 M0 6 L4 2 8 6 M8 8\",\n        _buttonCollapsedFigure: \"M0 0 M0 2 L4 6 8 2 M8 8\",\n        _buttonFillNormal: \"rgba(0, 0, 0, 0)\",\n        _buttonStrokeNormal: null,\n        _buttonFillOver: \"rgba(0, 0, 0, .2)\",\n        _buttonStrokeOver: null,\n        _buttonFillPressed: \"rgba(0, 0, 0, .4)\",\n        _buttonStrokePressed: null\n      }, Kl(W, {\n        name: \"ButtonIcon\",\n        strokeWidth: 2\n      }, new Li(\"geometryString\", \"visible\", function (a) {\n        return a ? c._buttonExpandedFigure : c._buttonCollapsedFigure;\n      }).Uq(b)));\n    a = c.$a(\"ButtonBorder\");\n    a instanceof W && (a.stroke = null, a.fill = \"rgba(0, 0, 0, 0)\");\n    c.click = function (a, c) {\n      var d = c.diagram;\n      if (null !== d && !d.isReadOnly) {\n        var e = c.ij();\n        null === e && (e = c.part);\n        null !== e && (c = e.$a(b), null !== c && (a.handled = !0, d.va(\"Collapse/Expand Panel\"), c.visible = !c.visible, d.Wa(\"Collapse/Expand Panel\")));\n      }\n    };\n    return c;\n  });\n  Pl(\"CheckBoxButton\", function (a) {\n    var b = Ql(a);\n    a = Kl(\"Button\", {\n      desiredSize: new M(14, 14)\n    }, Kl(W, {\n      name: \"ButtonIcon\",\n      geometryString: \"M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2\",\n      strokeWidth: 2,\n      stretch: vd,\n      geometryStretch: Ag,\n      visible: !1\n    }, \"\" !== b ? new Li(\"visible\", b).Fy() : []));\n    a.click = function (a, d) {\n      if (d instanceof X) {\n        var c = a.diagram;\n        if (!(null === c || c.isReadOnly || \"\" !== b && c.model.isReadOnly)) {\n          a.handled = !0;\n          var f = d.$a(\"ButtonIcon\");\n          c.va(\"checkbox\");\n          f.visible = !f.visible;\n          \"function\" === typeof d._doClick && d._doClick(a, d);\n          c.Wa(\"checkbox\");\n        }\n      }\n    };\n    return a;\n  });\n  Pl(\"CheckBox\", function (a) {\n    a = Ql(a);\n    a = Kl(\"CheckBoxButton\", a, {\n      name: \"Button\",\n      isActionable: !1,\n      margin: new pc(0, 1, 0, 0)\n    });\n    var b = Kl(X, \"Horizontal\", a, {\n      isActionable: !0,\n      cursor: a.cursor,\n      margin: 1,\n      _buttonFillNormal: a._buttonFillNormal,\n      _buttonStrokeNormal: a._buttonStrokeNormal,\n      _buttonFillOver: a._buttonFillOver,\n      _buttonStrokeOver: a._buttonStrokeOver,\n      _buttonFillPressed: a._buttonFillPressed,\n      _buttonStrokePressed: a._buttonStrokePressed,\n      _buttonFillDisabled: a._buttonFillDisabled,\n      mouseEnter: a.mouseEnter,\n      mouseLeave: a.mouseLeave,\n      actionDown: a.actionDown,\n      actionUp: a.actionUp,\n      actionCancel: a.actionCancel,\n      actionMove: a.actionMove,\n      click: a.click,\n      _buttonClick: a.click\n    });\n    a.mouseEnter = null;\n    a.mouseLeave = null;\n    a.actionDown = null;\n    a.actionUp = null;\n    a.actionCancel = null;\n    a.actionMove = null;\n    a.click = null;\n    return b;\n  });\n  Y.None = yg = new D(Y, \"None\", 0);\n  Y.Default = Vk = new D(Y, \"Default\", 0);\n  Y.Vertical = Xk = new D(Y, \"Vertical\", 4);\n  Y.Horizontal = Wk = new D(Y, \"Horizontal\", 5);\n  Y.Fill = vd = new D(Y, \"Fill\", 3);\n  Y.Uniform = Ag = new D(Y, \"Uniform\", 1);\n  Y.UniformToFill = Yk = new D(Y, \"UniformToFill\", 2);\n  Y.FlipVertical = Zk = new D(Y, \"FlipVertical\", 1);\n  Y.FlipHorizontal = $k = new D(Y, \"FlipHorizontal\", 2);\n  Y.FlipBoth = al = new D(Y, \"FlipBoth\", 3);\n  Y.make = Kl;\n  Y.getBuilders = function () {\n    var a = new H(),\n      b;\n    for (b in Ll) if (b !== b.toLowerCase()) {\n      var c = Ll.H(b);\n      \"function\" === typeof c && a.add(b, c);\n    }\n    a.freeze();\n    return a;\n  };\n  Y.defineBuilder = Pl;\n  Y.takeBuilderArgument = Ql;\n  function cl() {\n    this.Vn = this.Qf = this.wg = this.dn = this.gn = this.fn = this.en = this.gg = this.Xo = this.Wo = this.ig = this.jg = this.lg = this.kg = this.hg = this.Pf = this.Tf = this.Of = null;\n  }\n  cl.prototype.copy = function () {\n    var a = new cl();\n    a.Of = this.Of;\n    a.Tf = this.Tf;\n    a.Pf = this.Pf;\n    a.hg = this.hg;\n    a.kg = this.kg;\n    a.lg = this.lg;\n    a.jg = this.jg;\n    a.ig = this.ig;\n    a.Wo = this.Wo;\n    a.Xo = this.Xo;\n    a.gg = this.gg;\n    a.en = this.en;\n    a.fn = this.fn;\n    a.gn = this.gn;\n    a.dn = this.dn;\n    a.wg = this.wg;\n    a.Qf = this.Qf;\n    a.Vn = this.Vn;\n    return a;\n  };\n  cl.className = \"GraphObjectEventHandlers\";\n  function Ul() {\n    this.Ma = [1, 0, 0, 1, 0, 0];\n  }\n  Ul.prototype.copy = function () {\n    var a = new Ul();\n    a.Ma[0] = this.Ma[0];\n    a.Ma[1] = this.Ma[1];\n    a.Ma[2] = this.Ma[2];\n    a.Ma[3] = this.Ma[3];\n    a.Ma[4] = this.Ma[4];\n    a.Ma[5] = this.Ma[5];\n    return a;\n  };\n  Ul.prototype.translate = function (a, b) {\n    this.Ma[4] += this.Ma[0] * a + this.Ma[2] * b;\n    this.Ma[5] += this.Ma[1] * a + this.Ma[3] * b;\n  };\n  Ul.prototype.scale = function (a, b) {\n    this.Ma[0] *= a;\n    this.Ma[1] *= a;\n    this.Ma[2] *= b;\n    this.Ma[3] *= b;\n  };\n  Ul.className = \"STransform\";\n  function Vl(a) {\n    this.type = a;\n    this.r2 = this.y2 = this.x2 = this.r1 = this.y1 = this.x1 = 0;\n    this.Zx = [];\n    this.pattern = null;\n  }\n  Vl.prototype.addColorStop = function (a, b) {\n    this.Zx.push({\n      offset: a,\n      color: b\n    });\n  };\n  Vl.className = \"SGradient\";\n  function Cj(a, b) {\n    this.ownerDocument = a = void 0 === b ? x.document : b;\n    this.HA = \"http://www.w3.org/2000/svg\";\n    void 0 !== a && (this.Ga = this.wb(\"svg\", {\n      width: \"1px\",\n      height: \"1px\",\n      viewBox: \"0 0 1 1\"\n    }), this.Ga.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns\", \"http://www.w3.org/2000/svg\"), this.Ga.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\"));\n    this.Bq = null;\n    this.context = new Wl(this);\n  }\n  Cj.prototype.resize = function (a, b, c, d) {\n    return this.width !== a || this.height !== b ? (this.style.width = c + \"px\", this.style.height = d + \"px\", this.Ga.setAttributeNS(null, \"width\", c + \"px\"), this.Ga.setAttributeNS(null, \"height\", d + \"px\"), this.Ga.setAttributeNS(null, \"viewBox\", \"0 0 \" + c + \" \" + d), this.context.cv.firstElementChild.setAttributeNS(null, \"width\", c + \"px\"), this.context.cv.firstElementChild.setAttributeNS(null, \"height\", d + \"px\"), !0) : !1;\n  };\n  Cj.prototype.wb = function (a, b, c) {\n    a = this.ownerDocument.createElementNS(this.HA, a);\n    if (ya(b)) for (var d in b) a.setAttributeNS(\"href\" === d ? \"http://www.w3.org/1999/xlink\" : \"\", d, b[d]);\n    void 0 !== c && (a.textContent = c);\n    return a;\n  };\n  Cj.prototype.getBoundingClientRect = function () {\n    return this.Ga.getBoundingClientRect();\n  };\n  Cj.prototype.focus = function () {\n    this.Ga.focus();\n  };\n  Cj.prototype.hy = function () {\n    this.ownerDocument = null;\n  };\n  ma.Object.defineProperties(Cj.prototype, {\n    width: {\n      get: function () {\n        return this.Ga.width.baseVal.value;\n      },\n      set: function (a) {\n        this.Ga.width = a;\n      }\n    },\n    height: {\n      get: function () {\n        return this.Ga.height.baseVal.value;\n      },\n      set: function (a) {\n        this.Ga.height = a;\n      }\n    },\n    style: {\n      get: function () {\n        return this.Ga.style;\n      }\n    }\n  });\n  Cj.className = \"SVGSurface\";\n  function Wl(a) {\n    this.Mk = a;\n    this.svg = a.Ga;\n    this.stack = [];\n    this.zc = [];\n    this.fillStyle = \"#000000\";\n    this.font = \"10px sans-serif\";\n    this.globalAlpha = 1;\n    this.lineCap = \"butt\";\n    this.lineDashOffset = 0;\n    this.lineJoin = \"miter\";\n    this.lineWidth = 1;\n    this.miterLimit = 10;\n    this.shadowBlur = 0;\n    this.shadowColor = \"rgba(0, 0, 0, 0)\";\n    this.shadowOffsetY = this.shadowOffsetX = 0;\n    this.strokeStyle = \"#000000\";\n    this.textAlign = \"start\";\n    this.clipInsteadOfFill = !1;\n    this.jf = this.Vp = this.Up = 0;\n    this.Oq = null;\n    this.path = [];\n    this.Uu = !1;\n    this.vh = null;\n    this.wh = 0;\n    this.Xd = new Ul();\n    Xl(this, 1, 0, 0, 1, 0, 0);\n    var b = qb++,\n      c = this.wb(\"clipPath\", {\n        id: \"mainClip\" + b\n      });\n    c.appendChild(this.wb(\"rect\", {\n      x: 0,\n      y: 0,\n      width: a.width,\n      height: a.height\n    }));\n    this.cv = c;\n    this.Mk.Ga.appendChild(c);\n    this.zc[0].setAttributeNS(null, \"clip-path\", \"url(#mainClip\" + b + \")\");\n    this.JA = {};\n  }\n  t = Wl.prototype;\n  t.reset = function () {\n    this.stack = [];\n    this.zc = [];\n    this.fillStyle = \"#000000\";\n    this.font = \"10px sans-serif\";\n    this.globalAlpha = 1;\n    this.lineCap = \"butt\";\n    this.lineDashOffset = 0;\n    this.lineJoin = \"miter\";\n    this.lineWidth = 1;\n    this.miterLimit = 10;\n    this.shadowBlur = 0;\n    this.shadowColor = \"rgba(0, 0, 0, 0)\";\n    this.shadowOffsetY = this.shadowOffsetX = 0;\n    this.strokeStyle = \"#000000\";\n    this.textAlign = \"start\";\n    this.clipInsteadOfFill = !1;\n    this.jf = this.Vp = this.Up = 0;\n    this.Oq = null;\n    this.path = [];\n    this.Xd = new Ul();\n    Xl(this, 1, 0, 0, 1, 0, 0);\n    var a = qb++,\n      b = this.wb(\"clipPath\", {\n        id: \"mainClip\" + a\n      });\n    b.appendChild(this.wb(\"rect\", {\n      x: 0,\n      y: 0,\n      width: this.Mk.width,\n      height: this.Mk.height\n    }));\n    this.cv = b;\n    this.Mk.Ga.appendChild(b);\n    this.zc[0].setAttributeNS(null, \"clip-path\", \"url(#mainClip\" + a + \")\");\n  };\n  t.arc = function (a, b, c, d, e, f, g, h) {\n    var k = 2 * Math.PI,\n      l = k - 1E-6,\n      m = c * Math.cos(d),\n      n = c * Math.sin(d),\n      p = a + m,\n      r = b + n,\n      q = f ? 0 : 1;\n    d = f ? d - e : e - d;\n    (1E-6 < Math.abs(g - p) || 1E-6 < Math.abs(h - r)) && this.path.push([\"L\", p, +r]);\n    0 > d && (d = d % k + k);\n    d > l ? (this.path.push([\"A\", c, c, 0, 1, q, a - m, b - n]), this.path.push([\"A\", c, c, 0, 1, q, p, r])) : 1E-6 < d && this.path.push([\"A\", c, c, 0, +(d >= Math.PI), q, a + c * Math.cos(e), b + c * Math.sin(e)]);\n  };\n  t.beginPath = function () {\n    this.path = [];\n  };\n  t.bezierCurveTo = function (a, b, c, d, e, f) {\n    this.path.push([\"C\", a, b, c, d, e, f]);\n  };\n  t.clearRect = function () {};\n  t.clip = function () {\n    this.addPath(\"clipPath\", this.path, this.Xd);\n    this.addPath(\"clipPath\", this.path, new Ul());\n  };\n  t.closePath = function () {\n    this.path.push([\"z\"]);\n  };\n  t.createLinearGradient = function (a, b, c, d) {\n    var e = new Vl(\"linear\");\n    e.x1 = a;\n    e.y1 = b;\n    e.x2 = c;\n    e.y2 = d;\n    return e;\n  };\n  t.createPattern = function (a) {\n    var b = \"\";\n    a instanceof HTMLCanvasElement && (b = a.toDataURL());\n    a instanceof HTMLImageElement && (b = a.getAttribute(\"src\"));\n    var c = this.JA;\n    if (c[b]) return \"url(#\" + c[b] + \")\";\n    var d = \"PATTERN\" + qb++,\n      e = {\n        x: 0,\n        y: 0,\n        width: a.width,\n        height: a.height,\n        href: b\n      };\n    a = this.wb(\"pattern\", {\n      width: a.width,\n      height: a.height,\n      id: d,\n      patternUnits: \"userSpaceOnUse\"\n    });\n    a.appendChild(this.wb(\"image\", e));\n    this.svg.appendChild(a);\n    c[b] = d;\n    return \"url(#\" + d + \")\";\n  };\n  t.createRadialGradient = function (a, b, c, d, e, f) {\n    var g = new Vl(\"radial\");\n    g.x1 = a;\n    g.y1 = b;\n    g.r1 = c;\n    g.x2 = d;\n    g.y2 = e;\n    g.r2 = f;\n    return g;\n  };\n  t.drawImage = function (a, b, c, d, e, f, g, h, k) {\n    var l = \"\";\n    a instanceof HTMLCanvasElement && (l = a.toDataURL());\n    a instanceof HTMLImageElement && (l = a.getAttribute(\"src\"));\n    var m = a instanceof HTMLImageElement ? a.naturalWidth : a.width,\n      n = a instanceof HTMLImageElement ? a.naturalHeight : a.height;\n    void 0 === d && (f = b, g = c, h = d = m, k = e = n);\n    d = d || 0;\n    e = e || 0;\n    f = f || 0;\n    g = g || 0;\n    h = h || 0;\n    k = k || 0;\n    a = {\n      x: 0,\n      y: 0,\n      width: m || d,\n      height: n || e,\n      href: l\n    };\n    K.$(d, h) && K.$(e, k) ? -1 === l.toLowerCase().indexOf(\".svg\") && -1 === l.toLowerCase().indexOf(\"data:image/svg\") && (a.preserveAspectRatio = \"xMidYMid slice\") : a.preserveAspectRatio = \"none\";\n    l = \"\";\n    h /= d;\n    k /= e;\n    if (0 !== f || 0 !== g) l += \" translate(\" + f + \", \" + g + \")\";\n    if (1 !== h || 1 !== k) l += \" scale(\" + h + \", \" + k + \")\";\n    if (0 !== b || 0 !== c) l += \" translate(\" + -b + \", \" + -c + \")\";\n    if (0 !== b || 0 !== c || d !== m || e !== n) f = \"CLIP\" + qb++, g = this.wb(\"clipPath\", {\n      id: f\n    }), g.appendChild(this.wb(\"rect\", {\n      x: b,\n      y: c,\n      width: d,\n      height: e\n    })), this.svg.appendChild(g), a[\"clip-path\"] = \"url(#\" + f + \")\";\n    Yl(this, \"image\", a, this.Xd, l);\n    this.addElement(\"image\", a);\n  };\n  t.fill = function () {\n    this.addPath(\"fill\", this.path, this.Xd);\n  };\n  t.Yd = function () {\n    this.clipInsteadOfFill ? this.clip() : this.fill();\n  };\n  t.fillRect = function (a, b, c, d) {\n    a = [a, b, c, d];\n    a = {\n      x: a[0],\n      y: a[1],\n      width: a[2],\n      height: a[3]\n    };\n    Yl(this, \"fill\", a, this.Xd);\n    this.addElement(\"rect\", a);\n  };\n  t.fillText = function (a, b, c) {\n    a = [a, b, c];\n    b = this.textAlign;\n    \"left\" === b ? b = \"start\" : \"right\" === b ? b = \"end\" : \"center\" === b && (b = \"middle\");\n    b = {\n      x: a[1],\n      y: a[2],\n      style: \"font: \" + this.font,\n      \"text-anchor\": b\n    };\n    Yl(this, \"fill\", b, this.Xd);\n    this.addElement(\"text\", b, a[0]);\n  };\n  t.lineTo = function (a, b) {\n    this.path.push([\"L\", a, b]);\n  };\n  t.moveTo = function (a, b) {\n    this.path.push([\"M\", a, b]);\n  };\n  t.quadraticCurveTo = function (a, b, c, d) {\n    this.path.push([\"Q\", a, b, c, d]);\n  };\n  t.rect = function (a, b, c, d) {\n    this.path.push([\"M\", a, b], [\"L\", a + c, b], [\"L\", a + c, b + d], [\"L\", a, b + d], [\"z\"]);\n  };\n  t.restore = function () {\n    this.Xd = this.stack.pop();\n    this.path = this.stack.pop();\n    var a = this.stack.pop();\n    this.fillStyle = a.fillStyle;\n    this.font = a.font;\n    this.globalAlpha = a.globalAlpha;\n    this.lineCap = a.lineCap;\n    this.lineDashOffset = a.lineDashOffset;\n    this.lineJoin = a.lineJoin;\n    this.lineWidth = a.lineWidth;\n    this.miterLimit = a.miterLimit;\n    this.shadowBlur = a.shadowBlur;\n    this.shadowColor = a.shadowColor;\n    this.shadowOffsetX = a.shadowOffsetX;\n    this.shadowOffsetY = a.shadowOffsetY;\n    this.strokeStyle = a.strokeStyle;\n    this.textAlign = a.textAlign;\n  };\n  t.save = function () {\n    this.stack.push({\n      fillStyle: this.fillStyle,\n      font: this.font,\n      globalAlpha: this.globalAlpha,\n      lineCap: this.lineCap,\n      lineDashOffset: this.lineDashOffset,\n      lineJoin: this.lineJoin,\n      lineWidth: this.lineWidth,\n      miterLimit: this.miterLimit,\n      shadowBlur: this.shadowBlur,\n      shadowColor: this.shadowColor,\n      shadowOffsetX: this.shadowOffsetX,\n      shadowOffsetY: this.shadowOffsetY,\n      strokeStyle: this.strokeStyle,\n      textAlign: this.textAlign\n    });\n    for (var a = [], b = 0; b < this.path.length; b++) a.push(this.path[b]);\n    this.stack.push(a);\n    this.stack.push(this.Xd.copy());\n  };\n  t.setTransform = function (a, b, c, d, e, f) {\n    1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || Xl(this, a, b, c, d, e, f);\n  };\n  t.scale = function (a, b) {\n    this.Xd.scale(a, b);\n  };\n  t.translate = function (a, b) {\n    this.Xd.translate(a, b);\n  };\n  t.transform = function () {};\n  t.stroke = function () {\n    this.addPath(\"stroke\", this.path, this.Xd);\n  };\n  t.uj = function () {\n    this.clipInsteadOfFill || this.stroke();\n  };\n  t.wb = function (a, b, c) {\n    return this.Mk.wb(a, b, c);\n  };\n  t.addElement = function (a, b, c) {\n    a = this.wb(a, b, c);\n    0 < this.zc.length ? this.zc[this.zc.length - 1].appendChild(a) : this.svg.appendChild(a);\n    return this.Oq = a;\n  };\n  function Yl(a, b, c, d, e) {\n    1 !== a.globalAlpha && (c.opacity = a.globalAlpha);\n    \"fill\" === b ? (a.fillStyle instanceof Vl ? c.fill = Zl(a, a.fillStyle) : /^rgba\\(/.test(a.fillStyle) ? (a = /^\\s*rgba\\s*\\(([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\)\\s*$/i.exec(a.fillStyle), c.fill = \"rgb(\" + a[1] + \",\" + a[2] + \",\" + a[3] + \")\", c[\"fill-opacity\"] = a[4]) : c.fill = a.fillStyle, c.stroke = \"none\") : \"stroke\" === b && (c.fill = \"none\", a.strokeStyle instanceof Vl ? c.stroke = Zl(a, a.strokeStyle) : /^rgba\\(/.test(a.strokeStyle) ? (b = /^\\s*rgba\\s*\\(([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\)\\s*$/i.exec(a.strokeStyle), c.stroke = \"rgb(\" + b[1] + \",\" + b[2] + \",\" + b[3] + \")\", c[\"stroke-opacity\"] = b[4]) : c.stroke = a.strokeStyle, c[\"stroke-width\"] = a.lineWidth, c[\"stroke-linecap\"] = a.lineCap, c[\"stroke-linejoin\"] = a.lineJoin, c[\"stroke-miterlimit\"] = a.miterLimit);\n    d = d.Ma;\n    d = \"matrix(\" + d[0] + \", \" + d[1] + \", \" + d[2] + \", \" + d[3] + \", \" + d[4] + \", \" + d[5] + \")\";\n    void 0 !== e && (d += e);\n    c.transform = d;\n  }\n  function Zl(a, b) {\n    var c = \"GRAD\" + qb++;\n    if (\"linear\" === b.type) var d = a.wb(\"linearGradient\", {\n      x1: b.x1,\n      x2: b.x2,\n      y1: b.y1,\n      y2: b.y2,\n      id: c,\n      gradientUnits: \"userSpaceOnUse\"\n    });else if (\"radial\" === b.type) d = a.wb(\"radialGradient\", {\n      x1: b.x1,\n      x2: b.x2,\n      y1: b.y1,\n      y2: b.y2,\n      r1: b.r1,\n      r2: b.r2,\n      id: c\n    });else throw Error(\"invalid gradient\");\n    var e = b.Zx;\n    b = e.length;\n    for (var f = [], g = 0; g < b; g++) {\n      var h = e[g],\n        k = h.color;\n      h = {\n        offset: h.offset,\n        \"stop-color\": k\n      };\n      /^rgba\\(/.test(k) && (k = /^\\s*rgba\\s*\\(([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\)\\s*$/i.exec(k), h[\"stop-color\"] = \"rgb(\" + k[1] + \",\" + k[2] + \",\" + k[3] + \")\", h[\"stop-opacity\"] = k[4]);\n      f.push(h);\n    }\n    f.sort(function (a, b) {\n      return a.offset > b.offset ? 1 : -1;\n    });\n    for (e = 0; e < b; e++) d.appendChild(a.wb(\"stop\", f[e]));\n    a.svg.appendChild(d);\n    return \"url(#\" + c + \")\";\n  }\n  t.addPath = function (a, b, c) {\n    for (var d = [], e = 0; e < b.length; e++) {\n      var f = Ba(b[e]),\n        g = [f.shift()];\n      if (\"A\" === g[0]) g.push(f.shift() + \",\" + f.shift(), f.shift(), f.shift() + \",\" + f.shift(), f.shift() + \",\" + f.shift());else for (; f.length;) g.push(f.shift() + \",\" + f.shift());\n      d.push(g.join(\" \"));\n    }\n    b = {\n      d: d.join(\" \")\n    };\n    \"stroke\" === a && this.Uu && (b[\"stroke-dasharray\"] = this.vh.toString(), b[\"stroke-dashoffset\"] = this.wh);\n    Yl(this, a, b, c);\n    \"clipPath\" === a ? (a = \"CLIP\" + qb++, c = this.wb(\"clipPath\", {\n      id: a\n    }), c.appendChild(this.wb(\"path\", b)), this.svg.appendChild(c), 0 < this.zc.length && this.zc[this.zc.length - 1].setAttributeNS(null, \"clip-path\", \"url(#\" + a + \")\")) : this.addElement(\"path\", b);\n  };\n  function Xl(a, b, c, d, e, f, g) {\n    var h = new Ul();\n    h.Ma = [b, c, d, e, f, g];\n    b = {};\n    Yl(a, \"g\", b, h);\n    h = a.addElement(\"g\", b);\n    a.zc.push(h);\n  }\n  t.gr = function () {\n    if (0 !== this.shadowOffsetX || 0 !== this.shadowOffsetY || 0 !== this.shadowBlur) {\n      var a = \"SHADOW\" + qb++,\n        b = this.addElement(\"filter\", {\n          id: a,\n          x: \"-100%\",\n          y: \"-100%\",\n          width: \"300%\",\n          height: \"300%\"\n        }, null);\n      var c = this.wb(\"feGaussianBlur\", {\n        \"in\": \"SourceAlpha\",\n        result: \"blur\",\n        uB: this.shadowBlur / 2\n      });\n      var d = this.wb(\"feFlood\", {\n        \"in\": \"blur\",\n        result: \"flood\",\n        \"flood-color\": this.shadowColor\n      });\n      var e = this.wb(\"feComposite\", {\n        \"in\": \"flood\",\n        in2: \"blur\",\n        operator: \"in\",\n        result: \"comp\"\n      });\n      var f = this.wb(\"feOffset\", {\n        \"in\": \"comp\",\n        result: \"offsetBlur\",\n        dx: this.shadowOffsetX,\n        dy: this.shadowOffsetY\n      });\n      var g = this.wb(\"feMerge\", {});\n      g.appendChild(this.wb(\"feMergeNode\", {\n        \"in\": \"offsetBlur\"\n      }));\n      g.appendChild(this.wb(\"feMergeNode\", {\n        \"in\": \"SourceGraphic\"\n      }));\n      b.appendChild(c);\n      b.appendChild(d);\n      b.appendChild(e);\n      b.appendChild(f);\n      b.appendChild(g);\n      0 < this.zc.length && this.zc[this.zc.length - 1].setAttributeNS(null, \"filter\", \"url(#\" + a + \")\");\n    }\n  };\n  t.Hw = function (a, b, c) {\n    this.Up = a;\n    this.Vp = b;\n    this.jf = c;\n  };\n  function sl(a) {\n    a.shadowOffsetX = 0;\n    a.shadowOffsetY = 0;\n    a.shadowBlur = 0;\n  }\n  function rl(a) {\n    a.shadowOffsetX = a.Up;\n    a.shadowOffsetY = a.Vp;\n    a.shadowBlur = a.jf;\n  }\n  t.Gt = function (a, b) {\n    this.Uu = !0;\n    this.vh = a;\n    this.wh = b;\n  };\n  t.Et = function () {\n    this.Uu = !1;\n  };\n  t.tc = function () {};\n  t.Py = function () {};\n  Wl.prototype.rotate = function () {};\n  Wl.prototype.getImageData = function () {\n    return null;\n  };\n  Wl.prototype.measureText = function () {\n    return null;\n  };\n  Wl.className = \"SVGContext\";\n  Q.prototype.Zt = function (a) {\n    var b = new Cj(this, x.document);\n    void 0 === a && (a = new ab());\n    var c = this;\n    return Bk(this, function (a, e) {\n      a = Ck(c, a, \"SVG\", b);\n      a = null !== a ? a.svg : null;\n      return \"function\" === typeof e ? (e(a), null) : a;\n    }, a);\n  };\n  Q.prototype.makeSvg = Q.prototype.Zt;\n  Q.prototype.hw = function (a) {\n    return this.Zt(a);\n  };\n  Q.prototype.makeSVG = Q.prototype.hw;\n  Y.prototype.iy = function (a, b) {\n    if (!(a instanceof Wl)) return !1;\n    if (!this.visible) return !0;\n    var c = null,\n      d = a.Oq;\n    if (this instanceof X && (this.type === X.TableRow || this.type === X.TableColumn)) return pl(this, a, b), !0;\n    var e = this.xb;\n    if (0 === e.width || 0 === e.height || isNaN(e.x) || isNaN(e.y)) return !0;\n    var f = this.transform,\n      g = this.panel;\n    0 !== (this.F & 4096) === !0 && ql(this);\n    var h = 0 !== (this.F & 256),\n      k = !1;\n    this instanceof Vg && (a.font = this.font);\n    if (h) {\n      k = g.de() ? g.naturalBounds : g.actualBounds;\n      if (null !== this.pd) {\n        var l = this.pd;\n        var m = l.x;\n        var n = l.y;\n        var p = l.width;\n        l = l.height;\n      } else m = Math.max(e.x, k.x), n = Math.max(e.y, k.y), p = Math.min(e.right, k.right) - m, l = Math.min(e.bottom, k.bottom) - n;\n      if (m > e.width + e.x || e.x > k.width + k.x || n > e.height + e.y || e.y > k.height + k.y) return !0;\n      k = !0;\n      Xl(a, 1, 0, 0, 1, 0, 0);\n      a.save();\n      a.beginPath();\n      a.rect(m, n, p, l);\n      a.clip();\n    }\n    if (this.Ef() && !this.isVisible()) return !0;\n    a.Xd.Ma = [1, 0, 0, 1, 0, 0];\n    (this instanceof Vg && 1 < this.lineCount || this instanceof W && 1 < this.geometry.figures.length) && Xl(a, 1, 0, 0, 1, 0, 0);\n    m = !1;\n    this.Ef() && this.isShadowed && b.Ge(\"drawShadows\") && (n = this.shadowOffset, a.Hw(n.x * b.scale * b.Sb, n.y * b.scale * b.Sb, this.shadowBlur), rl(a), a.shadowColor = this.shadowColor);\n    n = !1;\n    this.part && b.Ge(\"drawShadows\") && (n = this.part.isShadowed);\n    !0 === this.shadowVisible ? (rl(a), !1 === m && n && (Xl(a, 1, 0, 0, 1, 0, 0), a.gr(), m = !0)) : !1 === this.shadowVisible && sl(a);\n    p = this.naturalBounds;\n    null !== this.areaBackground && (li(this, a, this.areaBackground, !0, !0, p, e), !1 === m && n && (Xl(a, 1, 0, 0, 1, 0, 0), a.gr(), m = !0), this.areaBackground instanceof tl && this.areaBackground.type === ul ? (a.beginPath(), a.rect(e.x, e.y, e.width, e.height), a.Yd(this.areaBackground)) : a.fillRect(e.x, e.y, e.width, e.height));\n    this instanceof X ? Xl(a, f.m11, f.m12, f.m21, f.m22, f.dx, f.dy) : a.Xd.Ma = [f.m11, f.m12, f.m21, f.m22, f.dx, f.dy];\n    if (null !== this.background) {\n      !1 === m && n && (Xl(a, 1, 0, 0, 1, 0, 0), a.gr(), m = !0);\n      var r = this.naturalBounds;\n      l = f = 0;\n      var q = r.width;\n      r = r.height;\n      var u = 0;\n      this instanceof W && (r = this.geometry.bounds, f = r.x, l = r.y, q = r.width, r = r.height, u = this.strokeWidth);\n      li(this, a, this.background, !0, !1, p, e);\n      this.background instanceof tl && this.background.type === ul ? (a.beginPath(), a.rect(f - u / 2, l - u / 2, q + u, r + u), a.Yd(this.background)) : a.fillRect(f - u / 2, l - u / 2, q + u, r + u);\n    }\n    n && (null !== this.background || null !== this.areaBackground || null !== g && 0 !== (g.F & 512) || null !== g && (g.type === X.Auto || g.type === X.Spot) && g.pb() !== this) ? (vl(this, !0), null === this.shadowVisible && sl(a)) : vl(this, !1);\n    this.ej(a, b);\n    n && 0 !== (this.F & 512) === !0 && rl(a);\n    this.Ef() && n && sl(a);\n    h && (a.restore(), k && a.zc.pop());\n    this instanceof X && (c = a.zc.pop());\n    !0 === m && a.zc.pop();\n    if (this instanceof Vg && 1 < this.lineCount || this instanceof W && 1 < this.geometry.figures.length) c = a.zc.pop();\n    null !== a.Mk.Bq && (null === c && (d === a.Oq ? (Xl(a, 1, 0, 0, 1, 0, 0), c = a.zc.pop()) : c = a.Oq), a.Mk.Bq(this, c));\n    this.svg = c;\n    return !0;\n  };\n  function Dk(a, b) {\n    this.ownerDocument = b = void 0 === b ? x.document : b;\n    this.Bq = null;\n    b = b.createElement(\"canvas\");\n    b.tabIndex = 0;\n    this.Ga = b;\n    this.Ga.innerHTML = \"This text is displayed if your browser does not support the Canvas HTML element.\";\n    this.context = new xl(b);\n    b.B = a;\n  }\n  Dk.prototype.resize = function (a, b, c, d) {\n    return this.width !== a || this.height !== b ? (this.width = a, this.height = b, this.style.width = c + \"px\", this.style.height = d + \"px\", !0) : !1;\n  };\n  Dk.prototype.toDataURL = function (a, b) {\n    return this.Ga.toDataURL(a, b);\n  };\n  Dk.prototype.getBoundingClientRect = function () {\n    return this.Ga.getBoundingClientRect();\n  };\n  Dk.prototype.focus = function () {\n    this.Ga.focus();\n  };\n  Dk.prototype.hy = function () {\n    this.ownerDocument = this.Ga.B = null;\n  };\n  ma.Object.defineProperties(Dk.prototype, {\n    width: {\n      get: function () {\n        return this.Ga.width;\n      },\n      set: function (a) {\n        this.Ga.width = a;\n      }\n    },\n    height: {\n      get: function () {\n        return this.Ga.height;\n      },\n      set: function (a) {\n        this.Ga.height = a;\n      }\n    },\n    style: {\n      get: function () {\n        return this.Ga.style;\n      }\n    }\n  });\n  Dk.className = \"CanvasSurface\";\n  function xl(a) {\n    a.getContext && a.getContext(\"2d\") || B(\"Browser does not support HTML Canvas Element\");\n    this.Y = a.getContext(\"2d\");\n    this.wu = this.yu = this.xu = \"\";\n    this.xn = !1;\n    this.jf = this.Vp = this.Up = 0;\n  }\n  t = xl.prototype;\n  t.Py = function (a) {\n    this.Y.imageSmoothingEnabled = a;\n  };\n  t.arc = function (a, b, c, d, e, f) {\n    this.Y.arc(a, b, c, d, e, f);\n  };\n  t.beginPath = function () {\n    this.Y.beginPath();\n  };\n  t.bezierCurveTo = function (a, b, c, d, e, f) {\n    this.Y.bezierCurveTo(a, b, c, d, e, f);\n  };\n  t.clearRect = function (a, b, c, d) {\n    this.Y.clearRect(a, b, c, d);\n  };\n  t.clip = function () {\n    this.Y.clip();\n  };\n  t.closePath = function () {\n    this.Y.closePath();\n  };\n  t.createLinearGradient = function (a, b, c, d) {\n    return this.Y.createLinearGradient(a, b, c, d);\n  };\n  t.createPattern = function (a, b) {\n    return this.Y.createPattern(a, b);\n  };\n  t.createRadialGradient = function (a, b, c, d, e, f) {\n    return this.Y.createRadialGradient(a, b, c, d, e, f);\n  };\n  t.drawImage = function (a, b, c, d, e, f, g, h, k) {\n    void 0 === d ? this.Y.drawImage(a, b, c) : this.Y.drawImage(a, b, c, d, e, f, g, h, k);\n  };\n  t.fill = function () {\n    this.Y.fill();\n  };\n  t.fillRect = function (a, b, c, d) {\n    this.Y.fillRect(a, b, c, d);\n  };\n  t.fillText = function (a, b, c) {\n    this.Y.fillText(a, b, c);\n  };\n  t.getImageData = function (a, b, c, d) {\n    return this.Y.getImageData(a, b, c, d);\n  };\n  t.lineTo = function (a, b) {\n    this.Y.lineTo(a, b);\n  };\n  t.measureText = function (a) {\n    return this.Y.measureText(a);\n  };\n  t.moveTo = function (a, b) {\n    this.Y.moveTo(a, b);\n  };\n  t.quadraticCurveTo = function (a, b, c, d) {\n    this.Y.quadraticCurveTo(a, b, c, d);\n  };\n  t.rect = function (a, b, c, d) {\n    this.Y.rect(a, b, c, d);\n  };\n  t.restore = function () {\n    this.Y.restore();\n  };\n  xl.prototype.rotate = function (a) {\n    this.Y.rotate(a);\n  };\n  t = xl.prototype;\n  t.save = function () {\n    this.Y.save();\n  };\n  t.setTransform = function (a, b, c, d, e, f) {\n    this.Y.setTransform(a, b, c, d, e, f);\n  };\n  t.scale = function (a, b) {\n    this.Y.scale(a, b);\n  };\n  t.stroke = function () {\n    this.Y.stroke();\n  };\n  t.transform = function (a, b, c, d, e, f) {\n    1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || this.Y.transform(a, b, c, d, e, f);\n  };\n  t.translate = function (a, b) {\n    this.Y.translate(a, b);\n  };\n  t.Yd = function (a) {\n    if (a instanceof tl && a.type === ul) {\n      var b = a.$k;\n      a = a.zu;\n      a > b ? (this.scale(b / a, 1), this.translate((a - b) / 2, 0)) : b > a && (this.scale(1, a / b), this.translate(0, (b - a) / 2));\n      this.xn ? this.clip() : this.fill();\n      a > b ? (this.translate(-(a - b) / 2, 0), this.scale(1 / (b / a), 1)) : b > a && (this.translate(0, -(b - a) / 2), this.scale(1, 1 / (a / b)));\n    } else this.xn ? this.clip() : this.fill();\n  };\n  t.uj = function () {\n    this.xn || this.stroke();\n  };\n  t.Hw = function (a, b, c) {\n    this.Up = a;\n    this.Vp = b;\n    this.jf = c;\n  };\n  t.Gt = function (a, b) {\n    var c = this.Y;\n    void 0 !== c.setLineDash && (c.setLineDash(a), c.lineDashOffset = b);\n  };\n  t.Et = function () {\n    var a = this.Y;\n    void 0 !== a.setLineDash && (a.setLineDash($l), a.lineDashOffset = 0);\n  };\n  t.tc = function (a) {\n    a && (this.xu = \"\");\n    this.wu = this.yu = \"\";\n  };\n  ma.Object.defineProperties(xl.prototype, {\n    fillStyle: {\n      get: function () {\n        return this.Y.fillStyle;\n      },\n      set: function (a) {\n        this.wu !== a && (this.wu = this.Y.fillStyle = a);\n      }\n    },\n    font: {\n      get: function () {\n        return this.Y.font;\n      },\n      set: function (a) {\n        this.xu !== a && (this.xu = this.Y.font = a);\n      }\n    },\n    globalAlpha: {\n      get: function () {\n        return this.Y.globalAlpha;\n      },\n      set: function (a) {\n        this.Y.globalAlpha = a;\n      }\n    },\n    lineCap: {\n      get: function () {\n        return this.Y.lineCap;\n      },\n      set: function (a) {\n        this.Y.lineCap = a;\n      }\n    },\n    lineDashOffset: {\n      get: function () {\n        return this.Y.lineDashOffset;\n      },\n      set: function (a) {\n        this.Y.lineDashOffset = a;\n      }\n    },\n    lineJoin: {\n      get: function () {\n        return this.Y.lineJoin;\n      },\n      set: function (a) {\n        this.Y.lineJoin = a;\n      }\n    },\n    lineWidth: {\n      get: function () {\n        return this.Y.lineWidth;\n      },\n      set: function (a) {\n        this.Y.lineWidth = a;\n      }\n    },\n    miterLimit: {\n      get: function () {\n        return this.Y.miterLimit;\n      },\n      set: function (a) {\n        this.Y.miterLimit = a;\n      }\n    },\n    shadowBlur: {\n      get: function () {\n        return this.Y.shadowBlur;\n      },\n      set: function (a) {\n        this.Y.shadowBlur = a;\n      }\n    },\n    shadowColor: {\n      get: function () {\n        return this.Y.shadowColor;\n      },\n      set: function (a) {\n        this.Y.shadowColor = a;\n      }\n    },\n    shadowOffsetX: {\n      get: function () {\n        return this.Y.shadowOffsetX;\n      },\n      set: function (a) {\n        this.Y.shadowOffsetX = a;\n      }\n    },\n    shadowOffsetY: {\n      get: function () {\n        return this.Y.shadowOffsetY;\n      },\n      set: function (a) {\n        this.Y.shadowOffsetY = a;\n      }\n    },\n    strokeStyle: {\n      get: function () {\n        return this.Y.strokeStyle;\n      },\n      set: function (a) {\n        this.yu !== a && (this.yu = this.Y.strokeStyle = a);\n      }\n    },\n    textAlign: {\n      get: function () {\n        return this.Y.textAlign;\n      },\n      set: function (a) {\n        this.Y.textAlign = a;\n      }\n    },\n    imageSmoothingEnabled: {\n      get: function () {\n        return this.Y.imageSmoothingEnabled;\n      },\n      set: function (a) {\n        this.Y.imageSmoothingEnabled = a;\n      }\n    },\n    clipInsteadOfFill: {\n      get: function () {\n        return this.xn;\n      },\n      set: function (a) {\n        this.xn = a;\n      }\n    }\n  });\n  var $l = Object.freeze([]);\n  xl.className = \"CanvasSurfaceContext\";\n  function am() {\n    this.T = this.v = this.I = this.l = 0;\n  }\n  am.className = \"ColorNumbers\";\n  function tl(a) {\n    bm || (cm(), bm = !0);\n    Ya(this);\n    this.s = !1;\n    void 0 === a ? (this.pa = wl, this.Zk = \"black\") : \"string\" === typeof a ? (this.pa = wl, this.Zk = a) : (this.pa = a, this.Zk = \"black\");\n    a = this.pa;\n    a === zl ? (this.yd = yc, this.ll = Gc) : this.ll = a === ul ? this.yd = Bc : this.yd = vc;\n    this.jt = 0;\n    this.Xr = NaN;\n    this.ge = this.Ms = this.fe = null;\n    this.zu = this.$k = 0;\n  }\n  tl.prototype.copy = function () {\n    var a = new tl();\n    a.pa = this.pa;\n    a.Zk = this.Zk;\n    a.yd = this.yd.G();\n    a.ll = this.ll.G();\n    a.jt = this.jt;\n    a.Xr = this.Xr;\n    null !== this.fe && (a.fe = this.fe.copy());\n    a.Ms = this.Ms;\n    return a;\n  };\n  t = tl.prototype;\n  t.freeze = function () {\n    this.s = !0;\n    null !== this.fe && this.fe.freeze();\n    return this;\n  };\n  t.ea = function () {\n    Object.isFrozen(this) && B(\"cannot thaw constant: \" + this);\n    this.s = !1;\n    null !== this.fe && this.fe.ea();\n    return this;\n  };\n  t.hb = function (a) {\n    a.classType === tl && (this.type = a);\n  };\n  t.toString = function () {\n    var a = \"Brush(\";\n    if (this.type === wl) a += this.color;else if (a = this.type === zl ? a + \"Linear \" : this.type === ul ? a + \"Radial \" : this.type === yl ? a + \"Pattern \" : a + \"(unknown) \", a += this.start + \" \" + this.end, null !== this.colorStops) for (var b = this.colorStops.iterator; b.next();) a += \" \" + b.key + \":\" + b.value;\n    return a + \")\";\n  };\n  t.addColorStop = function (a, b) {\n    this.s && ua(this);\n    (\"number\" !== typeof a || !isFinite(a) || 1 < a || 0 > a) && va(a, \"0 <= loc <= 1\", tl, \"addColorStop:loc\");\n    null === this.fe && (this.fe = new H());\n    this.fe.add(a, b);\n    this.pa === wl && (this.type = zl);\n    this.ge = null;\n    return this;\n  };\n  t.BA = function (a, b) {\n    this.s && ua(this);\n    a = void 0 === a || \"number\" !== typeof a ? .2 : a;\n    b = void 0 === b ? dm : b;\n    if (this.type === wl) Uh(this.color), this.color = em(a, b);else if ((this.type === zl || this.type === ul) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();) Uh(c.value), this.addColorStop(c.key, em(a, b));\n    return this;\n  };\n  function fm(a, b, c) {\n    b = void 0 === b || \"number\" !== typeof b ? .2 : b;\n    c = void 0 === c ? dm : c;\n    Uh(a);\n    return em(b, c);\n  }\n  t.Dz = function (a, b) {\n    this.s && ua(this);\n    a = void 0 === a || \"number\" !== typeof a ? .2 : a;\n    b = void 0 === b ? dm : b;\n    if (this.type === wl) Uh(this.color), this.color = em(-a, b);else if ((this.type === zl || this.type === ul) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();) Uh(c.value), this.addColorStop(c.key, em(-a, b));\n    return this;\n  };\n  function gm(a, b, c) {\n    b = void 0 === b || \"number\" !== typeof b ? .2 : b;\n    c = void 0 === c ? dm : c;\n    Uh(a);\n    return em(-b, c);\n  }\n  function hm(a, b, c) {\n    Uh(a);\n    a = im.l;\n    var d = im.I,\n      e = im.v,\n      f = im.T;\n    Uh(b);\n    void 0 === c && (c = .5);\n    return \"rgba(\" + Math.round((im.l - a) * c + a) + \", \" + Math.round((im.I - d) * c + d) + \", \" + Math.round((im.v - e) * c + e) + \", \" + Math.round((im.T - f) * c + f) + \")\";\n  }\n  t.Cy = function () {\n    if (this.type === wl) return jm(this.color);\n    if ((this.type === zl || this.type === ul) && null !== this.colorStops) {\n      var a = this.colorStops;\n      if (this.type === ul) return jm(a.first().value);\n      if (null !== a.get(.5)) return jm(a.get(.5));\n      if (2 === a.count) return a = a.ma(), jm(hm(a[0].value, a[1].value));\n      for (var b = a.iterator, c = -1, d = -1, e = 1, f = 1; b.next();) {\n        var g = b.key,\n          h = Math.abs(.5 - b.key);\n        e > f && h < e ? (c = g, e = h) : f >= e && h < f && (d = g, f = h);\n      }\n      c > d && (f = c, c = d, d = f, f = e);\n      e = d - c;\n      return jm(hm(a.get(c), a.get(d), 1 - f / e));\n    }\n    return !1;\n  };\n  function jm(a) {\n    if (!a) return !1;\n    if (a instanceof tl) return a.Cy();\n    Uh(a);\n    return 128 > (299 * im.l + 587 * im.I + 114 * im.v) / 1E3;\n  }\n  function em(a, b) {\n    switch (b) {\n      case dm:\n        b = 100 * km(im.l);\n        var c = 100 * km(im.I),\n          d = 100 * km(im.v);\n        lm.l = .4124564 * b + .3575761 * c + .1804375 * d;\n        lm.I = .2126729 * b + .7151522 * c + .072175 * d;\n        lm.v = .0193339 * b + .119192 * c + .9503041 * d;\n        lm.T = im.T;\n        b = mm(lm.l / nm[0]);\n        c = mm(lm.I / nm[1]);\n        d = mm(lm.v / nm[2]);\n        om.l = 116 * c - 16;\n        om.I = 500 * (b - c);\n        om.v = 200 * (c - d);\n        om.T = lm.T;\n        om.l = Math.min(100, Math.max(0, om.l + 100 * a));\n        a = (om.l + 16) / 116;\n        b = a - om.v / 200;\n        lm.l = nm[0] * pm(om.I / 500 + a);\n        lm.I = nm[1] * (om.l > qm * rm ? Math.pow(a, 3) : om.l / qm);\n        lm.v = nm[2] * pm(b);\n        lm.T = om.T;\n        a = -.969266 * lm.l + 1.8760108 * lm.I + .041556 * lm.v;\n        b = .0556434 * lm.l + -.2040259 * lm.I + 1.0572252 * lm.v;\n        im.l = 255 * sm((3.2404542 * lm.l + -1.5371385 * lm.I + -.4985314 * lm.v) / 100);\n        im.I = 255 * sm(a / 100);\n        im.v = 255 * sm(b / 100);\n        im.T = lm.T;\n        im.l = Math.round(im.l);\n        255 < im.l ? im.l = 255 : 0 > im.l && (im.l = 0);\n        im.I = Math.round(im.I);\n        255 < im.I ? im.I = 255 : 0 > im.I && (im.I = 0);\n        im.v = Math.round(im.v);\n        255 < im.v ? im.v = 255 : 0 > im.v && (im.v = 0);\n        return \"rgba(\" + im.l + \", \" + im.I + \", \" + im.v + \", \" + im.T + \")\";\n      case tm:\n        return Vh(), Wh.v = Math.min(100, Math.max(0, Wh.v + 100 * a)), \"hsla(\" + Wh.l + \", \" + Wh.I + \"%, \" + Wh.v + \"%, \" + Wh.T + \")\";\n      default:\n        return B(\"Unknown color space: \" + b), \"rgba(0, 0, 0, 1)\";\n    }\n  }\n  function Uh(a) {\n    bm || (cm(), bm = !0);\n    var b = um;\n    if (null !== b) {\n      b.clearRect(0, 0, 1, 1);\n      b.fillStyle = \"#000000\";\n      var c = b.fillStyle;\n      b.fillStyle = a;\n      b.fillStyle !== c ? (b.fillRect(0, 0, 1, 1), a = b.getImageData(0, 0, 1, 1).data, im.l = a[0], im.I = a[1], im.v = a[2], im.T = a[3] / 255) : (b.fillStyle = \"#FFFFFF\", b.fillStyle = a, im.l = 0, im.I = 0, im.v = 0, im.T = 1);\n    }\n  }\n  function Vh() {\n    var a = im.l / 255,\n      b = im.I / 255,\n      c = im.v / 255,\n      d = Math.max(a, b, c),\n      e = Math.min(a, b, c),\n      f = d - e;\n    e = (d + e) / 2;\n    if (0 === f) var g = a = 0;else {\n      switch (d) {\n        case a:\n          g = (b - c) / f % 6;\n          break;\n        case b:\n          g = (c - a) / f + 2;\n          break;\n        case c:\n          g = (a - b) / f + 4;\n      }\n      g *= 60;\n      0 > g && (g += 360);\n      a = f / (1 - Math.abs(2 * e - 1));\n    }\n    Wh.l = Math.round(g);\n    Wh.I = Math.round(100 * a);\n    Wh.v = Math.round(100 * e);\n    Wh.T = im.T;\n  }\n  function km(a) {\n    a /= 255;\n    return .04045 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4);\n  }\n  function sm(a) {\n    return .0031308 >= a ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055;\n  }\n  function mm(a) {\n    return a > rm ? Math.pow(a, 1 / 3) : (qm * a + 16) / 116;\n  }\n  function pm(a) {\n    var b = a * a * a;\n    return b > rm ? b : (116 * a - 16) / qm;\n  }\n  function Rl(a, b) {\n    \"string\" !== typeof a && (a instanceof tl || B(\"Value for \" + b + \" must be a color string or a Brush, not \" + a));\n  }\n  function cm() {\n    um = Tg ? new Dk(null).context : null;\n  }\n  ma.Object.defineProperties(tl.prototype, {\n    type: {\n      get: function () {\n        return this.pa;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.pa = a;\n        this.start.mc() && (a === zl ? this.start = yc : a === ul && (this.start = Bc));\n        this.end.mc() && (a === zl ? this.end = Gc : a === ul && (this.end = Bc));\n        this.ge = null;\n      }\n    },\n    color: {\n      get: function () {\n        return this.Zk;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Zk = a;\n        this.ge = null;\n      }\n    },\n    start: {\n      get: function () {\n        return this.yd;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.yd = a.G();\n        this.ge = null;\n      }\n    },\n    end: {\n      get: function () {\n        return this.ll;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.ll = a.G();\n        this.ge = null;\n      }\n    },\n    startRadius: {\n      get: function () {\n        return this.jt;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        0 > a && va(a, \">= zero\", tl, \"startRadius\");\n        this.jt = a;\n        this.ge = null;\n      }\n    },\n    endRadius: {\n      get: function () {\n        return this.Xr;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        0 > a && va(a, \">= zero\", tl, \"endRadius\");\n        this.Xr = a;\n        this.ge = null;\n      }\n    },\n    colorStops: {\n      get: function () {\n        return this.fe;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.fe = a;\n        this.ge = null;\n      }\n    },\n    pattern: {\n      get: function () {\n        return this.Ms;\n      },\n      set: function (a) {\n        this.s && ua(this, a);\n        this.Ms = a;\n        this.ge = null;\n      }\n    }\n  });\n  tl.prototype.isDark = tl.prototype.Cy;\n  tl.prototype.darkenBy = tl.prototype.Dz;\n  tl.prototype.lightenBy = tl.prototype.BA;\n  tl.prototype.addColorStop = tl.prototype.addColorStop;\n  var rm = 216 / 24389,\n    qm = 24389 / 27,\n    nm = [95.047, 100, 108.883],\n    um = null,\n    im = new am(),\n    Wh = new am(),\n    lm = new am(),\n    om = new am(),\n    bm = !1;\n  tl.className = \"Brush\";\n  var wl;\n  tl.Solid = wl = new D(tl, \"Solid\", 0);\n  var zl;\n  tl.Linear = zl = new D(tl, \"Linear\", 1);\n  var ul;\n  tl.Radial = ul = new D(tl, \"Radial\", 2);\n  var yl;\n  tl.Pattern = yl = new D(tl, \"Pattern\", 4);\n  var dm;\n  tl.Lab = dm = new D(tl, \"Lab\", 5);\n  var tm;\n  tl.HSL = tm = new D(tl, \"HSL\", 6);\n  tl.randomColor = function (a, b) {\n    void 0 === a && (a = 128);\n    void 0 === b && (b = Math.max(a, 255));\n    var c = Math.abs(b - a);\n    b = Math.floor(a + Math.random() * c).toString(16);\n    var d = Math.floor(a + Math.random() * c).toString(16);\n    a = Math.floor(a + Math.random() * c).toString(16);\n    2 > b.length && (b = \"0\" + b);\n    2 > d.length && (d = \"0\" + d);\n    2 > a.length && (a = \"0\" + a);\n    return \"#\" + b + d + a;\n  };\n  tl.isValidColor = function (a) {\n    if (\"black\" === a) return !0;\n    if (\"\" === a) return !1;\n    bm || (cm(), bm = !0);\n    var b = um;\n    if (null === b) return !0;\n    b.fillStyle = \"#000000\";\n    var c = b.fillStyle;\n    b.fillStyle = a;\n    if (b.fillStyle !== c) return !0;\n    b.fillStyle = \"#FFFFFF\";\n    c = b.fillStyle;\n    b.fillStyle = a;\n    return b.fillStyle !== c;\n  };\n  tl.lighten = function (a) {\n    return fm(a);\n  };\n  tl.lightenBy = fm;\n  tl.darken = function (a) {\n    return gm(a);\n  };\n  tl.darkenBy = gm;\n  tl.mix = hm;\n  tl.isDark = jm;\n  function Ol() {\n    this.name = \"Base\";\n  }\n  Ol.prototype.measure = function () {};\n  Ol.prototype.EA = function (a, b, c, d, e) {\n    a.measure(b, c, d, e);\n  };\n  Ol.prototype.arrange = function () {};\n  Ol.prototype.qz = function (a, b, c, d, e, f) {\n    a.arrange(b, c, d, e, f);\n  };\n  Ol.prototype.bc = function () {};\n  ma.Object.defineProperties(Ol.prototype, {\n    classType: {\n      get: function () {\n        return X;\n      }\n    }\n  });\n  Ol.prototype.arrangeElement = Ol.prototype.qz;\n  Ol.prototype.measureElement = Ol.prototype.EA;\n  Ol.className = \"PanelLayout\";\n  function vm() {\n    this.name = \"Base\";\n  }\n  la(vm, Ol);\n  vm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length;\n    a = wm(a);\n    for (var k = 0; k < h; k++) {\n      var l = d[k];\n      if (l.visible || l === a) {\n        var m = l.margin,\n          n = m.right + m.left;\n        m = m.top + m.bottom;\n        l.measure(b, c, f, g);\n        var p = l.measuredBounds;\n        n = Math.max(p.width + n, 0);\n        m = Math.max(p.height + m, 0);\n        p = l.position.x;\n        var r = l.position.y;\n        isFinite(p) || (p = 0);\n        isFinite(r) || (r = 0);\n        l instanceof W && l.isGeometryPositioned && (l = l.strokeWidth / 2, p -= l, r -= l);\n        fc(e, p, r, n, m);\n      }\n    }\n  };\n  vm.prototype.arrange = function (a, b, c) {\n    var d = b.length,\n      e = a.padding;\n    a = c.x - e.left;\n    c = c.y - e.top;\n    for (e = 0; e < d; e++) {\n      var f = b[e],\n        g = f.measuredBounds,\n        h = f.margin,\n        k = f.position.x,\n        l = f.position.y;\n      k = isNaN(k) ? -a : k - a;\n      l = isNaN(l) ? -c : l - c;\n      if (f instanceof W && f.isGeometryPositioned) {\n        var m = f.strokeWidth / 2;\n        k -= m;\n        l -= m;\n      }\n      f.visible && f.arrange(k + h.left, l + h.top, g.width, g.height);\n    }\n  };\n  function xm() {\n    this.name = \"Base\";\n  }\n  la(xm, Ol);\n  xm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length;\n    b = Ea();\n    f = wm(a);\n    for (var k = 0; k < h; k++) {\n      var l = d[k];\n      if (l.visible || l === f) {\n        var m = kl(l, !1);\n        if (m !== yg && m !== Wk) b.push(l);else {\n          l.measure(Infinity, c, 0, g);\n          m = l.margin;\n          l = l.measuredBounds;\n          var n = Math.max(l.height + m.top + m.bottom, 0);\n          e.width += Math.max(l.width + m.right + m.left, 0);\n          e.height = Math.max(e.height, n);\n        }\n      }\n    }\n    d = b.length;\n    a.desiredSize.height ? c = Math.min(a.desiredSize.height, a.maxSize.height) : 0 !== e.height && (c = Math.min(e.height, a.maxSize.height));\n    for (a = 0; a < d; a++) if (k = b[a], k.visible || k === f) m = k.margin, h = m.right + m.left, m = m.top + m.bottom, k.measure(Infinity, c, 0, g), k = k.measuredBounds, m = Math.max(k.height + m, 0), e.width += Math.max(k.width + h, 0), e.height = Math.max(e.height, m);\n    Ha(b);\n  };\n  xm.prototype.arrange = function (a, b, c) {\n    for (var d = b.length, e = a.padding, f = e.top, g = a.isOpposite, h = g ? c.width : e.left, k = 0; k < d; k++) {\n      var l = f,\n        m = b[k];\n      if (m.visible) {\n        var n = m.measuredBounds,\n          p = m.margin,\n          r = p.top + p.bottom,\n          q = f + e.bottom,\n          u = n.height,\n          v = kl(m, !1);\n        if (isNaN(m.desiredSize.height) && v === vd || v === Xk) u = Math.max(c.height - r - q, 0);\n        r = u + r + q;\n        q = m.alignment;\n        q.Mb() && (q = a.defaultAlignment);\n        q.ib() || (q = Bc);\n        g && (h -= n.width + p.left + p.right);\n        m.arrange(h + q.offsetX + p.left, l + q.offsetY + p.top + (c.height * q.y - r * q.y), n.width, u);\n        g || (h += n.width + p.left + p.right);\n      }\n    }\n  };\n  function ym() {\n    this.name = \"Base\";\n  }\n  la(ym, Ol);\n  ym.prototype.measure = function (a, b, c, d, e, f) {\n    var g = d.length;\n    c = Ea();\n    for (var h = wm(a), k = 0; k < g; k++) {\n      var l = d[k];\n      if (l.visible || l === h) {\n        var m = kl(l, !1);\n        if (m !== yg && m !== Xk) c.push(l);else {\n          var n = l.margin;\n          m = n.right + n.left;\n          n = n.top + n.bottom;\n          l.measure(b, Infinity, f, 0);\n          l = l.measuredBounds;\n          Wb(e, Math.max(e.width, Math.max(l.width + m, 0)), e.height + Math.max(l.height + n, 0));\n        }\n      }\n    }\n    d = c.length;\n    if (0 !== d) {\n      a.desiredSize.width ? b = Math.min(a.desiredSize.width, a.maxSize.width) : 0 !== e.width && (b = Math.min(e.width, a.maxSize.width));\n      for (a = 0; a < d; a++) if (k = c[a], k.visible || k === h) l = k.margin, g = l.right + l.left, l = l.top + l.bottom, k.measure(b, Infinity, f, 0), k = k.measuredBounds, l = Math.max(k.height + l, 0), e.width = Math.max(e.width, Math.max(k.width + g, 0)), e.height += l;\n      Ha(c);\n    }\n  };\n  ym.prototype.arrange = function (a, b, c) {\n    for (var d = b.length, e = a.padding, f = e.left, g = a.isOpposite, h = g ? c.height : e.top, k = 0; k < d; k++) {\n      var l = f,\n        m = b[k];\n      if (m.visible) {\n        var n = m.measuredBounds,\n          p = m.margin,\n          r = p.left + p.right,\n          q = f + e.right,\n          u = n.width,\n          v = kl(m, !1);\n        if (isNaN(m.desiredSize.width) && v === vd || v === Wk) u = Math.max(c.width - r - q, 0);\n        r = u + r + q;\n        q = m.alignment;\n        q.Mb() && (q = a.defaultAlignment);\n        q.ib() || (q = Bc);\n        g && (h -= n.height + p.bottom + p.top);\n        m.arrange(l + q.offsetX + p.left + (c.width * q.x - r * q.x), h + q.offsetY + p.top, u, n.height);\n        g || (h += n.height + p.bottom + p.top);\n      }\n    }\n  };\n  function zm() {\n    this.name = \"Base\";\n  }\n  la(zm, Ol);\n  zm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length,\n      k = a.pb(),\n      l = k.margin,\n      m = l.right + l.left,\n      n = l.top + l.bottom;\n    k.measure(b, c, f, g);\n    var p = k.measuredBounds;\n    f = p.width;\n    g = p.height;\n    var r = Math.max(f + m, 0);\n    var q = Math.max(g + n, 0);\n    for (var u = a.isClipping, v = N.allocAt(-l.left, -l.top, r, q), w = !0, y = wm(a), z = 0; z < h; z++) {\n      var A = d[z];\n      if (A !== k && (A.visible || A === y)) {\n        l = A.margin;\n        r = l.right + l.left;\n        q = l.top + l.bottom;\n        p = kl(A, !1);\n        switch (p) {\n          case vd:\n            b = f;\n            c = g;\n            break;\n          case Wk:\n            b = f;\n            break;\n          case Xk:\n            c = g;\n        }\n        A.measure(b, c, 0, 0);\n        p = A.measuredBounds;\n        r = Math.max(p.width + r, 0);\n        q = Math.max(p.height + q, 0);\n        var C = A.alignment;\n        C.Mb() && (C = a.defaultAlignment);\n        C.ib() || (C = Bc);\n        var G = A.alignmentFocus;\n        G.Mb() && (G = Bc);\n        var L = null;\n        A instanceof X && \"\" !== A.Lg && (A.arrange(0, 0, p.width, p.height), L = A.$a(A.Lg), L === A && (L = null));\n        if (null !== L) {\n          l = L.naturalBounds;\n          p = L.margin;\n          for (l = J.allocAt(G.x * l.width - G.offsetX - p.left, G.y * l.height - G.offsetY - p.top); L !== A;) L.transform.sa(l), L = L.panel;\n          A = C.x * f + C.offsetX - l.x;\n          p = C.y * g + C.offsetY - l.y;\n          J.free(l);\n        } else A = C.x * f + C.offsetX - (G.x * p.width + G.offsetX) - l.left, p = C.y * g + C.offsetY - (G.y * p.height + G.offsetY) - l.top;\n        w ? (w = !1, e.h(A, p, r, q)) : fc(e, A, p, r, q);\n      }\n    }\n    w ? e.assign(v) : u ? e.aw(v.x, v.y, v.width, v.height) : fc(e, v.x, v.y, v.width, v.height);\n    N.free(v);\n    p = k.stretch;\n    p === Vk && (p = kl(k, !1));\n    switch (p) {\n      case yg:\n        return;\n      case vd:\n        if (!isFinite(b) && !isFinite(c)) return;\n        break;\n      case Wk:\n        if (!isFinite(b)) return;\n        break;\n      case Xk:\n        if (!isFinite(c)) return;\n    }\n    p = k.measuredBounds;\n    f = p.width;\n    g = p.height;\n    r = Math.max(f + m, 0);\n    q = Math.max(g + n, 0);\n    l = k.margin;\n    v = N.allocAt(-l.left, -l.top, r, q);\n    for (b = 0; b < h; b++) c = d[b], c === k || !c.visible && c !== y || (l = c.margin, r = l.right + l.left, q = l.top + l.bottom, p = c.measuredBounds, r = Math.max(p.width + r, 0), q = Math.max(p.height + q, 0), m = c.alignment, m.Mb() && (m = a.defaultAlignment), m.ib() || (m = Bc), c = c.alignmentFocus, c.Mb() && (c = Bc), w ? (w = !1, e.h(m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, r, q)) : fc(e, m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, r, q));\n    w ? e.assign(v) : u ? e.aw(v.x, v.y, v.width, v.height) : fc(e, v.x, v.y, v.width, v.height);\n    N.free(v);\n  };\n  zm.prototype.arrange = function (a, b, c) {\n    var d = b.length,\n      e = a.pb(),\n      f = e.measuredBounds,\n      g = f.width;\n    f = f.height;\n    var h = a.padding,\n      k = h.left;\n    h = h.top;\n    var l = k - c.x,\n      m = h - c.y;\n    e.arrange(l, m, g, f);\n    for (var n = 0; n < d; n++) {\n      var p = b[n];\n      if (p !== e) {\n        var r = p.measuredBounds,\n          q = r.width;\n        r = r.height;\n        m = p.alignment;\n        m.Mb() && (m = a.defaultAlignment);\n        m.ib() || (m = Bc);\n        var u = p.alignmentFocus;\n        u.Mb() && (u = Bc);\n        l = null;\n        p instanceof X && \"\" !== p.Lg && (l = p.$a(p.Lg), l === p && (l = null));\n        if (null !== l) {\n          var v = l.naturalBounds;\n          for (u = J.allocAt(u.x * v.width - u.offsetX, u.y * v.height - u.offsetY); l !== p;) l.transform.sa(u), l = l.panel;\n          l = m.x * g + m.offsetX - u.x;\n          m = m.y * f + m.offsetY - u.y;\n          J.free(u);\n        } else l = m.x * g + m.offsetX - (u.x * q + u.offsetX), m = m.y * f + m.offsetY - (u.y * r + u.offsetY);\n        l -= c.x;\n        m -= c.y;\n        p.visible && p.arrange(k + l, h + m, q, r);\n      }\n    }\n  };\n  function Am() {\n    this.name = \"Base\";\n  }\n  la(Am, Ol);\n  Am.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length,\n      k = a.pb(),\n      l = k.margin,\n      m = b,\n      n = c,\n      p = l.right + l.left,\n      r = l.top + l.bottom;\n    k.measure(b, c, f, g);\n    l = k.measuredBounds;\n    var q = 0,\n      u = null;\n    k instanceof W && (u = k, q = u.strokeWidth * u.scale);\n    var v = Math.max(l.width + p, 0);\n    l = Math.max(l.height + r, 0);\n    var w = Bm(k),\n      y = w.x * v + w.offsetX;\n    w = w.y * l + w.offsetY;\n    var z = Cm(k),\n      A = z.x * v + z.offsetX;\n    z = z.y * l + z.offsetY;\n    isFinite(b) && (m = Math.max(Math.abs(y - A) - q, 0));\n    isFinite(c) && (n = Math.max(Math.abs(w - z) - q, 0));\n    q = M.alloc();\n    q.h(0, 0);\n    a = wm(a);\n    for (z = 0; z < h; z++) w = d[z], w === k || !w.visible && w !== a || (l = w.margin, v = l.right + l.left, y = l.top + l.bottom, w.measure(m, n, 0, 0), l = w.measuredBounds, v = Math.max(l.width + v, 0), l = Math.max(l.height + y, 0), q.h(Math.max(v, q.width), Math.max(l, q.height)));\n    if (1 === h) e.width = v, e.height = l, M.free(q);else {\n      w = Bm(k);\n      z = Cm(k);\n      h = d = 0;\n      z.x !== w.x && z.y !== w.y && (d = q.width / Math.abs(z.x - w.x), h = q.height / Math.abs(z.y - w.y));\n      M.free(q);\n      q = 0;\n      null !== u && (q = u.strokeWidth * u.scale, zg(u) === Ag && (d = h = Math.max(d, h)));\n      d += Math.abs(w.offsetX) + Math.abs(z.offsetX) + q;\n      h += Math.abs(w.offsetY) + Math.abs(z.offsetY) + q;\n      u = k.stretch;\n      u === Vk && (u = kl(k, !1));\n      switch (u) {\n        case yg:\n          g = f = 0;\n          break;\n        case vd:\n          isFinite(b) && (d = b);\n          isFinite(c) && (h = c);\n          break;\n        case Wk:\n          isFinite(b) && (d = b);\n          g = 0;\n          break;\n        case Xk:\n          f = 0, isFinite(c) && (h = c);\n      }\n      k.zm();\n      k.measure(d, h, f, g);\n      e.width = k.measuredBounds.width + p;\n      e.height = k.measuredBounds.height + r;\n    }\n  };\n  Am.prototype.arrange = function (a, b) {\n    var c = b.length,\n      d = a.pb(),\n      e = d.measuredBounds,\n      f = N.alloc();\n    f.h(0, 0, 1, 1);\n    var g = d.margin,\n      h = g.left;\n    g = g.top;\n    var k = a.padding,\n      l = k.left;\n    k = k.top;\n    d.arrange(l + h, k + g, e.width, e.height);\n    var m = Bm(d),\n      n = Cm(d),\n      p = m.y * e.height + m.offsetY,\n      r = n.x * e.width + n.offsetX;\n    n = n.y * e.height + n.offsetY;\n    f.x = m.x * e.width + m.offsetX;\n    f.y = p;\n    fc(f, r, n, 0, 0);\n    f.x += h + l;\n    f.y += g + k;\n    for (e = 0; e < c; e++) h = b[e], h !== d && (l = h.measuredBounds, g = h.margin, k = Math.max(l.width + g.right + g.left, 0), m = Math.max(l.height + g.top + g.bottom, 0), p = h.alignment, p.Mb() && (p = a.defaultAlignment), p.ib() || (p = Bc), k = f.width * p.x + p.offsetX - k * p.x + g.left + f.x, g = f.height * p.y + p.offsetY - m * p.y + g.top + f.y, h.visible && (gc(f.x, f.y, f.width, f.height, k, g, l.width, l.height) ? h.arrange(k, g, l.width, l.height) : h.arrange(k, g, l.width, l.height, new N(f.x, f.y, f.width, f.height))));\n    N.free(f);\n  };\n  function Dm() {\n    this.name = \"Base\";\n    this.name = \"Table\";\n  }\n  la(Dm, Ol);\n  Dm.prototype.measure = function (a, b, c, d, e, f, g) {\n    for (var h = d.length, k = Ea(), l = Ea(), m = 0; m < h; m++) {\n      var n = d[m],\n        p = n instanceof X ? n : null;\n      if (null === p || p.type !== X.TableRow && p.type !== X.TableColumn || !n.visible) k.push(n);else {\n        l.push(p);\n        for (var r = p.W.j, q = r.length, u = 0; u < q; u++) {\n          var v = r[u];\n          p.type === X.TableRow ? v.row = n.row : p.type === X.TableColumn && (v.column = n.column);\n          k.push(v);\n        }\n      }\n    }\n    h = k.length;\n    0 === h && (a.getRowDefinition(0), a.getColumnDefinition(0));\n    for (var w = [], y = 0; y < h; y++) {\n      var z = k[y];\n      nj(z, !0);\n      ll(z, !0);\n      w[z.row] || (w[z.row] = []);\n      w[z.row][z.column] || (w[z.row][z.column] = []);\n      w[z.row][z.column].push(z);\n    }\n    Ha(k);\n    var A = Ea(),\n      C = Ea(),\n      G = Ea(),\n      L = {\n        count: 0\n      },\n      I = {\n        count: 0\n      },\n      T = b,\n      R = c,\n      ca = a.ub;\n    h = ca.length;\n    for (var qa = 0; qa < h; qa++) {\n      var O = ca[qa];\n      void 0 !== O && (O.actual = 0);\n    }\n    ca = a.qb;\n    h = ca.length;\n    for (var za = 0; za < h; za++) O = ca[za], void 0 !== O && (O.actual = 0);\n    for (var Ma = w.length, jb = 0, Fa = 0; Fa < Ma; Fa++) w[Fa] && (jb = Math.max(jb, w[Fa].length));\n    var yb = Math.min(a.topIndex, Ma - 1),\n      Ad = Math.min(a.leftIndex, jb - 1),\n      kb = 0;\n    Ma = w.length;\n    for (var Zb = wm(a), bb = 0; bb < Ma; bb++) if (w[bb]) {\n      jb = w[bb].length;\n      for (var Nd = a.getRowDefinition(bb), xc = Nd.actual = 0; xc < jb; xc++) if (w[bb][xc]) {\n        var Bf = a.getColumnDefinition(xc);\n        void 0 === A[xc] && (Bf.actual = 0, A[xc] = !0);\n        for (var bf = w[bb][xc], Ie = bf.length, qh = 0; qh < Ie; qh++) {\n          var Ec = bf[qh];\n          if (Ec.visible || Ec === Zb) {\n            var Cf = 1 < Ec.rowSpan || 1 < Ec.columnSpan;\n            Cf && (bb < yb || xc < Ad || C.push(Ec));\n            var cf = Ec.margin,\n              Od = cf.right + cf.left,\n              bk = cf.top + cf.bottom;\n            var Gb = Dl(Ec, Nd, Bf, !1);\n            var Df = Ec.desiredSize,\n              Bd = !isNaN(Df.height),\n              lc = !isNaN(Df.width) && Bd;\n            Cf || Gb === yg || lc || bb < yb || xc < Ad || (void 0 !== L[xc] || Gb !== vd && Gb !== Wk || (L[xc] = -1, L.count++), void 0 !== I[bb] || Gb !== vd && Gb !== Xk || (I[bb] = -1, I.count++), G.push(Ec));\n            Ec.measure(Infinity, Infinity, 0, 0);\n            if (!(bb < yb || xc < Ad)) {\n              var df = Ec.measuredBounds,\n                Xc = Math.max(df.width + Od, 0),\n                dg = Math.max(df.height + bk, 0);\n              if (1 === Ec.rowSpan && (Gb === yg || Gb === Wk)) {\n                O = a.getRowDefinition(bb);\n                var rh = O.vc();\n                kb = Math.max(dg - O.actual, 0);\n                kb + rh > R && (kb = Math.max(R - rh, 0));\n                var wn = 0 === O.actual;\n                O.actual = O.actual + kb;\n                R = Math.max(R - (kb + (wn ? rh : 0)), 0);\n              }\n              if (1 === Ec.columnSpan && (Gb === yg || Gb === Xk)) {\n                O = a.getColumnDefinition(xc);\n                var eg = O.vc();\n                kb = Math.max(Xc - O.actual, 0);\n                kb + eg > T && (kb = Math.max(T - eg, 0));\n                var ck = 0 === O.actual;\n                O.actual = O.actual + kb;\n                T = Math.max(T - (kb + (ck ? eg : 0)), 0);\n              }\n              Cf && Ec.zm();\n            }\n          }\n        }\n      }\n    }\n    Ha(A);\n    var $b = 0,\n      Pc = 0;\n    h = a.columnCount;\n    for (var ec = 0; ec < h; ec++) {\n      var fg = a.qb[ec];\n      void 0 !== fg && ($b += fg.ha, 0 !== fg.ha && ($b += fg.vc()));\n    }\n    h = a.rowCount;\n    for (var sh = 0; sh < h; sh++) {\n      var ef = a.ub[sh];\n      void 0 !== ef && (Pc += ef.ha, 0 !== ef.ha && (Pc += ef.vc()));\n    }\n    T = Math.max(b - $b, 0);\n    var Ai = R = Math.max(c - Pc, 0),\n      ie = T;\n    h = G.length;\n    for (var Je = 0; Je < h; Je++) {\n      var mc = G[Je],\n        dk = a.getRowDefinition(mc.row),\n        xn = a.getColumnDefinition(mc.column),\n        gg = mc.measuredBounds,\n        zb = mc.margin,\n        hg = zb.right + zb.left,\n        ek = zb.top + zb.bottom;\n      L[mc.column] = 0 === xn.actual && void 0 !== L[mc.column] ? Math.max(gg.width + hg, L[mc.column]) : null;\n      I[mc.row] = 0 === dk.actual && void 0 !== I[mc.row] ? Math.max(gg.height + ek, I[mc.row]) : null;\n    }\n    var Bi = 0,\n      ig = 0,\n      Ef;\n    for (Ef in I) \"count\" !== Ef && (Bi += I[Ef]);\n    for (Ef in L) \"count\" !== Ef && (ig += L[Ef]);\n    for (var cb = M.alloc(), jg = 0; jg < h; jg++) {\n      var nc = G[jg];\n      if (nc.visible || nc === Zb) {\n        var Fc = a.getRowDefinition(nc.row),\n          db = a.getColumnDefinition(nc.column),\n          Cd = 0;\n        isFinite(db.width) ? Cd = db.width : (isFinite(T) && null !== L[nc.column] ? 0 === ig ? Cd = db.actual + T : Cd = L[nc.column] / ig * ie : null !== L[nc.column] ? Cd = T : Cd = db.actual || T, Cd = Math.max(0, Cd - db.vc()));\n        var Dd = 0;\n        isFinite(Fc.height) ? Dd = Fc.height : (isFinite(R) && null !== I[nc.row] ? 0 === Bi ? Dd = Fc.actual + R : Dd = I[nc.row] / Bi * Ai : null !== I[nc.row] ? Dd = R : Dd = Fc.actual || R, Dd = Math.max(0, Dd - Fc.vc()));\n        cb.h(Math.max(db.minimum, Math.min(Cd, db.maximum)), Math.max(Fc.minimum, Math.min(Dd, Fc.maximum)));\n        Gb = Dl(nc, Fc, db, !1);\n        switch (Gb) {\n          case Wk:\n            cb.height = Math.max(cb.height, Fc.actual + R);\n            break;\n          case Xk:\n            cb.width = Math.max(cb.width, db.actual + T);\n        }\n        var Pd = nc.margin,\n          yn = Pd.right + Pd.left,\n          th = Pd.top + Pd.bottom;\n        nc.zm();\n        nc.measure(cb.width, cb.height, db.minimum, Fc.minimum);\n        var uh = nc.measuredBounds,\n          vh = Math.max(uh.width + yn, 0),\n          wh = Math.max(uh.height + th, 0);\n        isFinite(T) && (vh = Math.min(vh, cb.width));\n        isFinite(R) && (wh = Math.min(wh, cb.height));\n        var kg = 0;\n        kg = Fc.actual;\n        Fc.actual = Math.max(Fc.actual, wh);\n        kb = Fc.actual - kg;\n        R = Math.max(R - kb, 0);\n        kg = db.actual;\n        db.actual = Math.max(db.actual, vh);\n        kb = db.actual - kg;\n        T = Math.max(T - kb, 0);\n      }\n    }\n    Ha(G);\n    var Ed = M.alloc(),\n      Yc = Ea(),\n      je = Ea();\n    h = C.length;\n    if (0 !== h) for (var Ab = 0; Ab < Ma; Ab++) if (w[Ab]) {\n      jb = w[Ab].length;\n      var Ci = a.getRowDefinition(Ab);\n      Yc[Ab] = Ci.actual;\n      for (var Zc = 0; Zc < jb; Zc++) if (w[Ab][Zc]) {\n        var zn = a.getColumnDefinition(Zc);\n        je[Zc] = zn.actual;\n      }\n    }\n    for (var ke = 0; ke < h; ke++) {\n      var Na = C[ke];\n      if (Na.visible || Na === Zb) {\n        var Fd = a.getRowDefinition(Na.row),\n          oc = a.getColumnDefinition(Na.column);\n        cb.h(Math.max(oc.minimum, Math.min(b, oc.maximum)), Math.max(Fd.minimum, Math.min(c, Fd.maximum)));\n        Gb = Dl(Na, Fd, oc, !1);\n        switch (Gb) {\n          case vd:\n            0 !== je[oc.index] && (cb.width = Math.min(cb.width, je[oc.index]));\n            0 !== Yc[Fd.index] && (cb.height = Math.min(cb.height, Yc[Fd.index]));\n            break;\n          case Wk:\n            0 !== je[oc.index] && (cb.width = Math.min(cb.width, je[oc.index]));\n            break;\n          case Xk:\n            0 !== Yc[Fd.index] && (cb.height = Math.min(cb.height, Yc[Fd.index]));\n        }\n        isFinite(oc.width) && (cb.width = oc.width);\n        isFinite(Fd.height) && (cb.height = Fd.height);\n        Ed.h(0, 0);\n        for (var le = 1; le < Na.rowSpan && !(Na.row + le >= a.rowCount); le++) O = a.getRowDefinition(Na.row + le), kb = 0, kb = Gb === vd || Gb === Xk ? Math.max(O.minimum, 0 === Yc[Na.row + le] ? O.maximum : Math.min(Yc[Na.row + le], O.maximum)) : Math.max(O.minimum, isNaN(O.Xc) ? O.maximum : Math.min(O.Xc, O.maximum)), Ed.height += kb;\n        for (var me = 1; me < Na.columnSpan && !(Na.column + me >= a.columnCount); me++) O = a.getColumnDefinition(Na.column + me), kb = 0, kb = Gb === vd || Gb === Wk ? Math.max(O.minimum, 0 === je[Na.column + me] ? O.maximum : Math.min(je[Na.column + me], O.maximum)) : Math.max(O.minimum, isNaN(O.Xc) ? O.maximum : Math.min(O.Xc, O.maximum)), Ed.width += kb;\n        cb.width += Ed.width;\n        cb.height += Ed.height;\n        var xh = Na.margin,\n          yh = xh.right + xh.left,\n          Qd = xh.top + xh.bottom;\n        Na.measure(cb.width, cb.height, f, g);\n        for (var ne = Na.measuredBounds, Ke = Math.max(ne.width + yh, 0), Le = Math.max(ne.height + Qd, 0), oe = 0, od = 0; od < Na.rowSpan && !(Na.row + od >= a.rowCount); od++) O = a.getRowDefinition(Na.row + od), oe += O.total || 0;\n        if (oe < Le) {\n          var Ff = Le - oe,\n            lg = Le - oe;\n          if (null !== Na.spanAllocation) for (var An = Na.spanAllocation, zh = 0; zh < Na.rowSpan && !(0 >= Ff) && !(Na.row + zh >= a.rowCount); zh++) {\n            O = a.getRowDefinition(Na.row + zh);\n            var Gd = O.ha || 0,\n              Di = An(Na, O, lg);\n            O.actual = Math.min(O.maximum, Gd + Di);\n            O.ha !== Gd && (Ff -= O.ha - Gd);\n          }\n          for (; 0 < Ff;) {\n            var Ah = O.ha || 0;\n            isNaN(O.height) && O.maximum > Ah && (O.actual = Math.min(O.maximum, Ah + Ff), O.ha !== Ah && (Ff -= O.ha - Ah));\n            if (0 === O.index) break;\n            O = a.getRowDefinition(O.index - 1);\n          }\n        }\n        for (var Bh = 0, fk = 0; fk < Na.columnSpan && !(Na.column + fk >= a.columnCount); fk++) O = a.getColumnDefinition(Na.column + fk), Bh += O.total || 0;\n        if (Bh < Ke) {\n          var Ei = Ke - Bh,\n            Xt = Ke - Bh;\n          if (null !== Na.spanAllocation) for (var Yt = Na.spanAllocation, gk = 0; gk < Na.columnSpan && !(0 >= Ei) && !(Na.column + gk >= a.columnCount); gk++) {\n            O = a.getColumnDefinition(Na.column + gk);\n            var Bn = O.ha || 0,\n              Zt = Yt(Na, O, Xt);\n            O.actual = Math.min(O.maximum, Bn + Zt);\n            O.ha !== Bn && (Ei -= O.ha - Bn);\n          }\n          for (; 0 < Ei;) {\n            var hk = O.ha || 0;\n            isNaN(O.width) && O.maximum > hk && (O.actual = Math.min(O.maximum, hk + Ei), O.ha !== hk && (Ei -= O.ha - hk));\n            if (0 === O.index) break;\n            O = a.getColumnDefinition(O.index - 1);\n          }\n        }\n      }\n    }\n    Ha(C);\n    M.free(Ed);\n    M.free(cb);\n    void 0 !== Yc && Ha(Yc);\n    void 0 !== je && Ha(je);\n    var mg = 0,\n      ng = 0,\n      ik = a.desiredSize,\n      kr = a.maxSize;\n    Gb = kl(a, !0);\n    var Fi = Pc = $b = 0,\n      Gi = 0;\n    h = a.columnCount;\n    for (var jk = 0; jk < h; jk++) void 0 !== a.qb[jk] && (O = a.getColumnDefinition(jk), isFinite(O.width) ? (Fi += O.width, Fi += O.vc()) : Em(O) === Fm ? (Fi += O.ha, Fi += O.vc()) : 0 !== O.ha && ($b += O.ha, $b += O.vc()));\n    isFinite(ik.width) ? mg = Math.min(ik.width, kr.width) : mg = Gb !== yg && isFinite(b) ? b : $b;\n    mg = Math.max(mg, a.minSize.width);\n    mg = Math.max(mg - Fi, 0);\n    for (var $t = 0 === $b ? 1 : Math.max(mg / $b, 1), lk = 0; lk < h; lk++) void 0 !== a.qb[lk] && (O = a.getColumnDefinition(lk), isFinite(O.width) || Em(O) === Fm || (O.actual = O.ha * $t), O.position = e.width, 0 !== O.ha && (e.width += O.ha, e.width += O.vc()));\n    h = a.rowCount;\n    for (var mk = 0; mk < h; mk++) void 0 !== a.ub[mk] && (O = a.getRowDefinition(mk), isFinite(O.height) ? (Gi += O.height, Gi += O.vc()) : Em(O) === Fm ? (Gi += O.ha, Gi += O.vc()) : 0 !== O.ha && (Pc += O.ha, 0 !== O.ha && (Pc += O.vc())));\n    isFinite(ik.height) ? ng = Math.min(ik.height, kr.height) : ng = Gb !== yg && isFinite(c) ? c : Pc;\n    ng = Math.max(ng, a.minSize.height);\n    ng = Math.max(ng - Gi, 0);\n    for (var au = 0 === Pc ? 1 : Math.max(ng / Pc, 1), nk = 0; nk < h; nk++) void 0 !== a.ub[nk] && (O = a.getRowDefinition(nk), isFinite(O.height) || Em(O) === Fm || (O.actual = O.ha * au), O.position = e.height, 0 !== O.ha && (e.height += O.ha, 0 !== O.ha && (e.height += O.vc())));\n    h = l.length;\n    for (var Cn = 0; Cn < h; Cn++) {\n      var pd = l[Cn],\n        Dn = 0,\n        En = 0;\n      pd.type === X.TableRow ? (Dn = e.width, O = a.getRowDefinition(pd.row), En = O.actual) : (O = a.getColumnDefinition(pd.column), Dn = O.actual, En = e.height);\n      pd.measuredBounds.h(0, 0, Dn, En);\n      nj(pd, !1);\n      w[pd.row] || (w[pd.row] = []);\n      w[pd.row][pd.column] || (w[pd.row][pd.column] = []);\n      w[pd.row][pd.column].push(pd);\n    }\n    Ha(l);\n    a.Hp = w;\n  };\n  Dm.prototype.arrange = function (a, b, c) {\n    var d = b.length,\n      e = a.padding,\n      f = e.left;\n    e = e.top;\n    for (var g = a.Hp, h, k, l = g.length, m = 0, n = 0; n < l; n++) g[n] && (m = Math.max(m, g[n].length));\n    for (n = Math.min(a.topIndex, l - 1); n !== l && (void 0 === a.ub[n] || 0 === a.ub[n].ha);) n++;\n    n = Math.min(n, l - 1);\n    n = -a.ub[n].position;\n    for (h = Math.min(a.leftIndex, m - 1); h !== m && (void 0 === a.qb[h] || 0 === a.qb[h].ha);) h++;\n    h = Math.min(h, m - 1);\n    for (var p = -a.qb[h].position, r = M.alloc(), q = 0; q < l; q++) if (g[q]) {\n      m = g[q].length;\n      var u = a.getRowDefinition(q);\n      k = u.position + n + e;\n      0 !== u.ha && (k += u.Iv());\n      for (var v = 0; v < m; v++) if (g[q][v]) {\n        var w = a.getColumnDefinition(v);\n        h = w.position + p + f;\n        0 !== w.ha && (h += w.Iv());\n        for (var y = g[q][v], z = y.length, A = 0; A < z; A++) {\n          var C = y[A],\n            G = C.measuredBounds,\n            L = C instanceof X ? C : null;\n          if (null === L || L.type !== X.TableRow && L.type !== X.TableColumn) {\n            r.h(0, 0);\n            for (var I = 1; I < C.rowSpan && !(q + I >= a.rowCount); I++) L = a.getRowDefinition(q + I), r.height += L.total;\n            for (I = 1; I < C.columnSpan && !(v + I >= a.columnCount); I++) L = a.getColumnDefinition(v + I), r.width += L.total;\n            var T = w.ha + r.width,\n              R = u.ha + r.height;\n            I = h;\n            L = k;\n            var ca = T,\n              qa = R,\n              O = h,\n              za = k,\n              Ma = T,\n              jb = R;\n            h + T > c.width && (Ma = Math.max(c.width - h, 0));\n            k + R > c.height && (jb = Math.max(c.height - k, 0));\n            var Fa = C.alignment;\n            if (Fa.Mb()) {\n              Fa = a.defaultAlignment;\n              Fa.ib() || (Fa = Bc);\n              var yb = Fa.x;\n              var Ad = Fa.y;\n              var kb = Fa.offsetX;\n              Fa = Fa.offsetY;\n              var Zb = w.alignment,\n                bb = u.alignment;\n              Zb.ib() && (yb = Zb.x, kb = Zb.offsetX);\n              bb.ib() && (Ad = bb.y, Fa = bb.offsetY);\n            } else yb = Fa.x, Ad = Fa.y, kb = Fa.offsetX, Fa = Fa.offsetY;\n            if (isNaN(yb) || isNaN(Ad)) Ad = yb = .5, Fa = kb = 0;\n            Zb = G.width;\n            bb = G.height;\n            var Nd = C.margin,\n              xc = Nd.left + Nd.right,\n              Bf = Nd.top + Nd.bottom,\n              bf = Dl(C, u, w, !1);\n            !isNaN(C.desiredSize.width) || bf !== vd && bf !== Wk || (Zb = Math.max(T - xc, 0));\n            !isNaN(C.desiredSize.height) || bf !== vd && bf !== Xk || (bb = Math.max(R - Bf, 0));\n            T = C.maxSize;\n            R = C.minSize;\n            Zb = Math.min(T.width, Zb);\n            bb = Math.min(T.height, bb);\n            Zb = Math.max(R.width, Zb);\n            bb = Math.max(R.height, bb);\n            T = bb + Bf;\n            I += ca * yb - (Zb + xc) * yb + kb + Nd.left;\n            L += qa * Ad - T * Ad + Fa + Nd.top;\n            C.visible && (gc(O, za, Ma, jb, I, L, G.width, G.height) ? C.arrange(I, L, Zb, bb) : C.arrange(I, L, Zb, bb, new N(O, za, Ma, jb)));\n          } else C.zl(), C.actualBounds.ea(), ca = C.actualBounds, I = N.allocAt(ca.x, ca.y, ca.width, ca.height), ca.x = L.type === X.TableRow ? f : h, ca.y = L.type === X.TableColumn ? e : k, ca.width = G.width, ca.height = G.height, C.actualBounds.freeze(), ll(C, !1), ac(I, ca) || (G = C.part, null !== G && (G.Oh(), C.ip(G))), N.free(I);\n        }\n      }\n    }\n    M.free(r);\n    for (a = 0; a < d; a++) c = b[a], f = c instanceof X ? c : null, null === f || f.type !== X.TableRow && f.type !== X.TableColumn || (f = c.actualBounds, c.naturalBounds.ea(), c.naturalBounds.h(0, 0, f.width, f.height), c.naturalBounds.freeze());\n  };\n  function Gm() {\n    this.name = \"Base\";\n  }\n  la(Gm, Ol);\n  Gm.prototype.measure = function () {};\n  Gm.prototype.arrange = function () {};\n  function Hm() {\n    this.name = \"Base\";\n  }\n  la(Hm, Ol);\n  Hm.prototype.measure = function () {};\n  Hm.prototype.arrange = function () {};\n  function Im() {\n    this.name = \"Base\";\n  }\n  la(Im, Ol);\n  Im.prototype.measure = function (a, b, c, d, e, f, g) {\n    1 < d.length && B(\"Viewbox Panel cannot contain more than one GraphObject.\");\n    d = d[0];\n    d.ya = 1;\n    d.zm();\n    d.measure(Infinity, Infinity, f, g);\n    var h = d.measuredBounds,\n      k = d.margin,\n      l = k.right + k.left;\n    k = k.top + k.bottom;\n    if (isFinite(b) || isFinite(c)) {\n      var m = d.scale,\n        n = h.width;\n      h = h.height;\n      var p = Math.max(b - l, 0),\n        r = Math.max(c - k, 0),\n        q = 1;\n      a.viewboxStretch === Ag ? 0 !== n && 0 !== h && (q = Math.min(p / n, r / h)) : 0 !== n && 0 !== h && (q = Math.max(p / n, r / h));\n      0 === q && (q = 1E-4);\n      d.ya *= q;\n      m !== d.scale && (nj(d, !0), d.measure(Infinity, Infinity, f, g));\n    }\n    h = d.measuredBounds;\n    e.width = isFinite(b) ? b : Math.max(h.width + l, 0);\n    e.height = isFinite(c) ? c : Math.max(h.height + k, 0);\n  };\n  Im.prototype.arrange = function (a, b, c) {\n    b = b[0];\n    var d = b.measuredBounds,\n      e = b.margin,\n      f = Math.max(d.width + (e.right + e.left), 0);\n    e = Math.max(d.height + (e.top + e.bottom), 0);\n    var g = b.alignment;\n    g.Mb() && (g = a.defaultAlignment);\n    g.ib() || (g = Bc);\n    b.arrange(c.width * g.x - f * g.x + g.offsetX, c.height * g.y - e * g.y + g.offsetY, d.width, d.height);\n  };\n  function Jm() {\n    this.name = \"Base\";\n  }\n  la(Jm, Ol);\n  Jm.prototype.measure = function () {};\n  Jm.prototype.arrange = function () {};\n  Jm.prototype.bc = function (a, b, c) {\n    c = a.Af() * c.scale;\n    0 >= c && (c = 1);\n    var d = a.gridCellSize,\n      e = d.width;\n    d = d.height;\n    var f = a.naturalBounds,\n      g = a.actualBounds,\n      h = f.width,\n      k = f.height,\n      l = Math.ceil(h / e),\n      m = Math.ceil(k / d),\n      n = a.gridOrigin;\n    b.save();\n    b.beginPath();\n    b.rect(0, 0, h, k);\n    b.clip();\n    for (var p = [], r = a.W.j, q = r.length, u = 0; u < q; u++) {\n      var v = r[u],\n        w = [];\n      p.push(w);\n      if (v.visible) {\n        var y = v.interval;\n        if (!(0 > y)) {\n          v = Vj(v.figure);\n          for (var z = 0; z < q; z++) if (z !== u) {\n            var A = r[z];\n            A.visible && Vj(A.figure) === v && (A = A.interval, A > y && w.push(A));\n          }\n        }\n      }\n    }\n    r = a.W.j;\n    q = r.length;\n    for (u = 0; u < q; u++) {\n      var C = r[u];\n      if (C.visible && (w = C.interval, !(2 > e * Math.abs(w) * c))) {\n        y = C.opacity;\n        v = 1;\n        if (1 !== y) {\n          if (0 === y) continue;\n          v = b.globalAlpha;\n          b.globalAlpha = v * y;\n        }\n        z = p[u];\n        A = !1;\n        var G = C.strokeDashArray;\n        null !== G && (A = !0, b.Gt(G, C.strokeDashOffset));\n        if (\"LineV\" === C.figure && null !== C.stroke && 0 < C.strokeWidth) {\n          b.lineWidth = C.strokeWidth;\n          li(a, b, C.stroke, !1, !1, f, g);\n          b.beginPath();\n          for (G = C = Math.floor(-n.x / e); G <= C + l; G++) {\n            var L = G * e + n.x;\n            0 <= L && L <= h && Km(G, w, z) && (b.moveTo(L, 0), b.lineTo(L, k));\n          }\n          b.stroke();\n        } else if (\"LineH\" === C.figure && null !== C.stroke && 0 < C.strokeWidth) {\n          b.lineWidth = C.strokeWidth;\n          li(a, b, C.stroke, !1, !1, f, g);\n          b.beginPath();\n          for (G = C = Math.floor(-n.y / d); G <= C + m; G++) L = G * d + n.y, 0 <= L && L <= k && Km(G, w, z) && (b.moveTo(0, L), b.lineTo(h, L));\n          b.stroke();\n        } else if (\"BarV\" === C.figure && null !== C.fill) for (li(a, b, C.fill, !0, !1, f, g), C = C.width, isNaN(C) && (C = e), L = G = Math.floor(-n.x / e); L <= G + l; L++) {\n          var I = L * e + n.x;\n          0 <= I && I <= h && Km(L, w, z) && b.fillRect(I, 0, C, k);\n        } else if (\"BarH\" === C.figure && null !== C.fill) for (li(a, b, C.fill, !0, !1, f, g), C = C.height, isNaN(C) && (C = d), L = G = Math.floor(-n.y / d); L <= G + m; L++) I = L * d + n.y, 0 <= I && I <= k && Km(L, w, z) && b.fillRect(0, I, h, C);\n        A && b.Et();\n        1 !== y && (b.globalAlpha = v);\n      }\n    }\n    b.restore();\n    b.tc(!1);\n  };\n  function Km(a, b, c) {\n    if (0 > b) return 0 === a % b;\n    if (0 !== a % b) return !1;\n    b = c.length;\n    for (var d = 0; d < b; d++) if (0 === a % c[d]) return !1;\n    return !0;\n  }\n  function Lm() {\n    this.name = \"Base\";\n  }\n  la(Lm, Ol);\n  Lm.prototype.measure = function (a, b, c, d, e) {\n    c = d.length;\n    if (a instanceof He || a instanceof S) {\n      var f = null,\n        g = null,\n        h = null;\n      a instanceof S && (g = f = a);\n      a instanceof He && (h = a, f = h.adornedPart);\n      if (f instanceof S) {\n        var k = f;\n        if (0 === c) Wb(a.naturalBounds, 0, 0), a.measuredBounds.h(0, 0, 0, 0);else {\n          var l = a instanceof He ? null : f.path,\n            m = f.routeBounds;\n          b = a.xg;\n          b.h(0, 0, m.width, m.height);\n          var n = k.points;\n          f = f.pointsCount;\n          null !== h ? h.Bk(!1) : null !== g && g.Bk(!1);\n          var p = m.width,\n            r = m.height;\n          a.location.h(m.x, m.y);\n          a.l.length = 0;\n          null !== l && (Mm(a, p, r, l), h = l.measuredBounds, b.Oc(h), a.l.push(h));\n          h = rd.alloc();\n          for (var q = J.alloc(), u = J.alloc(), v = 0; v < c; v++) {\n            var w = d[v];\n            if (w !== l) if (w.isPanelMain && w instanceof W) {\n              Mm(a, p, r, w);\n              var y = w.measuredBounds;\n              b.Oc(y);\n              a.l.push(y);\n            } else if (2 > f) w.measure(Infinity, Infinity, 0, 0), y = w.measuredBounds, b.Oc(y), a.l.push(y);else {\n              var z = w.segmentIndex,\n                A = w.segmentFraction,\n                C = w.alignmentFocus;\n              C.mc() && (C = Bc);\n              var G = w.segmentOrientation,\n                L = w.segmentOffset;\n              if (isNaN(z)) {\n                var I = k.na;\n                y = Ea();\n                I.Xv(A, y);\n                var T = J.allocAt(y[0], y[1]);\n                T.add(k.i(0));\n                I.type === wd ? T.offset(-I.startX, -I.startY) : (I = I.figures.first(), T.offset(-I.startX, -I.startY));\n                I = y[2];\n                if (G !== bg) {\n                  var R = k.computeAngle(w, G, I);\n                  w.Yb = R;\n                }\n                R = T.x - m.x;\n                var ca = T.y - m.y;\n                J.free(T);\n                Ha(y);\n              } else if (z < -f || z >= f) ca = k.midPoint, I = k.midAngle, G !== bg && (R = k.computeAngle(w, G, I), w.Yb = R), R = ca.x - m.x, ca = ca.y - m.y;else {\n                R = 0;\n                0 <= z ? (ca = n.L(z), y = z < f - 1 ? n.L(z + 1) : ca) : (R = f + z, ca = n.L(R), y = 0 < R ? n.L(R - 1) : ca);\n                if (ca.Na(y)) {\n                  0 <= z ? (I = 0 < z ? n.L(z - 1) : ca, R = z < f - 2 ? n.L(z + 2) : y) : (I = R < f - 1 ? n.L(R + 1) : ca, R = 1 < R ? n.L(R - 2) : y);\n                  T = I.Fe(ca);\n                  var qa = y.Fe(R);\n                  I = T > qa + 10 ? 0 <= z ? I.Sa(ca) : ca.Sa(I) : qa > T + 10 ? 0 <= z ? y.Sa(R) : R.Sa(y) : 0 <= z ? I.Sa(R) : R.Sa(I);\n                } else I = 0 <= z ? ca.Sa(y) : y.Sa(ca);\n                G !== bg && (R = k.computeAngle(w, G, I), w.Yb = R);\n                R = ca.x + (y.x - ca.x) * A - m.x;\n                ca = ca.y + (y.y - ca.y) * A - m.y;\n              }\n              w.measure(Infinity, Infinity, 0, 0);\n              y = w.measuredBounds;\n              T = w.naturalBounds;\n              var O = 0;\n              w instanceof W && (O = w.strokeWidth);\n              qa = T.width + O;\n              var za = T.height + O;\n              h.reset();\n              h.translate(-y.x, -y.y);\n              h.scale(w.scale, w.scale);\n              h.rotate(G === bg ? w.angle : I, qa / 2, za / 2);\n              G !== Nm && G !== Om || h.rotate(90, qa / 2, za / 2);\n              G !== Pm && G !== Qm || h.rotate(-90, qa / 2, za / 2);\n              G === Rm && (45 < I && 135 > I || 225 < I && 315 > I) && h.rotate(-I, qa / 2, za / 2);\n              T = new N(0, 0, qa, za);\n              q.sj(T, C);\n              h.sa(q);\n              C = -q.x + O / 2 * w.scale;\n              w = -q.y + O / 2 * w.scale;\n              u.assign(L);\n              O = isNaN(L.x);\n              var Ma = isNaN(L.y);\n              if (O || Ma) {\n                qa = qa / 2 + 3;\n                za = za / 2 + 3;\n                var jb = 45 <= I && 135 >= I,\n                  Fa = 225 <= I && 315 >= I;\n                G === bg && (jb || Fa) ? (u.x = Ma ? qa : L.y, u.y = O ? za : L.x, jb ? 0 <= z || isNaN(z) && .5 > A || !O || (u.y = -za) : Fa && ((0 <= z || isNaN(z) && .5 > A) && O && (u.y = -za), Ma && (u.x = -qa))) : (O && (u.x = 0 <= z || isNaN(z) && .5 > A ? qa : -qa), Ma && (u.y = -za), u.rotate(I));\n              } else u.rotate(I);\n              R += u.x;\n              ca += u.y;\n              T.set(y);\n              T.h(R + C, ca + w, y.width, y.height);\n              a.l.push(T);\n              b.Oc(T);\n            }\n          }\n          if (null !== g) for (d = g.labelNodes; d.next();) d.value.measure(Infinity, Infinity);\n          a.xg = b;\n          a = a.location;\n          a.h(a.x + b.x, a.y + b.y);\n          Wb(e, b.width || 0, b.height || 0);\n          rd.free(h);\n          J.free(q);\n          J.free(u);\n        }\n      }\n    }\n  };\n  Lm.prototype.arrange = function (a, b) {\n    var c = b.length;\n    if (a instanceof He || a instanceof S) {\n      var d = null,\n        e = null,\n        f = null;\n      a instanceof S && (e = d = a);\n      a instanceof He && (f = a, d = f.adornedPart);\n      var g = a instanceof He ? null : d.path;\n      if (0 !== a.l.length) {\n        var h = a.l,\n          k = 0;\n        if (null !== g && k < a.l.length) {\n          var l = h[k];\n          k++;\n          g.arrange(l.x - a.xg.x, l.y - a.xg.y, l.width, l.height);\n        }\n        for (l = 0; l < c; l++) {\n          var m = b[l];\n          if (m !== g && k < a.l.length) {\n            var n = h[k];\n            k++;\n            m.arrange(n.x - a.xg.x, n.y - a.xg.y, n.width, n.height);\n          }\n        }\n      }\n      b = d.points;\n      c = b.count;\n      if (2 <= c && a instanceof S) for (d = a.labelNodes; d.next();) {\n        var p = a;\n        g = d.value;\n        h = g.segmentIndex;\n        k = g.segmentFraction;\n        var r = g.alignmentFocus;\n        l = g.segmentOrientation;\n        m = g.segmentOffset;\n        if (isNaN(h)) {\n          n = p.na;\n          var q = Ea();\n          n.Xv(k, q);\n          var u = J.allocAt(q[0], q[1]);\n          u.add(p.i(0));\n          n.type === wd ? u.offset(-n.startX, -n.startY) : (n = n.figures.first(), u.offset(-n.startX, -n.startY));\n          n = q[2];\n          l !== bg && (p = p.computeAngle(g, l, n), g.angle = p);\n          p = u.x;\n          var v = u.y;\n          J.free(u);\n          Ha(q);\n        } else if (h < -c || h >= c) v = p.midPoint, n = p.midAngle, l !== bg && (p = p.computeAngle(g, l, n), g.angle = p), p = v.x, v = v.y;else {\n          u = 0;\n          0 <= h ? (q = b.j[h], v = h < c - 1 ? b.j[h + 1] : q) : (u = c + h, q = b.j[u], v = 0 < u ? b.j[u - 1] : q);\n          if (q.Na(v)) {\n            0 <= h ? (n = 0 < h ? b.j[h - 1] : q, u = h < c - 2 ? b.j[h + 2] : v) : (n = u < c - 1 ? b.j[u + 1] : q, u = 1 < u ? b.j[u - 2] : v);\n            var w = n.Fe(q),\n              y = v.Fe(u);\n            n = w > y + 10 ? 0 <= h ? n.Sa(q) : q.Sa(n) : y > w + 10 ? 0 <= h ? v.Sa(u) : u.Sa(v) : 0 <= h ? n.Sa(u) : u.Sa(n);\n          } else n = 0 <= h ? q.Sa(v) : v.Sa(q);\n          l !== bg && (p = p.computeAngle(g, l, n), g.angle = p);\n          p = q.x + (v.x - q.x) * k;\n          v = q.y + (v.y - q.y) * k;\n        }\n        if (r.Vt()) g.location = new J(p, v);else {\n          r.mc() && (r = Bc);\n          q = rd.alloc();\n          q.reset();\n          q.scale(g.scale, g.scale);\n          q.rotate(g.angle, 0, 0);\n          var z = g.naturalBounds;\n          u = N.allocAt(0, 0, z.width, z.height);\n          w = J.alloc();\n          w.sj(u, r);\n          q.sa(w);\n          r = -w.x;\n          y = -w.y;\n          var A = z.width,\n            C = z.height;\n          z = J.alloc();\n          z.assign(m);\n          var G = isNaN(m.x),\n            L = isNaN(m.y);\n          if (G || L) {\n            A = A / 2 + 3;\n            C = C / 2 + 3;\n            var I = 45 <= n && 135 >= n,\n              T = 225 <= n && 315 >= n;\n            l === bg && (I || T) ? (z.x = L ? A : m.y, z.y = G ? C : m.x, I ? 0 <= h || isNaN(h) && .5 > k || !G || (z.y = -C) : T && ((0 <= h || isNaN(h) && .5 > k) && G && (z.y = -C), L && (z.x = -A))) : (G && (z.x = 0 <= h || isNaN(h) && .5 > k ? A : -A), L && (z.y = -C), z.rotate(n));\n          } else z.rotate(n);\n          p += z.x;\n          v += z.y;\n          q.Ow(u);\n          r += u.x;\n          y += u.y;\n          h = J.allocAt(p + r, v + y);\n          g.move(h);\n          J.free(h);\n          J.free(z);\n          J.free(w);\n          N.free(u);\n          rd.free(q);\n        }\n      }\n      null !== f ? f.Bk(!1) : null !== e && e.Bk(!1);\n    }\n  };\n  function Mm(a, b, c, d) {\n    if (!1 !== sj(d)) {\n      var e = d.strokeWidth;\n      0 === e && a instanceof He && a.type === X.Link && a.adornedObject instanceof W && (e = a.adornedObject.strokeWidth);\n      e *= d.ya;\n      a instanceof S && null !== a.na ? (a = a.na.bounds, hl(d, a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : a instanceof He && null !== a.adornedPart.na ? (a = a.adornedPart.na.bounds, hl(d, a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : hl(d, -(e / 2), -(e / 2), b + e, c + e);\n      nj(d, !1);\n    }\n  }\n  function Sm() {\n    this.name = \"Base\";\n  }\n  la(Sm, Ol);\n  Sm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = a.pb();\n    a.bh = [];\n    var k = h.margin,\n      l = k.right + k.left,\n      m = k.top + k.bottom;\n    h.measure(b, c, f, g);\n    var n = h.measuredBounds,\n      p = new N(-k.left, -k.top, Math.max(n.width + l, 0), Math.max(n.height + m, 0));\n    a.bh.push(p);\n    e.assign(p);\n    for (var r = h.geometry, q = h.strokeWidth, u = r.flattenedSegments, v = r.flattenedLengths, w = r.flattenedTotalLength, y = u.length, z = 0, A = 0, C = Ea(), G = 0; G < y; G++) {\n      var L = u[G],\n        I = [];\n      A = z = 0;\n      for (var T = L.length, R = 0; R < T; R += 2) {\n        var ca = L[R],\n          qa = L[R + 1];\n        if (0 !== R) {\n          var O = 180 * Math.atan2(qa - A, ca - z) / Math.PI;\n          0 > O && (O += 360);\n          I.push(O);\n        }\n        z = ca;\n        A = qa;\n      }\n      C.push(I);\n    }\n    if (null === a.dh) {\n      for (var za = [], Ma = a.W.j, jb = Ma.length, Fa = 0; Fa < jb; Fa++) {\n        var yb = Ma[Fa],\n          Ad = [];\n        za.push(Ad);\n        if (yb.visible) {\n          var kb = yb.interval;\n          if (!(0 > kb)) for (var Zb = 0; Zb < jb; Zb++) if (Zb !== Fa) {\n            var bb = Ma[Zb];\n            if (bb.visible && yb.constructor === bb.constructor) {\n              var Nd = bb.interval;\n              Nd > kb && Ad.push(Nd);\n            }\n          }\n        }\n      }\n      a.dh = za;\n    }\n    var xc = a.dh;\n    var Bf = a.W.j,\n      bf = Bf.length,\n      Ie = 0,\n      qh = 0,\n      Ec = w;\n    a.Jj = [];\n    for (var Cf, cf = 0; cf < bf; cf++) {\n      var Od = Bf[cf];\n      Cf = [];\n      if (Od.visible && Od !== h) {\n        var bk = Math.abs(Od.interval),\n          Gb = a.graduatedTickUnit;\n        if (!(2 > Gb * bk * w / a.graduatedRange)) {\n          var Df = v[0][0],\n            Bd = 0,\n            lc = 0;\n          qh = w * Od.graduatedStart - 1E-4;\n          Ec = w * Od.graduatedEnd + 1E-4;\n          var df = Gb * bk,\n            Xc = a.graduatedTickBase;\n          if (Xc < a.graduatedMin) {\n            var dg = (a.graduatedMin - Xc) / df;\n            dg = 0 === dg % 1 ? dg : Math.floor(dg + 1);\n            Xc += dg * df;\n          } else Xc > a.graduatedMin + df && (Xc -= Math.floor((Xc - a.graduatedMin) / df) * df);\n          for (var rh = xc[cf]; Xc <= a.graduatedMax;) {\n            a: {\n              for (var wn = rh.length, eg = 0; eg < wn; eg++) if (K.$((Xc - a.graduatedTickBase) % (rh[eg] * a.graduatedTickUnit), 0)) {\n                var ck = !1;\n                break a;\n              }\n              ck = !0;\n            }\n            if (ck && (null === Od.graduatedSkip || !Od.graduatedSkip(Xc)) && (Ie = (Xc - a.graduatedMin) * w / a.graduatedRange, Ie > w && (Ie = w), qh <= Ie && Ie <= Ec)) {\n              for (var $b = C[Bd][lc], Pc = v[Bd][lc]; Bd < v.length;) {\n                for (; Ie > Df && lc < v[Bd].length - 1;) lc++, $b = C[Bd][lc], Pc = v[Bd][lc], Df += Pc;\n                if (Ie <= Df) break;\n                Bd++;\n                lc = 0;\n                $b = C[Bd][lc];\n                Pc = v[Bd][lc];\n                Df += Pc;\n              }\n              var ec = u[Bd],\n                fg = ec[2 * lc],\n                sh = ec[2 * lc + 1],\n                ef = (Ie - (Df - Pc)) / Pc,\n                Ai = new J(fg + (ec[2 * lc + 2] - fg) * ef + q / 2 - r.bounds.x, sh + (ec[2 * lc + 3] - sh) * ef + q / 2 - r.bounds.y);\n              Ai.scale(h.scale, h.scale);\n              var ie = $b,\n                Je = C[Bd];\n              1E-4 > ef ? 0 < lc ? ie = Je[lc - 1] : K.$(ec[0], ec[ec.length - 2]) && K.$(ec[1], ec[ec.length - 1]) && (ie = Je[Je.length - 1]) : .9999 < ef && (lc + 1 < Je.length ? ie = Je[lc + 1] : K.$(ec[0], ec[ec.length - 2]) && K.$(ec[1], ec[ec.length - 1]) && (ie = Je[0]));\n              $b !== ie && (180 < Math.abs($b - ie) && ($b < ie ? $b += 360 : ie += 360), $b = ($b + ie) / 2 % 360);\n              if (Od instanceof Vg) {\n                var mc = \"\";\n                null !== Od.graduatedFunction ? (mc = Od.graduatedFunction(Xc), mc = null !== mc && void 0 !== mc ? mc.toString() : \"\") : mc = (+Xc.toFixed(2)).toString();\n                \"\" !== mc && Cf.push({\n                  Jm: Ai,\n                  angle: $b,\n                  text: mc\n                });\n              } else Cf.push({\n                Jm: Ai,\n                angle: $b\n              });\n            }\n            Xc += df;\n          }\n        }\n      }\n      a.Jj.push(Cf);\n    }\n    Ha(C);\n    var dk = a.Jj;\n    if (null !== dk) for (var xn = d.length, gg = 0; gg < xn; gg++) {\n      var zb = d[gg],\n        hg = dk[gg];\n      if (zb.visible && zb !== h && 0 !== hg.length) {\n        if (zb instanceof W) {\n          var ek = a,\n            Bi = e,\n            ig = zb.alignmentFocus;\n          ig.mc() && (ig = yc);\n          var Ef = zb.angle;\n          zb.Yb = 0;\n          zb.measure(Infinity, Infinity, 0, 0);\n          zb.Yb = Ef;\n          var cb = zb.measuredBounds,\n            jg = cb.width,\n            nc = cb.height,\n            Fc = N.allocAt(0, 0, jg, nc),\n            db = J.alloc();\n          db.sj(Fc, ig);\n          N.free(Fc);\n          for (var Cd = -db.x, Dd = -db.y, Pd = new N(), yn = hg.length, th = 0; th < yn; th++) for (var uh = hg[th], vh = uh.Jm.x, wh = uh.Jm.y, kg = uh.angle, Ed = 0; 4 > Ed; Ed++) {\n            switch (Ed) {\n              case 0:\n                db.h(Cd, Dd);\n                break;\n              case 1:\n                db.h(Cd + jg, Dd);\n                break;\n              case 2:\n                db.h(Cd, Dd + nc);\n                break;\n              case 3:\n                db.h(Cd + jg, Dd + nc);\n            }\n            db.rotate(kg + zb.angle);\n            db.offset(vh, wh);\n            0 === th && 0 === Ed ? Pd.h(db.x, db.y, 0, 0) : Pd.Me(db);\n            db.offset(-vh, -wh);\n            db.rotate(-kg - zb.angle);\n          }\n          J.free(db);\n          null !== ek.bh && ek.bh.push(Pd);\n          fc(Bi, Pd.x, Pd.y, Pd.width, Pd.height);\n        } else if (zb instanceof Vg) {\n          var Yc = a,\n            je = e;\n          null === Yc.zh && (Yc.zh = new Vg());\n          var Ab = Yc.zh;\n          Tm(Ab, zb);\n          var Ci = zb.alignmentFocus;\n          Ci.mc() && (Ci = yc);\n          for (var Zc = zb.segmentOrientation, zn = zb.segmentOffset, ke = new N(), Na = 0, Fd = 0, oc = 0, le = 0, me = 0, xh = hg.length, yh = 0; yh < xh; yh++) {\n            var Qd = hg[yh];\n            Na = Qd.Jm.x;\n            Fd = Qd.Jm.y;\n            oc = Qd.angle;\n            me = le = zb.angle;\n            Zc !== bg && (me = Zc === Um || Zc === Vm ? oc + zb.angle : oc, le = S.computeAngle(Zc, me));\n            Ab.Yb = le;\n            Ab.text = Qd.text || \"\";\n            Ab.measure(Infinity, Infinity, 0, 0);\n            var ne = Ab.measuredBounds,\n              Ke = Ab.naturalBounds,\n              Le = Ke.width,\n              oe = Ke.height,\n              od = rd.alloc();\n            od.reset();\n            od.translate(-ne.x, -ne.y);\n            od.scale(Ab.scale, Ab.scale);\n            od.rotate(me, Le / 2, oe / 2);\n            Zc !== Nm && Zc !== Om || od.rotate(90, Le / 2, oe / 2);\n            Zc !== Pm && Zc !== Qm || od.rotate(-90, Le / 2, oe / 2);\n            Zc === Rm && (45 < oc && 135 > oc || 225 < oc && 315 > oc) && od.rotate(-oc, Le / 2, oe / 2);\n            var Ff = N.allocAt(0, 0, Le, oe),\n              lg = J.alloc();\n            lg.sj(Ff, Ci);\n            od.sa(lg);\n            var An = -lg.x,\n              zh = -lg.y,\n              Gd = J.alloc();\n            Gd.assign(zn);\n            isNaN(Gd.x) && (Gd.x = Le / 2 + 3);\n            isNaN(Gd.y) && (Gd.y = -(oe / 2 + 3));\n            Gd.rotate(oc);\n            Na += Gd.x + An;\n            Fd += Gd.y + zh;\n            var Di = new N(Na, Fd, ne.width, ne.height),\n              Ah = new N(ne.x, ne.y, ne.width, ne.height),\n              Bh = new N(Ke.x, Ke.y, Ke.width, Ke.height);\n            Qd.zA = le;\n            Qd.lineCount = Ab.lineCount;\n            Qd.lines = [Ab.sb, Ab.Di, Ab.ke, Ab.xe, Ab.Pb, Ab.jb, Ab.ie];\n            Qd.actualBounds = Di;\n            Qd.measuredBounds = Ah;\n            Qd.naturalBounds = Bh;\n            0 === yh ? ke.assign(Di) : ke.Oc(Di);\n            J.free(Gd);\n            J.free(lg);\n            N.free(Ff);\n            rd.free(od);\n          }\n          null !== Yc.bh && Yc.bh.push(ke);\n          fc(je, ke.x, ke.y, ke.width, ke.height);\n        }\n        nj(zb, !1);\n      }\n    }\n  };\n  Sm.prototype.arrange = function (a, b, c) {\n    if (null !== a.bh) {\n      var d = a.pb(),\n        e = a.Jj;\n      if (null !== e) {\n        var f = a.bh,\n          g = 0,\n          h = f[g];\n        g++;\n        null !== d && d.arrange(h.x - c.x, h.y - c.y, h.width, h.height);\n        for (var k = b.length, l = 0; l < k; l++) {\n          var m = b[l];\n          h = e[l];\n          m.visible && m !== d && 0 !== h.length && (h = f[g], g++, m.arrange(h.x - c.x, h.y - c.y, h.width, h.height));\n        }\n        a.bh = null;\n      }\n    }\n  };\n  Sm.prototype.bc = function (a, b, c) {\n    var d = c.xi;\n    c.xi = !0;\n    var e = a.naturalBounds,\n      f = e.width;\n    e = e.height;\n    b.save();\n    b.beginPath();\n    b.rect(-1, -1, f + 1, e + 1);\n    b.clip();\n    f = a.pb();\n    f.bc(b, c);\n    e = a.Af() * c.scale;\n    0 >= e && (e = 1);\n    for (var g = f.actualBounds, h = a.W.j, k = a.Jj, l = h.length, m = 0; m < l; m++) {\n      var n = h[m],\n        p = k[m],\n        r = p.length;\n      if (n.visible && n !== f && 0 !== p.length) if (n instanceof W) {\n        if (!(2 > a.graduatedTickUnit * n.interval * f.geometry.flattenedTotalLength / a.graduatedRange * e)) {\n          var q = n.measuredBounds,\n            u = n.strokeWidth * n.scale,\n            v = n.alignmentFocus;\n          v.mc() && (v = yc);\n          for (var w = 0; w < r; w++) {\n            var y = p[w].Jm,\n              z = p[w].angle,\n              A = v,\n              C = n.ob;\n            C.reset();\n            C.translate(y.x + g.x, y.y + g.y);\n            C.rotate(z + n.angle, 0, 0);\n            C.translate(-q.width * A.x + A.offsetX + u / 2, -q.height * A.y + A.offsetY + u / 2);\n            C.scale(n.scale, n.scale);\n            Al(n, !1);\n            n.Zh.set(n.ob);\n            n.jl = n.scale;\n            Bl(n, !1);\n            n.bc(b, c);\n            n.ob.reset();\n          }\n        }\n      } else if (n instanceof Vg) for (null === a.zh && (a.zh = new Vg()), q = a.zh, Tm(q, n), n = 0; n < r; n++) u = p[n], u.actualBounds && u.measuredBounds && u.naturalBounds && (q.Tb = u.text || \"\", q.Yb = u.zA || 0, q.Vc = u.lineCount || 0, v = u.lines, void 0 !== v && (q.sb = v[0], q.Di = v[1], q.ke = v[2], q.xe = v[3], q.Pb = v[4], q.jb = v[5], q.ie = v[6]), u.naturalBounds && (q.qc = u.naturalBounds), u.actualBounds && (v = u.actualBounds, q.arrange(v.x, v.y, v.width, v.height)), v = u.actualBounds, q.arrange(v.x, v.y, v.width, v.height), w = u.measuredBounds, u = u.naturalBounds, y = q.ob, y.reset(), y.translate(v.x + g.x, v.y + g.y), y.translate(-w.x, -w.y), il(q, y, u.x, u.y, u.width, u.height), Al(q, !1), q.Zh.set(q.ob), q.jl = q.scale, Bl(q, !1), q.bc(b, c));\n    }\n    c.xi = d;\n    b.restore();\n    b.tc(!0);\n  };\n  function X(a) {\n    Y.call(this);\n    this.pa = void 0 === a ? X.Position : a;\n    null === this.pa && B(\"Panel type not specified or PanelLayout not loaded: \" + a);\n    this.W = new E();\n    this.gb = tc;\n    this.pa === X.Grid && (this.isAtomic = !0);\n    this.Ln = ad;\n    this.Rf = Vk;\n    this.pa === X.Table && Wm(this);\n    this.nq = Ag;\n    this.lo = Qb;\n    this.mo = Hb;\n    this.io = 0;\n    this.ho = 100;\n    this.ko = 10;\n    this.jo = 0;\n    this.li = this.lb = this.dh = this.bh = this.Jj = null;\n    this.zo = NaN;\n    this.pe = this.Bi = null;\n    this.Dl = \"category\";\n    this.Rd = null;\n    this.xg = new N(NaN, NaN, NaN, NaN);\n    this.zh = this.Hp = this.Ui = null;\n    this.Lg = \"\";\n  }\n  la(X, Y);\n  function Wm(a) {\n    a.Cj = tc;\n    a.Ug = 1;\n    a.si = null;\n    a.ri = null;\n    a.Tg = 1;\n    a.Sg = null;\n    a.pi = null;\n    a.ub = [];\n    a.qb = [];\n    a.ak = Xm;\n    a.zj = Xm;\n    a.Xi = 0;\n    a.Fi = 0;\n  }\n  X.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.pa = this.pa;\n    a.gb = this.gb.G();\n    a.Ln = this.Ln.G();\n    a.Rf = this.Rf;\n    if (a.pa === X.Table) {\n      a.Cj = this.Cj.G();\n      a.Ug = this.Ug;\n      a.si = this.si;\n      a.ri = this.ri;\n      a.Tg = this.Tg;\n      a.Sg = this.Sg;\n      a.pi = this.pi;\n      var b = [];\n      if (0 < this.ub.length) for (var c = this.ub, d = c.length, e = 0; e < d; e++) if (void 0 !== c[e]) {\n        var f = c[e].copy();\n        f.rj(a);\n        b[e] = f;\n      }\n      a.ub = b;\n      b = [];\n      if (0 < this.qb.length) for (c = this.qb, d = c.length, e = 0; e < d; e++) void 0 !== c[e] && (f = c[e].copy(), f.rj(a), b[e] = f);\n      a.qb = b;\n      a.ak = this.ak;\n      a.zj = this.zj;\n      a.Xi = this.Xi;\n      a.Fi = this.Fi;\n    }\n    a.nq = this.nq;\n    a.lo = this.lo.G();\n    a.mo = this.mo.G();\n    a.io = this.io;\n    a.ho = this.ho;\n    a.ko = this.ko;\n    a.jo = this.jo;\n    a.Jj = this.Jj;\n    a.dh = this.dh;\n    a.lb = this.lb;\n    a.li = this.li;\n    a.zo = this.zo;\n    a.Bi = this.Bi;\n    a.pe = this.pe;\n    a.Dl = this.Dl;\n    a.xg.assign(this.xg);\n    a.Lg = this.Lg;\n    null !== this.Hp && (a.Hp = this.Hp);\n  };\n  X.prototype.yf = function (a) {\n    Y.prototype.yf.call(this, a);\n    a.W = this.W;\n    for (var b = a.W.j, c = b.length, d = 0; d < c; d++) b[d].og = a;\n    a.Ui = null;\n  };\n  X.prototype.copy = function () {\n    var a = Y.prototype.copy.call(this);\n    if (null !== a) {\n      for (var b = this.W.j, c = b.length, d = 0; d < c; d++) {\n        var e = b[d].copy();\n        e.rj(a);\n        e.Yj = null;\n        var f = a.W,\n          g = f.count;\n        f.vb(g, e);\n        f = a.part;\n        if (null !== f) {\n          f.Uj = null;\n          null !== e.portId && f instanceof V && (f.Nh = !0);\n          var h = a.diagram;\n          null !== h && h.undoManager.isUndoingRedoing || f.ab(xe, \"elements\", a, null, e, null, g);\n        }\n      }\n      return a;\n    }\n    return null;\n  };\n  t = X.prototype;\n  t.toString = function () {\n    return \"Panel(\" + this.type + \")#\" + mb(this);\n  };\n  t.ip = function (a) {\n    Y.prototype.ip.call(this, a);\n    for (var b = this.W.j, c = b.length, d = 0; d < c; d++) b[d].ip(a);\n  };\n  t.ej = function (a, b) {\n    if (this.pa === X.Grid) this.pa.bc(this, a, b);else if (this.pa === X.Graduated) this.pa.bc(this, a, b);else {\n      this.pa === X.Table && (a.lineCap = \"butt\", Ym(this, a, !0, this.ub, !0), Ym(this, a, !1, this.qb, !0), Zm(this, a, !0, this.ub), Zm(this, a, !1, this.qb), Ym(this, a, !0, this.ub, !1), Ym(this, a, !1, this.qb, !1));\n      var c = this.isClipping && this.pa === X.Spot;\n      c && a.save();\n      for (var d = this.pb(), e = this.W.j, f = e.length, g = 0; g < f; g++) {\n        var h = e[g];\n        c && h === d && (a.clipInsteadOfFill = !0);\n        h.bc(a, b);\n        c && h === d && (a.clipInsteadOfFill = !1);\n      }\n      c && (a.restore(), a.tc(!0));\n    }\n  };\n  function Zm(a, b, c, d) {\n    for (var e = d.length, f = a.actualBounds, g = a.naturalBounds, h = !0, k = 0; k < e; k++) {\n      var l = d[k];\n      if (void 0 !== l) if (h) h = !1;else if (0 !== l.actual) {\n        if (c) {\n          if (l.position > f.height) continue;\n        } else if (l.position > f.width) continue;\n        var m = l.separatorStrokeWidth;\n        isNaN(m) && (m = c ? a.Ug : a.Tg);\n        var n = l.separatorStroke;\n        null === n && (n = c ? a.si : a.Sg);\n        if (0 !== m && null !== n) {\n          li(a, b, n, !1, !1, g, f);\n          n = !1;\n          var p = l.separatorDashArray;\n          null === p && (p = c ? a.ri : a.pi);\n          null !== p && (n = !0, b.Gt(p, 0));\n          b.beginPath();\n          p = l.position + m;\n          c ? p > f.height && (m -= p - f.height) : p > f.width && (m -= p - f.width);\n          l = l.position + m / 2;\n          b.lineWidth = m;\n          m = a.gb;\n          c ? (l += m.top, p = f.width - m.right, b.moveTo(m.left, l), b.lineTo(p, l)) : (l += m.left, p = f.height - m.bottom, b.moveTo(l, m.top), b.lineTo(l, p));\n          b.stroke();\n          n && b.Et();\n        }\n      }\n    }\n  }\n  function Ym(a, b, c, d, e) {\n    for (var f = d.length, g = a.actualBounds, h = a.naturalBounds, k = 0; k < f; k++) {\n      var l = d[k];\n      if (void 0 !== l && null !== l.background && l.coversSeparators !== e && 0 !== l.actual) {\n        var m = c ? g.height : g.width;\n        if (!(l.position > m)) {\n          var n = l.vc(),\n            p = l.separatorStrokeWidth;\n          isNaN(p) && (p = c ? a.Ug : a.Tg);\n          var r = l.separatorStroke;\n          null === r && (r = c ? a.si : a.Sg);\n          null === r && (p = 0);\n          n -= p;\n          p = l.position + p;\n          n += l.actual;\n          p + n > m && (n = m - p);\n          0 >= n || (m = a.gb, li(a, b, l.background, !0, !1, h, g), c ? b.fillRect(m.left, p + m.top, g.width - (m.left + m.right), n) : b.fillRect(p + m.left, m.top, n, g.height - (m.top + m.bottom)));\n        }\n      }\n    }\n  }\n  function Vj(a) {\n    return \"LineV\" === a || \"BarV\" === a;\n  }\n  t.vk = function (a, b, c, d, e) {\n    var f = this.de(),\n      g = this.transform,\n      h = 1 / (g.m11 * g.m22 - g.m12 * g.m21),\n      k = g.m22 * h,\n      l = -g.m12 * h,\n      m = -g.m21 * h,\n      n = g.m11 * h,\n      p = h * (g.m21 * g.dy - g.m22 * g.dx),\n      r = h * (g.m12 * g.dx - g.m11 * g.dy);\n    if (null !== this.areaBackground) return g = this.actualBounds, K.bd(g.left, g.top, g.right, g.bottom, a, b, c, d, e);\n    if (null !== this.background) return f = a * k + b * m + p, h = a * l + b * n + r, a = c * k + d * m + p, k = c * l + d * n + r, e.h(0, 0), c = this.naturalBounds, f = K.bd(0, 0, c.width, c.height, f, h, a, k, e), e.transform(g), f;\n    f || (k = 1, m = l = 0, n = 1, r = p = 0);\n    h = a * k + b * m + p;\n    a = a * l + b * n + r;\n    k = c * k + d * m + p;\n    c = c * l + d * n + r;\n    e.h(k, c);\n    d = (k - h) * (k - h) + (c - a) * (c - a);\n    l = !1;\n    n = this.W.j;\n    r = n.length;\n    m = J.alloc();\n    p = null;\n    b = Infinity;\n    var q = null,\n      u = this.isClipping && this.pa === X.Spot;\n    u && (q = J.alloc(), p = this.pb(), (l = p.vk(h, a, k, c, q)) && (b = (h - q.x) * (h - q.x) + (a - q.y) * (a - q.y)));\n    for (var v = 0; v < r; v++) {\n      var w = n[v];\n      w.visible && w !== p && w.vk(h, a, k, c, m) && (l = !0, w = (h - m.x) * (h - m.x) + (a - m.y) * (a - m.y), w < d && (d = w, e.set(m)));\n    }\n    u && (b > d && e.set(q), J.free(q));\n    J.free(m);\n    f && e.transform(g);\n    return l;\n  };\n  t.o = function (a) {\n    if (!0 !== sj(this)) {\n      Y.prototype.o.call(this, a);\n      a = null;\n      if (this.pa === X.Auto || this.pa === X.Link) a = this.pb();\n      for (var b = this.W.j, c = b.length, d = 0; d < c; d++) {\n        var e = b[d];\n        (e === a || e.isPanelMain) && e.o(!0);\n        if (!e.desiredSize.u()) {\n          var f = kl(e, !1);\n          (e instanceof wg || e instanceof X || e instanceof Vg || f !== yg) && e.o(!0);\n        }\n      }\n    }\n  };\n  t.zm = function () {\n    if (!1 === sj(this)) {\n      nj(this, !0);\n      ll(this, !0);\n      for (var a = this.W.j, b = a.length, c = 0; c < b; c++) a[c].zm();\n    }\n  };\n  t.zl = function () {\n    if (0 !== (this.F & 2048) === !1) {\n      Al(this, !0);\n      Bl(this, !0);\n      for (var a = this.W.j, b = a.length, c = 0; c < b; c++) a[c].cw();\n    }\n  };\n  t.cw = function () {\n    Bl(this, !0);\n    for (var a = this.W.j, b = a.length, c = 0; c < b; c++) a[c].cw();\n  };\n  t.Dm = function (a, b, c, d) {\n    var e = this.xg;\n    e.h(0, 0, 0, 0);\n    var f = this.desiredSize,\n      g = this.minSize;\n    void 0 === c && (c = g.width, d = g.height);\n    c = Math.max(c, g.width);\n    d = Math.max(d, g.height);\n    var h = this.maxSize;\n    isNaN(f.width) || (a = Math.min(f.width, h.width));\n    isNaN(f.height) || (b = Math.min(f.height, h.height));\n    a = Math.max(c, a);\n    b = Math.max(d, b);\n    var k = this.gb;\n    a = Math.max(a - k.left - k.right, 0);\n    b = Math.max(b - k.top - k.bottom, 0);\n    var l = this.W.j;\n    0 !== l.length && this.pa.measure(this, a, b, l, e, c, d);\n    a = e.width + k.left + k.right;\n    k = e.height + k.top + k.bottom;\n    isFinite(f.width) && (a = f.width);\n    isFinite(f.height) && (k = f.height);\n    a = Math.min(h.width, a);\n    k = Math.min(h.height, k);\n    a = Math.max(g.width, a);\n    k = Math.max(g.height, k);\n    a = Math.max(c, a);\n    k = Math.max(d, k);\n    Wb(e, a, k);\n    Wb(this.naturalBounds, a, k);\n    hl(this, 0, 0, a, k);\n  };\n  t.pb = function () {\n    if (null === this.Ui) {\n      var a = this.W.j,\n        b = a.length;\n      if (0 === b) return null;\n      for (var c = 0; c < b; c++) {\n        var d = a[c];\n        if (!0 === d.isPanelMain) return this.Ui = d;\n      }\n      this.Ui = a[0];\n    }\n    return this.Ui;\n  };\n  function wm(a) {\n    return null !== a.part ? a.part.locationObject : null;\n  }\n  t.Ih = function (a, b, c, d) {\n    var e = this.W.j;\n    this.actualBounds.h(a, b, c, d);\n    if (0 !== e.length) {\n      if (!this.desiredSize.u()) {\n        a = kl(this, !0);\n        var f = this.measuredBounds;\n        b = f.width;\n        f = f.height;\n        var g = this.ih,\n          h = g.left + g.right;\n        g = g.top + g.bottom;\n        b === c && f === d && (a = yg);\n        switch (a) {\n          case yg:\n            if (b > c || f > d) this.o(), this.measure(b > c ? c : b, f > d ? d : f, 0, 0);\n            break;\n          case vd:\n            this.o(!0);\n            this.measure(c + h, d + g, 0, 0);\n            break;\n          case Wk:\n            this.o(!0);\n            this.measure(c + h, f + g, 0, 0);\n            break;\n          case Xk:\n            this.o(!0), this.measure(b + h, d + g, 0, 0);\n        }\n      }\n      this.pa.arrange(this, e, this.xg);\n    }\n  };\n  t.Kh = function (a) {\n    var b = this.naturalBounds,\n      c = wm(this);\n    if (gc(0, 0, b.width, b.height, a.x, a.y)) {\n      b = this.W.j;\n      for (var d = b.length, e = J.allocAt(0, 0); d--;) {\n        var f = b[d];\n        if (f.visible || f === c) if (Bb(e.set(a), f.transform), f.aa(e)) return J.free(e), !0;\n      }\n      J.free(e);\n      return null === this.kb && null === this.dc ? !1 : !0;\n    }\n    return !1;\n  };\n  t.Ht = function (a) {\n    if (this.Xk === a) return this;\n    for (var b = this.W.j, c = b.length, d = 0; d < c; d++) {\n      var e = b[d].Ht(a);\n      if (null !== e) return e;\n    }\n    return null;\n  };\n  t.Zm = function (a, b) {\n    b(this, a);\n    if (a instanceof X) {\n      a = a.W.j;\n      for (var c = a.length, d = 0; d < c; d++) this.Zm(a[d], b);\n    }\n  };\n  function Fj(a, b) {\n    $m(a, a, b);\n  }\n  function $m(a, b, c) {\n    c(b);\n    b = b.W.j;\n    for (var d = b.length, e = 0; e < d; e++) {\n      var f = b[e];\n      f instanceof X && $m(a, f, c);\n    }\n  }\n  function an(a, b) {\n    bn(a, a, b);\n  }\n  function bn(a, b, c) {\n    c(b);\n    if (b instanceof X) {\n      b = b.W.j;\n      for (var d = b.length, e = 0; e < d; e++) bn(a, b[e], c);\n    }\n  }\n  t.sm = function (a) {\n    return cn(this, this, a);\n  };\n  function cn(a, b, c) {\n    if (c(b)) return b;\n    if (b instanceof X) {\n      b = b.W.j;\n      for (var d = b.length, e = 0; e < d; e++) {\n        var f = cn(a, b[e], c);\n        if (null !== f) return f;\n      }\n    }\n    return null;\n  }\n  t.$a = function (a) {\n    if (this.name === a) return this;\n    var b = this.W.j,\n      c = b.length;\n    null === this.Bi && null === this.pe || (c = dn(this));\n    for (var d = 0; d < c; d++) {\n      var e = b[d];\n      if (e instanceof X) {\n        var f = e.$a(a);\n        if (null !== f) return f;\n      }\n      if (e.name === a) return e;\n    }\n    return null;\n  };\n  function en(a) {\n    a = a.W.j;\n    for (var b = a.length, c = 0, d = 0; d < b; d++) {\n      var e = a[d];\n      e instanceof X ? c = Math.max(c, en(e)) : e instanceof W && (c = Math.max(c, e.xh / 2 * e.dk * e.Af()));\n    }\n    return c;\n  }\n  t.de = function () {\n    return !(this.type === X.TableRow || this.type === X.TableColumn);\n  };\n  t.Ub = function (a, b, c) {\n    if (!1 === this.pickable) return null;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    if (tj(this)) return null;\n    var d = this.naturalBounds,\n      e = 1 / this.Af(),\n      f = this.de(),\n      g = f ? a : Bb(J.allocAt(a.x, a.y), this.transform),\n      h = this.diagram,\n      k = 10,\n      l = 5;\n    null !== h && (k = h.xm(\"extraTouchArea\"), l = k / 2);\n    if (gc(-(l * e), -(l * e), d.width + k * e, d.height + k * e, g.x, g.y)) {\n      if (!this.isAtomic) {\n        e = this.W.j;\n        var m = e.length;\n        h = J.alloc();\n        l = (k = this.isClipping && this.pa === X.Spot) ? this.pb() : null;\n        if (k && (l.de() ? Bb(h.set(a), l.transform) : h.set(a), !l.aa(h))) return J.free(h), f || J.free(g), null;\n        for (var n = wm(this); m--;) {\n          var p = e[m];\n          if (p.visible || p === n) if (p.de() ? Bb(h.set(a), p.transform) : h.set(a), !k || p !== l) {\n            var r = null;\n            p instanceof X ? r = p.Ub(h, b, c) : !0 === p.pickable && p.aa(h) && (r = p);\n            if (null !== r && (null !== b && (r = b(r)), null !== r && (null === c || c(r)))) return J.free(h), f || J.free(g), r;\n          }\n        }\n        J.free(h);\n      }\n      if (null === this.background && null === this.areaBackground) return f || J.free(g), null;\n      a = gc(0, 0, d.width, d.height, g.x, g.y) ? this : null;\n      f || J.free(g);\n      return a;\n    }\n    f || J.free(g);\n    return null;\n  };\n  t.hj = function (a, b, c, d) {\n    if (!1 === this.pickable) return !1;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var e = this.naturalBounds,\n      f = this.de(),\n      g = f ? a : Bb(J.allocAt(a.x, a.y), this.transform);\n    e = gc(0, 0, e.width, e.height, g.x, g.y);\n    if (this.type === X.TableRow || this.type === X.TableColumn || e) {\n      if (!this.isAtomic) {\n        for (var h = this.W.j, k = h.length, l = J.alloc(), m = wm(this); k--;) {\n          var n = h[k];\n          if (n.visible || n === m) {\n            n.de() ? Bb(l.set(a), n.transform) : l.set(a);\n            var p = n;\n            n = n instanceof X ? n : null;\n            (null !== n ? n.hj(l, b, c, d) : p.aa(l)) && !1 !== p.pickable && (null !== b && (p = b(p)), null === p || null !== c && !c(p) || d.add(p));\n          }\n        }\n        J.free(l);\n      }\n      f || J.free(g);\n      return e && (null !== this.background || null !== this.areaBackground);\n    }\n    f || J.free(g);\n    return !1;\n  };\n  t.zf = function (a, b, c, d, e, f) {\n    if (!1 === this.pickable) return !1;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var g = f;\n    void 0 === f && (g = rd.alloc(), g.reset());\n    g.multiply(this.transform);\n    if (this.Jh(a, g)) return fn(this, b, c, e), void 0 === f && rd.free(g), !0;\n    if (this.Lc(a, g)) {\n      if (!this.isAtomic) for (var h = wm(this), k = this.W.j, l = k.length; l--;) {\n        var m = k[l];\n        if (m.visible || m === h) {\n          var n = m.actualBounds,\n            p = this.naturalBounds;\n          if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {\n            n = m;\n            m = m instanceof X ? m : null;\n            p = rd.alloc();\n            p.set(g);\n            if (null !== m ? m.zf(a, b, c, d, e, p) : jl(n, a, d, p)) null !== b && (n = b(n)), null === n || null !== c && !c(n) || e.add(n);\n            rd.free(p);\n          }\n        }\n      }\n      void 0 === f && rd.free(g);\n      return d;\n    }\n    void 0 === f && rd.free(g);\n    return !1;\n  };\n  function fn(a, b, c, d) {\n    for (var e = a.W.j, f = e.length; f--;) {\n      var g = e[f];\n      if (g.visible) {\n        var h = g.actualBounds,\n          k = a.naturalBounds;\n        h.x > k.width || h.y > k.height || 0 > h.x + h.width || 0 > h.y + h.height || (g instanceof X && fn(g, b, c, d), null !== b && (g = b(g)), null === g || null !== c && !c(g) || d.add(g));\n      }\n    }\n  }\n  t.Eg = function (a, b, c, d, e, f) {\n    if (!1 === this.pickable) return !1;\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    var g = this.naturalBounds,\n      h = this.de(),\n      k = h ? a : Bb(J.allocAt(a.x, a.y), this.transform),\n      l = h ? b : Bb(J.allocAt(b.x, b.y), this.transform),\n      m = k.Fe(l),\n      n = 0 < k.x && k.x < g.width && 0 < k.y && k.y < g.height || Cb(k.x, k.y, 0, 0, 0, g.height) <= m || Cb(k.x, k.y, 0, g.height, g.width, g.height) <= m || Cb(k.x, k.y, g.width, g.height, g.width, 0) <= m || Cb(k.x, k.y, g.width, 0, 0, 0) <= m;\n    g = k.kd(0, 0) <= m && k.kd(0, g.height) <= m && k.kd(g.width, 0) <= m && k.kd(g.width, g.height) <= m;\n    h || (J.free(k), J.free(l));\n    if (n) {\n      if (!this.isAtomic) {\n        k = J.alloc();\n        l = J.alloc();\n        m = wm(this);\n        for (var p = this.W.j, r = p.length; r--;) {\n          var q = p[r];\n          if (q.visible || q === m) {\n            var u = q.actualBounds,\n              v = this.naturalBounds;\n            if (!h || !(u.x > v.width || u.y > v.height || 0 > u.x + u.width || 0 > u.y + u.height)) if (q.de() ? (u = q.transform, Bb(k.set(a), u), Bb(l.set(b), u)) : (k.set(a), l.set(b)), u = q, q = q instanceof X ? q : null, null !== q ? q.Eg(k, l, c, d, e, f) : u.oy(k, l, e)) null !== c && (u = c(u)), null === u || null !== d && !d(u) || f.add(u);\n          }\n        }\n        J.free(k);\n        J.free(l);\n      }\n      return e ? n : g;\n    }\n    return !1;\n  };\n  function Bm(a) {\n    var b = null;\n    a instanceof W && (b = a.spot1, b === ad && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot1));\n    null === b && (b = wc);\n    return b;\n  }\n  function Cm(a) {\n    var b = null;\n    a instanceof W && (b = a.spot2, b === ad && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot2));\n    null === b && (b = Hc);\n    return b;\n  }\n  t.add = function (a) {\n    this.vb(this.W.count, a);\n  };\n  t.L = function (a) {\n    return this.W.L(a);\n  };\n  t.vb = function (a, b) {\n    b instanceof U && B(\"Cannot add a Part to a Panel: \" + b + \"; use a Panel instead\");\n    if (this === b || this.Gg(b)) this === b && B(\"Cannot make a Panel contain itself: \" + this.toString()), B(\"Cannot make a Panel indirectly contain itself: \" + this.toString() + \" already contains \" + b.toString());\n    var c = b.panel;\n    null !== c && c !== this && B(\"Cannot add a GraphObject that already belongs to another Panel to this Panel: \" + b.toString() + \", already contained by \" + c.toString() + \", cannot be shared by this Panel: \" + this.toString());\n    this.pa !== X.Grid || b instanceof W || B(\"Can only add Shapes to a Grid Panel, not: \" + b);\n    this.pa !== X.Graduated || b instanceof W || b instanceof Vg || B(\"Can only add Shapes or TextBlocks to a Graduated Panel, not: \" + b);\n    b.rj(this);\n    b.Yj = null;\n    if (null !== this.itemArray) {\n      var d = b.data;\n      null !== d && \"object\" === typeof d && (null === this.Rd && (this.Rd = new H()), this.Rd.add(d, b));\n    }\n    var e = this.W;\n    d = -1;\n    if (c === this) {\n      for (var f = -1, g = this.W.j, h = g.length, k = 0; k < h; k++) if (g[k] === b) {\n        f = k;\n        break;\n      }\n      if (-1 !== f) {\n        if (f === a || f + 1 >= e.count && a >= e.count) return;\n        e.bb(f);\n        d = f;\n      } else B(\"element \" + b.toString() + \" has panel \" + c.toString() + \" but is not contained by it.\");\n    }\n    if (0 > a || a > e.count) a = e.count;\n    e.vb(a, b);\n    if (0 === a || b.isPanelMain) this.Ui = null;\n    sj(this) || this.o();\n    b.o(!1);\n    null !== b.portId ? this.Nh = !0 : b instanceof X && !0 === b.Nh && (this.Nh = !0);\n    this.dh = null;\n    c = this.part;\n    null !== c && (c.Uj = null, c.jh = NaN, this.Nh && c instanceof V && (c.Nh = !0), c.Nh && c instanceof V && (c.sc = null), e = this.diagram, null !== e && e.undoManager.isUndoingRedoing || (-1 !== d && c.ab(ye, \"elements\", this, b, null, d, null), c.ab(xe, \"elements\", this, null, b, null, a), this.Hg() || gn(this, b, !1)));\n  };\n  function hn(a, b) {\n    a.F = b ? a.F | 16777216 : a.F & -16777217;\n  }\n  t.remove = function (a) {\n    for (var b = this.W.j, c = b.length, d = -1, e = 0; e < c; e++) if (b[e] === a) {\n      d = e;\n      break;\n    }\n    -1 !== d && this.Kc(d, !0);\n  };\n  t.bb = function (a) {\n    0 <= a && this.Kc(a, !0);\n  };\n  t.Kc = function (a, b) {\n    var c = this.W,\n      d = c.L(a);\n    d.Yj = null;\n    d.rj(null);\n    if (null !== this.Rd) {\n      var e = d.data;\n      \"object\" === typeof e && this.Rd.remove(e);\n    }\n    c.bb(a);\n    nj(this, !1);\n    this.o();\n    this.Ui === d && (this.Ui = null);\n    this.dh = null;\n    var f = this.part;\n    null !== f && (f.Uj = null, f.jh = NaN, f.Lb(), f instanceof V && (d instanceof X ? d.Zm(d, function (a, c) {\n      Sl(f, c, b);\n    }) : Sl(f, d, b)), c = this.diagram, null !== c && c.undoManager.isUndoingRedoing || f.ab(ye, \"elements\", this, d, null, a, null));\n  };\n  X.prototype.getRowDefinition = function (a) {\n    0 > a && va(a, \">= 0\", X, \"getRowDefinition:idx\");\n    a = Math.round(a);\n    var b = this.ub;\n    if (void 0 === b) return null;\n    if (void 0 === b[a]) {\n      var c = new Tj();\n      c.rj(this);\n      c.isRow = !0;\n      c.index = a;\n      b[a] = c;\n    }\n    return b[a];\n  };\n  X.prototype.tw = function (a) {\n    0 > a && va(a, \">= 0\", X, \"removeRowDefinition:idx\");\n    a = Math.round(a);\n    var b = this.ub;\n    void 0 !== b && (this.ab(ye, \"coldefs\", this, b[a], null, a, null), b[a] && delete b[a], this.o());\n  };\n  X.prototype.getColumnDefinition = function (a) {\n    0 > a && va(a, \">= 0\", X, \"getColumnDefinition:idx\");\n    a = Math.round(a);\n    var b = this.qb;\n    if (void 0 === b) return null;\n    if (void 0 === b[a]) {\n      var c = new Tj();\n      c.rj(this);\n      c.isRow = !1;\n      c.index = a;\n      b[a] = c;\n    }\n    return b[a];\n  };\n  t = X.prototype;\n  t.rw = function (a) {\n    0 > a && va(a, \">= 0\", X, \"removeColumnDefinition:idx\");\n    a = Math.round(a);\n    var b = this.qb;\n    void 0 !== b && (this.ab(ye, \"coldefs\", this, b[a], null, a, null), b[a] && delete b[a], this.o());\n  };\n  t.Wz = function (a) {\n    if (0 > a || this.type !== X.Table) return -1;\n    for (var b = 0, c = this.ub, d = c.length, e = this.Xi; e < d; e++) {\n      var f = c[e];\n      if (void 0 !== f && (b += f.total, a < b)) break;\n    }\n    return e;\n  };\n  t.Oz = function (a) {\n    if (0 > a || this.type !== X.Table) return -1;\n    for (var b = 0, c = this.qb, d = c.length, e = this.Fi; e < d; e++) {\n      var f = c[e];\n      if (void 0 !== f && (b += f.total, a < b)) break;\n    }\n    return e;\n  };\n  t.lA = function (a, b) {\n    void 0 === b && (b = new J(NaN, NaN));\n    if (this.type !== X.Graduated) return b.h(NaN, NaN), b;\n    a = Math.min(Math.max(a, this.graduatedMin), this.graduatedMax);\n    var c = this.pb();\n    c.geometry.Wv((a - this.graduatedMin) / this.graduatedRange, b);\n    return c.transform.sa(b);\n  };\n  t.mA = function (a) {\n    if (this.type !== X.Graduated) return NaN;\n    var b = this.pb();\n    b.transform.Zd(a);\n    return b.geometry.ty(a) * this.graduatedRange + this.graduatedMin;\n  };\n  function Il(a) {\n    a = a.li;\n    return null !== a && a.s;\n  }\n  function xg(a) {\n    var b = a.li;\n    if (null === b) null !== a.data && B(\"Template cannot have .data be non-null: \" + a), a.li = b = new E();else if (b.s) return;\n    var c = new E();\n    hn(a, !1);\n    a.Zm(a, function (a, d) {\n      var e = d.eb;\n      if (null !== e) for (Fl(d, !1), e = e.iterator; e.next();) {\n        var f = e.value;\n        f.mode === jn && Fl(d, !0);\n        var g = f.sourceName;\n        null !== g && (\"/\" === g && hn(a, !0), g = gl(f, a, d), null !== g && (c.add(g), null === g.cm && (g.cm = new E()), g.cm.add(f)));\n        b.add(f);\n      }\n      if (d instanceof X && d.type === X.Table) {\n        if (0 < d.ub.length) for (a = d.ub, e = a.length, f = 0; f < e; f++) if (g = a[f], void 0 !== g && null !== g.eb) for (var h = g.eb.iterator; h.next();) {\n          var k = h.value;\n          k.jd = g;\n          k.fq = 2;\n          k.im = g.index;\n          b.add(k);\n        }\n        if (0 < d.qb.length) for (d = d.qb, a = d.length, e = 0; e < a; e++) if (f = d[e], void 0 !== f && null !== f.eb) for (g = f.eb.iterator; g.next();) h = g.value, h.jd = f, h.fq = 1, h.im = f.index, b.add(h);\n      }\n    });\n    for (var d = c.iterator; d.next();) {\n      var e = d.value;\n      if (null !== e.cm) {\n        Fl(e, !0);\n        for (var f = e.cm.iterator; f.next();) {\n          var g = f.value;\n          null === e.eb && (e.eb = new E());\n          e.eb.add(g);\n        }\n      }\n      e.cm = null;\n    }\n    for (d = b.iterator; d.next();) if (e = d.value, f = e.jd, null !== f) {\n      e.jd = null;\n      var h = e.targetProperty,\n        k = h.indexOf(\".\");\n      0 < k && f instanceof X && (g = h.substring(0, k), h = h.substr(k + 1), k = f.$a(g), null !== k ? (f = k, e.targetProperty = h) : wa('Warning: unable to find GraphObject named \"' + g + '\" for Binding: ' + e.toString()));\n      f instanceof Tj ? (g = mb(f.panel), e.vj = void 0 === g ? -1 : g, f.panel.Xk = e.vj) : f instanceof Y ? (g = mb(f), e.vj = void 0 === g ? -1 : g, f.Xk = e.vj) : B(\"Unknown type of binding target: \" + f);\n    }\n    b.freeze();\n    a instanceof U && a.Wb() && a.Ta();\n  }\n  t.Bz = function (a) {\n    void 0 === a && (a = !1);\n    var b = this.copy();\n    an(b, function (a) {\n      a instanceof X && (a.li = null, a.lb = null);\n      var b = a.eb;\n      null !== b && (a.eb = null, b.each(function (b) {\n        a.bind(b.copy());\n      }));\n      b = a.Mg;\n      null !== b && (a.Mg = null, b.each(function (b) {\n        Jl(a, b.value.copy());\n      }));\n    });\n    a && xg(b);\n    return b;\n  };\n  t.Ca = function (a) {\n    var b = this.li;\n    if (null !== b) for (void 0 === a && (a = \"\"), b = b.iterator; b.next();) {\n      var c = b.value,\n        d = c.sourceProperty;\n      if (\"\" === a || \"\" === d || d === a) if (d = c.targetProperty, null !== c.converter || \"\" !== d) {\n        d = this.data;\n        var e = c.sourceName;\n        if (null !== e) d = \"\" === e ? this : \"/\" === e ? this : \".\" === e ? this : \"..\" === e ? this : this.$a(e);else {\n          var f = this.diagram;\n          null !== f && c.isToModel && (d = f.model.modelData);\n        }\n        if (null !== d) {\n          f = this;\n          var g = c.vj;\n          if (-1 !== g) {\n            if (f = this.Ht(g), null === f) continue;\n          } else null !== c.jd && (f = c.jd);\n          \"/\" === e ? d = f.part : \".\" === e ? d = f : \"..\" === e && (d = f.panel);\n          e = c.fq;\n          if (0 !== e) {\n            if (!(f instanceof X)) continue;\n            1 === e ? f = f.getColumnDefinition(c.im) : 2 === e && (f = f.getRowDefinition(c.im));\n          }\n          void 0 !== f && c.Rw(f, d);\n        }\n      }\n    }\n  };\n  function kn(a, b) {\n    a = a.W.j;\n    for (var c = a.length, d = b.length, e = 0, f = null; e < c && !(f = a[e], f instanceof X && null !== f.data);) e++, f = a[e];\n    if (c - e !== d) return !0;\n    if (null === f) return 0 < d;\n    for (var g = 0; e < c && g < d;) {\n      f = a[e];\n      if (!(f instanceof X) || f.data !== b[g]) return !0;\n      e++;\n      g++;\n    }\n    return !1;\n  }\n  function dn(a) {\n    if (a.type === X.Spot || a.type === X.Auto) return Math.min(a.W.length, 1);\n    if (a.type === X.Link) {\n      a = a.W;\n      for (var b = a.length, c = 0; c < b; c++) {\n        var d = a.L(c);\n        if (!(d instanceof W && d.isPanelMain)) break;\n      }\n      return c;\n    }\n    return a.type === X.Table && 0 < a.W.length && (a = a.W.L(0), a.isPanelMain && a instanceof X && (a.type === X.TableRow || a.type === X.TableColumn)) ? 1 : 0;\n  }\n  t.eu = function () {\n    for (var a = dn(this); this.W.length > a;) this.Kc(this.W.length - 1, !1);\n    a = this.itemArray;\n    if (null !== a) for (var b = a.length, c = 0; c < b; c++) ln(this, a[c], c);\n  };\n  t.ny = function (a) {\n    return void 0 === a || null === a || null === this.Rd ? null : this.Rd.H(a);\n  };\n  function ln(a, b, c) {\n    if (!(void 0 === b || null === b || 0 > c)) {\n      var d = mn(a, b),\n        e = a.itemTemplateMap,\n        f = null;\n      null !== e && (f = e.H(d));\n      null === f && (nn || (nn = !0, wa('No item template Panel found for category \"' + d + '\" on ' + a), wa(\"  Using default item template.\"), d = new X(), e = new Vg(), e.bind(new Li(\"text\", \"\", Ja)), d.add(e), on = d), f = on);\n      d = f;\n      null !== d && (xg(d), d = d.copy(), 0 !== (d.F & 16777216) && (e = a.ij(), null !== e && hn(e, !0)), \"object\" === typeof b && (null === a.Rd && (a.Rd = new H()), a.Rd.add(b, d)), e = c + dn(a), a.vb(e, d), d.lb = b, pn(a, e, c), d.lb = null, d.data = b);\n    }\n  }\n  function pn(a, b, c) {\n    for (a = a.W; b < a.length;) {\n      var d = a.L(b);\n      if (d instanceof X) {\n        var e = b,\n          f = c;\n        d.type === X.TableRow ? d.row = e : d.type === X.TableColumn && (d.column = e);\n        d.itemIndex = f;\n      }\n      b++;\n      c++;\n    }\n  }\n  function mn(a, b) {\n    if (null === b) return \"\";\n    a = a.Dl;\n    if (\"function\" === typeof a) a = a(b);else if (\"string\" === typeof a && \"object\" === typeof b) {\n      if (\"\" === a) return \"\";\n      a = qn(b, a);\n    } else return \"\";\n    if (void 0 === a) return \"\";\n    if (\"string\" === typeof a) return a;\n    B(\"Panel.getCategoryForItemData found a non-string category for \" + b + \": \" + a);\n    return \"\";\n  }\n  function gn(a, b, c) {\n    var d = b.enabledChanged;\n    null !== d && d(b, c);\n    if (b instanceof X) {\n      b = b.W.j;\n      d = b.length;\n      for (var e = 0; e < d; e++) {\n        var f = b[e];\n        c && f instanceof X && !f.isEnabled || gn(a, f, c);\n      }\n    }\n  }\n  function rn(a, b) {\n    b.name = a;\n    Nl.add(a, b);\n  }\n  ma.Object.defineProperties(X.prototype, {\n    type: {\n      get: function () {\n        return this.pa;\n      },\n      set: function (a) {\n        var b = this.pa;\n        b !== a && (this.pa = a, this.pa === X.Grid ? this.isAtomic = !0 : this.pa === X.Table && Wm(this), this.o(), this.g(\"type\", b, a));\n      }\n    },\n    elements: {\n      get: function () {\n        return this.W.iterator;\n      }\n    },\n    naturalBounds: {\n      get: function () {\n        return this.qc;\n      }\n    },\n    padding: {\n      get: function () {\n        return this.gb;\n      },\n      set: function (a) {\n        \"number\" === typeof a ? (0 > a && va(a, \">= 0\", X, \"padding\"), a = new pc(a)) : (0 > a.left && va(a.left, \">= 0\", X, \"padding:value.left\"), 0 > a.right && va(a.right, \">= 0\", X, \"padding:value.right\"), 0 > a.top && va(a.top, \">= 0\", X, \"padding:value.top\"), 0 > a.bottom && va(a.bottom, \">= 0\", X, \"padding:value.bottom\"));\n        var b = this.gb;\n        b.w(a) || (this.gb = a = a.G(), this.o(), this.g(\"padding\", b, a));\n      }\n    },\n    defaultAlignment: {\n      get: function () {\n        return this.Ln;\n      },\n      set: function (a) {\n        var b = this.Ln;\n        b.w(a) || (this.Ln = a = a.G(), this.o(), this.g(\"defaultAlignment\", b, a));\n      }\n    },\n    defaultStretch: {\n      get: function () {\n        return this.Rf;\n      },\n      set: function (a) {\n        var b = this.Rf;\n        b !== a && (this.Rf = a, this.o(), this.g(\"defaultStretch\", b, a));\n      }\n    },\n    defaultSeparatorPadding: {\n      get: function () {\n        return void 0 === this.Cj ? tc : this.Cj;\n      },\n      set: function (a) {\n        if (void 0 !== this.Cj) {\n          \"number\" === typeof a && (a = new pc(a));\n          var b = this.Cj;\n          b.w(a) || (this.Cj = a = a.G(), this.o(), this.g(\"defaultSeparatorPadding\", b, a));\n        }\n      }\n    },\n    defaultRowSeparatorStroke: {\n      get: function () {\n        return void 0 === this.si ? null : this.si;\n      },\n      set: function (a) {\n        var b = this.si;\n        b !== a && (null === a || \"string\" === typeof a || a instanceof tl) && (a instanceof tl && a.freeze(), this.si = a, this.M(), this.g(\"defaultRowSeparatorStroke\", b, a));\n      }\n    },\n    defaultRowSeparatorStrokeWidth: {\n      get: function () {\n        return void 0 === this.Ug ? 1 : this.Ug;\n      },\n      set: function (a) {\n        if (void 0 !== this.Ug) {\n          var b = this.Ug;\n          b !== a && isFinite(a) && 0 <= a && (this.Ug = a, this.o(), this.g(\"defaultRowSeparatorStrokeWidth\", b, a));\n        }\n      }\n    },\n    defaultRowSeparatorDashArray: {\n      get: function () {\n        return void 0 === this.ri ? null : this.ri;\n      },\n      set: function (a) {\n        if (void 0 !== this.ri) {\n          var b = this.ri;\n          if (b !== a) {\n            if (null !== a) {\n              for (var c = a.length, d = 0, e = 0; e < c; e++) {\n                var f = a[e];\n                \"number\" === typeof f && 0 <= f && isFinite(f) || B(\"defaultRowSeparatorDashArray value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n                d += f;\n              }\n              if (0 === d) {\n                if (null === b) return;\n                a = null;\n              }\n            }\n            this.ri = a;\n            this.M();\n            this.g(\"defaultRowSeparatorDashArray\", b, a);\n          }\n        }\n      }\n    },\n    defaultColumnSeparatorStroke: {\n      get: function () {\n        return void 0 === this.Sg ? null : this.Sg;\n      },\n      set: function (a) {\n        if (void 0 !== this.Sg) {\n          var b = this.Sg;\n          b !== a && (null === a || \"string\" === typeof a || a instanceof tl) && (a instanceof tl && a.freeze(), this.Sg = a, this.M(), this.g(\"defaultColumnSeparatorStroke\", b, a));\n        }\n      }\n    },\n    defaultColumnSeparatorStrokeWidth: {\n      get: function () {\n        return void 0 === this.Tg ? 1 : this.Tg;\n      },\n      set: function (a) {\n        if (void 0 !== this.Tg) {\n          var b = this.Tg;\n          b !== a && isFinite(a) && 0 <= a && (this.Tg = a, this.o(), this.g(\"defaultColumnSeparatorStrokeWidth\", b, a));\n        }\n      }\n    },\n    defaultColumnSeparatorDashArray: {\n      get: function () {\n        return void 0 === this.pi ? null : this.pi;\n      },\n      set: function (a) {\n        if (void 0 !== this.pi) {\n          var b = this.pi;\n          if (b !== a) {\n            if (null !== a) {\n              for (var c = a.length, d = 0, e = 0; e < c; e++) {\n                var f = a[e];\n                \"number\" === typeof f && 0 <= f && isFinite(f) || B(\"defaultColumnSeparatorDashArray value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n                d += f;\n              }\n              if (0 === d) {\n                if (null === b) return;\n                a = null;\n              }\n            }\n            this.pi = a;\n            this.M();\n            this.g(\"defaultColumnSeparatorDashArray\", b, a);\n          }\n        }\n      }\n    },\n    viewboxStretch: {\n      get: function () {\n        return this.nq;\n      },\n      set: function (a) {\n        var b = this.nq;\n        b !== a && (this.nq = a, this.o(), this.g(\"viewboxStretch\", b, a));\n      }\n    },\n    gridCellSize: {\n      get: function () {\n        return this.lo;\n      },\n      set: function (a) {\n        var b = this.lo;\n        if (!b.w(a)) {\n          a.u() && 0 !== a.width && 0 !== a.height || B(\"Invalid Panel.gridCellSize: \" + a);\n          this.lo = a.G();\n          var c = this.diagram;\n          null !== c && this === c.grid && oj(c);\n          this.M();\n          this.g(\"gridCellSize\", b, a);\n        }\n      }\n    },\n    gridOrigin: {\n      get: function () {\n        return this.mo;\n      },\n      set: function (a) {\n        var b = this.mo;\n        if (!b.w(a)) {\n          a.u() || B(\"Invalid Panel.gridOrigin: \" + a);\n          this.mo = a.G();\n          var c = this.diagram;\n          null !== c && this === c.grid && oj(c);\n          this.M();\n          this.g(\"gridOrigin\", b, a);\n        }\n      }\n    },\n    graduatedMin: {\n      get: function () {\n        return this.io;\n      },\n      set: function (a) {\n        var b = this.io;\n        b !== a && (this.io = a, this.o(), this.g(\"graduatedMin\", b, a), el(this) && (a = this.part, null !== a && fl(this, a, \"graduatedRange\")));\n      }\n    },\n    graduatedMax: {\n      get: function () {\n        return this.ho;\n      },\n      set: function (a) {\n        var b = this.ho;\n        b !== a && (this.ho = a, this.o(), this.g(\"graduatedMax\", b, a), el(this) && (a = this.part, null !== a && fl(this, a, \"graduatedRange\")));\n      }\n    },\n    graduatedRange: {\n      get: function () {\n        return this.graduatedMax - this.graduatedMin;\n      }\n    },\n    graduatedTickUnit: {\n      get: function () {\n        return this.ko;\n      },\n      set: function (a) {\n        var b = this.ko;\n        b !== a && 0 < a && (this.ko = a, this.o(), this.g(\"graduatedTickUnit\", b, a));\n      }\n    },\n    graduatedTickBase: {\n      get: function () {\n        return this.jo;\n      },\n      set: function (a) {\n        var b = this.jo;\n        b !== a && (this.jo = a, this.o(), this.g(\"graduatedTickBase\", b, a));\n      }\n    },\n    Nh: {\n      get: function () {\n        return 0 !== (this.F & 8388608);\n      },\n      set: function (a) {\n        0 !== (this.F & 8388608) !== a && (this.F ^= 8388608);\n      }\n    },\n    rowCount: {\n      get: function () {\n        return void 0 === this.ub ? 0 : this.ub.length;\n      }\n    },\n    columnCount: {\n      get: function () {\n        return void 0 === this.qb ? 0 : this.qb.length;\n      }\n    },\n    rowSizing: {\n      get: function () {\n        return void 0 === this.ak ? Xm : this.ak;\n      },\n      set: function (a) {\n        if (void 0 !== this.ak) {\n          var b = this.ak;\n          b !== a && (this.ak = a, this.o(), this.g(\"rowSizing\", b, a));\n        }\n      }\n    },\n    columnSizing: {\n      get: function () {\n        return void 0 === this.zj ? Xm : this.zj;\n      },\n      set: function (a) {\n        if (void 0 !== this.zj) {\n          var b = this.zj;\n          b !== a && (this.zj = a, this.o(), this.g(\"columnSizing\", b, a));\n        }\n      }\n    },\n    topIndex: {\n      get: function () {\n        return void 0 === this.Xi ? 0 : this.Xi;\n      },\n      set: function (a) {\n        if (void 0 !== this.Xi) {\n          var b = this.Xi;\n          b !== a && ((!isFinite(a) || 0 > a) && B(\"Panel.topIndex must be greater than zero and a real number, not: \" + a), this.Xi = a, this.o(), this.g(\"topIndex\", b, a));\n        }\n      }\n    },\n    leftIndex: {\n      get: function () {\n        return void 0 === this.Fi ? 0 : this.Fi;\n      },\n      set: function (a) {\n        if (void 0 !== this.Fi) {\n          var b = this.Fi;\n          b !== a && ((!isFinite(a) || 0 > a) && B(\"Panel.leftIndex must be greater than zero and a real number, not: \" + a), this.Fi = a, this.o(), this.g(\"leftIndex\", b, a));\n        }\n      }\n    },\n    data: {\n      get: function () {\n        return this.lb;\n      },\n      set: function (a) {\n        var b = this.lb;\n        if (b !== a) {\n          var c = this instanceof U && !(this instanceof He);\n          xg(this);\n          this.lb = a;\n          var d = this.diagram;\n          null !== d && (c ? (c = d.partManager, this instanceof S ? (null !== b && c.Se.remove(b), null !== a && c.Se.add(a, this)) : this instanceof U && (null !== b && c.Te.remove(b), null !== a && c.Te.add(a, this))) : (c = this.panel, null !== c && null !== c.Rd && (null !== b && c.Rd.remove(b), null !== a && c.Rd.add(a, this))));\n          this.g(\"data\", b, a);\n          null !== d && d.undoManager.isUndoingRedoing || null !== a && this.Ca();\n        }\n      }\n    },\n    itemIndex: {\n      get: function () {\n        return this.zo;\n      },\n      set: function (a) {\n        var b = this.zo;\n        b !== a && (this.zo = a, this.g(\"itemIndex\", b, a));\n      }\n    },\n    itemArray: {\n      get: function () {\n        return this.Bi;\n      },\n      set: function (a) {\n        var b = this.Bi;\n        if (b !== a || null !== a && kn(this, a)) {\n          var c = this.diagram;\n          b !== a && (null !== c && null !== b && Kj(c.partManager, this, c), this.Bi = a, null !== c && null !== a && Hj(c.partManager, this));\n          this.g(\"itemArray\", b, a);\n          null !== c && c.undoManager.isUndoingRedoing || this.eu();\n        }\n      }\n    },\n    itemTemplate: {\n      get: function () {\n        return null === this.pe ? null : this.pe.H(\"\");\n      },\n      set: function (a) {\n        if (null === this.pe) {\n          if (null === a) return;\n          this.pe = new H();\n        }\n        var b = this.pe.H(\"\");\n        b !== a && ((a instanceof U || a.isPanelMain) && B(\"Panel.itemTemplate must not be a Part or be Panel.isPanelMain: \" + a), this.pe.add(\"\", a), this.g(\"itemTemplate\", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.eu());\n      }\n    },\n    itemTemplateMap: {\n      get: function () {\n        return this.pe;\n      },\n      set: function (a) {\n        var b = this.pe;\n        if (b !== a) {\n          for (var c = a.iterator; c.next(););\n          this.pe = a;\n          this.g(\"itemTemplateMap\", b, a);\n          a = this.diagram;\n          null !== a && a.undoManager.isUndoingRedoing || this.eu();\n        }\n      }\n    },\n    itemCategoryProperty: {\n      get: function () {\n        return this.Dl;\n      },\n      set: function (a) {\n        var b = this.Dl;\n        b !== a && (this.Dl = a, this.g(\"itemCategoryProperty\", b, a));\n      }\n    },\n    isAtomic: {\n      get: function () {\n        return 0 !== (this.F & 1048576);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 1048576);\n        b !== a && (this.F ^= 1048576, this.g(\"isAtomic\", b, a));\n      }\n    },\n    isClipping: {\n      get: function () {\n        return 0 !== (this.F & 2097152);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 2097152);\n        b !== a && (a && this.type !== X.Spot && wa(\"Warning: Panel.isClipping set on non-Spot Panel: \" + this.toString()), this.F ^= 2097152, this.o(), this.g(\"isClipping\", b, a));\n      }\n    },\n    isOpposite: {\n      get: function () {\n        return 0 !== (this.F & 33554432);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 33554432);\n        b !== a && (this.F ^= 33554432, this.o(), this.g(\"isOpposite\", b, a));\n      }\n    },\n    isEnabled: {\n      get: function () {\n        return 0 !== (this.F & 4194304);\n      },\n      set: function (a) {\n        var b = 0 !== (this.F & 4194304);\n        if (b !== a) {\n          var c = null === this.panel || this.panel.Hg();\n          this.F ^= 4194304;\n          this.g(\"isEnabled\", b, a);\n          b = this.diagram;\n          null !== b && b.undoManager.isUndoingRedoing || c && gn(this, this, a);\n        }\n      }\n    },\n    alignmentFocusName: {\n      get: function () {\n        return this.Lg;\n      },\n      set: function (a) {\n        var b = this.Lg;\n        b !== a && (this.Lg = a, this.o(), this.g(\"alignmentFocusName\", b, a));\n      }\n    }\n  });\n  ma.Object.defineProperties(X, {\n    Position: {\n      get: function () {\n        return Nl.H(\"Position\");\n      }\n    },\n    Horizontal: {\n      get: function () {\n        return Nl.H(\"Horizontal\");\n      }\n    },\n    Vertical: {\n      get: function () {\n        return Nl.H(\"Vertical\");\n      }\n    },\n    Spot: {\n      get: function () {\n        return Nl.H(\"Spot\");\n      }\n    },\n    Auto: {\n      get: function () {\n        return Nl.H(\"Auto\");\n      }\n    },\n    Table: {\n      get: function () {\n        return Nl.H(\"Table\");\n      }\n    },\n    Viewbox: {\n      get: function () {\n        return Nl.H(\"Viewbox\");\n      }\n    },\n    TableRow: {\n      get: function () {\n        return Nl.H(\"TableRow\");\n      }\n    },\n    TableColumn: {\n      get: function () {\n        return Nl.H(\"TableColumn\");\n      }\n    },\n    Link: {\n      get: function () {\n        return Nl.H(\"Link\");\n      }\n    },\n    Grid: {\n      get: function () {\n        return Nl.H(\"Grid\");\n      }\n    },\n    Graduated: {\n      get: function () {\n        return Nl.H(\"Graduated\");\n      }\n    }\n  });\n  X.prototype.findItemPanelForData = X.prototype.ny;\n  X.prototype.rebuildItemElements = X.prototype.eu;\n  X.prototype.updateTargetBindings = X.prototype.Ca;\n  X.prototype.copyTemplate = X.prototype.Bz;\n  X.prototype.graduatedValueForPoint = X.prototype.mA;\n  X.prototype.graduatedPointForValue = X.prototype.lA;\n  X.prototype.findColumnForLocalX = X.prototype.Oz;\n  X.prototype.findRowForLocalY = X.prototype.Wz;\n  X.prototype.removeColumnDefinition = X.prototype.rw;\n  X.prototype.removeRowDefinition = X.prototype.tw;\n  X.prototype.removeAt = X.prototype.bb;\n  X.prototype.remove = X.prototype.remove;\n  X.prototype.insertAt = X.prototype.vb;\n  X.prototype.elt = X.prototype.L;\n  X.prototype.add = X.prototype.add;\n  X.prototype.findObject = X.prototype.$a;\n  X.prototype.findInVisualTree = X.prototype.sm;\n  X.prototype.walkVisualTreeFrom = X.prototype.Zm;\n  X.prototype.findMainElement = X.prototype.pb;\n  var nn = !1,\n    on = null,\n    Nl = new H();\n  X.className = \"Panel\";\n  X.definePanelLayout = rn;\n  rn(\"Position\", new vm());\n  rn(\"Vertical\", new ym());\n  rn(\"Auto\", new Am());\n  rn(\"Link\", new Lm());\n  function Tj() {\n    Ya(this);\n    this.og = null;\n    this.ps = !0;\n    this.Pa = 0;\n    this.Xc = NaN;\n    this.mh = 0;\n    this.kh = Infinity;\n    this.yb = ad;\n    this.la = this.ha = 0;\n    this.eb = null;\n    this.Wp = sn;\n    this.ze = Vk;\n    this.Qp = this.sg = null;\n    this.Rp = NaN;\n    this.kb = this.ck = null;\n    this.Hn = !1;\n  }\n  Tj.prototype.copy = function () {\n    var a = new Tj();\n    a.ps = this.ps;\n    a.Pa = this.Pa;\n    a.Xc = this.Xc;\n    a.mh = this.mh;\n    a.kh = this.kh;\n    a.yb = this.yb;\n    a.ha = this.ha;\n    a.la = this.la;\n    a.ze = this.ze;\n    a.Wp = this.Wp;\n    null === this.sg ? a.sg = null : a.sg = this.sg.G();\n    a.Qp = this.Qp;\n    a.Rp = this.Rp;\n    a.ck = null;\n    null !== this.ck && (a.separatorDashArray = Ba(this.separatorDashArray));\n    a.kb = this.kb;\n    a.Hn = this.Hn;\n    a.eb = this.eb;\n    return a;\n  };\n  t = Tj.prototype;\n  t.Dt = function (a) {\n    a.isRow ? this.height = a.height : this.width = a.width;\n    this.minimum = a.minimum;\n    this.maximum = a.maximum;\n    this.alignment = a.alignment;\n    this.stretch = a.stretch;\n    this.sizing = a.sizing;\n    this.sg = null === a.separatorPadding ? null : a.separatorPadding.G();\n    this.separatorStroke = a.separatorStroke;\n    this.separatorStrokeWidth = a.separatorStrokeWidth;\n    this.ck = null;\n    a.separatorDashArray && (this.ck = Ba(a.separatorDashArray));\n    this.background = a.background;\n    this.coversSeparators = a.coversSeparators;\n    this.eb = a.eb;\n  };\n  t.hb = function (a) {\n    a.classType === Tj && (this.sizing = a);\n  };\n  t.toString = function () {\n    return \"RowColumnDefinition \" + (this.isRow ? \"(Row \" : \"(Column \") + this.index + \") #\" + mb(this);\n  };\n  t.rj = function (a) {\n    this.og = a;\n  };\n  t.Iv = function () {\n    var a = 0,\n      b = 0,\n      c = this.og,\n      d = this.isRow;\n    if (null !== c && c.type === X.Table) for (var e = d ? c.ub.length : c.qb.length, f = 0; f < e; f++) {\n      var g = d ? c.ub[f] : c.qb[f];\n      if (void 0 !== g) {\n        b = g.index;\n        break;\n      }\n    }\n    this.index !== b && (b = this.separatorStroke, null === b && null !== c && (b = this.isRow ? c.defaultRowSeparatorStroke : c.defaultColumnSeparatorStroke), null !== b && (a = this.separatorStrokeWidth, isNaN(a) && (null !== c ? a = this.isRow ? c.defaultRowSeparatorStrokeWidth : c.defaultColumnSeparatorStrokeWidth : a = 0)));\n    b = this.sg;\n    if (null === b) if (null !== c) b = c.defaultSeparatorPadding;else return a;\n    return a + (this.isRow ? b.top : b.left);\n  };\n  t.vc = function () {\n    var a = 0,\n      b = this.og,\n      c = 0,\n      d = this.isRow;\n    if (null !== b && b.type === X.Table) for (var e = d ? b.ub.length : b.qb.length, f = 0; f < e; f++) {\n      var g = d ? b.ub[f] : b.qb[f];\n      if (void 0 !== g) {\n        c = g.index;\n        break;\n      }\n    }\n    this.index !== c && (c = this.separatorStroke, null === c && null !== b && (c = d ? b.defaultRowSeparatorStroke : b.defaultColumnSeparatorStroke), null !== c && (a = this.separatorStrokeWidth, isNaN(a) && (null !== b ? a = d ? b.defaultRowSeparatorStrokeWidth : b.defaultColumnSeparatorStrokeWidth : a = 0)));\n    d = this.sg;\n    if (null === d) if (null !== b) d = b.defaultSeparatorPadding;else return a;\n    return a + (this.isRow ? d.top + d.bottom : d.left + d.right);\n  };\n  t.Bb = function (a, b, c) {\n    var d = this.og;\n    if (null !== d && (d.ab(ve, a, this, b, c, void 0, void 0), null !== this.eb && (b = d.diagram, null !== b && !b.skipsModelSourceBindings && (d = d.ij(), null !== d && (b = d.data, null !== b))))) for (c = this.eb.iterator; c.next();) c.value.lr(this, b, a, d);\n  };\n  function Em(a) {\n    if (a.sizing === sn) {\n      var b = a.og;\n      return a.isRow ? b.rowSizing : b.columnSizing;\n    }\n    return a.sizing;\n  }\n  t.bind = function (a) {\n    a.jd = this;\n    var b = this.panel;\n    if (null !== b) {\n      var c = b.ij();\n      null !== c && Il(c) && B(\"Cannot add a Binding to a RowColumnDefinition that is already frozen: \" + a + \" on \" + b);\n    }\n    null === this.eb && (this.eb = new E());\n    this.eb.add(a);\n  };\n  ma.Object.defineProperties(Tj.prototype, {\n    panel: {\n      get: function () {\n        return this.og;\n      }\n    },\n    isRow: {\n      get: function () {\n        return this.ps;\n      },\n      set: function (a) {\n        this.ps = a;\n      }\n    },\n    index: {\n      get: function () {\n        return this.Pa;\n      },\n      set: function (a) {\n        this.Pa = a;\n      }\n    },\n    height: {\n      get: function () {\n        return this.Xc;\n      },\n      set: function (a) {\n        var b = this.Xc;\n        b !== a && (0 > a && va(a, \">= 0\", Tj, \"height\"), this.Xc = a, this.actual = this.ha, null !== this.panel && this.panel.o(), this.Bb(\"height\", b, a));\n      }\n    },\n    width: {\n      get: function () {\n        return this.Xc;\n      },\n      set: function (a) {\n        var b = this.Xc;\n        b !== a && (0 > a && va(a, \">= 0\", Tj, \"width\"), this.Xc = a, this.actual = this.ha, null !== this.panel && this.panel.o(), this.Bb(\"width\", b, a));\n      }\n    },\n    minimum: {\n      get: function () {\n        return this.mh;\n      },\n      set: function (a) {\n        var b = this.mh;\n        b !== a && ((0 > a || !isFinite(a)) && va(a, \">= 0\", Tj, \"minimum\"), this.mh = a, this.actual = this.ha, null !== this.panel && this.panel.o(), this.Bb(\"minimum\", b, a));\n      }\n    },\n    maximum: {\n      get: function () {\n        return this.kh;\n      },\n      set: function (a) {\n        var b = this.kh;\n        b !== a && (0 > a && va(a, \">= 0\", Tj, \"maximum\"), this.kh = a, this.actual = this.ha, null !== this.panel && this.panel.o(), this.Bb(\"maximum\", b, a));\n      }\n    },\n    alignment: {\n      get: function () {\n        return this.yb;\n      },\n      set: function (a) {\n        var b = this.yb;\n        b.w(a) || (this.yb = a.G(), null !== this.panel && this.panel.o(), this.Bb(\"alignment\", b, a));\n      }\n    },\n    stretch: {\n      get: function () {\n        return this.ze;\n      },\n      set: function (a) {\n        var b = this.ze;\n        b !== a && (this.ze = a, null !== this.panel && this.panel.o(), this.Bb(\"stretch\", b, a));\n      }\n    },\n    separatorPadding: {\n      get: function () {\n        return this.sg;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.sg;\n        null !== a && null !== b && b.w(a) || (null !== a && (a = a.G()), this.sg = a, null !== this.panel && this.panel.o(), this.Bb(\"separatorPadding\", b, a));\n      }\n    },\n    separatorStroke: {\n      get: function () {\n        return this.Qp;\n      },\n      set: function (a) {\n        var b = this.Qp;\n        b !== a && (null !== a && Rl(a, \"RowColumnDefinition.separatorStroke\"), a instanceof tl && a.freeze(), this.Qp = a, null !== this.panel && this.panel.o(), this.Bb(\"separatorStroke\", b, a));\n      }\n    },\n    separatorStrokeWidth: {\n      get: function () {\n        return this.Rp;\n      },\n      set: function (a) {\n        var b = this.Rp;\n        b !== a && (this.Rp = a, null !== this.panel && this.panel.o(), this.Bb(\"separatorStrokeWidth\", b, a));\n      }\n    },\n    separatorDashArray: {\n      get: function () {\n        return this.ck;\n      },\n      set: function (a) {\n        var b = this.ck;\n        if (b !== a) {\n          if (null !== a) {\n            for (var c = a.length, d = 0, e = 0; e < c; e++) {\n              var f = a[e];\n              \"number\" === typeof f && 0 <= f && isFinite(f) || B(\"separatorDashArray value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n              d += f;\n            }\n            if (0 === d) {\n              if (null === b) return;\n              a = null;\n            }\n          }\n          this.ck = a;\n          null !== this.panel && this.panel.M();\n          this.Bb(\"separatorDashArray\", b, a);\n        }\n      }\n    },\n    background: {\n      get: function () {\n        return this.kb;\n      },\n      set: function (a) {\n        var b = this.kb;\n        b !== a && (null !== a && Rl(a, \"RowColumnDefinition.background\"), a instanceof tl && a.freeze(), this.kb = a, null !== this.panel && this.panel.M(), this.Bb(\"background\", b, a));\n      }\n    },\n    coversSeparators: {\n      get: function () {\n        return this.Hn;\n      },\n      set: function (a) {\n        var b = this.Hn;\n        b !== a && (this.Hn = a, null !== this.panel && this.panel.M(), this.Bb(\"coversSeparators\", b, a));\n      }\n    },\n    sizing: {\n      get: function () {\n        return this.Wp;\n      },\n      set: function (a) {\n        var b = this.Wp;\n        b !== a && (this.Wp = a, null !== this.panel && this.panel.o(), this.Bb(\"sizing\", b, a));\n      }\n    },\n    actual: {\n      get: function () {\n        return this.ha;\n      },\n      set: function (a) {\n        this.ha = isNaN(this.Xc) ? Math.max(Math.min(this.kh, a), this.mh) : Math.max(Math.min(this.kh, this.Xc), this.mh);\n      }\n    },\n    total: {\n      get: function () {\n        return this.ha + this.vc();\n      },\n      set: function (a) {\n        this.ha = isNaN(this.Xc) ? Math.max(Math.min(this.kh, a), this.mh) : Math.max(Math.min(this.kh, this.Xc), this.mh);\n        this.ha = Math.max(0, this.ha - this.vc());\n      }\n    },\n    position: {\n      get: function () {\n        return this.la;\n      },\n      set: function (a) {\n        this.la = a;\n      }\n    }\n  });\n  Tj.prototype.bind = Tj.prototype.bind;\n  Tj.prototype.computeEffectiveSpacing = Tj.prototype.vc;\n  Tj.prototype.computeEffectiveSpacingTop = Tj.prototype.Iv;\n  var sn = new D(Tj, \"Default\", 0),\n    Fm = new D(Tj, \"None\", 1),\n    Xm = new D(Tj, \"ProportionalExtra\", 2);\n  Tj.className = \"RowColumnDefinition\";\n  Tj.Default = sn;\n  Tj.None = Fm;\n  Tj.ProportionalExtra = Xm;\n  function W() {\n    Y.call(this);\n    this.zd = this.na = null;\n    this.Xn = \"None\";\n    this.fo = Vk;\n    this.Hc = this.ml = \"black\";\n    this.xh = 1;\n    this.em = \"butt\";\n    this.fm = \"miter\";\n    this.dk = 10;\n    this.vh = null;\n    this.wh = 0;\n    this.pf = this.nf = ad;\n    this.pp = this.op = NaN;\n    this.ro = !1;\n    this.rp = null;\n    this.nl = this.lm = \"None\";\n    this.Qd = 1;\n    this.Od = 0;\n    this.Md = 1;\n    this.Nd = null;\n  }\n  la(W, Y);\n  W.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.na = this.na;\n    a.Xn = this.Xn;\n    a.fo = this.fo;\n    a.zd = this.zd;\n    a.ml = this.ml;\n    a.Hc = this.Hc;\n    a.xh = this.xh;\n    a.em = this.em;\n    a.fm = this.fm;\n    a.dk = this.dk;\n    null !== this.vh && (a.vh = Ba(this.vh));\n    a.wh = this.wh;\n    a.nf = this.nf.G();\n    a.pf = this.pf.G();\n    a.op = this.op;\n    a.pp = this.pp;\n    a.ro = this.ro;\n    a.rp = this.rp;\n    a.lm = this.lm;\n    a.nl = this.nl;\n    a.Qd = this.Qd;\n    a.Od = this.Od;\n    a.Md = this.Md;\n    a.Nd = this.Nd;\n  };\n  t = W.prototype;\n  t.hb = function (a) {\n    a === yg || a === Ag || a === Yk || a === Vk ? this.geometryStretch = a : Y.prototype.hb.call(this, a);\n  };\n  t.toString = function () {\n    return \"Shape(\" + (\"None\" !== this.figure ? this.figure : \"None\" !== this.toArrow ? this.toArrow : this.fromArrow) + \")#\" + mb(this);\n  };\n  function tn(a, b, c, d) {\n    var e = c.length;\n    if (!(4 > e)) {\n      var f = d.measuredBounds,\n        g = Math.max(1, f.width);\n      f = f.height;\n      for (var h = c[0], k = c[1], l, m, n, p, r, q, u = 0, v = Ea(), w = 2; w < e; w += 2) l = c[w], m = c[w + 1], n = l - h, h = m - k, 0 === n && (n = .001), p = h / n, r = Math.atan2(h, n), q = Math.sqrt(n * n + h * h), v.push([n, r, p, q]), u += q, h = l, k = m;\n      h = c[0];\n      k = c[1];\n      n = d.measuredBounds.width;\n      d instanceof W && (n -= d.strokeWidth);\n      1 > n && (n = 1);\n      e = c = n;\n      l = g / 2;\n      m = 0 === l ? !1 : !0;\n      w = 0;\n      q = v[w];\n      n = q[0];\n      r = q[1];\n      p = q[2];\n      q = q[3];\n      for (var y = 0; .1 <= u;) {\n        0 === y && (m ? (e = c, e -= l, u -= l, m = !1) : e = c, 0 === e && (e = 1));\n        if (e > u) {\n          Ha(v);\n          return;\n        }\n        e > q ? (y = e - q, e = q) : y = 0;\n        var z = Math.sqrt(e * e / (1 + p * p));\n        0 > n && (z = -z);\n        h += z;\n        k += p * z;\n        a.translate(h, k);\n        a.rotate(r);\n        a.translate(-(g / 2), -(f / 2));\n        0 === y && d.ej(a, b);\n        a.translate(g / 2, f / 2);\n        a.rotate(-r);\n        a.translate(-h, -k);\n        u -= e;\n        q -= e;\n        if (0 !== y) {\n          w++;\n          if (w === v.length) {\n            Ha(v);\n            return;\n          }\n          q = v[w];\n          n = q[0];\n          r = q[1];\n          p = q[2];\n          q = q[3];\n          e = y;\n        }\n      }\n      Ha(v);\n    }\n  }\n  t.ej = function (a, b) {\n    var c = this.Hc,\n      d = this.ml;\n    if (null !== c || null !== d) {\n      var e = this.actualBounds,\n        f = this.naturalBounds;\n      null !== d && li(this, a, d, !0, !1, f, e);\n      var g = this.part,\n        h = this.xh;\n      null === c || 0 !== h || null === g || !this.isPanelMain && g.pb() !== this || (h = g.type === X.Link && g instanceof He && \"Selection\" === g.category && g.adornedObject instanceof W && g.adornedPart.pb() === g.adornedObject ? g.adornedObject.strokeWidth : 0);\n      null !== c && 0 !== h && (li(this, a, c, !1, !1, f, e), a.lineWidth = h, a.lineJoin = this.fm, a.lineCap = this.em, a.miterLimit = this.dk);\n      e = !1;\n      g && b.Ge(\"drawShadows\") && (e = g.isShadowed);\n      g = !0;\n      null === c || null !== d && \"transparent\" !== d || (g = !1);\n      f = !1;\n      var k = this.strokeDashArray;\n      null !== k && (f = !0, a.Gt(k, this.wh));\n      var l = this.na;\n      if (null !== l) {\n        if (l.type === wd) a.beginPath(), a.moveTo(l.startX, l.startY), a.lineTo(l.endX, l.endY), null !== d && a.Yd(d), 0 !== h && null !== c && a.uj();else if (l.type === Hd) {\n          var m = l.startX;\n          k = l.startY;\n          var n = l.endX,\n            p = l.endY;\n          l = Math.min(m, n);\n          var r = Math.min(k, p);\n          m = Math.abs(n - m);\n          k = Math.abs(p - k);\n          a.beginPath();\n          a.rect(l, r, m, k);\n          null !== d && a.Yd(d);\n          if (null !== c) {\n            g && e && sl(a);\n            if (0 !== h) {\n              if (0 === m || 0 === k) a.beginPath(), a.rect(l, r, Math.max(m, .1), Math.max(k, .1));\n              a.uj();\n            }\n            g && e && rl(a);\n          }\n        } else if (l.type === Id) m = l.startX, k = l.startY, n = l.endX, p = l.endY, l = Math.abs(n - m) / 2, r = Math.abs(p - k) / 2, m = Math.min(m, n) + l, k = Math.min(k, p) + r, a.beginPath(), a.moveTo(m, k - r), a.bezierCurveTo(m + K.Kg * l, k - r, m + l, k - K.Kg * r, m + l, k), a.bezierCurveTo(m + l, k + K.Kg * r, m + K.Kg * l, k + r, m, k + r), a.bezierCurveTo(m - K.Kg * l, k + r, m - l, k + K.Kg * r, m - l, k), a.bezierCurveTo(m - l, k - K.Kg * r, m - K.Kg * l, k - r, m, k - r), a.closePath(), null !== d && a.Yd(d), 0 !== h && null !== c && (g && e ? (sl(a), a.uj(), rl(a)) : a.uj());else if (l.type === ud) for (k = l.figures, l = k.length, r = 0; r < l; r++) {\n          m = k.j[r];\n          a.beginPath();\n          a.moveTo(m.startX, m.startY);\n          n = m.segments.j;\n          p = n.length;\n          for (var q = null, u = 0; u < p; u++) {\n            var v = n[u];\n            switch (v.type) {\n              case Xd:\n                a.moveTo(v.endX, v.endY);\n                break;\n              case yd:\n                a.lineTo(v.endX, v.endY);\n                break;\n              case Yd:\n                a.bezierCurveTo(v.point1X, v.point1Y, v.point2X, v.point2Y, v.endX, v.endY);\n                break;\n              case Zd:\n                a.quadraticCurveTo(v.point1X, v.point1Y, v.endX, v.endY);\n                break;\n              case $d:\n                if (v.radiusX === v.radiusY) {\n                  var w = Math.PI / 180;\n                  a.arc(v.point1X, v.point1Y, v.radiusX, v.startAngle * w, (v.startAngle + v.sweepAngle) * w, 0 > v.sweepAngle, null !== q ? q.endX : m.startX, null !== q ? q.endY : m.startY);\n                } else if (q = be(v, m), w = q.length, 0 === w) a.lineTo(v.centerX, v.centerY);else for (var y = 0; y < w; y++) {\n                  var z = q[y];\n                  0 === y && a.lineTo(z[0], z[1]);\n                  a.bezierCurveTo(z[2], z[3], z[4], z[5], z[6], z[7]);\n                }\n                break;\n              case ae:\n                y = w = 0;\n                if (null !== q && q.type === $d) {\n                  q = be(q, m);\n                  z = q.length;\n                  if (0 === z) {\n                    a.lineTo(v.centerX, v.centerY);\n                    break;\n                  }\n                  q = q[z - 1] || null;\n                  null !== q && (w = q[6], y = q[7]);\n                } else w = null !== q ? q.endX : m.startX, y = null !== q ? q.endY : m.startY;\n                q = ce(v, m, w, y);\n                w = q.length;\n                if (0 === w) {\n                  a.lineTo(v.centerX, v.centerY);\n                  break;\n                }\n                for (y = 0; y < w; y++) z = q[y], a.bezierCurveTo(z[2], z[3], z[4], z[5], z[6], z[7]);\n                break;\n              default:\n                B(\"Segment not of valid type: \" + v.type);\n            }\n            v.isClosed && a.closePath();\n            q = v;\n          }\n          e ? m.isShadowed ? (!0 === m.isFilled && \"transparent\" !== d && null !== d && a.Yd(d), 0 !== h && null !== c && (g && sl(a), a.uj(), g && rl(a))) : (g && sl(a), !0 === m.isFilled && \"transparent\" !== d && null !== d && a.Yd(d), 0 !== h && null !== c && a.uj(), g && rl(a)) : (!0 === m.isFilled && null !== d && a.Yd(d), 0 !== h && null !== c && a.uj());\n        }\n        f && a.Et();\n        if (null !== this.pathPattern) {\n          c = this.pathPattern;\n          c.measure(Infinity, Infinity);\n          d = c.measuredBounds;\n          c.arrange(0, 0, d.width, d.height);\n          h = this.geometry;\n          a.save();\n          a.beginPath();\n          d = Ea();\n          if (h.type === wd) d.push(h.startX), d.push(h.startY), d.push(h.endX), d.push(h.endY), tn(a, b, d, c);else if (h.type === ud) for (h = h.figures.iterator; h.next();) {\n            e = h.value;\n            d.length = 0;\n            d.push(e.startX);\n            d.push(e.startY);\n            g = e.startX;\n            f = e.startY;\n            k = g;\n            l = f;\n            r = e.segments.j;\n            m = r.length;\n            for (n = 0; n < m; n++) {\n              p = r[n];\n              switch (p.type) {\n                case Xd:\n                  tn(a, b, d, c);\n                  d.length = 0;\n                  d.push(p.endX);\n                  d.push(p.endY);\n                  g = p.endX;\n                  f = p.endY;\n                  k = g;\n                  l = f;\n                  break;\n                case yd:\n                  d.push(p.endX);\n                  d.push(p.endY);\n                  g = p.endX;\n                  f = p.endY;\n                  break;\n                case Yd:\n                  K.Ce(g, f, p.point1X, p.point1Y, p.point2X, p.point2Y, p.endX, p.endY, .5, d);\n                  g = p.endX;\n                  f = p.endY;\n                  break;\n                case Zd:\n                  K.Wq(g, f, p.point1X, p.point1Y, p.endX, p.endY, .5, d);\n                  g = p.endX;\n                  f = p.endY;\n                  break;\n                case $d:\n                  u = be(p, e);\n                  v = u.length;\n                  if (0 === v) {\n                    d.push(p.centerX);\n                    d.push(p.centerY);\n                    g = p.centerX;\n                    f = p.centerY;\n                    break;\n                  }\n                  for (q = 0; q < v; q++) w = u[q], K.Ce(g, f, w[2], w[3], w[4], w[5], w[6], w[7], .5, d), g = w[6], f = w[7];\n                  break;\n                case ae:\n                  u = ce(p, e, g, f);\n                  v = u.length;\n                  if (0 === v) {\n                    d.push(p.centerX);\n                    d.push(p.centerY);\n                    g = p.centerX;\n                    f = p.centerY;\n                    break;\n                  }\n                  for (q = 0; q < v; q++) w = u[q], K.Ce(g, f, w[2], w[3], w[4], w[5], w[6], w[7], .5, d), g = w[6], f = w[7];\n                  break;\n                default:\n                  B(\"Segment not of valid type: \" + p.type);\n              }\n              p.isClosed && (d.push(k), d.push(l), tn(a, b, d, c));\n            }\n            tn(a, b, d, c);\n          } else if (h.type === Hd) d.push(h.startX), d.push(h.startY), d.push(h.endX), d.push(h.startY), d.push(h.endX), d.push(h.endY), d.push(h.startX), d.push(h.endY), d.push(h.startX), d.push(h.startY), tn(a, b, d, c);else if (h.type === Id) {\n            f = new he();\n            f.startX = h.endX;\n            f.startY = (h.startY + h.endY) / 2;\n            g = new pe($d);\n            g.startAngle = 0;\n            g.sweepAngle = 360;\n            g.centerX = (h.startX + h.endX) / 2;\n            g.centerY = (h.startY + h.endY) / 2;\n            g.radiusX = Math.abs(h.startX - h.endX) / 2;\n            g.radiusY = Math.abs(h.startY - h.endY) / 2;\n            f.add(g);\n            h = be(g, f);\n            e = h.length;\n            if (0 === e) d.push(g.centerX), d.push(g.centerY);else for (g = f.startX, f = f.startY, k = 0; k < e; k++) l = h[k], K.Ce(g, f, l[2], l[3], l[4], l[5], l[6], l[7], .5, d), g = l[6], f = l[7];\n            tn(a, b, d, c);\n          }\n          Ha(d);\n          a.restore();\n          a.tc(!1);\n        }\n      }\n    }\n  };\n  t.ga = function (a, b) {\n    void 0 === b && (b = new J());\n    if (a instanceof P) {\n      a.mc() && B(\"getDocumentPoint Spot must be a real, specific Spot, not: \" + a.toString());\n      var c = this.naturalBounds,\n        d = this.strokeWidth;\n      b.h(a.x * (c.width + d) - d / 2 + c.x + a.offsetX, a.y * (c.height + d) - d / 2 + c.y + a.offsetY);\n    } else b.set(a);\n    this.Ad.sa(b);\n    return b;\n  };\n  t.wm = function (a) {\n    void 0 === a && (a = new N());\n    var b = this.naturalBounds,\n      c = this.Ad;\n    b = N.allocAt(b.x, b.y, b.width, b.height);\n    var d = this.strokeWidth;\n    b.Ic(d / 2, d / 2);\n    d = J.allocAt(b.x, b.y).transform(c);\n    a.h(d.x, d.y, 0, 0);\n    d.h(b.right, b.y).transform(c);\n    fc(a, d.x, d.y, 0, 0);\n    d.h(b.right, b.bottom).transform(c);\n    fc(a, d.x, d.y, 0, 0);\n    d.h(b.x, b.bottom).transform(c);\n    fc(a, d.x, d.y, 0, 0);\n    N.free(b);\n    J.free(d);\n    return a;\n  };\n  t.Kh = function (a, b) {\n    var c = this.geometry;\n    if (null === c || null === this.fill && null === this.stroke) return !1;\n    var d = c.bounds,\n      e = this.strokeWidth / 2;\n    c.type !== wd || b || (e += 2);\n    var f = N.alloc();\n    f.assign(d);\n    f.Ic(e + 2, e + 2);\n    if (!f.aa(a)) return N.free(f), !1;\n    d = e + 1E-4;\n    if (c.type === wd) {\n      if (null === this.stroke) return !1;\n      d = (c.endX - c.startX) * (a.x - c.startX) + (c.endY - c.startY) * (a.y - c.startY);\n      if (0 > (c.startX - c.endX) * (a.x - c.endX) + (c.startY - c.endY) * (a.y - c.endY) || 0 > d) return !1;\n      N.free(f);\n      return K.Nb(c.startX, c.startY, c.endX, c.endY, e, a.x, a.y);\n    }\n    if (c.type === Hd) {\n      b = c.startX;\n      var g = c.startY,\n        h = c.endX;\n      c = c.endY;\n      f.x = Math.min(b, h);\n      f.y = Math.min(g, c);\n      f.width = Math.abs(h - b);\n      f.height = Math.abs(c - g);\n      if (null === this.fill) {\n        f.Ic(-d, -d);\n        if (f.aa(a)) return N.free(f), !1;\n        f.Ic(d, d);\n      }\n      null !== this.stroke && f.Ic(e, e);\n      a = f.aa(a);\n      N.free(f);\n      return a;\n    }\n    if (c.type === Id) {\n      g = c.startX;\n      e = c.startY;\n      h = c.endX;\n      var k = c.endY;\n      c = Math.min(g, h);\n      b = Math.min(e, k);\n      g = Math.abs(h - g) / 2;\n      e = Math.abs(k - e) / 2;\n      c = a.x - (c + g);\n      b = a.y - (b + e);\n      if (null === this.fill) {\n        g -= d;\n        e -= d;\n        if (0 >= g || 0 >= e || 1 >= c * c / (g * g) + b * b / (e * e)) return N.free(f), !1;\n        g += d;\n        e += d;\n      }\n      null !== this.stroke && (g += d, e += d);\n      N.free(f);\n      return 0 >= g || 0 >= e ? !1 : 1 >= c * c / (g * g) + b * b / (e * e);\n    }\n    if (c.type === ud) return N.free(f), null === this.fill ? fe(c, a.x, a.y, e) : de(c, a, e, 1 < this.strokeWidth, b);\n    B(\"Unknown Geometry type: \" + c.type);\n    return !1;\n  };\n  t.Dm = function (a, b, c, d) {\n    var e = this.desiredSize,\n      f = this.xh;\n    a = Math.max(a, 0);\n    b = Math.max(b, 0);\n    if (null !== this.zd) var g = this.geometry.bounds;else {\n      var h = this.figure,\n        k = un[h];\n      if (void 0 === k) {\n        var l = K.Oe[h];\n        \"string\" === typeof l && (l = K.Oe[l]);\n        \"function\" === typeof l ? (k = l(null, 100, 100), un[h] = k) : B(\"Unsupported Figure: \" + h);\n      }\n      g = k.bounds;\n    }\n    h = g.width;\n    k = g.height;\n    l = g.width;\n    var m = g.height;\n    switch (kl(this, !0)) {\n      case yg:\n        d = c = 0;\n        break;\n      case vd:\n        l = Math.max(a - f, 0);\n        m = Math.max(b - f, 0);\n        break;\n      case Wk:\n        l = Math.max(a - f, 0);\n        d = 0;\n        break;\n      case Xk:\n        c = 0, m = Math.max(b - f, 0);\n    }\n    isFinite(e.width) && (l = e.width);\n    isFinite(e.height) && (m = e.height);\n    e = this.maxSize;\n    g = this.minSize;\n    c = Math.max(c - f, g.width);\n    d = Math.max(d - f, g.height);\n    l = Math.min(e.width, l);\n    m = Math.min(e.height, m);\n    l = isFinite(l) ? Math.max(c, l) : Math.max(h, c);\n    m = isFinite(m) ? Math.max(d, m) : Math.max(k, d);\n    c = zg(this);\n    switch (c) {\n      case yg:\n        break;\n      case vd:\n        h = l;\n        k = m;\n        break;\n      case Ag:\n        c = Math.min(l / h, m / k);\n        isFinite(c) || (c = 1);\n        h *= c;\n        k *= c;\n        break;\n      default:\n        B(c + \" is not a valid geometryStretch.\");\n    }\n    null !== this.zd ? (h = Math.max(h, .01), k = Math.max(k, .01), c = null !== this.zd ? this.zd : this.na, e = c.bounds, d = h / e.width, e = k / e.height, isFinite(d) || (d = 1), isFinite(e) || (e = 1), this.na = 1 === d && 1 === e ? c : c.copy().scale(d, e)) : null !== this.na && K.$(this.na.xl, a - f) && K.$(this.na.wl, b - f) || (this.na = W.makeGeometry(this, h, k));\n    g = this.na.bounds;\n    Infinity === a || Infinity === b ? hl(this, g.x - f / 2, g.y - f / 2, 0 === a && 0 === h ? 0 : g.width + f, 0 === b && 0 === k ? 0 : g.height + f) : hl(this, -(f / 2), -(f / 2), l + f, m + f);\n  };\n  function zg(a) {\n    var b = a.geometryStretch;\n    return null !== a.zd ? b === Vk ? vd : b : b === Vk ? un[a.figure].defaultStretch : b;\n  }\n  t.Ih = function (a, b, c, d) {\n    ml(this, a, b, c, d);\n  };\n  t.bd = function (a, b, c) {\n    return this.vk(a.x, a.y, b.x, b.y, c);\n  };\n  t.vk = function (a, b, c, d, e) {\n    var f = this.transform,\n      g = 1 / (f.m11 * f.m22 - f.m12 * f.m21),\n      h = f.m22 * g,\n      k = -f.m12 * g,\n      l = -f.m21 * g,\n      m = f.m11 * g,\n      n = g * (f.m21 * f.dy - f.m22 * f.dx),\n      p = g * (f.m12 * f.dx - f.m11 * f.dy);\n    f = a * h + b * l + n;\n    g = a * k + b * m + p;\n    h = c * h + d * l + n;\n    k = c * k + d * m + p;\n    n = this.xh / 2;\n    l = this.na;\n    null === l && (this.measure(Infinity, Infinity), l = this.na);\n    p = l.bounds;\n    m = !1;\n    if (l.type === wd) {\n      if (1.5 >= this.strokeWidth) m = K.Ie(l.startX, l.startY, l.endX, l.endY, f, g, h, k, e);else {\n        l.startX === l.endX ? (d = n, m = 0) : (b = (l.endY - l.startY) / (l.endX - l.startX), m = n / Math.sqrt(1 + b * b), d = m * b);\n        b = Ea();\n        a = new J();\n        K.Ie(l.startX + d, l.startY + m, l.endX + d, l.endY + m, f, g, h, k, a) && b.push(a);\n        a = new J();\n        K.Ie(l.startX - d, l.startY - m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a);\n        a = new J();\n        K.Ie(l.startX + d, l.startY + m, l.startX - d, l.startY - m, f, g, h, k, a) && b.push(a);\n        a = new J();\n        K.Ie(l.endX + d, l.endY + m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a);\n        h = b.length;\n        if (0 === h) return Ha(b), !1;\n        m = !0;\n        k = Infinity;\n        for (d = 0; d < h; d++) a = b[d], c = (a.x - f) * (a.x - f) + (a.y - g) * (a.y - g), c < k && (k = c, e.x = a.x, e.y = a.y);\n        Ha(b);\n      }\n    } else if (l.type === Hd) m = K.bd(p.x - n, p.y - n, p.x + p.width + n, p.y + p.height + n, f, g, h, k, e);else if (l.type === Id) {\n      b = N.allocAt(p.x, p.y, p.width, p.height).Ic(n, n);\n      a: if (0 === b.width) m = K.Ie(b.x, b.y, b.x, b.y + b.height, f, g, h, k, e);else if (0 === b.height) m = K.Ie(b.x, b.y, b.x + b.width, b.y, f, g, h, k, e);else {\n        a = b.width / 2;\n        l = b.height / 2;\n        d = b.x + a;\n        m = b.y + l;\n        c = 9999;\n        f !== h && (c = (g - k) / (f - h));\n        if (9999 > Math.abs(c)) {\n          k = g - m - c * (f - d);\n          if (0 > a * a * c * c + l * l - k * k) {\n            e.x = NaN;\n            e.y = NaN;\n            m = !1;\n            break a;\n          }\n          n = Math.sqrt(a * a * c * c + l * l - k * k);\n          h = (-(a * a * c * k) + a * l * n) / (l * l + a * a * c * c) + d;\n          a = (-(a * a * c * k) - a * l * n) / (l * l + a * a * c * c) + d;\n          l = c * (h - d) + k + m;\n          k = c * (a - d) + k + m;\n          Math.abs((f - h) * (f - h)) + Math.abs((g - l) * (g - l)) < Math.abs((f - a) * (f - a)) + Math.abs((g - k) * (g - k)) ? (e.x = h, e.y = l) : (e.x = a, e.y = k);\n        } else {\n          h = l * l;\n          k = f - d;\n          h -= h / (a * a) * k * k;\n          if (0 > h) {\n            e.x = NaN;\n            e.y = NaN;\n            m = !1;\n            break a;\n          }\n          k = Math.sqrt(h);\n          h = m + k;\n          k = m - k;\n          Math.abs(h - g) < Math.abs(k - g) ? (e.x = f, e.y = h) : (e.x = f, e.y = k);\n        }\n        m = !0;\n      }\n      N.free(b);\n    } else if (l.type === ud) {\n      p = J.alloc();\n      var r = h - f;\n      var q = k - g;\n      var u = r * r + q * q;\n      e.x = h;\n      e.y = k;\n      for (var v = 0; v < l.figures.count; v++) {\n        var w = l.figures.j[v],\n          y = w.segments;\n        r = w.startX;\n        q = w.startY;\n        for (var z = r, A = q, C = 0; C < y.count; C++) {\n          var G = y.j[C],\n            L = G.type;\n          var I = G.endX;\n          var T = G.endY;\n          var R = !1;\n          switch (L) {\n            case Xd:\n              z = I;\n              A = T;\n              break;\n            case yd:\n              R = vn(r, q, I, T, f, g, h, k, p);\n              break;\n            case Yd:\n              R = K.uq(r, q, G.point1X, G.point1Y, G.point2X, G.point2Y, I, T, f, g, h, k, .6, p);\n              break;\n            case Zd:\n              R = K.uq(r, q, r + 2 / 3 * (G.point1X - r), q + 2 / 3 * (G.point1Y - q), I + 2 / 3 * (G.point1X - I), T + 2 / 3 * (G.point1Y - T), I, T, f, g, h, k, .6, p);\n              break;\n            case $d:\n            case ae:\n              L = G.type === $d ? be(G, w) : ce(G, w, r, q);\n              var ca = L.length;\n              if (0 === ca) {\n                R = vn(r, q, G.centerX, G.centerY, f, g, h, k, p);\n                break;\n              }\n              T = null;\n              for (I = 0; I < ca; I++) {\n                T = L[I];\n                if (0 === I && vn(r, q, T[0], T[1], f, g, h, k, p)) {\n                  var qa = Fn(f, g, p, u, e);\n                  qa < u && (u = qa, m = !0);\n                }\n                K.uq(T[0], T[1], T[2], T[3], T[4], T[5], T[6], T[7], f, g, h, k, .6, p) && (qa = Fn(f, g, p, u, e), qa < u && (u = qa, m = !0));\n              }\n              I = T[6];\n              T = T[7];\n              break;\n            default:\n              B(\"Unknown Segment type: \" + L);\n          }\n          r = I;\n          q = T;\n          R && (R = Fn(f, g, p, u, e), R < u && (u = R, m = !0));\n          G.isClosed && (I = z, T = A, vn(r, q, I, T, f, g, h, k, p) && (G = Fn(f, g, p, u, e), G < u && (u = G, m = !0)));\n        }\n      }\n      f = c - a;\n      g = d - b;\n      h = Math.sqrt(f * f + g * g);\n      0 !== h && (f /= h, g /= h);\n      e.x -= f * n;\n      e.y -= g * n;\n      J.free(p);\n    } else B(\"Unknown Geometry type: \" + l.type);\n    if (!m) return !1;\n    this.transform.sa(e);\n    return !0;\n  };\n  function Fn(a, b, c, d, e) {\n    a = c.x - a;\n    b = c.y - b;\n    b = a * a + b * b;\n    return b < d ? (e.x = c.x, e.y = c.y, b) : d;\n  }\n  function vn(a, b, c, d, e, f, g, h, k) {\n    var l = !1,\n      m = (e - g) * (b - d) - (f - h) * (a - c);\n    if (0 === m) return !1;\n    k.x = ((e * h - f * g) * (a - c) - (e - g) * (a * d - b * c)) / m;\n    k.y = ((e * h - f * g) * (b - d) - (f - h) * (a * d - b * c)) / m;\n    (a > c ? a - c : c - a) < (b > d ? b - d : d - b) ? (a = b < d ? b : d, b = b < d ? d : b, (k.y > a || K.$(k.y, a)) && (k.y < b || K.$(k.y, b)) && (l = !0)) : (b = a < c ? a : c, a = a < c ? c : a, (k.x > b || K.$(k.x, b)) && (k.x < a || K.$(k.x, a)) && (l = !0));\n    return l;\n  }\n  t.Jh = function (a, b) {\n    if (void 0 === b) return a.De(this.actualBounds);\n    var c = this.na;\n    null === c && (this.measure(Infinity, Infinity), c = this.na);\n    c = c.bounds;\n    var d = this.strokeWidth / 2,\n      e = !1,\n      f = J.alloc();\n    f.h(c.x - d, c.y - d);\n    a.aa(b.sa(f)) && (f.h(c.x - d, c.bottom + d), a.aa(b.sa(f)) && (f.h(c.right + d, c.bottom + d), a.aa(b.sa(f)) && (f.h(c.right + d, c.y - d), a.aa(b.sa(f)) && (e = !0))));\n    J.free(f);\n    return e;\n  };\n  t.Lc = function (a, b) {\n    if (this.Jh(a, b) || void 0 === b && (b = this.transform, a.De(this.actualBounds))) return !0;\n    var c = rd.alloc();\n    c.set(b);\n    c.St();\n    var d = a.left,\n      e = a.right,\n      f = a.top;\n    a = a.bottom;\n    var g = J.alloc();\n    g.h(d, f);\n    c.sa(g);\n    if (this.Kh(g, !0)) return J.free(g), !0;\n    g.h(e, f);\n    c.sa(g);\n    if (this.Kh(g, !0)) return J.free(g), !0;\n    g.h(d, a);\n    c.sa(g);\n    if (this.Kh(g, !0)) return J.free(g), !0;\n    g.h(e, a);\n    c.sa(g);\n    if (this.Kh(g, !0)) return J.free(g), !0;\n    var h = J.alloc(),\n      k = J.alloc();\n    c.set(b);\n    c.iw(this.transform);\n    c.St();\n    h.x = e;\n    h.y = f;\n    h.transform(c);\n    g.x = d;\n    g.y = f;\n    g.transform(c);\n    b = !1;\n    Gn(this, g, h, k) ? b = !0 : (g.x = e, g.y = a, g.transform(c), Gn(this, g, h, k) ? b = !0 : (h.x = d, h.y = a, h.transform(c), Gn(this, g, h, k) ? b = !0 : (g.x = d, g.y = f, g.transform(c), Gn(this, g, h, k) && (b = !0))));\n    J.free(g);\n    rd.free(c);\n    J.free(h);\n    J.free(k);\n    return b;\n  };\n  function Gn(a, b, c, d) {\n    if (!a.bd(b, c, d)) return !1;\n    a = b.x;\n    b = b.y;\n    var e = c.x,\n      f = c.y;\n    c = d.x;\n    d = d.y;\n    if (a === e) return b < f ? (a = b, b = f) : a = f, d >= a && d <= b;\n    a < e ? (d = a, a = e) : d = e;\n    return c >= d && c <= a;\n  }\n  t.oy = function (a, b, c) {\n    function d(a, b) {\n      for (var c = a.length, d = 0; d < c; d += 2) if (b.kd(a[d], a[d + 1]) > e) return !0;\n      return !1;\n    }\n    if (c && null !== this.fill && this.Kh(a, !0)) return !0;\n    var e = a.Fe(b),\n      f = e;\n    1.5 < this.strokeWidth && (e = this.strokeWidth / 2 + Math.sqrt(e), e *= e);\n    b = this.na;\n    if (null === b && (this.measure(Infinity, Infinity), b = this.na, null === b)) return !1;\n    if (!c) {\n      var g = b.bounds,\n        h = g.x,\n        k = g.y,\n        l = g.x + g.width;\n      g = g.y + g.height;\n      if (Db(a.x, a.y, h, k) <= e && Db(a.x, a.y, l, k) <= e && Db(a.x, a.y, h, g) <= e && Db(a.x, a.y, l, g) <= e) return !0;\n    }\n    h = b.startX;\n    k = b.startY;\n    l = b.endX;\n    g = b.endY;\n    if (b.type === wd) {\n      if (c = (h - l) * (a.x - l) + (k - g) * (a.y - g), Cb(a.x, a.y, h, k, l, g) <= (0 <= (l - h) * (a.x - h) + (g - k) * (a.y - k) && 0 <= c ? e : f)) return !0;\n    } else {\n      if (b.type === Hd) return b = !1, c && (b = Cb(a.x, a.y, h, k, h, g) <= e || Cb(a.x, a.y, h, k, l, k) <= e || Cb(a.x, a.y, l, k, l, g) <= e || Cb(a.x, a.y, h, g, l, g) <= e), b;\n      if (b.type === Id) {\n        b = a.x - (h + l) / 2;\n        f = a.y - (k + g) / 2;\n        var m = Math.abs(l - h) / 2,\n          n = Math.abs(g - k) / 2;\n        if (0 === m || 0 === n) return Cb(a.x, a.y, h, k, l, g) <= e ? !0 : !1;\n        if (c) {\n          if (a = K.Hz(m, n, b, f), a * a <= e) return !0;\n        } else return Db(b, f, -m, 0) >= e || Db(b, f, 0, -n) >= e || Db(b, f, 0, n) >= e || Db(b, f, m, 0) >= e ? !1 : !0;\n      } else if (b.type === ud) {\n        l = b.bounds;\n        f = l.x;\n        h = l.y;\n        k = l.x + l.width;\n        l = l.y + l.height;\n        if (a.x > k && a.x < f && a.y > l && a.y < h && Cb(a.x, a.y, f, h, f, l) > e && Cb(a.x, a.y, f, h, k, h) > e && Cb(a.x, a.y, k, l, f, l) > e && Cb(a.x, a.y, k, l, k, h) > e) return !1;\n        f = Math.sqrt(e);\n        if (c) {\n          if (null === this.fill ? fe(b, a.x, a.y, f) : de(b, a, f, !0, !1)) return !0;\n        } else {\n          c = b.figures;\n          for (b = 0; b < c.count; b++) {\n            f = c.j[b];\n            g = f.startX;\n            m = f.startY;\n            if (a.kd(g, m) > e) return !1;\n            h = f.segments.j;\n            k = h.length;\n            for (l = 0; l < k; l++) switch (n = h[l], n.type) {\n              case Xd:\n              case yd:\n                g = n.endX;\n                m = n.endY;\n                if (a.kd(g, m) > e) return !1;\n                break;\n              case Yd:\n                var p = Ea();\n                K.Ce(g, m, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .8, p);\n                g = d(p, a);\n                Ha(p);\n                if (g) return !1;\n                g = n.endX;\n                m = n.endY;\n                if (a.kd(g, m) > e) return !1;\n                break;\n              case Zd:\n                p = Ea();\n                K.Wq(g, m, n.point1X, n.point1Y, n.endX, n.endY, .8, p);\n                g = d(p, a);\n                Ha(p);\n                if (g) return !1;\n                g = n.endX;\n                m = n.endY;\n                if (a.kd(g, m) > e) return !1;\n                break;\n              case $d:\n              case ae:\n                p = n.type === $d ? be(n, f) : ce(n, f, g, m);\n                var r = p.length;\n                if (0 === r) {\n                  g = n.centerX;\n                  m = n.centerY;\n                  if (a.kd(g, m) > e) return !1;\n                  break;\n                }\n                n = null;\n                for (var q = Ea(), u = 0; u < r; u++) if (n = p[u], q.length = 0, K.Ce(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .8, q), d(q, a)) return Ha(q), !1;\n                Ha(q);\n                null !== n && (g = n[6], m = n[7]);\n                break;\n              default:\n                B(\"Unknown Segment type: \" + n.type);\n            }\n          }\n          return !0;\n        }\n      }\n    }\n    return !1;\n  };\n  t.cc = function () {\n    this.na = null;\n  };\n  function Hn(a) {\n    var b = a.diagram;\n    null !== b && b.undoManager.isUndoingRedoing || (a.segmentOrientation = Um, \"None\" !== a.lm ? (a.segmentIndex = -1, a.alignmentFocus = hd) : \"None\" !== a.nl && (a.segmentIndex = 0, a.alignmentFocus = new P(1 - hd.x, hd.y)));\n  }\n  W.makeGeometry = function (a, b, c) {\n    if (\"None\" !== a.toArrow) var d = In[a.toArrow];else \"None\" !== a.fromArrow ? d = In[a.fromArrow] : (d = K.Oe[a.figure], \"string\" === typeof d && (d = K.Oe[d]), void 0 === d && B(\"Unknown Shape.figure: \" + a.figure), d = d(a, b, c), d.xl = b, d.wl = c);\n    if (null === d) {\n      var e = K.Oe.Rectangle;\n      \"function\" === typeof e && (d = e(a, b, c));\n    }\n    return d;\n  };\n  function Jn(a) {\n    var b = In[a];\n    if (void 0 === b) {\n      var c = a.toLowerCase();\n      if (\"none\" === c) return \"None\";\n      b = In[c];\n      if (void 0 === b) {\n        var d = null,\n          e;\n        for (e in K.bn) if (e.toLowerCase() === c) {\n          d = e;\n          break;\n        }\n        if (null !== d) return a = Jd(K.bn[d], !1), In[d] = a, c !== d && (In[c] = d), d;\n      }\n    }\n    return \"string\" === typeof b ? b : b instanceof td ? a : null;\n  }\n  ma.Object.defineProperties(W.prototype, {\n    geometry: {\n      get: function () {\n        return null !== this.na ? this.na : this.zd;\n      },\n      set: function (a) {\n        var b = this.na,\n          c = this.zd;\n        if (b !== a) {\n          null !== a ? this.zd = this.na = a.freeze() : this.zd = this.na = null;\n          var d = this.part;\n          null !== d && (d.jh = NaN);\n          this.o();\n          this.g(\"geometry\", b || c, a);\n          el(this) && (a = this.part, null !== a && fl(this, a, \"geometryString\"));\n        }\n      }\n    },\n    geometryString: {\n      get: function () {\n        return null === this.geometry ? \"\" : this.geometry.toString();\n      },\n      set: function (a) {\n        a = Jd(a);\n        var b = a.normalize();\n        this.geometry = a;\n        this.position = a = J.allocAt(-b.x, -b.y);\n        J.free(a);\n      }\n    },\n    isGeometryPositioned: {\n      get: function () {\n        return this.ro;\n      },\n      set: function (a) {\n        var b = this.ro;\n        b !== a && (this.ro = a, this.o(), this.g(\"isGeometryPositioned\", b, a));\n      }\n    },\n    fill: {\n      get: function () {\n        return this.ml;\n      },\n      set: function (a) {\n        var b = this.ml;\n        b !== a && (null !== a && Rl(a, \"Shape.fill\"), a instanceof tl && a.freeze(), this.ml = a, this.M(), this.g(\"fill\", b, a));\n      }\n    },\n    stroke: {\n      get: function () {\n        return this.Hc;\n      },\n      set: function (a) {\n        var b = this.Hc;\n        b !== a && (null !== a && Rl(a, \"Shape.stroke\"), a instanceof tl && a.freeze(), this.Hc = a, this.M(), this.g(\"stroke\", b, a));\n      }\n    },\n    strokeWidth: {\n      get: function () {\n        return this.xh;\n      },\n      set: function (a) {\n        var b = this.xh;\n        if (b !== a) if (0 <= a) {\n          this.xh = a;\n          this.o();\n          var c = this.part;\n          null !== c && (c.jh = NaN);\n          this.g(\"strokeWidth\", b, a);\n        } else va(a, \"value >= 0\", W, \"strokeWidth:value\");\n      }\n    },\n    strokeCap: {\n      get: function () {\n        return this.em;\n      },\n      set: function (a) {\n        var b = this.em;\n        b !== a && (\"string\" !== typeof a || \"butt\" !== a && \"round\" !== a && \"square\" !== a ? va(a, '\"butt\", \"round\", or \"square\"', W, \"strokeCap\") : (this.em = a, this.M(), this.g(\"strokeCap\", b, a)));\n      }\n    },\n    strokeJoin: {\n      get: function () {\n        return this.fm;\n      },\n      set: function (a) {\n        var b = this.fm;\n        b !== a && (\"string\" !== typeof a || \"miter\" !== a && \"bevel\" !== a && \"round\" !== a ? va(a, '\"miter\", \"bevel\", or \"round\"', W, \"strokeJoin\") : (this.fm = a, this.M(), this.g(\"strokeJoin\", b, a)));\n      }\n    },\n    strokeMiterLimit: {\n      get: function () {\n        return this.dk;\n      },\n      set: function (a) {\n        var b = this.dk;\n        if (b !== a && 1 <= a) {\n          this.dk = a;\n          this.M();\n          var c = this.part;\n          null !== c && (c.jh = NaN);\n          this.g(\"strokeMiterLimit\", b, a);\n        }\n      }\n    },\n    strokeDashArray: {\n      get: function () {\n        return this.vh;\n      },\n      set: function (a) {\n        var b = this.vh;\n        if (b !== a) {\n          if (null !== a) {\n            for (var c = a.length, d = 0, e = 0; e < c; e++) {\n              var f = a[e];\n              0 <= f && isFinite(f) || B(\"strokeDashArray:value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n              d += f;\n            }\n            if (0 === d) {\n              if (null === b) return;\n              a = null;\n            }\n          }\n          this.vh = a;\n          this.M();\n          this.g(\"strokeDashArray\", b, a);\n        }\n      }\n    },\n    strokeDashOffset: {\n      get: function () {\n        return this.wh;\n      },\n      set: function (a) {\n        var b = this.wh;\n        b !== a && 0 <= a && (this.wh = a, this.M(), this.g(\"strokeDashOffset\", b, a));\n      }\n    },\n    figure: {\n      get: function () {\n        return this.Xn;\n      },\n      set: function (a) {\n        var b = this.Xn;\n        if (b !== a) {\n          var c = K.Oe[a];\n          \"function\" === typeof c ? c = a : (c = K.Oe[a.toLowerCase()]) || B(\"Unknown Shape.figure: \" + a);\n          b !== c && (a = this.part, null !== a && (a.jh = NaN), this.Xn = c, this.zd = null, this.cc(), this.o(), this.g(\"figure\", b, c));\n        }\n      }\n    },\n    toArrow: {\n      get: function () {\n        return this.lm;\n      },\n      set: function (a) {\n        var b = this.lm;\n        !0 === a ? a = \"Standard\" : !1 === a && (a = \"\");\n        if (b !== a) {\n          var c = Jn(a);\n          null === c ? B(\"Unknown Shape.toArrow: \" + a) : b !== c && (this.lm = c, this.zd = null, this.cc(), this.o(), Hn(this), this.g(\"toArrow\", b, c));\n        }\n      }\n    },\n    fromArrow: {\n      get: function () {\n        return this.nl;\n      },\n      set: function (a) {\n        var b = this.nl;\n        !0 === a ? a = \"Standard\" : !1 === a && (a = \"\");\n        if (b !== a) {\n          var c = Jn(a);\n          null === c ? B(\"Unknown Shape.fromArrow: \" + a) : b !== c && (this.nl = c, this.zd = null, this.cc(), this.o(), Hn(this), this.g(\"fromArrow\", b, c));\n        }\n      }\n    },\n    spot1: {\n      get: function () {\n        return this.nf;\n      },\n      set: function (a) {\n        var b = this.nf;\n        b.w(a) || (this.nf = a = a.G(), this.o(), this.g(\"spot1\", b, a));\n      }\n    },\n    spot2: {\n      get: function () {\n        return this.pf;\n      },\n      set: function (a) {\n        var b = this.pf;\n        b.w(a) || (this.pf = a = a.G(), this.o(), this.g(\"spot2\", b, a));\n      }\n    },\n    parameter1: {\n      get: function () {\n        return this.op;\n      },\n      set: function (a) {\n        var b = this.op;\n        b !== a && (this.op = a, this.cc(), this.o(), this.g(\"parameter1\", b, a));\n      }\n    },\n    parameter2: {\n      get: function () {\n        return this.pp;\n      },\n      set: function (a) {\n        var b = this.pp;\n        b !== a && (this.pp = a, this.cc(), this.o(), this.g(\"parameter2\", b, a));\n      }\n    },\n    naturalBounds: {\n      get: function () {\n        if (null !== this.na) return this.qc.assign(this.na.bounds), this.qc;\n        var a = this.desiredSize;\n        return new N(0, 0, a.width, a.height);\n      }\n    },\n    pathPattern: {\n      get: function () {\n        return this.rp;\n      },\n      set: function (a) {\n        var b = this.rp;\n        b !== a && (this.rp = a, this.M(), this.g(\"pathPattern\", b, a));\n      }\n    },\n    geometryStretch: {\n      get: function () {\n        return this.fo;\n      },\n      set: function (a) {\n        var b = this.fo;\n        b !== a && (this.fo = a, this.g(\"geometryStretch\", b, a));\n      }\n    },\n    interval: {\n      get: function () {\n        return this.Qd;\n      },\n      set: function (a) {\n        var b = this.Qd;\n        a = Math.round(a);\n        if (b !== a && 0 !== a && isFinite(a)) {\n          this.Qd = a;\n          var c = this.diagram;\n          null !== c && this.panel === c.grid && oj(c);\n          this.o();\n          c = this.panel;\n          null !== c && (c.dh = null);\n          this.g(\"interval\", b, a);\n        }\n      }\n    },\n    graduatedStart: {\n      get: function () {\n        return this.Od;\n      },\n      set: function (a) {\n        var b = this.Od;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Od = a, this.o(), this.g(\"graduatedStart\", b, a));\n      }\n    },\n    graduatedEnd: {\n      get: function () {\n        return this.Md;\n      },\n      set: function (a) {\n        var b = this.Md;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Md = a, this.o(), this.g(\"graduatedEnd\", b, a));\n      }\n    },\n    graduatedSkip: {\n      get: function () {\n        return this.Nd;\n      },\n      set: function (a) {\n        var b = this.Nd;\n        b !== a && (this.Nd = a, this.o(), this.g(\"graduatedSkip\", b, a));\n      }\n    }\n  });\n  W.prototype.intersectsRect = W.prototype.Lc;\n  W.prototype.containedInRect = W.prototype.Jh;\n  W.prototype.getNearestIntersectionPoint = W.prototype.bd;\n  W.prototype.getDocumentBounds = W.prototype.wm;\n  W.prototype.getDocumentPoint = W.prototype.ga;\n  var In = new ab(),\n    un = new ab();\n  W.className = \"Shape\";\n  W.getFigureGenerators = function () {\n    var a = new H(),\n      b;\n    for (b in K.Oe) b !== b.toLowerCase() && a.add(b, K.Oe[b]);\n    a.freeze();\n    return a;\n  };\n  W.defineFigureGenerator = function (a, b) {\n    var c = a.toLowerCase(),\n      d = K.Oe;\n    d[a] = b;\n    d[c] = a;\n  };\n  W.getArrowheadGeometries = function () {\n    var a = new H();\n    for (d in K.bn) if (void 0 === In[d]) {\n      var b = Jd(K.bn[d], !1);\n      In[d] = b;\n      b = d.toLowerCase();\n      b !== d && (In[b] = d);\n    }\n    for (var c in In) if (c !== c.toLowerCase()) {\n      var d = In[c];\n      d instanceof td && a.add(c, d);\n    }\n    a.freeze();\n    return a;\n  };\n  W.defineArrowheadGeometry = function (a, b) {\n    var c = null;\n    \"string\" === typeof b ? c = Jd(b, !1) : c = b;\n    b = a.toLowerCase();\n    \"none\" !== b && a !== b || B(\"Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: \" + a);\n    var d = In;\n    d[a] = c;\n    d[b] = a;\n  };\n  function Vg() {\n    Y.call(this);\n    Kn || (Ln = Tg ? new Dk(null).context : null, Kn = !0);\n    this.Hx = this.Tb = \"\";\n    this.Hc = \"black\";\n    this.je = \"13px sans-serif\";\n    this.Vi = \"start\";\n    this.Ld = yg;\n    this.aj = dd;\n    this.Mj = !0;\n    this.zi = this.Ai = !1;\n    this.mg = Mn;\n    this.zg = Nn;\n    this.ws = this.sb = this.Vc = 0;\n    this.dv = this.ev = null;\n    this.Un = !1;\n    this.Cc = this.wn = this.gq = this.Wi = this.hq = null;\n    this.mf = this.lf = 0;\n    this.re = Infinity;\n    this.Di = 0;\n    this.ke = null;\n    this.xe = 0;\n    this.ie = this.jb = this.Pb = null;\n    this.Qd = 1;\n    this.Od = 0;\n    this.Md = 1;\n    this.Nd = this.Ij = null;\n  }\n  la(Vg, Y);\n  Vg.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.Tb = this.Tb;\n    a.Hx = this.Hx;\n    a.Hc = this.Hc;\n    a.je = this.je;\n    a.Vi = this.Vi;\n    a.Ld = this.Ld;\n    a.aj = this.aj;\n    a.Mj = this.Mj;\n    a.Ai = this.Ai;\n    a.zi = this.zi;\n    a.mg = this.mg;\n    a.zg = this.zg;\n    a.Vc = this.Vc;\n    a.ws = this.ws;\n    a.sb = this.sb;\n    a.ev = this.ev;\n    a.dv = this.dv;\n    a.Un = this.Un;\n    a.hq = this.hq;\n    a.Wi = this.Wi;\n    a.gq = this.gq;\n    a.wn = this.wn;\n    a.Cc = this.Cc;\n    a.lf = this.lf;\n    a.mf = this.mf;\n    a.re = this.re;\n    a.ke = this.ke;\n    a.xe = this.xe;\n    a.Pb = this.Pb;\n    a.jb = this.jb;\n    a.ie = this.ie;\n    a.Di = this.Di;\n    a.Qd = this.Qd;\n    a.Od = this.Od;\n    a.Md = this.Md;\n    a.Ij = this.Ij;\n    a.Nd = this.Nd;\n  };\n  function Tm(a, b) {\n    a.F = b.F | 6144;\n    a.tb = b.opacity;\n    a.kb = b.background;\n    a.dc = b.areaBackground;\n    a.Uc = b.desiredSize.G();\n    a.fg = b.minSize.G();\n    a.eg = b.maxSize.G();\n    a.cg = b.cg.copy();\n    a.ya = b.scale;\n    a.Yb = b.angle;\n    a.ze = b.stretch;\n    a.ih = b.margin.G();\n    a.yb = b.alignment.G();\n    a.Tk = b.alignmentFocus.G();\n    a.Vl = b.segmentFraction;\n    a.Wl = b.segmentOffset.G();\n    a.Xl = b.segmentOrientation;\n    null !== b.pd && (a.pd = b.pd.copy());\n    a.Zl = b.shadowVisible;\n    b instanceof Vg && (a.Tb = b.Tb, a.Hc = b.Hc, a.je = b.je, a.Vi = b.Vi, a.Ld = b.Ld, a.aj = b.aj, a.Mj = b.Mj, a.Ai = b.Ai, a.zi = b.zi, a.mg = b.mg, a.zg = b.zg, a.ke = null, a.lf = b.lf, a.mf = b.mf, a.re = b.re, a.Di = b.Di, a.Qd = b.Qd, a.Od = b.Od, a.Md = b.Md, a.Ij = b.Ij, a.Nd = b.Nd);\n  }\n  t = Vg.prototype;\n  t.hb = function (a) {\n    a.classType === Vg ? this.wrap = a : Y.prototype.hb.call(this, a);\n  };\n  t.toString = function () {\n    return 22 < this.Tb.length ? 'TextBlock(\"' + this.Tb.substring(0, 20) + '\"...)' : 'TextBlock(\"' + this.Tb + '\")';\n  };\n  t.o = function () {\n    Y.prototype.o.call(this);\n    this.dv = this.ev = null;\n  };\n  t.ej = function (a, b) {\n    if (null !== this.Hc && 0 !== this.Tb.length && null !== this.je) {\n      var c = this.naturalBounds,\n        d = this.actualBounds,\n        e = c.width,\n        f = c.height,\n        g = On(this),\n        h = a.textAlign = this.Vi,\n        k = b.Al;\n      \"start\" === h ? h = k ? \"right\" : \"left\" : \"end\" === h && (h = k ? \"left\" : \"right\");\n      k = this.Ai;\n      var l = this.zi;\n      li(this, a, this.Hc, !0, !1, c, d);\n      (k || l) && li(this, a, this.Hc, !1, !1, c, d);\n      d = 0;\n      c = !1;\n      var m = J.allocAt(0, 0);\n      this.Ad.sa(m);\n      var n = J.allocAt(0, g);\n      this.Ad.sa(n);\n      var p = m.Fe(n);\n      J.free(m);\n      J.free(n);\n      m = b.scale;\n      8 > p * m * m && (c = !0);\n      b.Gb !== a && (c = !1);\n      !1 === b.Ge(\"textGreeking\") && (c = !1);\n      b = this.lf;\n      p = this.mf;\n      switch (this.flip) {\n        case $k:\n          a.translate(e, 0);\n          a.scale(-1, 1);\n          break;\n        case Zk:\n          a.translate(0, f);\n          a.scale(1, -1);\n          break;\n        case al:\n          a.translate(e, f), a.scale(-1, -1);\n      }\n      m = this.Vc;\n      n = (b + g + p) * m;\n      f > n && (d = this.aj, d = d.y * f - d.y * n + d.offsetY);\n      if (1 === m && null !== this.ie) p = this.sb, p > e && (p = e), this.dj(this.ie, a, 0, d + b, e, g, p, c, h, k, l);else if (null !== this.Pb && null !== this.jb) for (n = 0; n < m; n++) {\n        var r = this.Pb[n];\n        r > e && (r = e);\n        d += b;\n        this.dj(this.jb[n], a, 0, d, e, g, r, c, h, k, l);\n        d += g + p;\n      }\n      switch (this.flip) {\n        case $k:\n          a.scale(-1, 1);\n          a.translate(-e, 0);\n          break;\n        case Zk:\n          a.scale(1, -1);\n          a.translate(0, -f);\n          break;\n        case al:\n          a.scale(-1, -1), a.translate(-e, -f);\n      }\n    }\n  };\n  t.dj = function (a, b, c, d, e, f, g, h, k, l, m) {\n    var n = 0;\n    h ? (\"left\" === k ? n = 0 : \"right\" === k ? n = e - g : \"center\" === k && (n = (e - g) / 2), b.fillRect(c + n, d + .25 * f, g, 1)) : (\"left\" === k ? n = 0 : \"right\" === k ? n = e : \"center\" === k && (n = e / 2), e = null !== Pn ? Pn(this, f) : .75 * f, b.fillText(a, c + n, d + e), a = f / 20 | 0, 0 === a && (a = 1), \"right\" === k ? n -= g : \"center\" === k && (n -= g / 2), l && (k = null !== Qn ? Qn(this, f) : .8 * f, b.beginPath(), b.lineWidth = a, b.moveTo(c + n, d + k), b.lineTo(c + n + g, d + k), b.stroke()), m && (b.beginPath(), b.lineWidth = a, d = d + f - f / 2.2 | 0, 0 !== a % 2 && (d += .5), b.moveTo(c + n, d), b.lineTo(c + n + g, d), b.stroke()));\n  };\n  t.Dm = function (a, b, c, d) {\n    this.Di = a;\n    var e = this.je;\n    null !== Ln && Rn !== e && (Rn = Ln.font = e);\n    this.sb = this.xe = 0;\n    this.ie = this.jb = this.Pb = this.ke = null;\n    var f;\n    if (isNaN(this.desiredSize.width)) {\n      e = this.Tb.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n      if (0 === e.length) e = 0;else if (this.isMultiline) {\n        for (var g = f = 0, h = !1; !h;) {\n          var k = e.indexOf(\"\\n\", g);\n          -1 === k && (k = e.length, h = !0);\n          f = Math.max(f, Sn(e.substr(g, k - g).trim()));\n          g = k + 1;\n        }\n        e = f;\n      } else f = e.indexOf(\"\\n\", 0), 0 <= f && (e = e.substr(0, f)), e = Sn(e);\n      e = Math.min(e, a / this.scale);\n      e = Math.max(8, e);\n    } else e = this.desiredSize.width;\n    null !== this.panel && (e = Math.min(e, this.panel.maxSize.width));\n    f = Tn(this, e);\n    isNaN(this.desiredSize.height) ? f = Math.min(f, b / this.scale) : f = this.desiredSize.height;\n    g = f;\n    if (0 !== this.sb && null !== this.Pb && null !== this.jb && this.mg === Un && (b = this.je, b = this.mg === Un ? Vn(b) : 0, h = this.lf + this.mf, h = Math.max(0, On(this) + h), g = Math.min(this.maxLines - 1, Math.max(Math.floor(g / h + .01) - 1, 0)), !(g + 1 >= this.jb.length))) {\n      h = this.jb[g];\n      for (b = Math.max(1, a - b); Sn(h) > b && 1 < h.length;) h = h.substr(0, h.length - 1);\n      h += Wn;\n      b = Sn(h);\n      this.jb[g] = h;\n      this.jb = this.jb.slice(0, g + 1);\n      this.Pb[g] = b;\n      this.Pb = this.Pb.slice(0, g + 1);\n      this.xe = this.jb.length;\n      this.sb = Math.max(this.sb, b);\n      this.Vc = this.xe;\n      1 === this.Vc && (this.ie = this.jb[0]);\n    }\n    if (this.wrap === Xn || isNaN(this.desiredSize.width)) e = isNaN(a) ? this.sb : Math.min(a, this.sb), isNaN(this.desiredSize.width) && (e = Math.max(8, e));\n    e = Math.max(c, e);\n    f = Math.max(d, f);\n    Wb(this.qc, e, f);\n    hl(this, 0, 0, e, f);\n  };\n  t.Ih = function (a, b, c, d) {\n    ml(this, a, b, c, d);\n  };\n  function Yn(a, b, c) {\n    if (null === a.ie) a.ie = b, a.sb = c;else {\n      if (null === a.jb || null === a.Pb) a.jb = [], a.Pb = [], a.jb.push(a.ie), a.Pb.push(a.sb);\n      a.jb.push(b);\n      a.Pb.push(c);\n    }\n  }\n  function Zn(a, b, c, d) {\n    b = b.trim();\n    var e = 0;\n    var f = a.je;\n    var g = a.lf + a.mf;\n    g = Math.max(0, On(a) + g);\n    var h = a.mg === Un ? Vn(f) : 0;\n    if (a.Vc >= a.re) null !== d && d.h(0, g);else {\n      var k = b;\n      if (a.zg === $n) {\n        if (a.xe = 1, f = Sn(b), 0 === h || f <= c) a.sb = Math.max(a.sb, f), Yn(a, b, a.sb), null !== d && d.h(f, g);else {\n          e = ao(a, k);\n          k = k.substr(e.length);\n          b = ao(a, k);\n          for (f = Sn(e + b); 0 < b.length && f <= c;) e += b, k = k.substr(b.length), b = ao(a, k), f = Sn((e + b).trim());\n          e += b.trim();\n          for (c = Math.max(1, c - h); Sn(e) > c && 1 < e.length;) e = e.substr(0, e.length - 1);\n          e += Wn;\n          b = Sn(e);\n          a.sb = b;\n          Yn(a, e, b);\n          null !== d && d.h(b, g);\n        }\n      } else {\n        h = 0;\n        0 === k.length && (h = 1, Yn(a, k, 0));\n        for (; 0 < k.length;) {\n          var l = ao(a, k);\n          for (k = k.substr(l.length); Sn(l) > c;) {\n            var m = 1;\n            f = Sn(l.substr(0, m));\n            for (b = 0; f <= c;) m++, b = f, f = Sn(l.substr(0, m));\n            if (1 === m) {\n              var n = f;\n              e = Math.max(e, f);\n            } else n = b, e = Math.max(e, b);\n            m--;\n            1 > m && (m = 1);\n            Yn(a, l.substr(0, m), n);\n            h++;\n            l = l.substr(m);\n            if (a.Vc + h > a.re) break;\n          }\n          b = ao(a, k);\n          for (f = Sn(l + b); 0 < b.length && f <= c;) l += b, k = k.substr(b.length), b = ao(a, k), f = Sn((l + b).trim());\n          l = l.trim();\n          if (\"\" !== l && (\"\\u00ad\" === l[l.length - 1] && (l = l.substring(0, l.length - 1) + \"\\u2010\"), 0 === b.length ? (m = f, e = Math.max(e, f)) : (m = b = Sn(l), e = Math.max(e, b)), Yn(a, l, m), h++, a.Vc + h > a.re)) break;\n        }\n        a.xe = Math.min(a.re, h);\n        a.sb = Math.max(a.sb, e);\n        null !== d && d.h(a.sb, g * a.xe);\n      }\n    }\n  }\n  function ao(a, b) {\n    if (a.zg === bo) return b.substr(0, 1);\n    a = b.length;\n    for (var c = 0, d = co; c < a && !d.test(b.charAt(c));) c++;\n    for (; c < a && d.test(b.charAt(c));) c++;\n    return c >= a ? b : b.substr(0, c);\n  }\n  function Sn(a) {\n    return null === Ln ? 8 * a.length : Ln.measureText(a).width;\n  }\n  function On(a) {\n    if (null !== a.ke) return a.ke;\n    var b = a.je;\n    if (null === Ln) {\n      var c = 16;\n      return a.ke = c;\n    }\n    void 0 !== eo[b] && 5E3 > fo ? c = eo[b] : (c = 1.3 * Ln.measureText(\"M\").width, eo[b] = c, fo++);\n    return a.ke = c;\n  }\n  function Vn(a) {\n    if (null === Ln) return 6;\n    if (void 0 !== go[a] && 5E3 > ho) var b = go[a];else b = Ln.measureText(Wn).width, go[a] = b, ho++;\n    return b;\n  }\n  function Tn(a, b) {\n    var c = a.Tb.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\"),\n      d = a.lf + a.mf;\n    d = Math.max(0, On(a) + d);\n    if (0 === c.length) return a.sb = 0, a.Vc = 1, d;\n    if (!a.isMultiline) {\n      var e = c.indexOf(\"\\n\", 0);\n      0 <= e && (c = c.substr(0, e));\n    }\n    e = 0;\n    for (var f = a.Vc = 0, g, h = !1; !h;) {\n      g = c.indexOf(\"\\n\", f);\n      -1 === g && (g = c.length, h = !0);\n      if (f <= g) {\n        f = c.substr(f, g - f);\n        if (a.zg !== $n) {\n          a.xe = 0;\n          var k = M.alloc();\n          Zn(a, f, b, k);\n          e += k.height;\n          M.free(k);\n          a.Vc += a.xe;\n        } else Zn(a, f, b, null), e += d, a.Vc++;\n        a.Vc === a.re && (h = !0);\n      }\n      f = g + 1;\n    }\n    return a.ws = e;\n  }\n  ma.Object.defineProperties(Vg.prototype, {\n    font: {\n      get: function () {\n        return this.je;\n      },\n      set: function (a) {\n        var b = this.je;\n        b !== a && (this.je = a, this.ke = null, this.o(), this.g(\"font\", b, a));\n      }\n    },\n    text: {\n      get: function () {\n        return this.Tb;\n      },\n      set: function (a) {\n        var b = this.Tb;\n        null !== a && void 0 !== a ? a = a.toString() : a = \"\";\n        b !== a && (this.Tb = a, this.o(), this.g(\"text\", b, a));\n      }\n    },\n    textAlign: {\n      get: function () {\n        return this.Vi;\n      },\n      set: function (a) {\n        var b = this.Vi;\n        b === a || \"start\" !== a && \"end\" !== a && \"left\" !== a && \"right\" !== a && \"center\" !== a || (this.Vi = a, this.M(), this.g(\"textAlign\", b, a));\n      }\n    },\n    flip: {\n      get: function () {\n        return this.Ld;\n      },\n      set: function (a) {\n        var b = this.Ld;\n        b !== a && (this.Ld = a, this.M(), this.g(\"flip\", b, a));\n      }\n    },\n    verticalAlignment: {\n      get: function () {\n        return this.aj;\n      },\n      set: function (a) {\n        var b = this.aj;\n        b.w(a) || (this.aj = a = a.G(), Cl(this), this.g(\"verticalAlignment\", b, a));\n      }\n    },\n    naturalBounds: {\n      get: function () {\n        if (!this.qc.u()) {\n          var a = M.alloc();\n          Zn(this, this.Tb, 999999, a);\n          var b = a.width;\n          M.free(a);\n          a = Tn(this, b);\n          var c = this.desiredSize;\n          isNaN(c.width) || (b = c.width);\n          isNaN(c.height) || (a = c.height);\n          Wb(this.qc, b, a);\n        }\n        return this.qc;\n      }\n    },\n    isMultiline: {\n      get: function () {\n        return this.Mj;\n      },\n      set: function (a) {\n        var b = this.Mj;\n        b !== a && (this.Mj = a, this.o(), this.g(\"isMultiline\", b, a));\n      }\n    },\n    isUnderline: {\n      get: function () {\n        return this.Ai;\n      },\n      set: function (a) {\n        var b = this.Ai;\n        b !== a && (this.Ai = a, this.M(), this.g(\"isUnderline\", b, a));\n      }\n    },\n    isStrikethrough: {\n      get: function () {\n        return this.zi;\n      },\n      set: function (a) {\n        var b = this.zi;\n        b !== a && (this.zi = a, this.M(), this.g(\"isStrikethrough\", b, a));\n      }\n    },\n    wrap: {\n      get: function () {\n        return this.zg;\n      },\n      set: function (a) {\n        var b = this.zg;\n        b !== a && (this.zg = a, this.o(), this.g(\"wrap\", b, a));\n      }\n    },\n    overflow: {\n      get: function () {\n        return this.mg;\n      },\n      set: function (a) {\n        var b = this.mg;\n        b !== a && (this.mg = a, this.o(), this.g(\"overflow\", b, a));\n      }\n    },\n    stroke: {\n      get: function () {\n        return this.Hc;\n      },\n      set: function (a) {\n        var b = this.Hc;\n        b !== a && (null !== a && Rl(a, \"TextBlock.stroke\"), a instanceof tl && a.freeze(), this.Hc = a, this.M(), this.g(\"stroke\", b, a));\n      }\n    },\n    lineCount: {\n      get: function () {\n        return this.Vc;\n      }\n    },\n    editable: {\n      get: function () {\n        return this.Un;\n      },\n      set: function (a) {\n        var b = this.Un;\n        b !== a && (this.Un = a, this.g(\"editable\", b, a));\n      }\n    },\n    textEditor: {\n      get: function () {\n        return this.hq;\n      },\n      set: function (a) {\n        var b = this.hq;\n        b !== a && (this.hq = a, this.g(\"textEditor\", b, a));\n      }\n    },\n    errorFunction: {\n      get: function () {\n        return this.Cc;\n      },\n      set: function (a) {\n        var b = this.Cc;\n        b !== a && (this.Cc = a, this.g(\"errorFunction\", b, a));\n      }\n    },\n    interval: {\n      get: function () {\n        return this.Qd;\n      },\n      set: function (a) {\n        var b = this.Qd;\n        a = Math.round(a);\n        if (b !== a && 0 !== a && isFinite(a)) {\n          this.Qd = a;\n          this.o();\n          var c = this.panel;\n          null !== c && (c.dh = null);\n          this.g(\"interval\", b, a);\n        }\n      }\n    },\n    graduatedStart: {\n      get: function () {\n        return this.Od;\n      },\n      set: function (a) {\n        var b = this.Od;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Od = a, this.o(), this.g(\"graduatedStart\", b, a));\n      }\n    },\n    graduatedEnd: {\n      get: function () {\n        return this.Md;\n      },\n      set: function (a) {\n        var b = this.Md;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Md = a, this.o(), this.g(\"graduatedEnd\", b, a));\n      }\n    },\n    graduatedFunction: {\n      get: function () {\n        return this.Ij;\n      },\n      set: function (a) {\n        var b = this.Ij;\n        b !== a && (this.Ij = a, this.o(), this.g(\"graduatedFunction\", b, a));\n      }\n    },\n    graduatedSkip: {\n      get: function () {\n        return this.Nd;\n      },\n      set: function (a) {\n        var b = this.Nd;\n        b !== a && (this.Nd = a, this.o(), this.g(\"graduatedSkip\", b, a));\n      }\n    },\n    textValidation: {\n      get: function () {\n        return this.Wi;\n      },\n      set: function (a) {\n        var b = this.Wi;\n        b !== a && (this.Wi = a, this.g(\"textValidation\", b, a));\n      }\n    },\n    textEdited: {\n      get: function () {\n        return this.gq;\n      },\n      set: function (a) {\n        var b = this.gq;\n        b !== a && (this.gq = a, this.g(\"textEdited\", b, a));\n      }\n    },\n    spacingAbove: {\n      get: function () {\n        return this.lf;\n      },\n      set: function (a) {\n        var b = this.lf;\n        b !== a && (this.lf = a, this.g(\"spacingAbove\", b, a));\n      }\n    },\n    spacingBelow: {\n      get: function () {\n        return this.mf;\n      },\n      set: function (a) {\n        var b = this.mf;\n        b !== a && (this.mf = a, this.g(\"spacingBelow\", b, a));\n      }\n    },\n    maxLines: {\n      get: function () {\n        return this.re;\n      },\n      set: function (a) {\n        var b = this.re;\n        b !== a && (a = Math.floor(a), 0 >= a && va(a, \"> 0\", Vg, \"maxLines\"), this.re = a, this.g(\"maxLines\", b, a), this.o());\n      }\n    },\n    metrics: {\n      get: function () {\n        return {\n          arrSize: null !== this.Pb ? this.Pb : [this.sb],\n          arrText: null !== this.jb ? this.jb : [this.ie],\n          maxLineWidth: this.sb,\n          fontHeight: this.ke\n        };\n      }\n    },\n    choices: {\n      get: function () {\n        return this.wn;\n      },\n      set: function (a) {\n        var b = this.wn;\n        b !== a && (this.wn = a, this.g(\"choices\", b, a));\n      }\n    }\n  });\n  var Pn = null,\n    Qn = null,\n    $n = new D(Vg, \"None\", 0),\n    Xn = new D(Vg, \"WrapFit\", 1),\n    Nn = new D(Vg, \"WrapDesiredSize\", 2),\n    bo = new D(Vg, \"WrapBreakAll\", 3),\n    Mn = new D(Vg, \"OverflowClip\", 0),\n    Un = new D(Vg, \"OverflowEllipsis\", 1),\n    co = /[ \\u200b\\u00ad]/,\n    eo = new ab(),\n    fo = 0,\n    go = new ab(),\n    ho = 0,\n    Wn = \"...\",\n    Rn = \"\",\n    Ln = null,\n    Kn = !1;\n  Vg.className = \"TextBlock\";\n  Vg.getEllipsis = function () {\n    return Wn;\n  };\n  Vg.setEllipsis = function (a) {\n    Wn = a;\n    go = new ab();\n    ho = 0;\n  };\n  Vg.getBaseline = function () {\n    return Pn;\n  };\n  Vg.setBaseline = function (a) {\n    Pn = a;\n    a = Pa();\n    for (var b = a.length, c = 0; c < b; c++) a[c].Je();\n  };\n  Vg.getUnderline = function () {\n    return Qn;\n  };\n  Vg.setUnderline = function (a) {\n    Qn = a;\n    a = Pa();\n    for (var b = a.length, c = 0; c < b; c++) a[c].Je();\n  };\n  Vg.isValidFont = function (a) {\n    Kn || (Ln = Tg ? new Dk(null).context : null, Kn = !0);\n    if (null === Ln) return !0;\n    var b = Ln.font;\n    if (a === b || \"10px sans-serif\" === a) return !0;\n    Ln.font = \"10px sans-serif\";\n    Ln.font = a;\n    var c = Ln.font;\n    if (\"10px sans-serif\" !== c) return Ln.font = b, !0;\n    Ln.font = \"19px serif\";\n    var d = Ln.font;\n    Ln.font = a;\n    c = Ln.font;\n    Ln.font = b;\n    return c !== d;\n  };\n  Vg.None = $n;\n  Vg.WrapFit = Xn;\n  Vg.WrapDesiredSize = Nn;\n  Vg.WrapBreakAll = bo;\n  Vg.OverflowClip = Mn;\n  Vg.OverflowEllipsis = Un;\n  function io() {\n    this.Pb = [];\n    this.jb = [];\n  }\n  io.prototype.reset = function () {\n    this.Pb = [];\n    this.jb = [];\n  };\n  io.prototype.Dt = function (a) {\n    this.Pb = Ba(a.Pb);\n    this.jb = Ba(a.jb);\n  };\n  io.className = \"TextBlockMetrics\";\n  function Zj() {\n    Y.call(this);\n    this.Yg = null;\n    this.Yp = \"\";\n    this.uh = kc;\n    this.sl = vd;\n    this.qf = this.Cc = null;\n    this.rl = Bc;\n    this.Ld = yg;\n    this.hm = null;\n    this.Su = !1;\n    this.$r = !0;\n    this.Il = !1;\n    this.am = null;\n  }\n  la(Zj, Y);\n  Zj.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.element = this.Yg;\n    a.Yp = this.Yp;\n    a.uh = this.uh.G();\n    a.sl = this.sl;\n    a.Ld = this.Ld;\n    a.Cc = this.Cc;\n    a.qf = this.qf;\n    a.rl = this.rl.G();\n    a.$r = this.$r;\n    a.am = this.am;\n  };\n  t = Zj.prototype;\n  t.hb = function (a) {\n    a === yg || a === Ag || a === Yk ? this.imageStretch = a : Y.prototype.hb.call(this, a);\n  };\n  t.toString = function () {\n    return \"Picture(\" + this.source + \")#\" + mb(this);\n  };\n  function kk(a) {\n    void 0 === a && (a = \"\");\n    \"\" !== a ? jo[a] && (delete jo[a], ko--) : (jo = new ab(), ko = 0);\n  }\n  function lo(a, b) {\n    a.ns = !0;\n    a.ol = !1;\n    for (var c, d = Pa(), e = d.length, f = 0; f < e; f++) {\n      var g = d[f];\n      c = a.getAttribute(\"src\");\n      var h = g.Pi.H(c);\n      if (null !== h) for (var k = h.length, l = 0; l < k; l++) c = h[l], g.Ns.add(c), g.Db(), void 0 === a.ov && (a.ov = b, null !== c.qf && c.qf(c, b));\n    }\n  }\n  function mo(a, b) {\n    a.ol = b;\n    for (var c, d = Pa(), e = d.length, f = 0; f < e; f++) {\n      var g = d[f],\n        h = a.getAttribute(\"src\");\n      c = g.Pi.H(h);\n      if (null !== c) {\n        g = c.length;\n        h = Ea();\n        for (var k = 0; k < g; k++) h.push(c[k]);\n        for (k = 0; k < g; k++) c = h[k], null !== c.Cc && c.Cc(c, b);\n        Ha(h);\n      }\n    }\n  }\n  t.MA = function () {\n    if (\"\" !== this.source) {\n      kk(this.source);\n      var a = this.source;\n      this.source = \"\";\n      this.source = a;\n    }\n  };\n  t.Je = function () {\n    this.M();\n  };\n  t.ej = function (a, b) {\n    var c = this.Yg;\n    if (null !== c) {\n      var d = c.getAttribute(\"src\");\n      if (!(c instanceof HTMLImageElement && (null === d || \"\" === d) || c.ol instanceof Event && a instanceof xl)) {\n        d = this.naturalBounds;\n        var e = 0,\n          f = 0,\n          g = this.Su,\n          h = g ? +c.width : c.naturalWidth;\n        g = g ? +c.height : c.naturalHeight;\n        void 0 === h && c.videoWidth && (h = c.videoWidth);\n        void 0 === g && c.videoHeight && (g = c.videoHeight);\n        h = h || d.width;\n        g = g || d.height;\n        if (0 !== h && 0 !== g) {\n          var k = h,\n            l = g;\n          this.sourceRect.u() && (e = this.uh.x, f = this.uh.y, h = this.uh.width, g = this.uh.height);\n          var m = h,\n            n = g,\n            p = this.sl,\n            r = this.rl;\n          switch (p) {\n            case yg:\n              if (this.sourceRect.u()) break;\n              m >= d.width && (e = e + r.offsetX + (m * r.x - d.width * r.x));\n              n >= d.height && (f = f + r.offsetY + (n * r.y - d.height * r.y));\n              h = Math.min(d.width, m);\n              g = Math.min(d.height, n);\n              break;\n            case vd:\n              m = d.width;\n              n = d.height;\n              break;\n            case Ag:\n            case Yk:\n              p === Ag ? (p = Math.min(d.height / n, d.width / m), m *= p, n *= p) : p === Yk && (p = Math.max(d.height / n, d.width / m), m *= p, n *= p, m >= d.width && (e = (e + r.offsetX + (m * r.x - d.width * r.x) / m) * h), n >= d.height && (f = (f + r.offsetY + (n * r.y - d.height * r.y) / n) * g), h *= 1 / (m / d.width), g *= 1 / (n / d.height), m = d.width, n = d.height);\n          }\n          p = this.Af() * b.scale;\n          var q = m * p * n * p,\n            u = h * g / q,\n            v = c.__goCache;\n          p = null;\n          var w = no;\n          if (c.ns && void 0 !== v && 4 < q && u > w * w) for (null === v.cj && (oo(v, 4, k, l, c), oo(v, 16, k, l, c)), k = v.cj, l = k.length, q = 0; q < l; q++) if (k[q].ratio * k[q].ratio < u) p = k[q];else break;\n          if (!b.kl) {\n            if (null === this.hm) if (null === this.Yg) this.hm = !1;else {\n              k = new Dk(null).context;\n              k.drawImage(this.Yg, 0, 0);\n              try {\n                k.getImageData(0, 0, 1, 1).data[3] && (this.hm = !1), this.hm = !1;\n              } catch (y) {\n                this.hm = !0;\n              }\n            }\n            if (this.hm) return;\n          }\n          k = 0;\n          m < d.width && (k = r.offsetX + (d.width * r.x - m * r.x));\n          l = 0;\n          n < d.height && (l = r.offsetY + (d.height * r.y - n * r.y));\n          switch (this.flip) {\n            case $k:\n              a.translate(Math.min(d.width, m), 0);\n              a.scale(-1, 1);\n              break;\n            case Zk:\n              a.translate(0, Math.min(d.height, n));\n              a.scale(1, -1);\n              break;\n            case al:\n              a.translate(Math.min(d.width, m), Math.min(d.height, n)), a.scale(-1, -1);\n          }\n          if (b.Ge(\"pictureRatioOptimization\") && !b.xi && void 0 !== v && null !== p && 1 !== p.ratio) {\n            a.save();\n            b = p.ratio;\n            try {\n              a.drawImage(p.source, e / b, f / b, Math.min(p.source.width, h / b), Math.min(p.source.height, g / b), k, l, Math.min(d.width, m), Math.min(d.height, n));\n            } catch (y) {\n              this.$r = !1;\n            }\n            a.restore();\n          } else try {\n            a.drawImage(c, e, f, h, g, k, l, Math.min(d.width, m), Math.min(d.height, n));\n          } catch (y) {\n            this.$r = !1;\n          }\n          switch (this.flip) {\n            case $k:\n              a.scale(-1, 1);\n              a.translate(-Math.min(d.width, m), 0);\n              break;\n            case Zk:\n              a.scale(1, -1);\n              a.translate(0, -Math.min(d.height, n));\n              break;\n            case al:\n              a.scale(-1, -1), a.translate(-Math.min(d.width, m), -Math.min(d.height, n));\n          }\n        }\n      }\n    }\n  };\n  t.Dm = function (a, b, c, d) {\n    var e = this.desiredSize,\n      f = kl(this, !0),\n      g = this.Yg,\n      h = this.Su;\n    if (h || !this.Il && g && g.complete) this.Il = !0;\n    null === g && (isFinite(e.width) || (a = 0), isFinite(e.height) || (b = 0));\n    isFinite(e.width) || f === vd || f === Wk ? (isFinite(a) || (a = this.sourceRect.u() ? this.sourceRect.width : h ? +g.width : g.naturalWidth), c = 0) : null !== g && !1 !== this.Il && (a = this.sourceRect.u() ? this.sourceRect.width : h ? +g.width : g.naturalWidth);\n    isFinite(e.height) || f === vd || f === Xk ? (isFinite(b) || (b = this.sourceRect.u() ? this.sourceRect.height : h ? +g.height : g.naturalHeight), d = 0) : null !== g && !1 !== this.Il && (b = this.sourceRect.u() ? this.sourceRect.height : h ? +g.height : g.naturalHeight);\n    isFinite(e.width) && (a = e.width);\n    isFinite(e.height) && (b = e.height);\n    e = this.maxSize;\n    f = this.minSize;\n    c = Math.max(c, f.width);\n    d = Math.max(d, f.height);\n    a = Math.min(e.width, a);\n    b = Math.min(e.height, b);\n    a = Math.max(c, a);\n    b = Math.max(d, b);\n    null === g || g.complete || (isFinite(a) || (a = 0), isFinite(b) || (b = 0));\n    Wb(this.qc, a, b);\n    hl(this, 0, 0, a, b);\n  };\n  t.Ih = function (a, b, c, d) {\n    ml(this, a, b, c, d);\n  };\n  ma.Object.defineProperties(Zj.prototype, {\n    element: {\n      get: function () {\n        return this.Yg;\n      },\n      set: function (a) {\n        var b = this.Yg;\n        if (b !== a) {\n          null === a || a instanceof HTMLImageElement || a instanceof HTMLVideoElement || a instanceof HTMLCanvasElement || B(\"Picture.element must be an instance of Image, Canvas, or Video, not: \" + a);\n          this.Su = a instanceof HTMLCanvasElement;\n          this.Yg = a;\n          if (null !== a) if (a instanceof HTMLCanvasElement || !0 === a.complete) a.ol instanceof Event && null !== this.Cc && this.Cc(this, a.ol), !0 === a.ns && null !== this.qf && this.qf(this, a.ov), a.ns = !0, this.desiredSize.u() || (nj(this, !1), this.o());else {\n            var c = this;\n            a.vx || (a.addEventListener(\"load\", function (b) {\n              lo(a, b);\n              c.desiredSize.u() || (nj(c, !1), c.o());\n            }), a.addEventListener(\"error\", function (b) {\n              mo(a, b);\n            }), a.vx = !0);\n          }\n          this.g(\"element\", b, a);\n          this.M();\n        }\n      }\n    },\n    source: {\n      get: function () {\n        return this.Yp;\n      },\n      set: function (a) {\n        var b = this.Yp;\n        if (b !== a) {\n          this.Yp = a;\n          var c = jo,\n            d = this.diagram;\n          if (Tg) {\n            var e = null;\n            if (void 0 !== c[a]) e = c[a];else if (\"\" !== a) {\n              30 < ko && (kk(), c = jo);\n              e = ta(\"img\");\n              var f = this;\n              e.addEventListener(\"load\", function (a) {\n                lo(e, a);\n                f.desiredSize.u() || (nj(f, !1), f.o());\n              });\n              e.addEventListener(\"error\", function (a) {\n                mo(e, a);\n              });\n              e.vx = !0;\n              var g = this.am;\n              null !== g && (e.crossOrigin = g(this));\n              e.src = a;\n              c[a] = e;\n              ko++;\n            }\n            null !== d && ak(d, this);\n            this.element = e;\n            null !== d && null !== e && Yj(d, this);\n            null !== e && void 0 === e.__goCache && (e.__goCache = new po());\n            this.o();\n            this.M();\n          }\n          this.g(\"source\", b, a);\n        }\n      }\n    },\n    sourceCrossOrigin: {\n      get: function () {\n        return this.am;\n      },\n      set: function (a) {\n        if (this.am !== a && (this.am = a, null !== this.element)) {\n          var b = this.element.getAttribute(\"src\");\n          null === a && \"string\" === typeof b ? this.element.crossOrigin = null : null !== a && (this.element.crossOrigin = a(this));\n          this.element.src = b;\n        }\n      }\n    },\n    sourceRect: {\n      get: function () {\n        return this.uh;\n      },\n      set: function (a) {\n        var b = this.uh;\n        b.w(a) || (this.uh = a = a.G(), this.M(), this.g(\"sourceRect\", b, a));\n      }\n    },\n    imageStretch: {\n      get: function () {\n        return this.sl;\n      },\n      set: function (a) {\n        var b = this.sl;\n        b !== a && (this.sl = a, this.M(), this.g(\"imageStretch\", b, a));\n      }\n    },\n    flip: {\n      get: function () {\n        return this.Ld;\n      },\n      set: function (a) {\n        var b = this.Ld;\n        b !== a && (this.Ld = a, this.M(), this.g(\"flip\", b, a));\n      }\n    },\n    imageAlignment: {\n      get: function () {\n        return this.rl;\n      },\n      set: function (a) {\n        var b = this.rl;\n        b.w(a) || (this.rl = a = a.G(), this.o(), this.g(\"imageAlignment\", b, a));\n      }\n    },\n    errorFunction: {\n      get: function () {\n        return this.Cc;\n      },\n      set: function (a) {\n        var b = this.Cc;\n        b !== a && (this.Cc = a, this.g(\"errorFunction\", b, a));\n      }\n    },\n    successFunction: {\n      get: function () {\n        return this.qf;\n      },\n      set: function (a) {\n        var b = this.qf;\n        b !== a && (this.qf = a, this.g(\"successFunction\", b, a));\n      }\n    },\n    naturalBounds: {\n      get: function () {\n        return this.qc;\n      }\n    }\n  });\n  Zj.prototype.redraw = Zj.prototype.Je;\n  Zj.prototype.reloadSource = Zj.prototype.MA;\n  var jo = null,\n    ko = 0,\n    no = 4;\n  Zj.className = \"Picture\";\n  jo = new ab();\n  Zj.clearCache = kk;\n  function po() {\n    this.cj = null;\n  }\n  function oo(a, b, c, d, e) {\n    null === a.cj && (a.cj = []);\n    var f = new Dk(null),\n      g = f.context,\n      h = 1 / b;\n    f.width = c / b;\n    f.height = d / b;\n    0 !== f.width && 0 !== f.height && (b = new qo(f.Ga, b), c = 1, 0 < a.cj.length && (c = a.cj[a.cj.length - 1], e = c.source, c = c.ratio), g.setTransform(h * c, 0, 0, h * c, 0, 0), g.drawImage(e, 0, 0), a.cj.push(b));\n  }\n  po.className = \"PictureCacheArray\";\n  function qo(a, b) {\n    this.source = a;\n    this.ratio = b;\n  }\n  qo.className = \"PictureCacheInstance\";\n  function ro() {\n    this.Lt = new td();\n    this.hc = null;\n  }\n  t = ro.prototype;\n  t.reset = function (a) {\n    null !== a ? (a.ea(), this.Lt = a, a.figures.clear()) : this.Lt = new td();\n    this.hc = null;\n  };\n  function Ld(a, b, c, d, e) {\n    a.hc = new he();\n    a.hc.startX = b;\n    a.hc.startY = c;\n    a.hc.isFilled = d;\n    a.Lt.figures.add(a.hc);\n    void 0 !== e && (a.hc.isShadowed = e);\n  }\n  function Td(a) {\n    var b = a.hc.segments.length;\n    0 < b && a.hc.segments.L(b - 1).close();\n  }\n  t.gr = function (a) {\n    this.hc.isShadowed = a;\n  };\n  t.moveTo = function (a, b, c) {\n    void 0 === c && (c = !1);\n    var d = new pe(Xd);\n    d.endX = a;\n    d.endY = b;\n    c && d.close();\n    this.hc.segments.add(d);\n  };\n  t.lineTo = function (a, b, c) {\n    void 0 === c && (c = !1);\n    var d = new pe(yd);\n    d.endX = a;\n    d.endY = b;\n    c && d.close();\n    this.hc.segments.add(d);\n  };\n  function Md(a, b, c, d, e, f, g) {\n    var h;\n    void 0 === h && (h = !1);\n    var k = new pe(Yd);\n    k.point1X = b;\n    k.point1Y = c;\n    k.point2X = d;\n    k.point2Y = e;\n    k.endX = f;\n    k.endY = g;\n    h && k.close();\n    a.hc.segments.add(k);\n  }\n  function Rd(a, b, c, d, e) {\n    var f;\n    void 0 === f && (f = !1);\n    var g = new pe(Zd);\n    g.point1X = b;\n    g.point1Y = c;\n    g.endX = d;\n    g.endY = e;\n    f && g.close();\n    a.hc.segments.add(g);\n  }\n  t.arcTo = function (a, b, c, d, e, f, g) {\n    void 0 === f && (f = 0);\n    void 0 === g && (g = !1);\n    var h = new pe($d);\n    h.startAngle = a;\n    h.sweepAngle = b;\n    h.centerX = c;\n    h.centerY = d;\n    h.radiusX = e;\n    h.radiusY = 0 !== f ? f : e;\n    g && h.close();\n    this.hc.segments.add(h);\n  };\n  function Sd(a, b, c, d, e, f, g, h) {\n    var k;\n    void 0 === k && (k = !1);\n    b = new pe(ae, g, h, b, c, d, e, f);\n    k && b.close();\n    a.hc.segments.add(b);\n  }\n  function Kd(a) {\n    var b = Ud;\n    if (null !== b) return Ud = null, b.reset(a), b;\n    b = new ro();\n    b.reset(a);\n    return b;\n  }\n  var Ud = null;\n  ro.className = \"StreamGeometryContext\";\n  function so(a, b) {\n    var c = a.toLowerCase(),\n      d = K.Oe;\n    d[a] = b;\n    d[c] = a;\n  }\n  so(\"Rectangle\", function (a, b, c) {\n    a = \"r\" + b + \",\" + c;\n    var d = K.Uh[a];\n    if (void 0 !== d) return d;\n    d = new td(Hd);\n    d.endX = b;\n    d.endY = c;\n    50 > K.Vh && (K.Uh[a] = d, K.Vh++);\n    return d;\n  });\n  so(\"Square\", function (a, b, c) {\n    a = \"s\" + b + \",\" + c;\n    var d = K.Uh[a];\n    if (void 0 !== d) return d;\n    d = new td(Hd);\n    d.endX = b;\n    d.endY = c;\n    d.defaultStretch = Ag;\n    50 > K.Vh && (K.Uh[a] = d, K.Vh++);\n    return d;\n  });\n  so(\"RoundedRectangle\", function (a, b, c) {\n    var d = a ? a.parameter1 : NaN;\n    if (isNaN(d) || 0 > d) d = 5;\n    d = Math.min(d, b / 3);\n    d = Math.min(d, c / 3);\n    a = d * K.Kg;\n    b = new td().add(new he(d, 0, !0).add(new pe(yd, b - d, 0)).add(new pe(Yd, b, d, b - a, 0, b, a)).add(new pe(yd, b, c - d)).add(new pe(Yd, b - d, c, b, c - a, b - a, c)).add(new pe(yd, d, c)).add(new pe(Yd, 0, c - d, a, c, 0, c - a)).add(new pe(yd, 0, d)).add(new pe(Yd, d, 0, 0, a, a, 0).close()));\n    1 < a && (b.spot1 = new P(0, 0, a, a), b.spot2 = new P(1, 1, -a, -a));\n    return b;\n  });\n  so(\"Border\", \"RoundedRectangle\");\n  so(\"Ellipse\", function (a, b, c) {\n    a = \"e\" + b + \",\" + c;\n    var d = K.Uh[a];\n    if (void 0 !== d) return d;\n    d = new td(Id);\n    d.endX = b;\n    d.endY = c;\n    d.spot1 = jd;\n    d.spot2 = kd;\n    50 > K.Vh && (K.Uh[a] = d, K.Vh++);\n    return d;\n  });\n  so(\"Circle\", function (a, b, c) {\n    a = \"c\" + b + \",\" + c;\n    var d = K.Uh[a];\n    if (void 0 !== d) return d;\n    d = new td(Id);\n    d.endX = b;\n    d.endY = c;\n    d.spot1 = jd;\n    d.spot2 = kd;\n    d.defaultStretch = Ag;\n    50 > K.Vh && (K.Uh[a] = d, K.Vh++);\n    return d;\n  });\n  so(\"TriangleRight\", function (a, b, c) {\n    return new td().add(new he(0, 0).add(new pe(yd, b, .5 * c)).add(new pe(yd, 0, c).close())).Xm(0, .25, .5, .75);\n  });\n  so(\"TriangleDown\", function (a, b, c) {\n    return new td().add(new he(0, 0).add(new pe(yd, b, 0)).add(new pe(yd, .5 * b, c).close())).Xm(.25, 0, .75, .5);\n  });\n  so(\"TriangleLeft\", function (a, b, c) {\n    return new td().add(new he(b, c).add(new pe(yd, 0, .5 * c)).add(new pe(yd, b, 0).close())).Xm(.5, .25, 1, .75);\n  });\n  so(\"TriangleUp\", function (a, b, c) {\n    return new td().add(new he(b, c).add(new pe(yd, 0, c)).add(new pe(yd, .5 * b, 0).close())).Xm(.25, .5, .75, 1);\n  });\n  so(\"Triangle\", \"TriangleUp\");\n  so(\"Diamond\", function (a, b, c) {\n    return new td().add(new he(.5 * b, 0).add(new pe(yd, 0, .5 * c)).add(new pe(yd, .5 * b, c)).add(new pe(yd, b, .5 * c).close())).Xm(.25, .25, .75, .75);\n  });\n  so(\"LineH\", function (a, b, c) {\n    a = new td(wd);\n    a.startX = 0;\n    a.startY = c / 2;\n    a.endX = b;\n    a.endY = c / 2;\n    return a;\n  });\n  so(\"LineV\", function (a, b, c) {\n    a = new td(wd);\n    a.startX = b / 2;\n    a.startY = 0;\n    a.endX = b / 2;\n    a.endY = c;\n    return a;\n  });\n  so(\"None\", \"Rectangle\");\n  so(\"BarH\", \"Rectangle\");\n  so(\"BarV\", \"Rectangle\");\n  so(\"MinusLine\", \"LineH\");\n  so(\"PlusLine\", function (a, b, c) {\n    return new td().add(new he(0, c / 2, !1).add(new pe(yd, b, c / 2)).add(new pe(Xd, b / 2, 0)).add(new pe(yd, b / 2, c)));\n  });\n  so(\"XLine\", function (a, b, c) {\n    return new td().add(new he(0, c, !1).add(new pe(yd, b, 0)).add(new pe(Xd, 0, 0)).add(new pe(yd, b, c)));\n  });\n  K.bn = {\n    \"\": \"\",\n    Standard: \"F1 m 0,0 l 8,4 -8,4 2,-4 z\",\n    Backward: \"F1 m 8,0 l -2,4 2,4 -8,-4 z\",\n    Triangle: \"F1 m 0,0 l 8,4.62 -8,4.62 z\",\n    BackwardTriangle: \"F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z\",\n    Boomerang: \"F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z\",\n    BackwardBoomerang: \"F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z\",\n    SidewaysV: \"m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z\",\n    BackwardV: \"m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z\",\n    OpenTriangle: \"m 0,0 l 8,4 -8,4\",\n    BackwardOpenTriangle: \"m 8,0 l -8,4 8,4\",\n    OpenTriangleLine: \"m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8\",\n    BackwardOpenTriangleLine: \"m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8\",\n    OpenTriangleTop: \"m 0,0 l 8,4 m 0,4\",\n    BackwardOpenTriangleTop: \"m 8,0 l -8,4 m 0,4\",\n    OpenTriangleBottom: \"m 0,8 l 8,-4\",\n    BackwardOpenTriangleBottom: \"m 0,4 l 8,4\",\n    HalfTriangleTop: \"F1 m 0,0 l 0,4 8,0 z m 0,8\",\n    BackwardHalfTriangleTop: \"F1 m 8,0 l 0,4 -8,0 z m 0,8\",\n    HalfTriangleBottom: \"F1 m 0,4 l 0,4 8,-4 z\",\n    BackwardHalfTriangleBottom: \"F1 m 8,4 l 0,4 -8,-4 z\",\n    ForwardSemiCircle: \"m 4,0 b 270 180 0 4 4\",\n    BackwardSemiCircle: \"m 4,8 b 90 180 0 -4 4\",\n    Feather: \"m 0,0 l 3,4 -3,4\",\n    BackwardFeather: \"m 3,0 l -3,4 3,4\",\n    DoubleFeathers: \"m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4\",\n    BackwardDoubleFeathers: \"m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4\",\n    TripleFeathers: \"m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4\",\n    BackwardTripleFeathers: \"m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4\",\n    ForwardSlash: \"m 0,8 l 5,-8\",\n    BackSlash: \"m 0,0 l 5,8\",\n    DoubleForwardSlash: \"m 0,8 l 4,-8 m -2,8 l 4,-8\",\n    DoubleBackSlash: \"m 0,0 l 4,8 m -2,-8 l 4,8\",\n    TripleForwardSlash: \"m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8\",\n    TripleBackSlash: \"m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8\",\n    Fork: \"m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4\",\n    BackwardFork: \"m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4\",\n    LineFork: \"m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4\",\n    BackwardLineFork: \"m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8\",\n    CircleFork: \"F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4\",\n    BackwardCircleFork: \"F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3\",\n    CircleLineFork: \"F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4\",\n    BackwardCircleLineFork: \"F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3\",\n    Circle: \"F1 m 8,4 b 0 360 -4 0 4 z\",\n    Block: \"F1 m 0,0 l 0,8 8,0 0,-8 z\",\n    StretchedDiamond: \"F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z\",\n    Diamond: \"F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z\",\n    Chevron: \"F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z\",\n    StretchedChevron: \"F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z\",\n    NormalArrow: \"F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z\",\n    X: \"m 0,0 l 8,8 m 0,-8 l -8,8\",\n    TailedNormalArrow: \"F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z\",\n    DoubleTriangle: \"F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z\",\n    BigEndArrow: \"F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z\",\n    ConcaveTailArrow: \"F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z\",\n    RoundedTriangle: \"F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z\",\n    SimpleArrow: \"F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z\",\n    AccelerationArrow: \"F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z\",\n    BoxArrow: \"F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z\",\n    TriangleLine: \"F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8\",\n    CircleEndedArrow: \"F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z\",\n    DynamicWidthArrow: \"F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z\",\n    EquilibriumArrow: \"m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3\",\n    FastForward: \"F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z\",\n    Kite: \"F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z\",\n    HalfArrowTop: \"F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8\",\n    HalfArrowBottom: \"F1 m 0,8 l 4,-4 4,0 -8,4 z\",\n    OpposingDirectionDoubleArrow: \"F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z\",\n    PartialDoubleTriangle: \"F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z\",\n    LineCircle: \"F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z\",\n    DoubleLineCircle: \"F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z\",\n    TripleLineCircle: \"F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z\",\n    CircleLine: \"F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8\",\n    DiamondCircle: \"F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z\",\n    PlusCircle: \"F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8\",\n    OpenRightTriangleTop: \"m 8,0 l 0,4 -8,0 m 0,4\",\n    OpenRightTriangleBottom: \"m 8,8 l 0,-4 -8,0\",\n    Line: \"m 0,0 l 0,8\",\n    DoubleLine: \"m 0,0 l 0,8 m 2,0 l 0,-8\",\n    TripleLine: \"m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8\",\n    PentagonArrow: \"F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z\"\n  };\n  function U(a) {\n    X.call(this, a);\n    this.D = 2408959;\n    this.hh = this.Mf = \"\";\n    this.Cp = this.yp = this.Np = this.Do = null;\n    this.Pp = \"\";\n    this.Kf = this.po = this.Op = this.th = null;\n    this.Ap = \"\";\n    this.zp = Sb;\n    this.Tb = this.Dp = \"\";\n    this.Ei = this.zn = this.mi = null;\n    this.dg = new J(NaN, NaN).freeze();\n    this.Ko = \"\";\n    this.bf = null;\n    this.Lo = wc;\n    this.Ep = ad;\n    this.Uo = Ib;\n    this.Mo = Jb;\n    this.Rn = null;\n    this.Eo = 127;\n    this.Tp = Kb;\n    this.Sp = \"gray\";\n    this.jf = 4;\n    this.xx = -1;\n    this.rq = NaN;\n    this.bz = new N();\n    this.Uj = null;\n    this.jh = NaN;\n  }\n  la(U, X);\n  U.prototype.cloneProtected = function (a) {\n    X.prototype.cloneProtected.call(this, a);\n    a.D = this.D & -4097 | 49152;\n    a.Mf = this.Mf;\n    a.hh = this.hh;\n    a.Do = this.Do;\n    a.Np = this.Np;\n    a.yp = this.yp;\n    a.Cp = this.Cp;\n    a.Pp = this.Pp;\n    a.Op = this.Op;\n    a.po = this.po;\n    a.Kf = null;\n    a.Ap = this.Ap;\n    a.zp = this.zp.G();\n    a.Dp = this.Dp;\n    a.Ep = this.Ep.G();\n    a.Tb = this.Tb;\n    a.zn = this.zn;\n    a.dg.assign(this.dg);\n    a.Ko = this.Ko;\n    a.Lo = this.Lo.G();\n    a.Uo = this.Uo.G();\n    a.Mo = this.Mo.G();\n    a.Rn = this.Rn;\n    a.Eo = this.Eo;\n    a.Tp = this.Tp.G();\n    a.Sp = this.Sp;\n    a.jf = this.jf;\n    a.rq = this.rq;\n  };\n  U.prototype.yf = function (a) {\n    X.prototype.yf.call(this, a);\n    a.Oh();\n    a.th = null;\n    a.bf = null;\n    a.Uj = null;\n  };\n  U.prototype.toString = function () {\n    var a = Ia(this.constructor) + \"#\" + mb(this);\n    null !== this.data && (a += \"(\" + Ja(this.data) + \")\");\n    return a;\n  };\n  U.prototype.Jk = function (a, b, c, d, e, f, g) {\n    var h = this.diagram;\n    null !== h && (a === xe && \"elements\" === b ? e instanceof X ? Fj(e, function (a) {\n      Hj(h.partManager, a);\n      Gj(h, a);\n    }) : Yj(h, e) : a === ye && \"elements\" === b && (e instanceof X ? Fj(e, function (a) {\n      Kj(h.partManager, a, h);\n    }) : ak(h, e)), h.ab(a, b, c, d, e, f, g));\n  };\n  U.prototype.Ca = function (a) {\n    X.prototype.Ca.call(this, a);\n    if (null !== this.data) {\n      for (var b = this.W.j, c = b.length, d = 0; d < c; d++) {\n        var e = b[d];\n        e instanceof X && Fj(e, function (a) {\n          null !== a.data && a.Ca();\n        });\n      }\n      for (b = this.adornments; b.next();) b.value.Ca(a);\n    }\n  };\n  U.prototype.updateRelationshipsFromData = function () {\n    null !== this.data && this.diagram.partManager.updateRelationshipsFromData(this);\n  };\n  U.prototype.tk = function (a) {\n    var b = this.Kf;\n    return null === b ? null : b.H(a);\n  };\n  U.prototype.Gh = function (a, b) {\n    if (null !== b) {\n      var c = null,\n        d = this.Kf;\n      null !== d && (c = d.H(a));\n      if (c !== b) {\n        if (null !== c) {\n          var e = c.diagram;\n          null !== e && e.remove(c);\n        }\n        null === d && (this.Kf = d = new H());\n        b.Mf !== a && (b.category = a);\n        d.add(a, b);\n        a = this.diagram;\n        null !== a && (a.add(b), a = b.adornedObject, null !== a && (a = a.ij(), null !== a && (b.data = a.data)));\n      }\n    }\n  };\n  U.prototype.Gf = function (a) {\n    var b = this.Kf;\n    if (null !== b) {\n      var c = b.H(a);\n      if (null !== c) {\n        var d = c.diagram;\n        null !== d && d.remove(c);\n      }\n      b.remove(a);\n      0 === b.count && (this.Kf = null);\n    }\n  };\n  U.prototype.kk = function () {\n    var a = this.Kf;\n    if (null !== a) {\n      var b = Ea();\n      for (a = a.iterator; a.next();) b.push(a.key);\n      a = b.length;\n      for (var c = 0; c < a; c++) this.Gf(b[c]);\n      Ha(b);\n    }\n  };\n  U.prototype.updateAdornments = function () {\n    var a = this.diagram;\n    if (null !== a) {\n      for (var b = this.adornments; b.next();) {\n        var c = b.value;\n        c.o();\n        c.placeholder && c.placeholder.o();\n      }\n      a: {\n        if (this.isSelected && this.selectionAdorned && (b = this.selectionObject, null !== b && this.actualBounds.u() && this.isVisible() && b.Ff() && b.actualBounds.u())) {\n          c = this.tk(\"Selection\");\n          if (null === c) {\n            c = this.selectionAdornmentTemplate;\n            null === c && (c = this.Ph() ? a.linkSelectionAdornmentTemplate : this instanceof vf ? a.groupSelectionAdornmentTemplate : a.nodeSelectionAdornmentTemplate);\n            if (!(c instanceof He)) break a;\n            xg(c);\n            c = c.copy();\n            null !== c && (this.Ph() && this.selectionObject === this.path && (c.type = X.Link), c.adornedObject = b);\n          }\n          if (null !== c) {\n            c.type === X.Link && c.o();\n            this.Gh(\"Selection\", c);\n            break a;\n          }\n        }\n        this.Gf(\"Selection\");\n      }\n      to(this, a);\n      for (b = this.adornments; b.next();) b.value.Ca();\n    }\n  };\n  U.prototype.Lb = function () {\n    var a = this.diagram;\n    null !== a && (Ti(a), 0 !== (this.D & 16384) !== !0 && (this.D |= 16384, a.Db()));\n  };\n  function ji(a) {\n    0 !== (a.D & 16384) !== !1 && (a.updateAdornments(), a.D &= -16385);\n  }\n  function to(a, b) {\n    b.toolManager.mouseDownTools.each(function (b) {\n      b.isEnabled && b.updateAdornments(a);\n    });\n    b.toolManager.updateAdornments(a);\n  }\n  function uo(a) {\n    if (!1 === uj(a)) {\n      vo(a, !0);\n      a.zl();\n      var b = a.diagram;\n      null !== b && (b.rd.add(a), b.Db());\n    }\n  }\n  function wo(a) {\n    a.D |= 2097152;\n    if (!1 !== uj(a)) {\n      var b = a.position,\n        c = a.location;\n      c.u() && b.u() || xo(a, b, c);\n      c = a.xb;\n      var d = N.alloc().assign(c);\n      c.ea();\n      c.x = b.x;\n      c.y = b.y;\n      c.freeze();\n      a.cu(d, c);\n      N.free(d);\n      vo(a, !1);\n    }\n  }\n  U.prototype.move = function (a, b) {\n    !0 === b ? this.location = a : this.position = a;\n  };\n  U.prototype.moveTo = function (a, b, c) {\n    a = J.allocAt(a, b);\n    this.move(a, c);\n    J.free(a);\n  };\n  U.prototype.isVisible = function () {\n    if (!this.visible) return !1;\n    var a = this.layer;\n    if (null !== a) {\n      if (!a.visible) return !1;\n      a = a.diagram;\n      if (null !== a && a.animationManager.bu(this)) return !0;\n    }\n    a = this.containingGroup;\n    return null === a || a.isSubGraphExpanded && a.isVisible() ? !0 : !1;\n  };\n  t = U.prototype;\n  t.Ob = function (a) {\n    var b = this.diagram;\n    a ? (this.C(4), this.Lb(), null !== b && b.rd.add(this)) : (this.C(8), this.kk());\n    this.Oh();\n    null !== b && (b.Oa(), b.M());\n  };\n  t.$a = function (a) {\n    if (this.name === a) return this;\n    var b = this.Uj;\n    null === b && (this.Uj = b = new H());\n    if (null !== b.H(a)) return b.H(a);\n    var c = X.prototype.$a.call(this, a);\n    if (null !== c) return b.set(a, c), c;\n    b.set(a, null);\n    return null;\n  };\n  t.Cf = function (a, b, c) {\n    void 0 === c && (c = new J());\n    b = b.mc() ? Bc : b;\n    var d = a.naturalBounds;\n    c.h(d.width * b.x + b.offsetX, d.height * b.y + b.offsetY);\n    if (null === a || a === this) return c;\n    a.transform.sa(c);\n    for (a = a.panel; null !== a && a !== this;) a.transform.sa(c), a = a.panel;\n    this.cg.sa(c);\n    c.offset(-this.pc.x, -this.pc.y);\n    return c;\n  };\n  t.wm = function (a) {\n    void 0 === a && (a = new N());\n    return a.assign(this.actualBounds);\n  };\n  t.Ta = function () {\n    !0 === sj(this) && this.measure(Infinity, Infinity);\n    this.arrange();\n  };\n  function Dj(a, b) {\n    var c = a.bz;\n    isNaN(a.jh) && (a.jh = en(a));\n    var d = a.jh;\n    var e = 2 * d;\n    if (!a.isShadowed) return c.h(b.x - 1 - d, b.y - 1 - d, b.width + 2 + e, b.height + 2 + e), c;\n    d = b.x;\n    e = b.y;\n    var f = b.width;\n    b = b.height;\n    var g = a.shadowBlur;\n    a = a.shadowOffset;\n    f += g;\n    b += g;\n    d -= g / 2;\n    e -= g / 2;\n    0 < a.x ? f += a.x : (d += a.x, f -= a.x);\n    0 < a.y ? b += a.y : (e += a.y, b -= a.y);\n    c.h(d - 1, e - 1, f + 2, b + 2);\n    return c;\n  }\n  U.prototype.arrange = function () {\n    if (!1 === tj(this)) wo(this);else {\n      ll(this, !1);\n      var a = this.xb,\n        b = N.alloc();\n      b.assign(a);\n      a.ea();\n      var c = vg(this);\n      this.Ih(0, 0, this.pc.width, this.pc.height);\n      var d = this.position;\n      xo(this, d, this.location);\n      a.x = d.x;\n      a.y = d.y;\n      a.freeze();\n      this.cu(b, a);\n      b.w(a) ? this.Fd(c) : !this.Wb() || K.A(b.width, a.width) && K.A(b.height, a.height) || 0 <= this.xx && this.C(16);\n      N.free(b);\n      vo(this, !1);\n    }\n  };\n  t = U.prototype;\n  t.cu = function (a, b) {\n    var c = this.diagram;\n    if (null !== c) {\n      var d = !1;\n      if (!1 === c.ui && a.u()) {\n        var e = N.alloc();\n        e.assign(c.documentBounds);\n        e.Iw(c.padding);\n        a.x > e.x && a.y > e.y && a.right < e.right && a.bottom < e.bottom && b.x > e.x && b.y > e.y && b.right < e.right && b.bottom < e.bottom && (d = !0);\n        N.free(e);\n      }\n      0 !== (this.D & 65536) !== !0 && a.w(b) || Ij(this, d, c);\n      c.M();\n      ac(a, b) || (this instanceof V && !c.undoManager.isUndoingRedoing && this.md(), this.Oh());\n    }\n  };\n  t.Dw = function (a, b) {\n    if (this.Ph() || !a.u()) return !1;\n    var c = this.diagram;\n    null !== c && yo(this, c, a, b);\n    this.la = a;\n    this.D &= -2097153;\n    var d = this.dg;\n    !d.u() || null !== c && !c.animationManager.isTicking && c.undoManager.isUndoingRedoing || (c = d.copy(), d.h(d.x + (a.x - b.x), d.y + (a.y - b.y)), this.g(\"location\", c, d.copy()));\n    !1 === uj(this) && !1 === tj(this) && (uo(this), wo(this));\n    return !0;\n  };\n  function yo(a, b, c, d) {\n    null === b || a instanceof He || (b = b.animationManager, b.df && Nh(b, a, d.copy(), c.copy()));\n  }\n  t.fr = function (a, b, c) {\n    var d = this.dg,\n      e = this.la;\n    if (c) {\n      if (d.x === a && d.y === b) return;\n      uj(this) || tj(this) ? e.h(NaN, NaN) : e.h(e.x + a - d.x, e.y + b - d.y);\n      d.h(a, b);\n    } else {\n      if (e.x === a && e.y === b) return;\n      uj(this) || tj(this) ? this.lu() : d.h(d.x + a - e.x, d.y + b - e.y);\n      e.h(a, b);\n    }\n    uo(this);\n  };\n  t.lu = function () {\n    this.D &= -2097153;\n    uo(this);\n  };\n  function xo(a, b, c) {\n    var d = J.alloc(),\n      e = a.locationSpot,\n      f = a.locationObject;\n    e.mc() && B(\"determineOffset: Part's locationSpot must be real: \" + e.toString());\n    var g = f.naturalBounds,\n      h = f instanceof W ? f.strokeWidth : 0;\n    d.Lk(0, 0, g.width + h, g.height + h, e);\n    if (f !== a) for (d.offset(-h / 2, -h / 2), f.transform.sa(d), e = f.panel; null !== e && e !== a;) e.transform.sa(d), e = e.panel;\n    a.cg.sa(d);\n    d.offset(-a.pc.x, -a.pc.y);\n    e = a.diagram;\n    f = c.u();\n    g = b.u();\n    f && g ? 0 !== (a.D & 2097152) ? zo(a, b, c, e, d) : Ao(a, b, c, e, d) : f ? zo(a, b, c, e, d) : g && Ao(a, b, c, e, d);\n    a.D |= 2097152;\n    J.free(d);\n    a.zl();\n  }\n  function zo(a, b, c, d, e) {\n    var f = b.x,\n      g = b.y;\n    b.h(c.x - e.x, c.y - e.y);\n    null !== d && (c = d.animationManager, (d = c.isAnimating) || !c.df || a instanceof He || Nh(c, a, new J(f, g), b), d || b.x === f && b.y === g || a.g(\"position\", new J(f, g), b.copy()));\n  }\n  function Ao(a, b, c, d, e) {\n    var f = c.copy();\n    c.h(b.x + e.x, b.y + e.y);\n    c.w(f) || null === d || a.g(\"location\", f, c.copy());\n  }\n  function Ij(a, b, c) {\n    nl(a, !1);\n    a instanceof V && zk(c, a);\n    a.layer.isTemporary || b || c.Oa();\n    b = a.xb;\n    var d = c.viewportBounds;\n    d.u() ? vg(a) ? (dc(b, d) || a.Fd(!1), a.updateAdornments()) : b.Lc(d) ? (a.Fd(!0), a.updateAdornments()) : a.Lb() : c.wi = !0;\n  }\n  t.qj = function () {\n    return !0;\n  };\n  t.Wb = function () {\n    return !0;\n  };\n  t.Ph = function () {\n    return !1;\n  };\n  t.Ef = function () {\n    return !0;\n  };\n  function Bo(a, b, c, d) {\n    b.constructor === a.constructor || Co || (Co = !0, wa('Should not change the class of the Part when changing category from \"' + c + '\" to \"' + d + '\"'), wa(\"  Old class: \" + Ia(a.constructor) + \", new class: \" + Ia(b.constructor) + \", part: \" + a.toString()));\n    a.kk();\n    var e = a.data;\n    c = a.layerName;\n    var f = a.isSelected,\n      g = a.isHighlighted,\n      h = !0,\n      k = !0,\n      l = !1;\n    a instanceof V && (h = a.isTreeLeaf, k = a.isTreeExpanded, l = a.wasTreeExpanded);\n    b.yf(a);\n    b.cloneProtected(a);\n    a.Mf = d;\n    a.o();\n    a.M();\n    b = a.diagram;\n    d = !0;\n    null !== b && (d = b.skipsUndoManager, b.skipsUndoManager = !0);\n    a.lb = e;\n    a.D = f ? a.D | 4096 : a.D & -4097;\n    a.D = g ? a.D | 524288 : a.D & -524289;\n    a instanceof V && (a.P = h ? a.P | 4 : a.P & -5, a.P = k ? a.P | 1 : a.P & -2, a.P = l ? a.P | 2 : a.P & -3);\n    null !== e && a.Ca();\n    e = a.layerName;\n    e !== c && (a.hh = c, a.layerName = e);\n    null !== b && (b.skipsUndoManager = d);\n    a.Wb() && a.C(64);\n  }\n  U.prototype.canCopy = function () {\n    if (!this.copyable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowCopy) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowCopy ? !0 : !1;\n  };\n  U.prototype.canDelete = function () {\n    if (!this.deletable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowDelete) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowDelete ? !0 : !1;\n  };\n  U.prototype.canEdit = function () {\n    if (!this.textEditable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowTextEdit) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowTextEdit ? !0 : !1;\n  };\n  U.prototype.canGroup = function () {\n    if (!this.groupable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowGroup) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowGroup ? !0 : !1;\n  };\n  U.prototype.canMove = function () {\n    if (!this.movable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowMove) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowMove ? !0 : !1;\n  };\n  U.prototype.canReshape = function () {\n    if (!this.reshapable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowReshape) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowReshape ? !0 : !1;\n  };\n  U.prototype.canResize = function () {\n    if (!this.resizable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowResize) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowResize ? !0 : !1;\n  };\n  U.prototype.canRotate = function () {\n    if (!this.rotatable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowRotate) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowRotate ? !0 : !1;\n  };\n  U.prototype.canSelect = function () {\n    if (!this.selectable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowSelect) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowSelect ? !0 : !1;\n  };\n  function uj(a) {\n    return 0 !== (a.D & 32768);\n  }\n  function vo(a, b) {\n    a.D = b ? a.D | 32768 : a.D & -32769;\n  }\n  function nl(a, b) {\n    a.D = b ? a.D | 65536 : a.D & -65537;\n  }\n  function vg(a) {\n    return 0 !== (a.D & 131072);\n  }\n  t = U.prototype;\n  t.Fd = function (a) {\n    this.D = a ? this.D | 131072 : this.D & -131073;\n  };\n  function Do(a, b) {\n    a.D = b ? a.D | 1048576 : a.D & -1048577;\n  }\n  t.Oh = function () {\n    var a = this.containingGroup;\n    null !== a && (a.o(), null !== a.placeholder && a.placeholder.o(), a.md());\n  };\n  t.M = function () {\n    var a = this.diagram;\n    null !== a && !tj(this) && !uj(this) && this.isVisible() && this.xb.u() && a.M(Dj(this, this.xb));\n  };\n  t.o = function () {\n    X.prototype.o.call(this);\n    var a = this.diagram;\n    null !== a && (a.rd.add(this), this instanceof V && null !== this.labeledLink && Cl(this.labeledLink), a.Db(!0));\n  };\n  t.Kq = function (a) {\n    a || (a = this.mi, null !== a && Eo(a, this));\n  };\n  t.Lq = function (a) {\n    a || (a = this.mi, null !== a && Fo(a, this));\n  };\n  t.rk = function () {\n    var a = this.data;\n    if (null !== a) {\n      var b = this.diagram;\n      null !== b && (b = b.model, null !== b && b.Mm(a));\n    }\n  };\n  t.Xz = function () {\n    return Go(this, this);\n  };\n  function Go(a, b) {\n    var c = b.containingGroup;\n    return null !== c ? 1 + Go(a, c) : b instanceof V && (b = b.labeledLink, null !== b) ? Go(a, b) : 0;\n  }\n  t.$z = function () {\n    return Ho(this, this);\n  };\n  function Ho(a, b) {\n    var c = b.containingGroup;\n    return null !== c || b instanceof V && (c = b.labeledLink, null !== c) ? Ho(a, c) : b;\n  }\n  t.Cd = function (a) {\n    return a instanceof vf ? Io(this, this, a) : !1;\n  };\n  function Io(a, b, c) {\n    if (b === c || null === c) return !1;\n    var d = b.containingGroup;\n    return null === d || d !== c && !Io(a, d, c) ? b instanceof V && (b = b.labeledLink, null !== b) ? Io(a, b, c) : !1 : !0;\n  }\n  t.ly = function (a) {\n    if (null === a) return null;\n    if (this === a) return this.containingGroup;\n    for (var b = this; null !== b;) {\n      b instanceof vf && Do(b, !0);\n      if (b instanceof V) {\n        var c = b.labeledLink;\n        null !== c && (b = c);\n      }\n      b = b.containingGroup;\n    }\n    c = null;\n    for (b = a; null !== b;) {\n      if (0 !== (b.D & 1048576)) {\n        c = b;\n        break;\n      }\n      b instanceof V && (a = b.labeledLink, null !== a && (b = a));\n      b = b.containingGroup;\n    }\n    for (b = this; null !== b;) b instanceof vf && Do(b, !1), b instanceof V && (a = b.labeledLink, null !== a && (b = a)), b = b.containingGroup;\n    return c;\n  };\n  U.prototype.canLayout = function () {\n    if (!this.isLayoutPositioned || !this.isVisible()) return !1;\n    var a = this.layer;\n    return null !== a && a.isTemporary || this instanceof V && this.isLinkLabel ? !1 : !0;\n  };\n  U.prototype.C = function (a) {\n    void 0 === a && (a = 16777215);\n    if (this.isLayoutPositioned && 0 !== (a & this.layoutConditions)) {\n      var b = this.layer;\n      null !== b && b.isTemporary || this instanceof V && this.isLinkLabel ? b = !1 : (b = this.diagram, b = null !== b && b.undoManager.isUndoingRedoing ? !1 : !0);\n    } else b = !1;\n    if (b) if (b = this.mi, null !== b) {\n      var c = b.layout;\n      null !== c ? c.C() : b.C(a);\n    } else a = this.diagram, null !== a && (a = a.layout, null !== a && a.C());\n  };\n  function Jj(a) {\n    if (!a.isVisible()) return !1;\n    a = a.layer;\n    return null !== a && a.isTemporary ? !1 : !0;\n  }\n  function Sk(a, b, c, d, e, f) {\n    void 0 === f && (f = null);\n    if (!(a.contains(b) || null !== f && !f(b) || b instanceof He)) if (a.add(b), b instanceof V) {\n      if (c && b instanceof vf) for (var g = b.memberParts; g.next();) Sk(a, g.value, c, d, e, f);\n      if (!1 !== e) for (g = b.linksConnected; g.next();) {\n        var h = g.value;\n        if (!a.contains(h)) {\n          var k = h.fromNode,\n            l = h.toNode;\n          k = null === k || a.contains(k);\n          l = null === l || a.contains(l);\n          (e ? k && l : k || l) && Sk(a, h, c, d, e, f);\n        }\n      }\n      if (1 < d) for (b = b.Vv(); b.next();) Sk(a, b.value, c, d - 1, e, f);\n    } else if (b instanceof S) for (b = b.labelNodes; b.next();) Sk(a, b.value, c, d, e, f);\n  }\n  ma.Object.defineProperties(U.prototype, {\n    key: {\n      get: function () {\n        var a = this.diagram;\n        if (null !== a) return a.model.ja(this.data);\n      }\n    },\n    adornments: {\n      get: function () {\n        return null === this.Kf ? gb : this.Kf.iteratorValues;\n      }\n    },\n    layer: {\n      get: function () {\n        return this.Ei;\n      }\n    },\n    diagram: {\n      get: function () {\n        var a = this.Ei;\n        return null !== a ? a.diagram : null;\n      }\n    },\n    layerName: {\n      get: function () {\n        return this.hh;\n      },\n      set: function (a) {\n        var b = this.hh;\n        if (b !== a) {\n          var c = this.diagram;\n          if (null === c || null !== c.tm(a) && !c.partManager.addsToTemporaryLayer) if (this.hh = a, null !== c && c.Oa(), this.g(\"layerName\", b, a), b = this.layer, null !== b && b.name !== a && (c = b.diagram, null !== c && (a = c.tm(a), null !== a && a !== b))) {\n            var d = b.Kc(-1, this, !0);\n            0 <= d && c.ab(ye, \"parts\", b, this, null, d, !0);\n            d = a.nj(99999999, this, !0);\n            b.visible !== a.visible && this.Ob(a.visible);\n            0 <= d && c.ab(xe, \"parts\", a, null, this, !0, d);\n            d = this.layerChanged;\n            if (null !== d) {\n              var e = c.Z;\n              c.Z = !0;\n              d(this, b, a);\n              c.Z = e;\n            }\n          }\n        }\n      }\n    },\n    layerChanged: {\n      get: function () {\n        return this.Do;\n      },\n      set: function (a) {\n        var b = this.Do;\n        b !== a && (this.Do = a, this.g(\"layerChanged\", b, a));\n      }\n    },\n    zOrder: {\n      get: function () {\n        return this.rq;\n      },\n      set: function (a) {\n        var b = this.rq;\n        if (b !== a) {\n          this.rq = a;\n          var c = this.layer;\n          null !== c && mi(c, -1, this);\n          this.g(\"zOrder\", b, a);\n          a = this.diagram;\n          null !== a && a.M();\n        }\n      }\n    },\n    locationObject: {\n      get: function () {\n        if (null === this.bf) {\n          var a = this.locationObjectName;\n          \"\" !== a ? (a = this.$a(a), null !== a ? this.bf = a : this.bf = this) : this instanceof He ? this.type !== X.Link && null !== this.placeholder ? this.bf = this.placeholder : this.bf = this : this.bf = this;\n        }\n        return this.bf.visible ? this.bf : this;\n      }\n    },\n    minLocation: {\n      get: function () {\n        return this.Uo;\n      },\n      set: function (a) {\n        var b = this.Uo;\n        b.w(a) || (this.Uo = a = a.G(), this.g(\"minLocation\", b, a));\n      }\n    },\n    maxLocation: {\n      get: function () {\n        return this.Mo;\n      },\n      set: function (a) {\n        var b = this.Mo;\n        b.w(a) || (this.Mo = a = a.G(), this.g(\"maxLocation\", b, a));\n      }\n    },\n    locationObjectName: {\n      get: function () {\n        return this.Ko;\n      },\n      set: function (a) {\n        var b = this.Ko;\n        b !== a && (this.Ko = a, this.bf = null, this.o(), this.g(\"locationObjectName\", b, a));\n      }\n    },\n    locationSpot: {\n      get: function () {\n        return this.Lo;\n      },\n      set: function (a) {\n        var b = this.Lo;\n        b.w(a) || (this.Lo = a = a.G(), this.o(), this.g(\"locationSpot\", b, a));\n      }\n    },\n    location: {\n      get: function () {\n        return this.dg;\n      },\n      set: function (a) {\n        var b = a.x,\n          c = a.y,\n          d = this.dg,\n          e = d.x,\n          f = d.y;\n        (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (a = a.copy(), b = a, this.Ph() ? b = !1 : (this.dg = b, this.D |= 2097152, !1 === tj(this) && (uo(this), c = this.la, c.u() && (e = this.diagram, null === e || e.animationManager.isTicking || !e.undoManager.isUndoingRedoing)) && (f = c.copy(), c.h(c.x + (b.x - d.x), c.y + (b.y - d.y)), yo(this, e, c, f), this.g(\"position\", f, c.copy())), b = !0), b && this.g(\"location\", d.copy(), a.copy()));\n      }\n    },\n    category: {\n      get: function () {\n        return this.Mf;\n      },\n      set: function (a) {\n        var b = this.Mf;\n        if (b !== a) {\n          var c = this.diagram,\n            d = this.data,\n            e = null;\n          if (null !== c && null !== d && !(this instanceof He)) {\n            var f = c.model.undoManager;\n            f.isEnabled && !f.isUndoingRedoing && (e = this.clone(), e.W.addAll(this.W));\n          }\n          this.Mf = a;\n          this.g(\"category\", b, a);\n          null === c || null === d || this instanceof He ? this instanceof He && (e = this.adornedPart, null !== e && (a = e.Kf, null !== a && a.remove(b), e.Gh(this.category, this))) : (f = c.model, f.undoManager.isUndoingRedoing || (this.Ph() ? (c.partManager.setLinkCategoryForData(d, a), c = c.partManager.findLinkTemplateForCategory(a), null !== c && (xg(c), c = c.copy(), null !== c && Bo(this, c, b, a))) : (null !== f && f.Tm(d, a), c = Jo(c.partManager, d, a), null !== c && (xg(c), c = c.copy(), null === c || c instanceof S || (d = this.location.copy(), Bo(this, c, b, a), this.location.u() || (this.location = d)))), null !== e && (b = this.clone(), b.W.addAll(this.W), this.g(\"self\", e, b))));\n        }\n      }\n    },\n    self: {\n      get: function () {\n        return this;\n      },\n      set: function (a) {\n        Bo(this, a, this.category, a.category);\n      }\n    },\n    copyable: {\n      get: function () {\n        return 0 !== (this.D & 1);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 1);\n        b !== a && (this.D ^= 1, this.g(\"copyable\", b, a));\n      }\n    },\n    deletable: {\n      get: function () {\n        return 0 !== (this.D & 2);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 2);\n        b !== a && (this.D ^= 2, this.g(\"deletable\", b, a));\n      }\n    },\n    textEditable: {\n      get: function () {\n        return 0 !== (this.D & 4);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 4);\n        b !== a && (this.D ^= 4, this.g(\"textEditable\", b, a), this.Lb());\n      }\n    },\n    groupable: {\n      get: function () {\n        return 0 !== (this.D & 8);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 8);\n        b !== a && (this.D ^= 8, this.g(\"groupable\", b, a));\n      }\n    },\n    movable: {\n      get: function () {\n        return 0 !== (this.D & 16);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 16);\n        b !== a && (this.D ^= 16, this.g(\"movable\", b, a));\n      }\n    },\n    selectionAdorned: {\n      get: function () {\n        return 0 !== (this.D & 32);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 32);\n        b !== a && (this.D ^= 32, this.g(\"selectionAdorned\", b, a), this.Lb());\n      }\n    },\n    isInDocumentBounds: {\n      get: function () {\n        return 0 !== (this.D & 64);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 64);\n        if (b !== a) {\n          this.D ^= 64;\n          var c = this.diagram;\n          null !== c && c.Oa();\n          this.g(\"isInDocumentBounds\", b, a);\n        }\n      }\n    },\n    isLayoutPositioned: {\n      get: function () {\n        return 0 !== (this.D & 128);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 128);\n        b !== a && (this.D ^= 128, this.g(\"isLayoutPositioned\", b, a), this.C(a ? 4 : 8));\n      }\n    },\n    selectable: {\n      get: function () {\n        return 0 !== (this.D & 256);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 256);\n        b !== a && (this.D ^= 256, this.g(\"selectable\", b, a), this.Lb());\n      }\n    },\n    reshapable: {\n      get: function () {\n        return 0 !== (this.D & 512);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 512);\n        b !== a && (this.D ^= 512, this.g(\"reshapable\", b, a), this.Lb());\n      }\n    },\n    resizable: {\n      get: function () {\n        return 0 !== (this.D & 1024);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 1024);\n        b !== a && (this.D ^= 1024, this.g(\"resizable\", b, a), this.Lb());\n      }\n    },\n    rotatable: {\n      get: function () {\n        return 0 !== (this.D & 2048);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 2048);\n        b !== a && (this.D ^= 2048, this.g(\"rotatable\", b, a), this.Lb());\n      }\n    },\n    isSelected: {\n      get: function () {\n        return 0 !== (this.D & 4096);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 4096);\n        if (b !== a) {\n          var c = this.diagram;\n          if (!a || this.canSelect() && !(null !== c && c.selection.count >= c.maxSelectionCount)) {\n            this.D ^= 4096;\n            var d = !1;\n            if (null !== c) {\n              d = c.skipsUndoManager;\n              c.skipsUndoManager = !0;\n              var e = c.selection;\n              e.ea();\n              a ? e.add(this) : e.remove(this);\n              e.freeze();\n            }\n            this.g(\"isSelected\", b, a);\n            this.Lb();\n            a = this.selectionChanged;\n            null !== a && a(this);\n            null !== c && (c.Db(), c.skipsUndoManager = d);\n          }\n        }\n      }\n    },\n    isHighlighted: {\n      get: function () {\n        return 0 !== (this.D & 524288);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 524288);\n        if (b !== a) {\n          this.D ^= 524288;\n          var c = this.diagram;\n          null !== c && (c = c.highlighteds, c.ea(), a ? c.add(this) : c.remove(this), c.freeze());\n          this.g(\"isHighlighted\", b, a);\n          this.M();\n          a = this.highlightedChanged;\n          null !== a && a(this);\n        }\n      }\n    },\n    isShadowed: {\n      get: function () {\n        return 0 !== (this.D & 8192);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 8192);\n        b !== a && (this.D ^= 8192, this.g(\"isShadowed\", b, a), this.M());\n      }\n    },\n    isAnimated: {\n      get: function () {\n        return 0 !== (this.D & 262144);\n      },\n      set: function (a) {\n        var b = 0 !== (this.D & 262144);\n        b !== a && (this.D ^= 262144, this.g(\"isAnimated\", b, a));\n      }\n    },\n    highlightedChanged: {\n      get: function () {\n        return this.po;\n      },\n      set: function (a) {\n        var b = this.po;\n        b !== a && (this.po = a, this.g(\"highlightedChanged\", b, a));\n      }\n    },\n    selectionObjectName: {\n      get: function () {\n        return this.Pp;\n      },\n      set: function (a) {\n        var b = this.Pp;\n        b !== a && (this.Pp = a, this.th = null, this.g(\"selectionObjectName\", b, a));\n      }\n    },\n    selectionAdornmentTemplate: {\n      get: function () {\n        return this.Np;\n      },\n      set: function (a) {\n        var b = this.Np;\n        b !== a && (this.Np = a, this.g(\"selectionAdornmentTemplate\", b, a));\n      }\n    },\n    selectionObject: {\n      get: function () {\n        if (null === this.th) {\n          var a = this.selectionObjectName;\n          null !== a && \"\" !== a ? (a = this.$a(a), null !== a ? this.th = a : this.th = this) : this instanceof S ? (a = this.path, null !== a ? this.th = a : this.th = this) : this.th = this;\n        }\n        return this.th;\n      }\n    },\n    selectionChanged: {\n      get: function () {\n        return this.Op;\n      },\n      set: function (a) {\n        var b = this.Op;\n        b !== a && (this.Op = a, this.g(\"selectionChanged\", b, a));\n      }\n    },\n    resizeAdornmentTemplate: {\n      get: function () {\n        return this.yp;\n      },\n      set: function (a) {\n        var b = this.yp;\n        b !== a && (this.yp = a, this.g(\"resizeAdornmentTemplate\", b, a));\n      }\n    },\n    resizeObjectName: {\n      get: function () {\n        return this.Ap;\n      },\n      set: function (a) {\n        var b = this.Ap;\n        b !== a && (this.Ap = a, this.g(\"resizeObjectName\", b, a));\n      }\n    },\n    resizeObject: {\n      get: function () {\n        var a = this.resizeObjectName;\n        return \"\" !== a && (a = this.$a(a), null !== a) ? a : this;\n      }\n    },\n    resizeCellSize: {\n      get: function () {\n        return this.zp;\n      },\n      set: function (a) {\n        var b = this.zp;\n        b.w(a) || (this.zp = a = a.G(), this.g(\"resizeCellSize\", b, a));\n      }\n    },\n    rotateAdornmentTemplate: {\n      get: function () {\n        return this.Cp;\n      },\n      set: function (a) {\n        var b = this.Cp;\n        b !== a && (this.Cp = a, this.g(\"rotateAdornmentTemplate\", b, a));\n      }\n    },\n    rotateObjectName: {\n      get: function () {\n        return this.Dp;\n      },\n      set: function (a) {\n        var b = this.Dp;\n        b !== a && (this.Dp = a, this.g(\"rotateObjectName\", b, a));\n      }\n    },\n    rotateObject: {\n      get: function () {\n        var a = this.rotateObjectName;\n        return \"\" !== a && (a = this.$a(a), null !== a) ? a : this;\n      }\n    },\n    rotationSpot: {\n      get: function () {\n        return this.Ep;\n      },\n      set: function (a) {\n        var b = this.Ep;\n        b.w(a) || (this.Ep = a = a.G(), this.g(\"rotationSpot\", b, a));\n      }\n    },\n    text: {\n      get: function () {\n        return this.Tb;\n      },\n      set: function (a) {\n        var b = this.Tb;\n        b !== a && (this.Tb = a, this.g(\"text\", b, a));\n      }\n    },\n    containingGroup: {\n      get: function () {\n        return this.mi;\n      },\n      set: function (a) {\n        if (this.Wb()) {\n          var b = this.mi;\n          if (b !== a) {\n            null === a || this !== a && !a.Cd(this) || (this === a && B(\"Cannot make a Group a member of itself: \" + this.toString()), B(\"Cannot make a Group indirectly contain itself: \" + this.toString() + \" already contains \" + a.toString()));\n            this.C(2);\n            var c = this.diagram;\n            null !== b ? Fo(b, this) : this instanceof vf && null !== c && c.Dh.remove(this);\n            this.mi = a;\n            null !== a ? Eo(a, this) : this instanceof vf && null !== c && c.Dh.add(this);\n            this.C(1);\n            if (null !== c && c.Z) {\n              var d = this.data,\n                e = c.model;\n              if (null !== d && e.yk()) {\n                var f = e.ja(null !== a ? a.data : null);\n                e.er(d, f);\n              }\n            }\n            d = this.containingGroupChanged;\n            null !== d && (e = !0, null !== c && (e = c.Z, c.Z = !0), d(this, b, a), null !== c && (c.Z = e));\n            if (this instanceof vf) for (c = new F(), Sk(c, this, !0, 0, !0), c = c.iterator; c.next();) if (d = c.value, d instanceof V) for (d = d.linksConnected; d.next();) Ko(d.value);\n            if (this instanceof V) {\n              for (c = this.linksConnected; c.next();) Ko(c.value);\n              c = this.labeledLink;\n              null !== c && Ko(c);\n            }\n            this.g(\"containingGroup\", b, a);\n            null !== a && (b = a.layer, null !== b && mi(b, -1, a));\n          }\n        } else B(\"cannot set the Part.containingGroup of a Link or Adornment\");\n      }\n    },\n    containingGroupChanged: {\n      get: function () {\n        return this.zn;\n      },\n      set: function (a) {\n        var b = this.zn;\n        b !== a && (this.zn = a, this.g(\"containingGroupChanged\", b, a));\n      }\n    },\n    isTopLevel: {\n      get: function () {\n        return null !== this.containingGroup || this instanceof V && null !== this.labeledLink ? !1 : !0;\n      }\n    },\n    layoutConditions: {\n      get: function () {\n        return this.Eo;\n      },\n      set: function (a) {\n        var b = this.Eo;\n        b !== a && (this.Eo = a, this.g(\"layoutConditions\", b, a));\n      }\n    },\n    dragComputation: {\n      get: function () {\n        return this.Rn;\n      },\n      set: function (a) {\n        var b = this.Rn;\n        b !== a && (this.Rn = a, this.g(\"dragComputation\", b, a));\n      }\n    },\n    shadowOffset: {\n      get: function () {\n        return this.Tp;\n      },\n      set: function (a) {\n        var b = this.Tp;\n        b.w(a) || (this.Tp = a = a.G(), this.M(), this.g(\"shadowOffset\", b, a));\n      }\n    },\n    shadowColor: {\n      get: function () {\n        return this.Sp;\n      },\n      set: function (a) {\n        var b = this.Sp;\n        b !== a && (this.Sp = a, this.M(), this.g(\"shadowColor\", b, a));\n      }\n    },\n    shadowBlur: {\n      get: function () {\n        return this.jf;\n      },\n      set: function (a) {\n        var b = this.jf;\n        b !== a && (this.jf = a, this.M(), this.g(\"shadowBlur\", b, a));\n      }\n    }\n  });\n  U.prototype.invalidateLayout = U.prototype.C;\n  U.prototype.findCommonContainingGroup = U.prototype.ly;\n  U.prototype.isMemberOf = U.prototype.Cd;\n  U.prototype.findTopLevelPart = U.prototype.$z;\n  U.prototype.findSubGraphLevel = U.prototype.Xz;\n  U.prototype.ensureBounds = U.prototype.Ta;\n  U.prototype.getDocumentBounds = U.prototype.wm;\n  U.prototype.getRelativePoint = U.prototype.Cf;\n  U.prototype.findObject = U.prototype.$a;\n  U.prototype.moveTo = U.prototype.moveTo;\n  U.prototype.invalidateAdornments = U.prototype.Lb;\n  U.prototype.clearAdornments = U.prototype.kk;\n  U.prototype.removeAdornment = U.prototype.Gf;\n  U.prototype.addAdornment = U.prototype.Gh;\n  U.prototype.findAdornment = U.prototype.tk;\n  U.prototype.updateTargetBindings = U.prototype.Ca;\n  var Co = !1;\n  U.className = \"Part\";\n  U.LayoutNone = 0;\n  U.LayoutAdded = 1;\n  U.LayoutRemoved = 2;\n  U.LayoutShown = 4;\n  U.LayoutHidden = 8;\n  U.LayoutNodeSized = 16;\n  U.LayoutGroupLayout = 32;\n  U.LayoutNodeReplaced = 64;\n  U.LayoutStandard = 127;\n  U.LayoutAll = 16777215;\n  function He(a) {\n    U.call(this, a);\n    this.D &= -257;\n    this.hh = \"Adornment\";\n    this.ee = null;\n    this.Bx = 0;\n    this.Qx = !1;\n    this.l = [];\n    this.Ra = null;\n  }\n  la(He, U);\n  He.prototype.toString = function () {\n    var a = this.adornedPart;\n    return \"Adornment(\" + this.category + \")\" + (null !== a ? a.toString() : \"\");\n  };\n  He.prototype.updateRelationshipsFromData = function () {};\n  He.prototype.Bk = function (a) {\n    var b = this.adornedObject.part;\n    if (b instanceof S && this.adornedObject instanceof W) {\n      var c = b.path;\n      b.Bk(a);\n      a = c.geometry;\n      b = this.W.j;\n      c = b.length;\n      for (var d = 0; d < c; d++) {\n        var e = b[d];\n        e.isPanelMain && e instanceof W && (e.na = a);\n      }\n    }\n  };\n  He.prototype.qj = function () {\n    var a = this.ee;\n    if (null === a) return !0;\n    a = a.part;\n    return null === a || !tj(a);\n  };\n  He.prototype.Wb = function () {\n    return !1;\n  };\n  He.prototype.Jk = function (a, b, c, d, e, f, g) {\n    if (a === xe && \"elements\" === b) {\n      if (e instanceof wg) null === this.Ra && (this.Ra = e);else {\n        if (e instanceof X) {\n          var h = e.sm(function (a) {\n            return a instanceof wg;\n          });\n          h instanceof wg && null === this.Ra && (this.Ra = h);\n        }\n      }\n    } else a === ye && \"elements\" === b && null !== this.Ra && (d === this.Ra ? this.Ra = null : d instanceof X && this.Ra.Gg(d) && (this.Ra = null));\n    U.prototype.Jk.call(this, a, b, c, d, e, f, g);\n  };\n  He.prototype.updateAdornments = function () {};\n  He.prototype.rk = function () {};\n  ma.Object.defineProperties(He.prototype, {\n    placeholder: {\n      get: function () {\n        return this.Ra;\n      }\n    },\n    adornedObject: {\n      get: function () {\n        return this.ee;\n      },\n      set: function (a) {\n        var b = this.adornedPart,\n          c = null;\n        null !== a && (c = a.part);\n        null === b || null !== a && b === c || b.Gf(this.category);\n        this.ee = a;\n        null !== c && c.Gh(this.category, this);\n      }\n    },\n    adornedPart: {\n      get: function () {\n        var a = this.ee;\n        return null !== a ? a.part : null;\n      }\n    },\n    containingGroup: {\n      get: function () {\n        return null;\n      }\n    }\n  });\n  He.className = \"Adornment\";\n  function V(a) {\n    U.call(this, a);\n    this.P = 13;\n    this.Ya = new E();\n    this.lq = this.El = this.Hi = this.Go = this.Fo = null;\n    this.Wk = uc;\n    this.sc = this.Re = null;\n    this.vp = Lo;\n    this.Eh = !1;\n  }\n  la(V, U);\n  V.prototype.cloneProtected = function (a) {\n    U.prototype.cloneProtected.call(this, a);\n    a.P = this.P;\n    a.P = this.P & -17;\n    a.Fo = this.Fo;\n    a.Go = this.Go;\n    a.Hi = this.Hi;\n    a.lq = this.lq;\n    a.Wk = this.Wk.G();\n    a.vp = this.vp;\n  };\n  t = V.prototype;\n  t.yf = function (a) {\n    U.prototype.yf.call(this, a);\n    a.md();\n    a.Re = this.Re;\n    a.sc = null;\n  };\n  function Mo(a, b) {\n    null !== b && (null === a.Re && (a.Re = new F()), a.Re.add(b));\n  }\n  function No(a, b, c, d) {\n    if (null === b || null === a.Re) return null;\n    for (var e = a.Re.iterator; e.next();) {\n      var f = e.value;\n      if (f.$t === a && f.jw === b && f.Jy === c && f.Ky === d || f.$t === b && f.jw === a && f.Jy === d && f.Ky === c) return f;\n    }\n    return null;\n  }\n  t.tA = function (a, b, c) {\n    if (void 0 === b || null === b) b = \"\";\n    if (void 0 === c || null === c) c = \"\";\n    a = No(this, a, b, c);\n    null !== a && a.ym();\n  };\n  t.Jk = function (a, b, c, d, e, f, g) {\n    a === xe && \"elements\" === b ? this.sc = null : a === ye && \"elements\" === b && (this.sc = null);\n    U.prototype.Jk.call(this, a, b, c, d, e, f, g);\n  };\n  t.md = function (a) {\n    void 0 === a && (a = null);\n    for (var b = this.linksConnected; b.next();) {\n      var c = b.value;\n      null !== a && a.contains(c) || (Oo(this, c.fromPort), Oo(this, c.toPort), c.Ua());\n    }\n  };\n  function ol(a, b) {\n    for (var c = a.linksConnected; c.next();) {\n      var d = c.value;\n      if (d.fromPort === b || d.toPort === b) Oo(a, d.fromPort), Oo(a, d.toPort), d.Ua();\n    }\n  }\n  function Oo(a, b) {\n    null !== b && (b = b.tp, null !== b && b.ym(), b = a.containingGroup, null === b || a.isVisible() || Oo(b, b.port));\n  }\n  t.qj = function () {\n    return !0;\n  };\n  V.prototype.getAvoidableRect = function (a) {\n    a.set(this.actualBounds);\n    a.sq(this.Wk);\n    return a;\n  };\n  V.prototype.findVisibleNode = function () {\n    for (var a = this; null !== a && !a.isVisible();) a = a.containingGroup;\n    return a;\n  };\n  V.prototype.isVisible = function () {\n    if (!U.prototype.isVisible.call(this)) return !1;\n    var a = !0,\n      b = ri,\n      c = this.diagram;\n    if (null !== c) {\n      if (c.animationManager.bu(this)) return !0;\n      a = c.isTreePathToChildren;\n      b = c.treeCollapsePolicy;\n    }\n    if (b === ri) {\n      if (a = this.Fg(), null !== a && !a.isTreeExpanded) return !1;\n    } else if (b === Fk) {\n      if (a = a ? this.Sv() : this.Tv(), 0 < a.count && a.all(function (a) {\n        return !a.isTreeExpanded;\n      })) return !1;\n    } else if (b === Gk && (a = a ? this.Sv() : this.Tv(), 0 < a.count && a.any(function (a) {\n      return !a.isTreeExpanded;\n    }))) return !1;\n    a = this.labeledLink;\n    return null !== a ? a.isVisible() : !0;\n  };\n  V.prototype.Ob = function (a) {\n    U.prototype.Ob.call(this, a);\n    for (var b = this.linksConnected; b.next();) {\n      var c = b.value;\n      if (a && null !== this.containingGroup) {\n        var d = c.Iq(this);\n        null === d || d.Cd(this.containingGroup) || c.Ua();\n      }\n      c.Ob(a);\n    }\n  };\n  V.prototype.my = function () {\n    var a = new F(),\n      b = new F();\n    Po(this, this, a, b);\n    return b.iterator;\n  };\n  function Po(a, b, c, d) {\n    if (null !== b && !c.has(b)) {\n      c.add(b);\n      var e = !0,\n        f = a.diagram;\n      null !== f && (e = f.isTreePathToChildren);\n      b.linksConnected.each(function (f) {\n        f.isTreeLink ? (e ? f.fromNode === b : f.toNode === b) && Po(a, e ? f.toNode : f.fromNode, c, d) : d.add(f);\n      });\n    }\n  }\n  V.prototype.findLinksConnected = function (a) {\n    void 0 === a && (a = null);\n    if (null === a) return this.Ya.iterator;\n    var b = new ib(this.Ya),\n      c = this;\n    b.predicate = function (b) {\n      return b.fromNode === c && b.fromPortId === a || b.toNode === c && b.toPortId === a;\n    };\n    return b;\n  };\n  t = V.prototype;\n  t.Dq = function (a) {\n    void 0 === a && (a = null);\n    var b = new ib(this.Ya),\n      c = this;\n    b.predicate = function (b) {\n      return b.fromNode !== c ? !1 : null === a ? !0 : b.fromPortId === a;\n    };\n    return b;\n  };\n  t.Bd = function (a) {\n    void 0 === a && (a = null);\n    var b = new ib(this.Ya),\n      c = this;\n    b.predicate = function (b) {\n      return b.toNode !== c ? !1 : null === a ? !0 : b.toPortId === a;\n    };\n    return b;\n  };\n  t.Rv = function (a) {\n    void 0 === a && (a = null);\n    for (var b = null, c = null, d = this.Ya.iterator; d.next();) {\n      var e = d.value;\n      if (e.fromNode === this) {\n        if (null === a || e.fromPortId === a) e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new F(), b.add(c), b.add(e)) : c = e;\n      } else e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new F(), b.add(c), b.add(e)) : c = e);\n    }\n    return null !== b ? b.iterator : null !== c ? new hb(c) : gb;\n  };\n  t.Tv = function (a) {\n    void 0 === a && (a = null);\n    for (var b = null, c = null, d = this.Ya.iterator; d.next();) {\n      var e = d.value;\n      e.fromNode !== this || null !== a && e.fromPortId !== a || (e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new F(), b.add(c), b.add(e)) : c = e);\n    }\n    return null !== b ? b.iterator : null !== c ? new hb(c) : gb;\n  };\n  t.Sv = function (a) {\n    void 0 === a && (a = null);\n    for (var b = null, c = null, d = this.Ya.iterator; d.next();) {\n      var e = d.value;\n      e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new F(), b.add(c), b.add(e)) : c = e);\n    }\n    return null !== b ? b.iterator : null !== c ? new hb(c) : gb;\n  };\n  t.Sz = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var d = new ib(this.Ya),\n      e = this;\n    d.predicate = function (d) {\n      return (d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c) && (d.fromNode !== a || d.toNode !== e || null !== c && d.fromPortId !== c || null !== b && d.toPortId !== b) ? !1 : !0;\n    };\n    return d;\n  };\n  t.Tz = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var d = new ib(this.Ya),\n      e = this;\n    d.predicate = function (d) {\n      return d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c ? !1 : !0;\n    };\n    return d;\n  };\n  function Qo(a, b, c) {\n    Oo(a, c);\n    var d = a.Ya.contains(b);\n    d || a.Ya.add(b);\n    if (!d || b.fromNode === b.toNode) {\n      var e = a.linkConnected;\n      if (null !== e) {\n        var f = !0,\n          g = a.diagram;\n        null !== g && (f = g.Z, g.Z = !0);\n        e(a, b, c);\n        null !== g && (g.Z = f);\n      }\n    }\n    !d && b.isTreeLink && (c = b.fromNode, b = b.toNode, null !== c && null !== b && c !== b && (d = !0, a = a.diagram, null !== a && (d = a.isTreePathToChildren), e = d ? b : c, f = d ? c : b, e.Eh || (e.Eh = f), !f.isTreeLeaf || null !== a && a.undoManager.isUndoingRedoing || (d ? c === f && (f.isTreeLeaf = !1) : b === f && (f.isTreeLeaf = !1))));\n  }\n  function Ro(a, b, c) {\n    Oo(a, c);\n    var d = a.Ya.remove(b),\n      e = null;\n    if (d || b.toNode === b.fromNode) {\n      var f = a.linkDisconnected;\n      e = a.diagram;\n      if (null !== f) {\n        var g = !0;\n        null !== e && (g = e.Z, e.Z = !0);\n        f(a, b, c);\n        null !== e && (e.Z = g);\n      }\n    }\n    d && b.isTreeLink && (c = !0, null !== e && (c = e.isTreePathToChildren), a = c ? b.toNode : b.fromNode, b = c ? b.fromNode : b.toNode, null !== a && (a.Eh = !1), null === b || b.isTreeLeaf || (0 === b.Ya.count ? (b.Eh = null, null !== e && e.undoManager.isUndoingRedoing || (b.isTreeLeaf = !0)) : Ek(b)));\n  }\n  function Ek(a) {\n    a.Eh = !1;\n    if (0 !== a.Ya.count) {\n      var b = !0,\n        c = a.diagram;\n      if (null === c || !c.undoManager.isUndoingRedoing) {\n        null !== c && (b = c.isTreePathToChildren);\n        for (c = a.Ya.iterator; c.next();) {\n          var d = c.value;\n          if (d.isTreeLink) if (b) {\n            if (d.fromNode === a) {\n              a.isTreeLeaf = !1;\n              return;\n            }\n          } else if (d.toNode === a) {\n            a.isTreeLeaf = !1;\n            return;\n          }\n        }\n        a.isTreeLeaf = !0;\n      }\n    }\n  }\n  V.prototype.updateRelationshipsFromData = function () {\n    var a = this.diagram;\n    null !== a && a.partManager.updateRelationshipsFromData(this);\n  };\n  t = V.prototype;\n  t.Kq = function (a) {\n    U.prototype.Kq.call(this, a);\n    a || (Ek(this), a = this.El, null !== a && So(a, this));\n  };\n  t.Lq = function (a) {\n    U.prototype.Lq.call(this, a);\n    a || (a = this.El, null !== a && null !== a.hd && (a.hd.remove(this), a.o()));\n  };\n  t.rk = function () {\n    if (0 < this.Ya.count) {\n      var a = this.diagram;\n      if (null !== a) for (var b = null !== a.commandHandler ? a.commandHandler.deletesConnectedLinks : !0, c = this.Ya.copy().iterator; c.next();) {\n        var d = c.value;\n        b ? a.remove(d) : (d.fromNode === this && (d.fromNode = null), d.toNode === this && (d.toNode = null));\n      }\n    }\n    this.labeledLink = null;\n    U.prototype.rk.call(this);\n  };\n  t.Kt = function (a) {\n    if (null === this.sc) {\n      if (\"\" === a && !1 === this.Nh) return this;\n      To(this);\n    }\n    var b = this.sc.H(a);\n    return null !== b || \"\" !== a && (b = this.sc.H(\"\"), null !== b) ? b : this;\n  };\n  function To(a) {\n    null === a.sc ? a.sc = new H() : a.sc.clear();\n    a.Zm(a, function (a, c) {\n      Tl(a, c);\n    });\n    0 === a.sc.count && a.sc.add(\"\", a);\n  }\n  function Tl(a, b) {\n    var c = b.portId;\n    null !== c && null !== a.sc && a.sc.add(c, b);\n  }\n  function Sl(a, b, c) {\n    var d = b.portId;\n    if (null !== d && (null !== a.sc && a.sc.remove(d), b = a.diagram, null !== b && c)) {\n      c = null;\n      for (a = a.findLinksConnected(d); a.next();) d = a.value, null === c && (c = Ea()), c.push(d);\n      if (null !== c) {\n        for (a = 0; a < c.length; a++) b.remove(c[a]);\n        Ha(c);\n      }\n    }\n  }\n  t.vA = function (a) {\n    if (null === a || a === this) return !1;\n    var b = !0,\n      c = this.diagram;\n    null !== c && (b = c.isTreePathToChildren);\n    c = this;\n    if (b) for (; c !== a;) {\n      b = null;\n      for (var d = c.Ya.iterator; d.next();) {\n        var e = d.value;\n        if (e.isTreeLink && (b = e.fromNode, b !== c && b !== this)) break;\n      }\n      if (b === this || null === b || b === c) return !1;\n      c = b;\n    } else for (; c !== a;) {\n      b = null;\n      for (d = c.Ya.iterator; d.next() && (e = d.value, !e.isTreeLink || (b = e.toNode, b === c || b === this)););\n      if (b === this || null === b || b === c) return !1;\n      c = b;\n    }\n    return !0;\n  };\n  t.dA = function () {\n    var a = !0,\n      b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    b = this;\n    if (a) for (;;) {\n      a = null;\n      for (var c = b.Ya.iterator; c.next();) {\n        var d = c.value;\n        if (d.isTreeLink && (a = d.fromNode, a !== b && a !== this)) break;\n      }\n      if (a === this) return this;\n      if (null === a || a === b) return b;\n      b = a;\n    } else for (;;) {\n      a = null;\n      for (c = b.Ya.iterator; c.next() && (d = c.value, !d.isTreeLink || (a = d.toNode, a === b || a === this)););\n      if (a === this) return this;\n      if (null === a || a === b) return b;\n      b = a;\n    }\n  };\n  t.Pz = function (a) {\n    if (null === a) return null;\n    if (this === a) return this;\n    for (var b = this; null !== b;) Do(b, !0), b = b.Fg();\n    var c = null;\n    for (b = a; null !== b;) {\n      if (0 !== (b.D & 1048576)) {\n        c = b;\n        break;\n      }\n      b = b.Fg();\n    }\n    for (b = this; null !== b;) Do(b, !1), b = b.Fg();\n    return c;\n  };\n  t.jj = function () {\n    var a = !0,\n      b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    b = this.Ya.iterator;\n    if (a) for (; b.next();) {\n      if (a = b.value, a.isTreeLink && a.fromNode !== this) return a;\n    } else for (; b.next();) if (a = b.value, a.isTreeLink && a.toNode !== this) return a;\n    return null;\n  };\n  t.Fg = function () {\n    var a = this.Eh;\n    if (null === a) return null;\n    if (a instanceof V) return a;\n    var b = !0;\n    a = this.diagram;\n    null !== a && (b = a.isTreePathToChildren);\n    a = this.Ya.iterator;\n    if (b) for (; a.next();) {\n      if (b = a.value, b.isTreeLink && (b = b.fromNode, b !== this)) return this.Eh = b;\n    } else for (; a.next();) if (b = a.value, b.isTreeLink && (b = b.toNode, b !== this)) return this.Eh = b;\n    return this.Eh = null;\n  };\n  t.bA = function () {\n    function a(b, d) {\n      if (null !== b) {\n        d.add(b);\n        var c = b.jj();\n        null !== c && (d.add(c), a(b.Fg(), d));\n      }\n    }\n    var b = new F();\n    a(this, b);\n    return b;\n  };\n  t.aA = function () {\n    return Uo(this, this);\n  };\n  function Uo(a, b) {\n    b = b.Fg();\n    return null === b ? 0 : 1 + Uo(a, b);\n  }\n  t.Fq = function () {\n    var a = !0,\n      b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    b = new ib(this.Ya);\n    var c = this;\n    b.predicate = a ? function (a) {\n      return a.isTreeLink && a.fromNode === c ? !0 : !1;\n    } : function (a) {\n      return a.isTreeLink && a.toNode === c ? !0 : !1;\n    };\n    return b;\n  };\n  t.Vv = function () {\n    var a = !0,\n      b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    var c = b = null,\n      d = this.Ya.iterator;\n    if (a) for (; d.next();) a = d.value, a.isTreeLink && a.fromNode === this && (a = a.toNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new E(), b.add(c), b.add(a)) : c = a);else for (; d.next();) a = d.value, a.isTreeLink && a.toNode === this && (a = a.fromNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new E(), b.add(c), b.add(a)) : c = a);\n    return null !== b ? b.iterator : null !== c ? new hb(c) : gb;\n  };\n  t.cA = function (a) {\n    void 0 === a && (a = Infinity);\n    var b = new F();\n    Sk(b, this, !1, a, !0);\n    return b;\n  };\n  V.prototype.collapseTree = function (a) {\n    void 0 === a && (a = 1);\n    1 > a && (a = 1);\n    var b = this.diagram;\n    if (null !== b && !b.He) {\n      b.He = !0;\n      var c = new F();\n      c.add(this);\n      Vo(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === ri);\n      b.He = !1;\n    }\n  };\n  function Vo(a, b, c, d, e, f, g) {\n    if (1 < d) for (var h = c ? a.Dq() : a.Bd(); h.next();) {\n      var k = h.value;\n      k.isTreeLink && (k = k.Iq(a), null === k || k === a || b.contains(k) || (b.add(k), Vo(k, b, c, d - 1, e, f, g)));\n    } else Wo(a, b, c, e, f, g);\n  }\n  function Wo(a, b, c, d, e, f) {\n    for (var g = e === a ? !0 : a.isTreeExpanded, h = c ? a.Dq() : a.Bd(); h.next();) {\n      var k = h.value;\n      if (k.isTreeLink && (k = k.Iq(a), null !== k && k !== a)) {\n        var l = b.contains(k);\n        l || b.add(k);\n        g && (f && d.gk(k, e), k.Oh(), k.Ob(!1));\n        k.isTreeExpanded && (k.wasTreeExpanded = k.isTreeExpanded, l || Wo(k, b, c, d, e, f));\n      }\n    }\n    a.isTreeExpanded = !1;\n  }\n  V.prototype.expandTree = function (a) {\n    void 0 === a && (a = 2);\n    2 > a && (a = 2);\n    var b = this.diagram;\n    if (null !== b && !b.He) {\n      b.He = !0;\n      var c = new F();\n      c.add(this);\n      Xo(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === ri);\n      b.He = !1;\n    }\n  };\n  function Xo(a, b, c, d, e, f, g) {\n    for (var h = f === a ? !1 : a.isTreeExpanded, k = c ? a.Dq() : a.Bd(); k.next();) {\n      var l = k.value;\n      l.isTreeLink && (h || l.dd || l.Ua(), l = l.Iq(a), null !== l && l !== a && !b.contains(l) && (b.add(l), h || (l.Ob(!0), l.Oh(), g && e.ik(l, f)), 2 < d || l.wasTreeExpanded)) && (l.wasTreeExpanded = !1, Xo(l, b, c, d - 1, e, f, g));\n    }\n    a.isTreeExpanded = !0;\n  }\n  ma.Object.defineProperties(V.prototype, {\n    portSpreading: {\n      get: function () {\n        return this.vp;\n      },\n      set: function (a) {\n        var b = this.vp;\n        b !== a && (this.vp = a, this.g(\"portSpreading\", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.md());\n      }\n    },\n    avoidable: {\n      get: function () {\n        return 0 !== (this.P & 8);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 8);\n        if (b !== a) {\n          this.P ^= 8;\n          var c = this.diagram;\n          null !== c && zk(c, this);\n          this.g(\"avoidable\", b, a);\n        }\n      }\n    },\n    avoidableMargin: {\n      get: function () {\n        return this.Wk;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.Wk;\n        if (!b.w(a)) {\n          this.Wk = a = a.G();\n          var c = this.diagram;\n          null !== c && zk(c, this);\n          this.g(\"avoidableMargin\", b, a);\n        }\n      }\n    },\n    linksConnected: {\n      get: function () {\n        return this.Ya.iterator;\n      }\n    },\n    linkConnected: {\n      get: function () {\n        return this.Fo;\n      },\n      set: function (a) {\n        var b = this.Fo;\n        b !== a && (this.Fo = a, this.g(\"linkConnected\", b, a));\n      }\n    },\n    linkDisconnected: {\n      get: function () {\n        return this.Go;\n      },\n      set: function (a) {\n        var b = this.Go;\n        b !== a && (this.Go = a, this.g(\"linkDisconnected\", b, a));\n      }\n    },\n    linkValidation: {\n      get: function () {\n        return this.Hi;\n      },\n      set: function (a) {\n        var b = this.Hi;\n        b !== a && (this.Hi = a, this.g(\"linkValidation\", b, a));\n      }\n    },\n    isLinkLabel: {\n      get: function () {\n        return null !== this.El;\n      }\n    },\n    labeledLink: {\n      get: function () {\n        return this.El;\n      },\n      set: function (a) {\n        var b = this.El;\n        if (b !== a) {\n          var c = this.diagram,\n            d = this.data;\n          if (null !== b) {\n            null !== b.hd && (b.hd.remove(this), b.o());\n            if (null !== c && null !== d && !c.undoManager.isUndoingRedoing) {\n              var e = b.data,\n                f = c.model;\n              if (null !== e && f.pj()) {\n                var g = f.ja(d);\n                void 0 !== g && f.Ly(e, g);\n              }\n            }\n            this.containingGroup = null;\n          }\n          this.El = a;\n          null !== a && (So(a, this), null === c || null === d || c.undoManager.isUndoingRedoing || (e = a.data, c = c.model, null !== e && c.pj() && (d = c.ja(d), void 0 !== d && c.Dv(e, d))), this.containingGroup = a.containingGroup);\n          Cl(this);\n          this.g(\"labeledLink\", b, a);\n        }\n      }\n    },\n    port: {\n      get: function () {\n        return this.Kt(\"\");\n      }\n    },\n    ports: {\n      get: function () {\n        null === this.sc && To(this);\n        return this.sc.iteratorValues;\n      }\n    },\n    isTreeExpanded: {\n      get: function () {\n        return 0 !== (this.P & 1);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 1);\n        if (b !== a) {\n          this.P ^= 1;\n          var c = this.diagram;\n          this.g(\"isTreeExpanded\", b, a);\n          b = this.treeExpandedChanged;\n          if (null !== b) {\n            var d = !0;\n            null !== c && (d = c.Z, c.Z = !0);\n            b(this);\n            null !== c && (c.Z = d);\n          }\n          null !== c && c.undoManager.isUndoingRedoing ? this.Ob(a) : a ? this.expandTree() : this.collapseTree();\n        }\n      }\n    },\n    wasTreeExpanded: {\n      get: function () {\n        return 0 !== (this.P & 2);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 2);\n        b !== a && (this.P ^= 2, this.g(\"wasTreeExpanded\", b, a));\n      }\n    },\n    treeExpandedChanged: {\n      get: function () {\n        return this.lq;\n      },\n      set: function (a) {\n        var b = this.lq;\n        b !== a && (this.lq = a, this.g(\"treeExpandedChanged\", b, a));\n      }\n    },\n    isTreeLeaf: {\n      get: function () {\n        return 0 !== (this.P & 4);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 4);\n        b !== a && (this.P ^= 4, this.g(\"isTreeLeaf\", b, a));\n      }\n    }\n  });\n  V.prototype.expandTree = V.prototype.expandTree;\n  V.prototype.collapseTree = V.prototype.collapseTree;\n  V.prototype.findTreeParts = V.prototype.cA;\n  V.prototype.findTreeChildrenNodes = V.prototype.Vv;\n  V.prototype.findTreeChildrenLinks = V.prototype.Fq;\n  V.prototype.findTreeLevel = V.prototype.aA;\n  V.prototype.findTreeParentChain = V.prototype.bA;\n  V.prototype.findTreeParentNode = V.prototype.Fg;\n  V.prototype.findTreeParentLink = V.prototype.jj;\n  V.prototype.findCommonTreeParent = V.prototype.Pz;\n  V.prototype.findTreeRoot = V.prototype.dA;\n  V.prototype.isInTreeOf = V.prototype.vA;\n  V.prototype.findPort = V.prototype.Kt;\n  V.prototype.findLinksTo = V.prototype.Tz;\n  V.prototype.findLinksBetween = V.prototype.Sz;\n  V.prototype.findNodesInto = V.prototype.Sv;\n  V.prototype.findNodesOutOf = V.prototype.Tv;\n  V.prototype.findNodesConnected = V.prototype.Rv;\n  V.prototype.findLinksInto = V.prototype.Bd;\n  V.prototype.findLinksOutOf = V.prototype.Dq;\n  V.prototype.findExternalTreeLinksConnected = V.prototype.my;\n  V.prototype.invalidateConnectedLinks = V.prototype.md;\n  V.prototype.invalidateLinkBundle = V.prototype.tA;\n  var Yo = new D(V, \"SpreadingNone\", 10),\n    Lo = new D(V, \"SpreadingEvenly\", 11),\n    Zo = new D(V, \"SpreadingPacked\", 12);\n  V.className = \"Node\";\n  V.SpreadingNone = Yo;\n  V.SpreadingEvenly = Lo;\n  V.SpreadingPacked = Zo;\n  function vf(a) {\n    V.call(this, a);\n    this.P |= 4608;\n    this.Ro = new F();\n    this.Ml = new F();\n    this.Ra = this.bq = this.Ji = this.So = this.Qo = null;\n    this.kc = new yi();\n    this.kc.group = this;\n  }\n  la(vf, V);\n  vf.prototype.cloneProtected = function (a) {\n    V.prototype.cloneProtected.call(this, a);\n    this.P = this.P & -32769;\n    a.Qo = this.Qo;\n    a.So = this.So;\n    a.Ji = this.Ji;\n    a.bq = this.bq;\n    var b = a.sm(function (a) {\n      return a instanceof wg;\n    });\n    b instanceof wg ? a.Ra = b : a.Ra = null;\n    null !== this.kc ? (a.kc = this.kc.copy(), a.kc.group = a) : (null !== a.kc && (a.kc.group = null), a.kc = null);\n  };\n  t = vf.prototype;\n  t.yf = function (a) {\n    V.prototype.yf.call(this, a);\n    var b = a.uk();\n    for (a = a.memberParts; a.next();) {\n      var c = a.value;\n      c.o();\n      c.C(8);\n      c.kk();\n      if (c instanceof V) c.md(b);else if (c instanceof S) for (c = c.labelNodes; c.next();) c.value.md(b);\n    }\n  };\n  t.Jk = function (a, b, c, d, e, f, g) {\n    if (a === xe && \"elements\" === b) {\n      if (e instanceof wg) null === this.Ra ? this.Ra = e : this.Ra !== e && B(\"Cannot insert a second Placeholder into the visual tree of a Group.\");else {\n        if (e instanceof X) {\n          var h = e.sm(function (a) {\n            return a instanceof wg;\n          });\n          h instanceof wg && (null === this.Ra ? this.Ra = h : this.Ra !== h && B(\"Cannot insert a second Placeholder into the visual tree of a Group.\"));\n        }\n      }\n    } else a === ye && \"elements\" === b && null !== this.Ra && (d === this.Ra ? this.Ra = null : d instanceof X && this.Ra.Gg(d) && (this.Ra = null));\n    V.prototype.Jk.call(this, a, b, c, d, e, f, g);\n  };\n  t.Ih = function (a, b, c, d) {\n    this.bf = this.Ra;\n    V.prototype.Ih.call(this, a, b, c, d);\n  };\n  t.Ta = function () {\n    var a = this;\n    a.isSubGraphExpanded && this.memberParts.each(function (b) {\n      !a.computesBoundsIncludingLinks && b instanceof S || b.Ta();\n    });\n    V.prototype.Ta.call(this);\n  };\n  t.qj = function () {\n    if (!V.prototype.qj.call(this)) return !1;\n    for (var a = this.memberParts; a.next();) {\n      var b = a.value;\n      if (b instanceof V) {\n        if (b.isVisible() && tj(b)) return !1;\n      } else if (b instanceof S && b.isVisible() && tj(b) && b.fromNode !== this && b.toNode !== this) return !1;\n    }\n    return !0;\n  };\n  function Eo(a, b) {\n    if (a.Ro.add(b)) {\n      b instanceof vf && a.Ml.add(b);\n      var c = a.memberAdded;\n      if (null !== c) {\n        var d = !0,\n          e = a.diagram;\n        null !== e && (d = e.Z, e.Z = !0);\n        c(a, b);\n        null !== e && (e.Z = d);\n      }\n      a.isVisible() && a.isSubGraphExpanded || b.Ob(!1);\n    }\n    b instanceof S && !a.computesBoundsIncludingLinks || (b = a.Ra, null === b && (b = a), b.o());\n  }\n  function Fo(a, b) {\n    if (a.Ro.remove(b)) {\n      b instanceof vf && a.Ml.remove(b);\n      var c = a.memberRemoved;\n      if (null !== c) {\n        var d = !0,\n          e = a.diagram;\n        null !== e && (d = e.Z, e.Z = !0);\n        c(a, b);\n        null !== e && (e.Z = d);\n      }\n      a.isVisible() && a.isSubGraphExpanded || b.Ob(!0);\n    }\n    b instanceof S && !a.computesBoundsIncludingLinks || (b = a.Ra, null === b && (b = a), b.o());\n  }\n  t.rk = function () {\n    if (0 < this.Ro.count) {\n      var a = this.diagram;\n      if (null !== a) for (var b = this.Ro.copy().iterator; b.next();) a.remove(b.value);\n    }\n    V.prototype.rk.call(this);\n  };\n  vf.prototype.canAddMembers = function (a) {\n    var b = this.diagram;\n    if (null === b) return !1;\n    b = b.commandHandler;\n    for (a = Uk(a).iterator; a.next();) if (!b.isValidMember(this, a.value)) return !1;\n    return !0;\n  };\n  vf.prototype.addMembers = function (a, b) {\n    var c = this.diagram;\n    if (null === c) return !1;\n    c = c.commandHandler;\n    var d = !0;\n    for (a = Uk(a).iterator; a.next();) {\n      var e = a.value;\n      !b || c.isValidMember(this, e) ? e.containingGroup = this : d = !1;\n    }\n    return d;\n  };\n  vf.prototype.canUngroup = function () {\n    if (!this.ungroupable) return !1;\n    var a = this.layer;\n    if (null !== a && !a.allowUngroup) return !1;\n    a = a.diagram;\n    return null === a || a.allowUngroup ? !0 : !1;\n  };\n  t = vf.prototype;\n  t.md = function (a) {\n    void 0 === a && (a = null);\n    var b = 0 !== (this.P & 65536);\n    V.prototype.md.call(this, a);\n    if (!b) for (0 !== (this.P & 65536) !== !0 && (this.P = this.P ^ 65536), b = this.Qv(); b.next();) {\n      var c = b.value;\n      if (null === a || !a.contains(c)) {\n        var d = c.fromNode;\n        null !== d && d !== this && d.Cd(this) && !d.isVisible() ? (Oo(d, c.fromPort), Oo(d, c.toPort), c.Ua()) : (d = c.toNode, null !== d && d !== this && d.Cd(this) && !d.isVisible() && (Oo(d, c.fromPort), Oo(d, c.toPort), c.Ua()));\n      }\n    }\n  };\n  t.Qv = function () {\n    var a = this.uk();\n    a.add(this);\n    for (var b = new F(), c = a.iterator; c.next();) {\n      var d = c.value;\n      if (d instanceof V) for (d = d.linksConnected; d.next();) {\n        var e = d.value;\n        a.contains(e) || b.add(e);\n      }\n    }\n    return b.iterator;\n  };\n  t.Rz = function () {\n    var a = this.uk();\n    a.add(this);\n    for (var b = new F(), c = a.iterator; c.next();) {\n      var d = c.value;\n      if (d instanceof V) for (d = d.linksConnected; d.next();) {\n        var e = d.value,\n          f = e.fromNode;\n        null === f || a.contains(f) && f !== this || b.add(f);\n        e = e.toNode;\n        null === e || a.contains(e) && e !== this || b.add(e);\n      }\n    }\n    return b.iterator;\n  };\n  t.Qz = function () {\n    function a(b, d) {\n      null !== b && (d.add(b), a(b.containingGroup, d));\n    }\n    var b = new F();\n    a(this, b);\n    return b;\n  };\n  t.uk = function () {\n    var a = new F();\n    Sk(a, this, !0, 0, !0);\n    a.remove(this);\n    return a;\n  };\n  t.Ob = function (a) {\n    V.prototype.Ob.call(this, a);\n    for (var b = this.memberParts; b.next();) b.value.Ob(a);\n  };\n  vf.prototype.collapseSubGraph = function () {\n    var a = this.diagram;\n    if (null !== a && !a.He) {\n      a.He = !0;\n      var b = this.uk();\n      $o(this, b, a, this);\n      a.He = !1;\n    }\n  };\n  function $o(a, b, c, d) {\n    for (var e = a.memberParts; e.next();) {\n      var f = e.value;\n      f.Ob(!1);\n      f instanceof vf && f.isSubGraphExpanded && (f.wasSubGraphExpanded = f.isSubGraphExpanded, $o(f, b, c, d));\n      if (f instanceof V) f.md(b), c.gk(f, d);else if (f instanceof S) for (f = f.labelNodes; f.next();) f.value.md(b);\n    }\n    a.isSubGraphExpanded = !1;\n  }\n  vf.prototype.expandSubGraph = function () {\n    var a = this.diagram;\n    if (null !== a && !a.He) {\n      a.He = !0;\n      var b = this.uk();\n      ap(this, b, a, this);\n      a.He = !1;\n    }\n  };\n  function ap(a, b, c, d) {\n    for (var e = a.memberParts; e.next();) {\n      var f = e.value;\n      f.Ob(!0);\n      f instanceof vf && f.wasSubGraphExpanded && (f.wasSubGraphExpanded = !1, ap(f, b, c, d));\n      if (f instanceof V) f.md(b), c.ik(f, d);else if (f instanceof S) for (f = f.labelNodes; f.next();) f.value.md(b);\n    }\n    a.isSubGraphExpanded = !0;\n  }\n  vf.prototype.move = function (a, b) {\n    void 0 === b && (b = !1);\n    var c = b ? this.location : this.position,\n      d = c.x;\n    c = c.y;\n    var e = a.x,\n      f = a.y;\n    if (!(d === e || isNaN(d) && isNaN(e)) || !(c === f || isNaN(c) && isNaN(f))) {\n      d = e - (isNaN(d) ? 0 : d);\n      c = f - (isNaN(c) ? 0 : c);\n      f = J.alloc();\n      V.prototype.move.call(this, a, b);\n      a = new F();\n      for (b = this.uk().iterator; b.next();) if (e = b.value, e instanceof S && (e.suspendsRouting && a.add(e), e.dd || e.fromNode !== this && e.toNode !== this)) e.suspendsRouting = !0;\n      for (b.reset(); b.next();) if (e = b.value, !(e.Ph() || e instanceof V && e.isLinkLabel)) {\n        var g = e.position,\n          h = e.location;\n        g.u() ? (f.x = g.x + d, f.y = g.y + c, e.position = f) : h.u() && (f.x = h.x + d, f.y = h.y + c, e.location = f);\n      }\n      for (b.reset(); b.next();) if (e = b.value, e instanceof S && (e.suspendsRouting = a.contains(e), e.dd || e.fromNode !== this && e.toNode !== this)) g = e.position, f.x = g.x + d, f.y = g.y + c, f.u() ? e.move(f) : e.Ua(), Qj(e) && e.Ua();\n      J.free(f);\n    }\n  };\n  ma.Object.defineProperties(vf.prototype, {\n    placeholder: {\n      get: function () {\n        return this.Ra;\n      }\n    },\n    computesBoundsAfterDrag: {\n      get: function () {\n        return 0 !== (this.P & 2048);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 2048);\n        b !== a && (this.P ^= 2048, this.g(\"computesBoundsAfterDrag\", b, a));\n      }\n    },\n    computesBoundsIncludingLinks: {\n      get: function () {\n        return 0 !== (this.P & 4096);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 4096);\n        b !== a && (this.P ^= 4096, this.g(\"computesBoundsIncludingLinks\", b, a));\n      }\n    },\n    computesBoundsIncludingLocation: {\n      get: function () {\n        return 0 !== (this.P & 8192);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 8192);\n        b !== a && (this.P ^= 8192, this.g(\"computesBoundsIncludingLocation\", b, a));\n      }\n    },\n    handlesDragDropForMembers: {\n      get: function () {\n        return 0 !== (this.P & 16384);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 16384);\n        b !== a && (this.P ^= 16384, this.g(\"handlesDragDropForMembers\", b, a));\n      }\n    },\n    memberParts: {\n      get: function () {\n        return this.Ro.iterator;\n      }\n    },\n    layout: {\n      get: function () {\n        return this.kc;\n      },\n      set: function (a) {\n        var b = this.kc;\n        if (b !== a) {\n          null !== b && (b.diagram = null, b.group = null);\n          this.kc = a;\n          var c = this.diagram;\n          null !== a && (a.diagram = c, a.group = this);\n          null !== c && (c.Ng = !0);\n          this.g(\"layout\", b, a);\n          null !== c && c.Db();\n        }\n      }\n    },\n    memberAdded: {\n      get: function () {\n        return this.Qo;\n      },\n      set: function (a) {\n        var b = this.Qo;\n        b !== a && (this.Qo = a, this.g(\"memberAdded\", b, a));\n      }\n    },\n    memberRemoved: {\n      get: function () {\n        return this.So;\n      },\n      set: function (a) {\n        var b = this.So;\n        b !== a && (this.So = a, this.g(\"memberRemoved\", b, a));\n      }\n    },\n    memberValidation: {\n      get: function () {\n        return this.Ji;\n      },\n      set: function (a) {\n        var b = this.Ji;\n        b !== a && (this.Ji = a, this.g(\"memberValidation\", b, a));\n      }\n    },\n    ungroupable: {\n      get: function () {\n        return 0 !== (this.P & 256);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 256);\n        b !== a && (this.P ^= 256, this.g(\"ungroupable\", b, a));\n      }\n    },\n    isSubGraphExpanded: {\n      get: function () {\n        return 0 !== (this.P & 512);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 512);\n        if (b !== a) {\n          this.P ^= 512;\n          var c = this.diagram;\n          this.g(\"isSubGraphExpanded\", b, a);\n          b = this.subGraphExpandedChanged;\n          if (null !== b) {\n            var d = !0;\n            null !== c && (d = c.Z, c.Z = !0);\n            b(this);\n            null !== c && (c.Z = d);\n          }\n          null !== c && c.undoManager.isUndoingRedoing ? (null !== this.Ra && this.Ra.o(), this.memberParts.each(function (a) {\n            a.updateAdornments();\n          })) : a ? this.expandSubGraph() : this.collapseSubGraph();\n        }\n      }\n    },\n    wasSubGraphExpanded: {\n      get: function () {\n        return 0 !== (this.P & 1024);\n      },\n      set: function (a) {\n        var b = 0 !== (this.P & 1024);\n        b !== a && (this.P ^= 1024, this.g(\"wasSubGraphExpanded\", b, a));\n      }\n    },\n    subGraphExpandedChanged: {\n      get: function () {\n        return this.bq;\n      },\n      set: function (a) {\n        var b = this.bq;\n        b !== a && (this.bq = a, this.g(\"subGraphExpandedChanged\", b, a));\n      }\n    },\n    Rh: {\n      get: function () {\n        return 0 !== (this.P & 32768);\n      },\n      set: function (a) {\n        0 !== (this.P & 32768) !== a && (this.P ^= 32768);\n      }\n    }\n  });\n  vf.prototype.expandSubGraph = vf.prototype.expandSubGraph;\n  vf.prototype.collapseSubGraph = vf.prototype.collapseSubGraph;\n  vf.prototype.findSubGraphParts = vf.prototype.uk;\n  vf.prototype.findContainingGroupChain = vf.prototype.Qz;\n  vf.prototype.findExternalNodesConnected = vf.prototype.Rz;\n  vf.prototype.findExternalLinksConnected = vf.prototype.Qv;\n  vf.prototype.ensureBounds = vf.prototype.Ta;\n  vf.className = \"Group\";\n  function wg() {\n    Y.call(this);\n    this.gb = tc;\n    this.Jp = new N(NaN, NaN, NaN, NaN);\n  }\n  la(wg, Y);\n  wg.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.gb = this.gb.G();\n    a.Jp = this.Jp.copy();\n  };\n  wg.prototype.Kh = function (a) {\n    if (null === this.background && null === this.areaBackground) return !1;\n    var b = this.naturalBounds;\n    return gc(0, 0, b.width, b.height, a.x, a.y);\n  };\n  wg.prototype.Dm = function () {\n    var a = this.part;\n    null !== a && (a instanceof vf || a instanceof He) || B(\"Placeholder is not inside a Group or Adornment.\");\n    if (a instanceof vf) {\n      var b = this.computeBorder(this.Jp),\n        c = this.minSize,\n        d = this.qc;\n      Wb(d, (isFinite(c.width) ? Math.max(c.width, b.width) : b.width) || 0, (isFinite(c.height) ? Math.max(c.height, b.height) : b.height) || 0);\n      hl(this, 0, 0, d.width, d.height);\n      d = a.memberParts;\n      for (c = !1; d.next();) if (d.value.isVisible()) {\n        c = !0;\n        break;\n      }\n      d = a.diagram;\n      !c || null === d || d.animationManager.dw(a) || isNaN(b.x) || isNaN(b.y) || (c = J.alloc(), c.sj(b, a.locationSpot), c.w(a.location) || (a.location = new J(c.x, c.y)), J.free(c));\n    } else {\n      b = this.qc;\n      c = this.gb;\n      d = c.left + c.right;\n      var e = c.top + c.bottom,\n        f = a.adornedObject;\n      a.angle = f.lj();\n      var g = 0;\n      f instanceof W && (g = f.strokeWidth);\n      var h = f.Af(),\n        k = f.naturalBounds,\n        l = (k.width + g) * h;\n      g = (k.height + g) * h;\n      a.type !== X.Link && (f = f.ga(\"Selection\" === a.category ? wc : a.locationSpot, J.alloc()), a.location = f, J.free(f));\n      isNaN(l) || isNaN(g) ? (a = a.adornedObject, l = a.ga(wc, J.alloc()), f = N.allocAt(l.x, l.y, 0, 0), f.Me(a.ga(Hc, l)), f.Me(a.ga(zc, l)), f.Me(a.ga(Dc, l)), Wb(b, f.width + d || 0, f.height + e || 0), hl(this, -c.left, -c.top, b.width, b.height), J.free(l), N.free(f)) : (Wb(b, l + d || 0, g + e || 0), hl(this, -c.left, -c.top, b.width, b.height));\n    }\n  };\n  wg.prototype.Ih = function (a, b, c, d) {\n    this.actualBounds.h(a, b, c, d);\n  };\n  wg.prototype.computeBorder = function (a) {\n    var b = this.part,\n      c = b.diagram;\n    if (null !== c && b instanceof vf && !b.layer.isTemporary && b.computesBoundsAfterDrag && this.Jp.u()) {\n      var d = c.toolManager.findTool(\"Dragging\");\n      if (d === c.currentTool && (c = d.computeBorder(b, this.Jp, a), null !== c)) return c;\n    }\n    c = N.alloc();\n    d = this.computeMemberBounds(c);\n    var e = this.gb;\n    b instanceof vf && !b.isSubGraphExpanded ? a.h(d.x - e.left, d.y - e.top, 0, 0) : a.h(d.x - e.left, d.y - e.top, Math.max(d.width + e.left + e.right, 0), Math.max(d.height + e.top + e.bottom, 0));\n    N.free(c);\n    b instanceof vf && b.computesBoundsIncludingLocation && b.location.u() && a.Me(b.location);\n    return a;\n  };\n  wg.prototype.computeMemberBounds = function (a) {\n    if (!(this.part instanceof vf)) return a.h(0, 0, 0, 0), a;\n    for (var b = this.part, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = b.memberParts; g.next();) {\n      var h = g.value;\n      if (h.isVisible()) {\n        if (h instanceof S) {\n          if (!b.computesBoundsIncludingLinks) continue;\n          if (sj(h)) continue;\n          if (h.fromNode === b || h.toNode === b) continue;\n        }\n        h = h.actualBounds;\n        h.left < c && (c = h.left);\n        h.top < d && (d = h.top);\n        h.right > e && (e = h.right);\n        h.bottom > f && (f = h.bottom);\n      }\n    }\n    isFinite(c) && isFinite(d) ? a.h(c, d, e - c, f - d) : (b = b.location, a.h(b.x, b.y, 0, 0));\n    return a;\n  };\n  ma.Object.defineProperties(wg.prototype, {\n    padding: {\n      get: function () {\n        return this.gb;\n      },\n      set: function (a) {\n        \"number\" === typeof a && (a = new pc(a));\n        var b = this.gb;\n        b.w(a) || (this.gb = a = a.G(), this.g(\"padding\", b, a), this.o());\n      }\n    }\n  });\n  wg.className = \"Placeholder\";\n  function S() {\n    U.call(this, X.Link);\n    this.Fa = 8;\n    this.Ve = null;\n    this.We = \"\";\n    this.rf = this.eo = null;\n    this.sf = \"\";\n    this.kq = null;\n    this.Rk = bg;\n    this.Gn = 0;\n    this.In = bg;\n    this.Jn = NaN;\n    this.$j = bp;\n    this.Xp = .5;\n    this.hd = null;\n    this.Ab = new E().freeze();\n    this.qg = this.oh = null;\n    this.Rl = new N();\n    this.na = new td();\n    this.I = this.v = this.Lf = this.Uf = null;\n    this.l = [];\n    this.vv = new J();\n    this.cs = this.Lx = this.Kx = null;\n    this.Pu = NaN;\n    this.O = null;\n  }\n  la(S, U);\n  S.prototype.cloneProtected = function (a) {\n    U.prototype.cloneProtected.call(this, a);\n    a.Fa = this.Fa & -113;\n    a.We = this.We;\n    a.eo = this.eo;\n    a.sf = this.sf;\n    a.kq = this.kq;\n    a.Rk = this.Rk;\n    a.Gn = this.Gn;\n    a.In = this.In;\n    a.Jn = this.Jn;\n    a.$j = this.$j;\n    a.Xp = this.Xp;\n    null !== this.O && (a.O = this.O.copy());\n  };\n  t = S.prototype;\n  t.yf = function (a) {\n    U.prototype.yf.call(this, a);\n    this.We = a.We;\n    this.sf = a.sf;\n    a.oh = null;\n    a.Ua();\n    a.Lf = this.Lf;\n    var b = a.fromPort;\n    null !== b && Oo(a.fromNode, b);\n    b = a.toPort;\n    null !== b && Oo(a.toNode, b);\n  };\n  t.hb = function (a) {\n    a.classType === S ? 2 === (a.value & 2) ? this.routing = a : a === pg || a === ag || a === $f ? this.curve = a : a === cp || a === dp || a === ep ? this.adjusting = a : a !== bp && a !== bg && B(\"Unknown Link enum value for a Link property: \" + a) : U.prototype.hb.call(this, a);\n  };\n  t.Jc = function () {\n    null === this.O && (this.O = new dl());\n  };\n  t.qj = function () {\n    var a = this.fromNode;\n    if (null !== a) {\n      var b = a.findVisibleNode();\n      null !== b && (a = b);\n      if (tj(a) || uj(a)) return !1;\n    }\n    a = this.toNode;\n    return null !== a && (b = a.findVisibleNode(), null !== b && (a = b), tj(a) || uj(a)) ? !1 : !0;\n  };\n  t.Dw = function () {\n    return !1;\n  };\n  t.lu = function () {};\n  t.Wb = function () {\n    return !1;\n  };\n  S.prototype.computeAngle = function (a, b, c) {\n    return S.computeAngle(b, c);\n  };\n  S.computeAngle = function (a, b) {\n    switch (a) {\n      default:\n      case bg:\n        a = 0;\n        break;\n      case Um:\n        a = b;\n        break;\n      case Nm:\n        a = b + 90;\n        break;\n      case Pm:\n        a = b - 90;\n        break;\n      case fp:\n        a = b + 180;\n        break;\n      case Vm:\n        a = K.Tq(b);\n        90 < a && 270 > a && (a -= 180);\n        break;\n      case Om:\n        a = K.Tq(b + 90);\n        90 < a && 270 > a && (a -= 180);\n        break;\n      case Qm:\n        a = K.Tq(b - 90);\n        90 < a && 270 > a && (a -= 180);\n        break;\n      case Rm:\n        a = K.Tq(b);\n        if (45 < a && 135 > a || 225 < a && 315 > a) return 0;\n        90 < a && 270 > a && (a -= 180);\n    }\n    return K.Tq(a);\n  };\n  function Ko(a) {\n    var b = a.fromNode,\n      c = a.toNode,\n      d = null;\n    null !== b ? d = null !== c ? b.ly(c) : b.containingGroup : null !== c ? d = c.containingGroup : d = null;\n    b = d;\n    c = a.mi;\n    if (c !== b) {\n      null !== c && Fo(c, a);\n      a.mi = b;\n      null !== b && Eo(b, a);\n      var e = a.containingGroupChanged;\n      if (null !== e) {\n        var f = !0,\n          g = a.diagram;\n        null !== g && (f = g.Z, g.Z = !0);\n        e(a, c, b);\n        null !== g && (g.Z = f);\n      }\n      !a.dd || a.Kx !== c && a.Lx !== c || a.Ua();\n    }\n    if (a.isLabeledLink) for (a = a.labelNodes; a.next();) a.value.containingGroup = d;\n  }\n  t = S.prototype;\n  t.Oh = function () {\n    var a = this.containingGroup;\n    null !== a && this.fromNode !== a && this.toNode !== a && a.computesBoundsIncludingLinks && U.prototype.Oh.call(this);\n  };\n  t.Iq = function (a) {\n    var b = this.fromNode;\n    return a === b ? this.toNode : b;\n  };\n  t.iA = function (a) {\n    var b = this.fromPort;\n    return a === b ? this.toPort : b;\n  };\n  function So(a, b) {\n    null === a.hd && (a.hd = new F());\n    a.hd.add(b);\n    a.o();\n  }\n  t.Kq = function (a) {\n    U.prototype.Kq.call(this, a);\n    gp(this) && this.Nq(this.actualBounds);\n    if (!a) {\n      a = this.Ve;\n      var b = null;\n      null !== a && (b = this.fromPort, Qo(a, this, b));\n      var c = this.rf;\n      if (null !== c) {\n        var d = this.toPort;\n        c === a && d === b || Qo(c, this, d);\n      }\n      hp(this);\n    }\n  };\n  t.Lq = function (a) {\n    U.prototype.Lq.call(this, a);\n    gp(this) && this.Nq(this.actualBounds);\n    if (!a) {\n      a = this.Ve;\n      var b = null;\n      null !== a && (b = this.fromPort, Ro(a, this, b));\n      var c = this.rf;\n      if (null !== c) {\n        var d = this.toPort;\n        c === a && d === b || Ro(c, this, d);\n      }\n      ip(this);\n    }\n  };\n  t.rk = function () {\n    this.dd = !0;\n    if (null !== this.hd) {\n      var a = this.diagram;\n      if (null !== a) for (var b = this.hd.copy().iterator; b.next();) a.remove(b.value);\n    }\n    null !== this.data && (a = this.diagram, null !== a && a.partManager.removeDataForLink(this));\n  };\n  S.prototype.updateRelationshipsFromData = function () {\n    if (null !== this.data) {\n      var a = this.diagram;\n      null !== a && a.partManager.updateRelationshipsFromData(this);\n    }\n  };\n  S.prototype.move = function (a, b) {\n    var c = b ? this.location : this.position,\n      d = c.x;\n    isNaN(d) && (d = 0);\n    var e = c.y;\n    isNaN(e) && (e = 0);\n    d = a.x - d;\n    e = a.y - e;\n    !0 === b ? U.prototype.move.call(this, a, !1) : (a = J.allocAt(c.x + d, c.y + e), U.prototype.move.call(this, a, !1), J.free(a));\n    qf(this, d, e);\n    for (a = this.labelNodes; a.next();) b = a.value, c = b.position, b.moveTo(c.x + d, c.y + e);\n  };\n  S.prototype.canRelinkFrom = function () {\n    if (!this.relinkableFrom) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowRelink) return !1;\n    a = a.diagram;\n    return null === a || a.allowRelink ? !0 : !1;\n  };\n  S.prototype.canRelinkTo = function () {\n    if (!this.relinkableTo) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowRelink) return !1;\n    a = a.diagram;\n    return null === a || a.allowRelink ? !0 : !1;\n  };\n  S.prototype.computeMidPoint = function (a) {\n    var b = this.pointsCount;\n    if (0 === b) return a.assign(Lb), a;\n    if (1 === b) return a.assign(this.i(0)), a;\n    if (2 === b) {\n      var c = this.i(0),\n        d = this.i(1);\n      a.h((c.x + d.x) / 2, (c.y + d.y) / 2);\n      return a;\n    }\n    if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === pg)) return this.na.Wv(.5, a), a.add(this.i(0)), c = this.na.figures.first(), a.offset(-c.startX, -c.startY), a;\n    if (this.computeCurve() === pg) {\n      if (3 === b) return this.i(1);\n      d = (b - 1) / 3 | 0;\n      c = 3 * (d / 2 | 0);\n      if (1 === d % 2) {\n        d = this.i(c);\n        var e = this.i(c + 1),\n          f = this.i(c + 2);\n        c = this.i(c + 3);\n        K.sz(d.x, d.y, e.x, e.y, f.x, f.y, c.x, c.y, a);\n      } else a.assign(this.i(c));\n      return a;\n    }\n    var g = this.flattenedLengths;\n    c = this.flattenedTotalLength;\n    for (e = f = d = 0; d < c / 2 && f < b;) {\n      e = g[f];\n      if (d + e > c / 2) break;\n      d += e;\n      f++;\n    }\n    b = this.i(f);\n    f = this.i(f + 1);\n    1 > Math.abs(b.x - f.x) ? b.y > f.y ? a.h(b.x, b.y - (c / 2 - d)) : a.h(b.x, b.y + (c / 2 - d)) : 1 > Math.abs(b.y - f.y) ? b.x > f.x ? a.h(b.x - (c / 2 - d), b.y) : a.h(b.x + (c / 2 - d), b.y) : (c = (c / 2 - d) / e, a.h(b.x + c * (f.x - b.x), b.y + c * (f.y - b.y)));\n    return a;\n  };\n  S.prototype.computeMidAngle = function () {\n    var a = this.pointsCount;\n    if (2 > a) return NaN;\n    if (2 === a) return this.i(0).Sa(this.i(1));\n    if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === pg)) return this.na.sy(.5);\n    if (this.computeCurve() === pg && 4 <= a) {\n      var b = (a - 1) / 3 | 0,\n        c = 3 * (b / 2 | 0);\n      if (1 === b % 2) {\n        c = Math.floor(c);\n        a = this.i(c);\n        b = this.i(c + 1);\n        var d = this.i(c + 2);\n        c = this.i(c + 3);\n        return K.rz(a.x, a.y, b.x, b.y, d.x, d.y, c.x, c.y);\n      }\n      if (0 < c && c + 1 < a) return this.i(c - 1).Sa(this.i(c + 1));\n    }\n    b = this.flattenedLengths;\n    d = this.flattenedTotalLength;\n    var e = 0;\n    c = 0;\n    for (var f; e < d / 2 && c < a;) {\n      f = b[c];\n      if (e + f > d / 2) break;\n      e += f;\n      c++;\n    }\n    b = this.i(c);\n    d = this.i(c + 1);\n    if (1 > Math.abs(b.x - d.x) && 1 > Math.abs(b.y - d.y)) {\n      if (0 < c && c + 2 < a) return this.i(c - 1).Sa(this.i(c + 2));\n    } else {\n      if (1 > Math.abs(b.x - d.x)) return b.y > d.y ? 270 : 90;\n      if (1 > Math.abs(b.y - d.y)) return b.x > d.x ? 180 : 0;\n    }\n    return b.Sa(d);\n  };\n  t = S.prototype;\n  t.i = function (a) {\n    return this.Ab.j[a];\n  };\n  t.od = function (a, b) {\n    this.Ab.nd(a, b);\n  };\n  t.K = function (a, b, c) {\n    this.Ab.nd(a, new J(b, c));\n  };\n  t.rA = function (a, b) {\n    this.Ab.vb(a, b);\n  };\n  t.m = function (a, b, c) {\n    this.Ab.vb(a, new J(b, c));\n  };\n  t.Be = function (a) {\n    this.Ab.add(a);\n  };\n  t.vf = function (a, b) {\n    this.Ab.add(new J(a, b));\n  };\n  t.sw = function (a) {\n    this.Ab.bb(a);\n  };\n  t.lk = function () {\n    this.Ab.clear();\n  };\n  function qf(a, b, c) {\n    if (0 !== b || 0 !== c) {\n      for (var d = a.dd, e = new E(), f = a.Ab.iterator; f.next();) {\n        var g = f.value;\n        e.add(new J(g.x + b, g.y + c).freeze());\n      }\n      e.freeze();\n      f = a.Ab;\n      a.Ab = e;\n      g = a.diagram;\n      isNaN(b) || isNaN(c) || null !== g && g.animationManager.rc ? a.o() : (a.dg.h(a.dg.x + b, a.dg.y + c), a.la.h(a.la.x + b, a.la.y + c), Cl(a));\n      d && jp(a);\n      null !== g && g.animationManager.rc && (a.qg = e);\n      a.g(\"points\", f, e);\n    }\n  }\n  t.Th = function () {\n    null === this.oh && (this.oh = this.Ab, this.Ab = this.Ab.copy());\n  };\n  t.xf = function () {\n    if (null !== this.oh) {\n      for (var a = this.oh, b = this.Ab, c = Infinity, d = Infinity, e = a.j, f = e.length, g = 0; g < f; g++) {\n        var h = e[g];\n        c = Math.min(h.x, c);\n        d = Math.min(h.y, d);\n      }\n      h = g = Infinity;\n      for (var k = b.j, l = k.length, m = 0; m < l; m++) {\n        var n = k[m];\n        g = Math.min(n.x, g);\n        h = Math.min(n.y, h);\n        n.freeze();\n      }\n      b.freeze();\n      if (l === f) for (f = 0; f < l; f++) {\n        if (m = e[f], n = k[f], m.x - c !== n.x - g || m.y - d !== n.y - h) {\n          this.cc();\n          break;\n        }\n      } else this.cc();\n      this.oh = null;\n      c = this.diagram;\n      null !== c && c.animationManager.rc && (this.qg = b);\n      jp(this);\n      this.g(\"points\", a, b);\n    }\n  };\n  t.xw = function () {\n    null !== this.oh && (this.Ab = this.oh, this.oh = null);\n  };\n  function jp(a) {\n    0 === a.Ab.count ? a.dd = !1 : (a.dd = !0, a.cs = null, a.Pu = NaN, a.defaultFromPoint = a.i(0), a.defaultToPoint = a.i(a.pointsCount - 1), kp(a, !1));\n  }\n  t.Ua = function () {\n    if (!this.suspendsRouting) {\n      var a = this.diagram;\n      if (a) {\n        if (a.Xt.contains(this) || a.undoManager.isUndoingRedoing) return;\n        a = a.animationManager;\n        if (a.isTicking && !a.isAnimating) return;\n        null !== this.qg && !a.isTicking && a.isAnimating && (this.qg = null);\n      }\n      a = this.path;\n      null !== a && (this.dd = !1, this.o(), a.o());\n    }\n  };\n  t.wj = function () {\n    if (!this.dd && !this.Ct) {\n      var a = !0;\n      try {\n        this.Ct = !0, this.Th(), a = this.computePoints();\n      } catch (b) {\n        this.Ct = !1, this.xw();\n      } finally {\n        this.Ct = !1, a ? this.xf() : this.xw();\n      }\n    }\n  };\n  S.prototype.computePoints = function () {\n    var a = this.diagram;\n    if (null === a) return !1;\n    var b = this.fromNode,\n      c = null;\n    null === b ? (a.rh || (a.Tl = new W(), a.Tl.desiredSize = Mb, a.Tl.strokeWidth = 0, a.rh = new V(), a.rh.add(a.Tl), a.rh.Ta()), this.defaultFromPoint && (a.rh.position = a.rh.location = this.defaultFromPoint, a.rh.Ta(), b = a.rh, c = a.Tl)) : c = this.fromPort;\n    if (null !== c && !b.isVisible()) {\n      var d = b.findVisibleNode();\n      null !== d && d !== b ? (b = d, c = d.port) : b = d;\n    }\n    this.Kx = b;\n    if (null === b || !b.location.u()) return !1;\n    for (; !(null === c || c.actualBounds.u() && c.Ff());) c = c.panel;\n    if (null === c) return !1;\n    var e = this.toNode,\n      f = null;\n    null === e ? (a.sh || (a.Ul = new W(), a.Ul.desiredSize = Mb, a.Ul.strokeWidth = 0, a.sh = new V(), a.sh.add(a.Ul), a.sh.Ta()), this.defaultToPoint && (a.sh.position = a.sh.location = this.defaultToPoint, a.sh.Ta(), e = a.sh, f = a.Ul)) : f = this.toPort;\n    null === f || e.isVisible() || (a = e.findVisibleNode(), null !== a && a !== e ? (e = a, f = a.port) : e = a);\n    this.Lx = e;\n    if (null === e || !e.location.u()) return !1;\n    for (; !(null === f || f.actualBounds.u() && f.Ff());) f = f.panel;\n    if (null === f) return !1;\n    var g = this.pointsCount;\n    d = this.computeSpot(!0, c);\n    a = this.computeSpot(!1, f);\n    var h = lp(d),\n      k = lp(a),\n      l = c === f && null !== c,\n      m = this.isOrthogonal,\n      n = this.curve === pg;\n    this.Uf = l && !m ? n = !0 : !1;\n    var p = this.computeAdjusting() === bg || l;\n    if (!m && !l && h && k) {\n      if (h = !1, !p && 3 <= g && (p = this.getLinkPoint(b, c, d, !0, !1, e, f), k = this.getLinkPoint(e, f, a, !1, !1, b, c), h = this.adjustPoints(0, p, g - 1, k)) && (p = this.getLinkPoint(b, c, d, !0, !1, e, f), k = this.getLinkPoint(e, f, a, !1, !1, b, c), this.adjustPoints(0, p, g - 1, k)), !h) if (this.lk(), n) {\n        g = this.getLinkPoint(b, c, d, !0, !1, e, f);\n        p = this.getLinkPoint(e, f, a, !1, !1, b, c);\n        h = p.x - g.x;\n        k = p.y - g.y;\n        l = this.computeCurviness();\n        n = m = 0;\n        var r = g.x + h / 3,\n          q = g.y + k / 3,\n          u = r,\n          v = q;\n        K.A(k, 0) ? v = 0 < h ? v - l : v + l : (m = -h / k, n = Math.sqrt(l * l / (m * m + 1)), 0 > l && (n = -n), u = (0 > k ? -1 : 1) * n + r, v = m * (u - r) + q);\n        r = g.x + 2 * h / 3;\n        q = g.y + 2 * k / 3;\n        var w = r,\n          y = q;\n        K.A(k, 0) ? y = 0 < h ? y - l : y + l : (w = (0 > k ? -1 : 1) * n + r, y = m * (w - r) + q);\n        this.lk();\n        this.Be(g);\n        this.vf(u, v);\n        this.vf(w, y);\n        this.Be(p);\n        this.od(0, this.getLinkPoint(b, c, d, !0, !1, e, f));\n        this.od(3, this.getLinkPoint(e, f, a, !1, !1, b, c));\n      } else d = this.getLinkPoint(b, c, d, !0, !1, e, f), a = this.getLinkPoint(e, f, a, !1, !1, b, c), this.hasCurviness() ? (p = a.x - d.x, e = a.y - d.y, f = this.computeCurviness(), b = d.x + p / 2, c = d.y + e / 2, g = b, h = c, K.A(e, 0) ? h = 0 < p ? h - f : h + f : (p = -p / e, g = Math.sqrt(f * f / (p * p + 1)), 0 > f && (g = -g), g = (0 > e ? -1 : 1) * g + b, h = p * (g - b) + c), this.Be(d), this.vf(g, h)) : this.Be(d), this.Be(a);\n    } else {\n      n = this.isAvoiding;\n      p && (m && n || l) && this.lk();\n      var z = l ? this.computeCurviness() : 0;\n      n = this.getLinkPoint(b, c, d, !0, m, e, f);\n      r = u = q = 0;\n      if (m || !h || l) v = this.computeEndSegmentLength(b, c, d, !0), r = this.getLinkDirection(b, c, n, d, !0, m, e, f), l && (h || d.w(a) || !m && 1 === d.x + a.x && 1 === d.y + a.y) && (r -= m ? 90 : 30, 0 > z && (r -= 180)), 0 > r ? r += 360 : 360 <= r && (r -= 360), l && (v += Math.abs(z) * (m ? 1 : 2)), 0 === r ? q = v : 90 === r ? u = v : 180 === r ? q = -v : 270 === r ? u = -v : (q = v * Math.cos(r * Math.PI / 180), u = v * Math.sin(r * Math.PI / 180)), d.mc() && l && (v = c.ga(Bc, J.alloc()), w = J.allocAt(v.x + 1E3 * q, v.y + 1E3 * u), this.getLinkPointFromPoint(b, c, v, w, !0, n), J.free(v), J.free(w));\n      v = this.getLinkPoint(e, f, a, !1, m, b, c);\n      var A = y = w = 0;\n      if (m || !k || l) {\n        var C = this.computeEndSegmentLength(e, f, a, !1);\n        A = this.getLinkDirection(e, f, v, a, !1, m, b, c);\n        l && (k || d.w(a) || !m && 1 === d.x + a.x && 1 === d.y + a.y) && (A += m ? 0 : 30, 0 > z && (A += 180));\n        0 > A ? A += 360 : 360 <= A && (A -= 360);\n        l && (C += Math.abs(z) * (m ? 1 : 2));\n        0 === A ? w = C : 90 === A ? y = C : 180 === A ? w = -C : 270 === A ? y = -C : (w = C * Math.cos(A * Math.PI / 180), y = C * Math.sin(A * Math.PI / 180));\n        a.mc() && l && (a = f.ga(Bc, J.alloc()), d = J.allocAt(a.x + 1E3 * w, a.y + 1E3 * y), this.getLinkPointFromPoint(e, f, a, d, !1, v), J.free(a), J.free(d));\n      }\n      a = n;\n      if (m || !h || l) a = new J(n.x + q, n.y + u);\n      d = v;\n      if (m || !k || l) d = new J(v.x + w, v.y + y);\n      !p && !m && h && 3 < g && this.adjustPoints(0, n, g - 2, d) ? this.od(g - 1, v) : !p && !m && k && 3 < g && this.adjustPoints(1, a, g - 1, v) ? this.od(0, n) : !p && (m ? 6 <= g : 4 < g) && this.adjustPoints(1, a, g - 2, d) ? (this.od(0, n), this.od(g - 1, v)) : (this.lk(), this.Be(n), (m || !h || l) && this.Be(a), m && this.addOrthoPoints(a, r, d, A, b, e), (m || !k || l) && this.Be(d), this.Be(v));\n    }\n    return !0;\n  };\n  function mp(a, b) {\n    Math.abs(b.x - a.x) > Math.abs(b.y - a.y) ? (b.x >= a.x ? b.x = a.x + 9E9 : b.x = a.x - 9E9, b.y = a.y) : (b.y >= a.y ? b.y = a.y + 9E9 : b.y = a.y - 9E9, b.x = a.x);\n    return b;\n  }\n  S.prototype.getLinkPointFromPoint = function (a, b, c, d, e, f) {\n    void 0 === f && (f = new J());\n    if (null === a || null === b) return f.assign(c), f;\n    a.isVisible() || (e = a.findVisibleNode(), null !== e && e !== a && (b = e.port));\n    a = null;\n    e = b.panel;\n    null === e || e.de() || (e = e.panel);\n    if (null === e) {\n      e = d.x;\n      d = d.y;\n      var g = c.x;\n      c = c.y;\n    } else {\n      a = e.Ad;\n      e = 1 / (a.m11 * a.m22 - a.m12 * a.m21);\n      g = a.m22 * e;\n      var h = -a.m12 * e,\n        k = -a.m21 * e,\n        l = a.m11 * e,\n        m = e * (a.m21 * a.dy - a.m22 * a.dx),\n        n = e * (a.m12 * a.dx - a.m11 * a.dy);\n      e = d.x * g + d.y * k + m;\n      d = d.x * h + d.y * l + n;\n      g = c.x * g + c.y * k + m;\n      c = c.x * h + c.y * l + n;\n    }\n    b.vk(e, d, g, c, f);\n    null !== a && f.transform(a);\n    return f;\n  };\n  function np(a, b) {\n    var c = b.tp;\n    null === c && (c = new op(), c.port = b, c.node = b.part, b.tp = c);\n    return pp(c, a);\n  }\n  S.prototype.getLinkPoint = function (a, b, c, d, e, f, g, h) {\n    void 0 === h && (h = new J());\n    if (c.ib() && !lp(c)) return b.ga(c, h), h;\n    if (c.Mc()) {\n      var k = np(this, b);\n      if (null !== k) {\n        h.assign(k.Qq);\n        if (e && this.routing === qp) {\n          var l = np(this, g);\n          if (null !== l && k.qm < l.qm) {\n            k = J.alloc();\n            l = J.alloc();\n            var m = new N(b.ga(wc, k), b.ga(Hc, l)),\n              n = this.computeSpot(!d, g);\n            a = this.getLinkPoint(f, g, n, !d, e, a, b, l);\n            (c.Df(Jc) || c.Df(Kc)) && a.y >= m.y && a.y <= m.y + m.height ? h.y = a.y : (c.Df(Ic) || c.Df(Lc)) && a.x >= m.x && a.x <= m.x + m.width && (h.x = a.x);\n            J.free(k);\n            J.free(l);\n          }\n        }\n        return h;\n      }\n    }\n    c = b.ga(.5 === c.x && .5 === c.y ? c : Bc, J.alloc());\n    this.pointsCount > (e ? 6 : 2) ? (g = d ? this.i(1) : this.i(this.pointsCount - 2), e && (g = mp(c, g.copy()))) : (k = this.computeSpot(!d, g), f = J.alloc(), g = g.ga(.5 === k.x && .5 === k.y ? k : Bc, f), e && (g = mp(c, g)), J.free(f));\n    this.getLinkPointFromPoint(a, b, c, g, d, h);\n    J.free(c);\n    return h;\n  };\n  S.prototype.getLinkDirection = function (a, b, c, d, e, f, g, h) {\n    a: if (d.ib()) var k = d.x > d.y ? d.x > 1 - d.y ? 0 : d.x < 1 - d.y ? 270 : 315 : d.x < d.y ? d.x > 1 - d.y ? 90 : d.x < 1 - d.y ? 180 : 135 : .5 > d.x ? 225 : .5 < d.x ? 45 : 0;else {\n      if (d.Mc() && (k = np(this, b), null !== k)) switch (k.Ac) {\n        case 1:\n          k = 270;\n          break a;\n        case 2:\n          k = 180;\n          break a;\n        default:\n        case 4:\n          k = 0;\n          break a;\n        case 8:\n          k = 90;\n          break a;\n      }\n      k = b.ga(Bc, J.alloc());\n      this.pointsCount > (f ? 6 : 2) ? (h = e ? this.i(1) : this.i(this.pointsCount - 2), h = f ? mp(k, h.copy()) : c) : (c = J.alloc(), h = h.ga(Bc, c), J.free(c));\n      c = Math.abs(h.x - k.x) > Math.abs(h.y - k.y) ? h.x >= k.x ? 0 : 180 : h.y >= k.y ? 90 : 270;\n      J.free(k);\n      k = c;\n    }\n    d.mc() && g.Cd(a) && (k += 180, 360 <= k && (k -= 360));\n    if (lp(d)) return k;\n    a = b.lj();\n    if (0 === a) return k;\n    45 <= a && 135 > a ? k += 90 : 135 <= a && 225 > a ? k += 180 : 225 <= a && 315 > a && (k += 270);\n    360 <= k && (k -= 360);\n    return k;\n  };\n  S.prototype.computeEndSegmentLength = function (a, b, c, d) {\n    if (null !== b && c.Mc() && (a = np(this, b), null !== a)) return a.Ov;\n    a = d ? this.fromEndSegmentLength : this.toEndSegmentLength;\n    null !== b && isNaN(a) && (a = d ? b.fromEndSegmentLength : b.toEndSegmentLength);\n    isNaN(a) && (a = 10);\n    return a;\n  };\n  S.prototype.computeSpot = function (a, b) {\n    void 0 === b && (b = null);\n    a ? (a = b ? b : this.fromPort, null === a ? a = Bc : (b = this.fromSpot, b.Mb() && (b = a.fromSpot), a = b === ad ? vc : b)) : (a = b ? b : this.toPort, null === a ? a = Bc : (b = this.toSpot, b.Mb() && (b = a.toSpot), a = b === ad ? vc : b));\n    return a;\n  };\n  function lp(a) {\n    return a === vc || .5 === a.x && .5 === a.y;\n  }\n  S.prototype.computeOtherPoint = function (a, b) {\n    if (this.computeAdjusting() !== bg && 4 < this.pointsCount) return this.computeMidPoint(new J());\n    a = b.ga(Bc);\n    b = b.tp;\n    b = null !== b ? pp(b, this) : null;\n    null !== b && (a = b.Qq);\n    return a;\n  };\n  S.prototype.computeShortLength = function (a) {\n    if (a) {\n      a = this.fromShortLength;\n      if (isNaN(a)) {\n        var b = this.fromPort;\n        null !== b && (a = b.fromShortLength);\n      }\n      return isNaN(a) ? 0 : a;\n    }\n    a = this.toShortLength;\n    isNaN(a) && (b = this.toPort, null !== b && (a = b.toShortLength));\n    return isNaN(a) ? 0 : a;\n  };\n  S.prototype.zf = function (a, b, c, d, e, f) {\n    if (!1 === this.pickable) return !1;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var g = f;\n    void 0 === f && (g = rd.alloc(), g.reset());\n    g.multiply(this.transform);\n    if (this.Jh(a, g)) return fn(this, b, c, e), void 0 === f && rd.free(g), !0;\n    if (this.Lc(a, g)) {\n      var h = !1;\n      if (!this.isAtomic) for (var k = this.W.j, l = k.length; l--;) {\n        var m = k[l];\n        if (m.visible || m === this.locationObject) {\n          var n = m.actualBounds,\n            p = this.naturalBounds;\n          if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {\n            n = rd.alloc();\n            n.set(g);\n            if (m instanceof X) h = m.zf(a, b, c, d, e, n);else if (this.path === m) {\n              if (m instanceof W) if (h = a, p = d, !1 === m.pickable) h = !1;else if (n.multiply(m.transform), p) b: {\n                var r = h,\n                  q = n;\n                if (m.Jh(r, q)) h = !0;else {\n                  if (void 0 === q && (q = m.transform, r.De(m.actualBounds))) {\n                    h = !0;\n                    break b;\n                  }\n                  h = r.left;\n                  p = r.right;\n                  var u = r.top;\n                  r = r.bottom;\n                  var v = J.alloc(),\n                    w = J.alloc(),\n                    y = J.alloc(),\n                    z = rd.alloc();\n                  z.set(q);\n                  z.iw(m.transform);\n                  z.St();\n                  w.x = p;\n                  w.y = u;\n                  w.transform(z);\n                  v.x = h;\n                  v.y = u;\n                  v.transform(z);\n                  q = !1;\n                  Gn(m, v, w, y) ? q = !0 : (v.x = p, v.y = r, v.transform(z), Gn(m, v, w, y) ? q = !0 : (w.x = h, w.y = r, w.transform(z), Gn(m, v, w, y) ? q = !0 : (v.x = h, v.y = u, v.transform(z), Gn(m, v, w, y) && (q = !0))));\n                  rd.free(z);\n                  J.free(v);\n                  J.free(w);\n                  J.free(y);\n                  h = q;\n                }\n              } else h = m.Jh(h, n);\n            } else h = jl(m, a, d, n);\n            h && (p = m, null !== b && (p = b(m)), p && (null === c || c(p)) && e.add(p));\n            rd.free(n);\n          }\n        }\n      }\n      void 0 === f && rd.free(g);\n      return h || null !== this.background || null !== this.areaBackground;\n    }\n    void 0 === f && rd.free(g);\n    return !1;\n  };\n  S.prototype.computeCurve = function () {\n    if (null === this.Uf) {\n      var a = this.fromPort,\n        b = this.isOrthogonal;\n      this.Uf = null !== a && a === this.toPort && !b;\n    }\n    return this.Uf ? pg : this.curve;\n  };\n  S.prototype.computeCorner = function () {\n    if (this.curve === pg) return 0;\n    var a = this.corner;\n    if (isNaN(a) || 0 > a) a = 10;\n    return a;\n  };\n  S.prototype.findMidLabel = function () {\n    for (var a = this.path, b = this.W.j, c = b.length, d = 0; d < c; d++) {\n      var e = b[d];\n      if (e !== a && !e.isPanelMain && (-Infinity === e.segmentIndex || isNaN(e.segmentIndex))) return e;\n    }\n    for (a = this.labelNodes; a.next();) if (b = a.value, -Infinity === b.segmentIndex || isNaN(b.segmentIndex)) return b;\n    return null;\n  };\n  S.prototype.computeSpacing = function () {\n    if (!this.isVisible()) return 0;\n    var a = rp;\n    a = Math.max(a, this.computeThickness());\n    var b = this.fromPort,\n      c = this.toPort;\n    if (null !== b && null !== c) {\n      var d = this.findMidLabel();\n      if (null !== d) {\n        var e = d.naturalBounds,\n          f = d.margin,\n          g = isNaN(e.width) ? 30 : e.width * d.scale + f.left + f.right;\n        e = isNaN(e.height) ? 14 : e.height * d.scale + f.top + f.bottom;\n        d = d.segmentOrientation;\n        d === Um || d === Vm || d === fp ? a = Math.max(a, e) : d === Pm || d === Qm || d === Nm || d === Om ? a = Math.max(a, g) : (b = b.ga(Bc).Sa(c.ga(Bc)) / 180 * Math.PI, a = Math.max(a, Math.abs(Math.sin(b) * g) + Math.abs(Math.cos(b) * e) + 1));\n        this.curve === pg && (a *= 1.333);\n      }\n    }\n    return a;\n  };\n  S.prototype.arrangeBundledLinks = function (a, b) {\n    if (b) for (b = 0; b < a.length; b++) {\n      var c = a[b];\n      c.computeAdjusting() === bg && c.Ua();\n    }\n  };\n  S.prototype.computeCurviness = function () {\n    var a = this.curviness;\n    if (isNaN(a)) {\n      a = sp;\n      var b = this.Lf;\n      if (null !== b) {\n        for (var c = Ea(), d = 0, e = b.links, f = 0; f < e.length; f++) {\n          var g = e[f].computeSpacing();\n          c.push(g);\n          d += g;\n        }\n        d = -d / 2;\n        for (f = 0; f < e.length; f++) {\n          if (e[f] === this) {\n            a = d + c[f] / 2;\n            break;\n          }\n          d += c[f];\n        }\n        b.$t === this.fromNode && (a = -a);\n        Ha(c);\n      }\n    }\n    return a;\n  };\n  S.prototype.computeThickness = function () {\n    if (!this.isVisible()) return 0;\n    var a = this.path;\n    return null !== a ? Math.max(a.strokeWidth, 1) : 1;\n  };\n  S.prototype.hasCurviness = function () {\n    return !isNaN(this.curviness) || null !== this.Lf;\n  };\n  S.prototype.adjustPoints = function (a, b, c, d) {\n    var e = this.computeAdjusting();\n    if (this.isOrthogonal) {\n      if (e === dp) return !1;\n      e === ep && (e = cp);\n    }\n    switch (e) {\n      case dp:\n        var f = this.i(a),\n          g = this.i(c);\n        if (!f.Na(b) || !g.Na(d)) {\n          e = f.x;\n          f = f.y;\n          var h = g.x - e,\n            k = g.y - f,\n            l = Math.sqrt(h * h + k * k);\n          if (!K.$(l, 0)) {\n            if (K.$(h, 0)) var m = 0 > k ? -Math.PI / 2 : Math.PI / 2;else m = Math.atan(k / Math.abs(h)), 0 > h && (m = Math.PI - m);\n            g = b.x;\n            var n = b.y;\n            h = d.x - g;\n            var p = d.y - n;\n            k = Math.sqrt(h * h + p * p);\n            K.$(h, 0) ? p = 0 > p ? -Math.PI / 2 : Math.PI / 2 : (p = Math.atan(p / Math.abs(h)), 0 > h && (p = Math.PI - p));\n            l = k / l;\n            m = p - m;\n            this.od(a, b);\n            for (a += 1; a < c; a++) b = this.i(a), h = b.x - e, k = b.y - f, b = Math.sqrt(h * h + k * k), K.$(b, 0) || (K.$(h, 0) ? k = 0 > k ? -Math.PI / 2 : Math.PI / 2 : (k = Math.atan(k / Math.abs(h)), 0 > h && (k = Math.PI - k)), h = k + m, b *= l, this.K(a, g + b * Math.cos(h), n + b * Math.sin(h)));\n            this.od(c, d);\n          }\n        }\n        return !0;\n      case ep:\n        f = this.i(a);\n        n = this.i(c);\n        if (!f.Na(b) || !n.Na(d)) {\n          e = f.x;\n          f = f.y;\n          g = n.x;\n          n = n.y;\n          l = (g - e) * (g - e) + (n - f) * (n - f);\n          h = b.x;\n          m = b.y;\n          k = d.x;\n          p = d.y;\n          var r = 1;\n          if (0 !== k - h) {\n            var q = (p - m) / (k - h);\n            r = Math.sqrt(1 + 1 / (q * q));\n          } else q = 9E9;\n          this.od(a, b);\n          for (a += 1; a < c; a++) {\n            b = this.i(a);\n            var u = b.x,\n              v = b.y,\n              w = .5;\n            0 !== l && (w = ((e - u) * (e - g) + (f - v) * (f - n)) / l);\n            var y = e + w * (g - e),\n              z = f + w * (n - f);\n            b = Math.sqrt((u - y) * (u - y) + (v - z) * (v - z));\n            v < q * (u - y) + z && (b = -b);\n            0 < q && (b = -b);\n            u = h + w * (k - h);\n            w = m + w * (p - m);\n            0 !== q ? (b = u + b / r, this.K(a, b, w - (b - u) / q)) : this.K(a, u, w + b);\n          }\n          this.od(c, d);\n        }\n        return !0;\n      case cp:\n        a: {\n          if (this.isOrthogonal && (e = this.i(a), f = this.i(a + 1), g = this.i(a + 2), h = f.x, m = f.y, n = h, l = m, K.A(e.y, f.y) ? K.A(f.x, g.x) ? m = b.y : K.A(f.y, g.y) && (h = b.x) : K.A(e.x, f.x) && (K.A(f.y, g.y) ? h = b.x : K.A(f.x, g.x) && (m = b.y)), this.K(a + 1, h, m), e = this.i(c), f = this.i(c - 1), g = this.i(c - 2), h = f.x, m = f.y, k = h, p = m, K.A(e.y, f.y) ? K.A(f.x, g.x) ? m = d.y : K.A(f.y, g.y) && (h = d.x) : K.A(e.x, f.x) && (K.A(f.y, g.y) ? h = d.x : K.A(f.x, g.x) && (m = d.y)), this.K(c - 1, h, m), Qj(this))) {\n            this.K(a + 1, n, l);\n            this.K(c - 1, k, p);\n            c = !1;\n            break a;\n          }\n          this.od(a, b);\n          this.od(c, d);\n          c = !0;\n        }\n        return c;\n      default:\n        return !1;\n    }\n  };\n  S.prototype.addOrthoPoints = function (a, b, c, d, e, f) {\n    b = -45 <= b && 45 > b ? 0 : 45 <= b && 135 > b ? 90 : 135 <= b && 225 > b ? 180 : 270;\n    d = -45 <= d && 45 > d ? 0 : 45 <= d && 135 > d ? 90 : 135 <= d && 225 > d ? 180 : 270;\n    var g = e.actualBounds.copy(),\n      h = f.actualBounds.copy();\n    if (g.u() && h.u()) {\n      g.Ic(tp, tp);\n      h.Ic(tp, tp);\n      g.Me(a);\n      h.Me(c);\n      if (0 === b) {\n        if (c.x > a.x || 270 === d && c.y < a.y && h.right > a.x || 90 === d && c.y > a.y && h.right > a.x) {\n          var k = new J(c.x, a.y);\n          var l = new J(c.x, (a.y + c.y) / 2);\n          180 === d ? (k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), l.x = k.x, l.y = c.y) : 270 === d && c.y < a.y || 90 === d && c.y > a.y ? (k.x = a.x < h.left ? this.computeMidOrthoPosition(a.x, a.y, h.left, c.y, !1) : a.x < h.right && (270 === d && a.y < h.top || 90 === d && a.y > h.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : h.right, l.x = k.x, l.y = c.y) : 0 === d && a.x < h.left && a.y > h.top && a.y < h.bottom && (k.x = a.x, k.y = a.y < c.y ? Math.min(c.y, h.top) : Math.max(c.y, h.bottom), l.y = k.y);\n        } else {\n          k = new J(a.x, c.y);\n          l = new J((a.x + c.x) / 2, c.y);\n          if (180 === d || 90 === d && c.y < g.top || 270 === d && c.y > g.bottom) 180 === d && (h.aa(a) || g.aa(c)) ? k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : c.y < a.y && (180 === d || 90 === d) ? k.y = this.computeMidOrthoPosition(a.x, g.top, c.x, Math.max(c.y, h.bottom), !0) : c.y > a.y && (180 === d || 270 === d) && (k.y = this.computeMidOrthoPosition(a.x, g.bottom, c.x, Math.min(c.y, h.top), !0)), l.x = c.x, l.y = k.y;\n          if (k.y > g.top && k.y < g.bottom) if (c.x >= g.left && c.x <= a.x || a.x <= h.right && a.x >= c.x) {\n            if (90 === d || 270 === d) k = new J(Math.max((a.x + c.x) / 2, a.x), a.y), l = new J(k.x, c.y);\n          } else k.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 0 === d ? g.top : Math.min(g.top, h.top)) : Math.max(c.y, 0 === d ? g.bottom : Math.max(g.bottom, h.bottom)), l.x = c.x, l.y = k.y;\n        }\n      } else if (180 === b) {\n        if (c.x < a.x || 270 === d && c.y < a.y && h.left < a.x || 90 === d && c.y > a.y && h.left < a.x) k = new J(c.x, a.y), l = new J(c.x, (a.y + c.y) / 2), 0 === d ? (k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), l.x = k.x, l.y = c.y) : 270 === d && c.y < a.y || 90 === d && c.y > a.y ? (k.x = a.x > h.right ? this.computeMidOrthoPosition(a.x, a.y, h.right, c.y, !1) : a.x > h.left && (270 === d && a.y < h.top || 90 === d && a.y > h.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : h.left, l.x = k.x, l.y = c.y) : 180 === d && a.x > h.right && a.y > h.top && a.y < h.bottom && (k.x = a.x, k.y = a.y < c.y ? Math.min(c.y, h.top) : Math.max(c.y, h.bottom), l.y = k.y);else {\n          k = new J(a.x, c.y);\n          l = new J((a.x + c.x) / 2, c.y);\n          if (0 === d || 90 === d && c.y < g.top || 270 === d && c.y > g.bottom) 0 === d && (h.aa(a) || g.aa(c)) ? k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : c.y < a.y && (0 === d || 90 === d) ? k.y = this.computeMidOrthoPosition(a.x, g.top, c.x, Math.max(c.y, h.bottom), !0) : c.y > a.y && (0 === d || 270 === d) && (k.y = this.computeMidOrthoPosition(a.x, g.bottom, c.x, Math.min(c.y, h.top), !0)), l.x = c.x, l.y = k.y;\n          if (k.y > g.top && k.y < g.bottom) if (c.x <= g.right && c.x >= a.x || a.x >= h.left && a.x <= c.x) {\n            if (90 === d || 270 === d) k = new J(Math.min((a.x + c.x) / 2, a.x), a.y), l = new J(k.x, c.y);\n          } else k.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 180 === d ? g.top : Math.min(g.top, h.top)) : Math.max(c.y, 180 === d ? g.bottom : Math.max(g.bottom, h.bottom)), l.x = c.x, l.y = k.y;\n        }\n      } else if (90 === b) {\n        if (c.y > a.y || 180 === d && c.x < a.x && h.bottom > a.y || 0 === d && c.x > a.x && h.bottom > a.y) k = new J(a.x, c.y), l = new J((a.x + c.x) / 2, c.y), 270 === d ? (k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), l.x = c.x, l.y = k.y) : 180 === d && c.x < a.x || 0 === d && c.x > a.x ? (k.y = a.y < h.top ? this.computeMidOrthoPosition(a.x, a.y, c.x, h.top, !0) : a.y < h.bottom && (180 === d && a.x < h.left || 0 === d && a.x > h.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : h.bottom, l.x = c.x, l.y = k.y) : 90 === d && a.y < h.top && a.x > h.left && a.x < h.right && (k.x = a.x < c.x ? Math.min(c.x, h.left) : Math.max(c.x, h.right), k.y = a.y, l.x = k.x);else {\n          k = new J(c.x, a.y);\n          l = new J(c.x, (a.y + c.y) / 2);\n          if (270 === d || 0 === d && c.x < g.left || 180 === d && c.x > g.right) 270 === d && (h.aa(a) || g.aa(c)) ? k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : c.x < a.x && (270 === d || 0 === d) ? k.x = this.computeMidOrthoPosition(g.left, a.y, Math.max(c.x, h.right), c.y, !1) : c.x > a.x && (270 === d || 180 === d) && (k.x = this.computeMidOrthoPosition(g.right, a.y, Math.min(c.x, h.left), c.y, !1)), l.x = k.x, l.y = c.y;\n          if (k.x > g.left && k.x < g.right) if (c.y >= g.top && c.y <= a.y || a.y <= h.bottom && a.y >= c.y) {\n            if (0 === d || 180 === d) k = new J(a.x, Math.max((a.y + c.y) / 2, a.y)), l = new J(c.x, k.y);\n          } else k.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 90 === d ? g.left : Math.min(g.left, h.left)) : Math.max(c.x, 90 === d ? g.right : Math.max(g.right, h.right)), l.x = k.x, l.y = c.y;\n        }\n      } else if (c.y < a.y || 180 === d && c.x < a.x && h.top < a.y || 0 === d && c.x > a.x && h.top < a.y) k = new J(a.x, c.y), l = new J((a.x + c.x) / 2, c.y), 90 === d ? (k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), l.x = c.x, l.y = k.y) : 180 === d && c.x < a.x || 0 === d && c.x >= a.x ? (k.y = a.y > h.bottom ? this.computeMidOrthoPosition(a.x, a.y, c.x, h.bottom, !0) : a.y > h.top && (180 === d && a.x < h.left || 0 === d && a.x > h.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : h.top, l.x = c.x, l.y = k.y) : 270 === d && a.y > h.bottom && a.x > h.left && a.x < h.right && (k.x = a.x < c.x ? Math.min(c.x, h.left) : Math.max(c.x, h.right), k.y = a.y, l.x = k.x);else {\n        k = new J(c.x, a.y);\n        l = new J(c.x, (a.y + c.y) / 2);\n        if (90 === d || 0 === d && c.x < g.left || 180 === d && c.x > g.right) 90 === d && (h.aa(a) || g.aa(c)) ? k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : c.x < a.x && (90 === d || 0 === d) ? k.x = this.computeMidOrthoPosition(g.left, a.y, Math.max(c.x, h.right), c.y, !1) : c.x > a.x && (90 === d || 180 === d) && (k.x = this.computeMidOrthoPosition(g.right, a.y, Math.min(c.x, h.left), c.y, !1)), l.x = k.x, l.y = c.y;\n        if (k.x > g.left && k.x < g.right) if (c.y <= g.bottom && c.y >= a.y || a.y >= h.top && a.y <= c.y) {\n          if (0 === d || 180 === d) k = new J(a.x, Math.min((a.y + c.y) / 2, a.y)), l = new J(c.x, k.y);\n        } else k.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 270 === d ? g.left : Math.min(g.left, h.left)) : Math.max(c.x, 270 === d ? g.right : Math.max(g.right, h.right)), l.x = k.x, l.y = c.y;\n      }\n      var m = k,\n        n = l,\n        p = c;\n      if (this.isAvoiding) {\n        var r = this.diagram;\n        if (null === r || !sk(r) || g.aa(p) && !f.Cd(e) || h.aa(a) && !e.Cd(f) || e === f || this.layer.isTemporary) b = !1;else {\n          var q = tk(r, !0, this.containingGroup, null);\n          if (17 !== this.segmentIndex && q.zk(Math.min(a.x, m.x), Math.min(a.y, m.y), Math.abs(a.x - m.x), Math.abs(a.y - m.y)) && q.zk(Math.min(m.x, n.x), Math.min(m.y, n.y), Math.abs(m.x - n.x), Math.abs(m.y - n.y)) && q.zk(Math.min(n.x, p.x), Math.min(n.y, p.y), Math.abs(n.x - p.x), Math.abs(n.y - p.y))) b = !1;else {\n            e = a;\n            f = p;\n            var u = c = null;\n            if (r.isVirtualized) {\n              r = q.bounds.copy();\n              r.Ic(-q.xq, -q.wq);\n              var v = J.alloc();\n              xk(q, a.x, a.y) || (K.bd(r.x, r.y, r.x + r.width, r.y + r.height, a.x, a.y, m.x, m.y, v) ? (c = a = v.copy(), b = v.Sa(m)) : K.bd(r.x, r.y, r.x + r.width, r.y + r.height, m.x, m.y, n.x, n.y, v) ? (c = a = v.copy(), b = v.Sa(n)) : K.bd(r.x, r.y, r.x + r.width, r.y + r.height, n.x, n.y, p.x, p.y, v) && (c = a = v.copy(), b = v.Sa(p)));\n              xk(q, p.x, p.y) || (K.bd(r.x, r.y, r.x + r.width, r.y + r.height, p.x, p.y, n.x, n.y, v) ? (u = p = v.copy(), d = n.Sa(v)) : K.bd(r.x, r.y, r.x + r.width, r.y + r.height, n.x, n.y, m.x, m.y, v) ? (u = p = v.copy(), d = m.Sa(v)) : K.bd(r.x, r.y, r.x + r.width, r.y + r.height, m.x, m.y, a.x, a.y, v) && (u = p = v.copy(), d = a.Sa(v)));\n              J.free(v);\n            }\n            g = g.copy().Oc(h);\n            g.Ic(q.xq * q.Ty, q.wq * q.Ty);\n            up(q, a, b, p, d, g, !0);\n            h = vp(q, p.x, p.y);\n            !q.abort && h >= wp && (wk(q), g.Ic(q.xq * q.Dy, q.wq * q.Dy), up(q, a, b, p, d, g, !1), h = vp(q, p.x, p.y));\n            if (!q.abort && h < wp && vp(q, p.x, p.y) !== yk) {\n              xp(this, q, p.x, p.y, d, !0);\n              h = this.i(2);\n              if (4 > this.pointsCount) 0 === b || 180 === b ? (h.x = a.x, h.y = p.y) : (h.x = p.x, h.y = a.y), this.K(2, h.x, h.y), this.m(3, h.x, h.y);else if (g = this.i(3), 0 === b || 180 === b) K.A(h.x, g.x) ? (h = 0 === b ? Math.max(h.x, a.x) : Math.min(h.x, a.x), this.K(2, h, a.y), this.K(3, h, g.y)) : K.A(h.y, g.y) ? (Math.abs(a.y - h.y) <= q.wq / 2 && (this.K(2, h.x, a.y), this.K(3, g.x, a.y)), this.m(2, h.x, a.y)) : this.K(2, a.x, h.y);else if (90 === b || 270 === b) K.A(h.y, g.y) ? (h = 90 === b ? Math.max(h.y, a.y) : Math.min(h.y, a.y), this.K(2, a.x, h), this.K(3, g.x, h)) : K.A(h.x, g.x) ? (Math.abs(a.x - h.x) <= q.xq / 2 && (this.K(2, a.x, h.y), this.K(3, a.x, g.y)), this.m(2, a.x, h.y)) : this.K(2, h.x, a.y);\n              null !== c && (a = this.i(1), g = this.i(2), a.x !== g.x && a.y !== g.y ? 0 === b || 180 === b ? this.m(2, a.x, g.y) : this.m(2, g.x, a.y) : 0 === b || 180 === b ? this.m(2, e.x, c.y) : this.m(2, c.x, e.y));\n              null !== u && (0 === d || 180 === d ? this.vf(f.x, u.y) : this.vf(u.x, f.y));\n              b = !0;\n            } else b = !1;\n          }\n        }\n      } else b = !1;\n      b || (this.Be(k), this.Be(l));\n    }\n  };\n  S.prototype.computeMidOrthoPosition = function (a, b, c, d, e) {\n    var f = 0;\n    !this.hasCurviness() || this.computeSpot(!0, this.fromPort).Mc() || this.computeSpot(!1, this.toPort).Mc() || (f = this.computeCurviness());\n    return e ? (b + d) / 2 + f : (a + c) / 2 + f;\n  };\n  function Qj(a) {\n    if (null === a.diagram || !a.isAvoiding || !sk(a.diagram)) return !1;\n    var b = a.points.j,\n      c = b.length;\n    if (4 > c) return !1;\n    a = tk(a.diagram, !0, a.containingGroup, null);\n    for (var d = 1; d < c - 2; d++) {\n      var e = b[d],\n        f = b[d + 1];\n      if (!a.zk(Math.min(e.x, f.x), Math.min(e.y, f.y), Math.abs(e.x - f.x), Math.abs(e.y - f.y))) return !0;\n    }\n    return !1;\n  }\n  function xp(a, b, c, d, e, f) {\n    var g = b.xq,\n      h = b.wq,\n      k = vp(b, c, d),\n      l = c,\n      m = d;\n    for (0 === e ? l += g : 90 === e ? m += h : 180 === e ? l -= g : m -= h; k > yp && vp(b, l, m) === k - 1;) c = l, d = m, 0 === e ? l += g : 90 === e ? m += h : 180 === e ? l -= g : m -= h, --k;\n    if (f) {\n      if (k > yp) if (180 === e || 0 === e) c = Math.floor(c / g) * g + g / 2;else if (90 === e || 270 === e) d = Math.floor(d / h) * h + h / 2;\n    } else c = Math.floor(c / g) * g + g / 2, d = Math.floor(d / h) * h + h / 2;\n    k > yp && (f = e, l = c, m = d, 0 === e ? (f = 90, m += h) : 90 === e ? (f = 180, l -= g) : 180 === e ? (f = 270, m -= h) : 270 === e && (f = 0, l += g), vp(b, l, m) === k - 1 ? xp(a, b, l, m, f, !1) : (l = c, m = d, 0 === e ? (f = 270, m -= h) : 90 === e ? (f = 0, l += g) : 180 === e ? (f = 90, m += h) : 270 === e && (f = 180, l -= g), vp(b, l, m) === k - 1 && xp(a, b, l, m, f, !1)));\n    a.vf(c, d);\n  }\n  S.prototype.Nz = function (a) {\n    var b = a.x;\n    a = a.y;\n    for (var c = this.i(0), d = this.i(1), e = Cb(b, a, c.x, c.y, d.x, d.y), f = 0, g = 1; g < this.pointsCount - 1; g++) {\n      c = this.i(g + 1);\n      var h = Cb(b, a, d.x, d.y, c.x, c.y);\n      d = c;\n      h < e && (f = g, e = h);\n    }\n    return f;\n  };\n  S.prototype.cc = function () {\n    this.Ym = !1;\n    this.o();\n  };\n  S.prototype.Bk = function (a) {\n    if (!a) {\n      if (!1 === this.dd) return;\n      a = this.pb();\n      if (this.Ym && (null === a || null !== a.geometry)) return;\n    }\n    this.na = this.makeGeometry();\n    a = this.path;\n    if (null !== a) {\n      a.na = this.na;\n      for (var b = this.W.j, c = b.length, d = 0; d < c; d++) {\n        var e = b[d];\n        e !== a && e.isPanelMain && e instanceof W && (e.na = this.na);\n      }\n    }\n  };\n  S.prototype.makeGeometry = function () {\n    var a = this.na,\n      b = this.pointsCount;\n    if (2 > b) return a.type = wd, this.Ym = !0, a;\n    var c = !1,\n      d = this.diagram;\n    null !== d && gp(this) && d.Vg.contains(this) && (0 !== this.Rl.width || 0 !== this.Rl.height) && (c = !0);\n    var e = this.i(0).copy(),\n      f = e.copy();\n    d = this.Ab.j;\n    var g = this.computeCurve();\n    if (g === pg && 3 <= b && !K.$(this.smoothness, 0)) {\n      if (3 === b) {\n        var h = this.i(1);\n        d = Math.min(e.x, h.x);\n        var k = Math.min(e.y, h.y);\n        h = this.i(2);\n        d = Math.min(d, h.x);\n        k = Math.min(k, h.y);\n      } else {\n        if (this.isOrthogonal) for (k = 0; k < b; k++) h = d[k], f.x = Math.min(h.x, f.x), f.y = Math.min(h.y, f.y);else for (d = 3; d < b; d += 3) d + 3 >= b && (d = b - 1), k = this.i(d), f.x = Math.min(k.x, f.x), f.y = Math.min(k.y, f.y);\n        d = f.x;\n        k = f.y;\n      }\n    } else {\n      for (k = 0; k < b; k++) h = d[k], f.x = Math.min(h.x, f.x), f.y = Math.min(h.y, f.y);\n      d = f.x;\n      k = f.y;\n    }\n    d -= this.vv.x;\n    k -= this.vv.y;\n    e.x -= d;\n    e.y -= k;\n    if (2 !== b || gp(this)) {\n      a.type = ud;\n      h = Kd(a);\n      0 !== this.computeShortLength(!0) && (e = zp(this, e, !0, f));\n      Ld(h, e.x, e.y, !1);\n      if (g === pg && 3 <= b && !K.$(this.smoothness, 0)) {\n        if (3 === b) c = this.i(1), b = c.x - d, c = c.y - k, e = this.i(2).copy(), e.x -= d, e.y -= k, 0 !== this.computeShortLength(!1) && (e = zp(this, e, !1, f)), Md(h, b, c, b, c, e.x, e.y);else if (this.isOrthogonal) {\n          f = new J(d, k);\n          e = this.i(1).copy();\n          g = new J(d, k);\n          b = new J(d, k);\n          c = this.i(0);\n          for (var l, m = this.smoothness / 3, n = 1; n < this.pointsCount - 1; n++) {\n            l = this.i(n);\n            var p = c,\n              r = l,\n              q = this.i(Ap(this, l, n, !1));\n            if (!K.$(p.x, r.x) || !K.$(r.x, q.x)) if (!K.$(p.y, r.y) || !K.$(r.y, q.y)) {\n              var u = m;\n              isNaN(u) && (u = this.smoothness / 3);\n              var v = p.x;\n              p = p.y;\n              var w = r.x;\n              r = r.y;\n              var y = q.x;\n              q = q.y;\n              var z = u * Bp(v, p, w, r);\n              u *= Bp(w, r, y, q);\n              K.$(p, r) && K.$(w, y) && (w > v ? q > r ? (g.x = w - z, g.y = r - z, b.x = w + u, b.y = r + u) : (g.x = w - z, g.y = r + z, b.x = w + u, b.y = r - u) : q > r ? (g.x = w + z, g.y = r - z, b.x = w - u, b.y = r + u) : (g.x = w + z, g.y = r + z, b.x = w - u, b.y = r - u));\n              K.$(v, w) && K.$(r, q) && (r > p ? (y > w ? (g.x = w - z, g.y = r - z, b.x = w + u) : (g.x = w + z, g.y = r - z, b.x = w - u), b.y = r + u) : (y > w ? (g.x = w - z, g.y = r + z, b.x = w + u) : (g.x = w + z, g.y = r + z, b.x = w - u), b.y = r - u));\n              if (K.$(v, w) && K.$(w, y) || K.$(p, r) && K.$(r, q)) v = .5 * (v + y), p = .5 * (p + q), g.x = v, g.y = p, b.x = v, b.y = p;\n              1 === n ? (e.x = .5 * (c.x + l.x), e.y = .5 * (c.y + l.y)) : 2 === n && K.$(c.x, this.i(0).x) && K.$(c.y, this.i(0).y) && (e.x = .5 * (c.x + l.x), e.y = .5 * (c.y + l.y));\n              Md(h, e.x - d, e.y - k, g.x - d, g.y - k, l.x - d, l.y - k);\n              f.set(g);\n              e.set(b);\n              c = l;\n            }\n          }\n          f = c.x;\n          c = c.y;\n          e = this.i(this.pointsCount - 1);\n          0 !== this.computeShortLength(!1) && (e = zp(this, e.copy(), !1, Hb));\n          f = .5 * (f + e.x);\n          c = .5 * (c + e.y);\n          Md(h, b.x - d, b.y - k, f - d, c - k, e.x - d, e.y - k);\n        } else for (c = 3; c < b; c += 3) f = this.i(c - 2), c + 3 >= b && (c = b - 1), e = this.i(c - 1), g = this.i(c), c === b - 1 && 0 !== this.computeShortLength(!1) && (g = zp(this, g.copy(), !1, Hb)), Md(h, f.x - d, f.y - k, e.x - d, e.y - k, g.x - d, g.y - k);\n      } else {\n        f = J.alloc();\n        f.assign(this.i(0));\n        e = J.alloc();\n        e.assign(f);\n        g = this.computeCorner();\n        n = 1;\n        for (l = 0; n < b;) {\n          n = Ap(this, f, n, 1 < n);\n          m = this.i(n);\n          if (n >= b - 1) {\n            if (!f.w(m)) 0 !== this.computeShortLength(!1) && (m = zp(this, m.copy(), !1, Hb)), Cp(this, h, -d, -k, f, m, c);else if (0 === l) for (n = 1; n < b;) e.assign(f), m = this.i(n++), Cp(this, h, -d, -k, f, m, c), f.assign(m);\n            break;\n          }\n          l = Ap(this, m, n + 1, n < b - 3);\n          n = -d;\n          v = -k;\n          p = m;\n          u = this.i(l);\n          w = c;\n          if (K.A(f.y, p.y) && K.A(p.x, u.x)) {\n            if (r = Math.min(g, Math.abs(p.x - e.x) / 2), r = y = Math.min(r, Math.abs(u.y - p.y) / 2), K.A(r, 0)) Cp(this, h, n, v, f, p, w), f.assign(p);else {\n              q = p.x;\n              z = p.y;\n              var A = q,\n                C = z;\n              p.x > f.x ? q = p.x - r : q = p.x + r;\n              u.y > p.y ? C = p.y + y : C = p.y - y;\n              Cp(this, h, n, v, f, new J(q, z), w);\n              Rd(h, p.x + n, p.y + v, A + n, C + v);\n              f.h(A, C);\n            }\n          } else K.A(f.x, p.x) && K.A(p.y, u.y) ? (r = Math.min(g, Math.abs(p.y - e.y) / 2), r = y = Math.min(r, Math.abs(u.x - p.x) / 2), K.A(y, 0) ? (Cp(this, h, n, v, f, p, w), f.assign(p)) : (q = p.x, z = p.y, A = q, C = z, p.y > f.y ? z = p.y - r : z = p.y + r, u.x > p.x ? A = p.x + y : A = p.x - y, Cp(this, h, n, v, f, new J(q, z), w), Rd(h, p.x + n, p.y + v, A + n, C + v), f.h(A, C))) : (Cp(this, h, n, v, f, p, w), f.assign(p));\n          e.assign(m);\n          n = l;\n        }\n        J.free(f);\n      }\n      Ud = h;\n    } else h = this.i(1).copy(), h.x -= d, h.y -= k, 0 !== this.computeShortLength(!0) && (e = zp(this, e, !0, f)), 0 !== this.computeShortLength(!1) && (h = zp(this, h, !1, f)), a.type = wd, a.startX = e.x, a.startY = e.y, a.endX = h.x, a.endY = h.y;\n    this.Ym = !0;\n    return a;\n  };\n  function Bp(a, b, c, d) {\n    a = c - a;\n    if (isNaN(a) || Infinity === a || -Infinity === a) return NaN;\n    0 > a && (a = -a);\n    b = d - b;\n    if (isNaN(b) || Infinity === b || -Infinity === b) return NaN;\n    0 > b && (b = -b);\n    return K.$(a, 0) ? b : K.$(b, 0) ? a : Math.sqrt(a * a + b * b);\n  }\n  function zp(a, b, c, d) {\n    var e = a.pointsCount;\n    if (2 > e) return b;\n    if (c) {\n      var f = a.i(1);\n      c = f.x - d.x;\n      f = f.y - d.y;\n      d = Bp(b.x, b.y, c, f);\n      if (0 === d) return b;\n      e = 2 === e ? .5 * d : d;\n      a = a.computeShortLength(!0);\n      a > e && (a = e);\n      e = a * (f - b.y) / d;\n      b.x += a * (c - b.x) / d;\n      b.y += e;\n    } else {\n      f = a.i(e - 2);\n      c = f.x - d.x;\n      f = f.y - d.y;\n      d = Bp(b.x, b.y, c, f);\n      if (0 === d) return b;\n      e = 2 === e ? .5 * d : d;\n      a = a.computeShortLength(!1);\n      a > e && (a = e);\n      e = a * (b.y - f) / d;\n      b.x -= a * (b.x - c) / d;\n      b.y -= e;\n    }\n    return b;\n  }\n  function Ap(a, b, c, d) {\n    for (var e = a.pointsCount, f = b; K.$(b.x, f.x) && K.$(b.y, f.y);) {\n      if (c >= e) return e - 1;\n      f = a.i(c++);\n    }\n    if (!K.$(b.x, f.x) && !K.$(b.y, f.y)) return c - 1;\n    for (var g = f; K.$(b.x, f.x) && K.$(f.x, g.x) && (!d || (b.y >= f.y ? f.y >= g.y : f.y <= g.y)) || K.$(b.y, f.y) && K.$(f.y, g.y) && (!d || (b.x >= f.x ? f.x >= g.x : f.x <= g.x));) {\n      if (c >= e) return e - 1;\n      g = a.i(c++);\n    }\n    return c - 2;\n  }\n  function Cp(a, b, c, d, e, f, g) {\n    if (!g && gp(a)) {\n      g = [];\n      var h = 0;\n      a.isVisible() && (h = Dp(a, e, f, g));\n      if (0 < h) if (K.A(e.y, f.y)) {\n        if (e.x < f.x) for (var k = 0; k < h;) {\n          var l = Math.max(e.x, Math.min(g[k++] - 5, f.x - 10));\n          b.lineTo(l + c, f.y + d);\n          var m = l + c;\n          for (var n = Math.min(l + 10, f.x); k < h;) if (l = g[k], l < n + 10) k++, n = Math.min(l + 5, f.x);else break;\n          l = f.y - 10 + d;\n          n += c;\n          var p = f.y + d;\n          a.curve === ag ? Ld(b, n, p, !1) : Md(b, m, l, n, l, n, p);\n        } else for (--h; 0 <= h;) {\n          k = Math.min(e.x, Math.max(g[h--] + 5, f.x + 10));\n          b.lineTo(k + c, f.y + d);\n          m = k + c;\n          for (l = Math.max(k - 10, f.x); 0 <= h;) if (k = g[h], k > l - 10) h--, l = Math.max(k - 5, f.x);else break;\n          k = f.y - 10 + d;\n          l += c;\n          n = f.y + d;\n          a.curve === ag ? Ld(b, l, n, !1) : Md(b, m, k, l, k, l, n);\n        }\n      } else if (K.A(e.x, f.x)) if (e.y < f.y) for (k = 0; k < h;) {\n        l = Math.max(e.y, Math.min(g[k++] - 5, f.y - 10));\n        b.lineTo(f.x + c, l + d);\n        m = l + d;\n        for (l = Math.min(l + 10, f.y); k < h;) if (n = g[k], n < l + 10) k++, l = Math.min(n + 5, f.y);else break;\n        n = f.x - 10 + c;\n        p = f.x + c;\n        l += d;\n        a.curve === ag ? Ld(b, p, l, !1) : Md(b, n, m, n, l, p, l);\n      } else for (--h; 0 <= h;) {\n        k = Math.min(e.y, Math.max(g[h--] + 5, f.y + 10));\n        b.lineTo(f.x + c, k + d);\n        m = k + d;\n        for (k = Math.max(k - 10, f.y); 0 <= h;) if (l = g[h], l > k - 10) h--, k = Math.max(l - 5, f.y);else break;\n        l = f.x - 10 + c;\n        n = f.x + c;\n        k += d;\n        a.curve === ag ? Ld(b, n, k, !1) : Md(b, l, m, l, k, n, k);\n      }\n    }\n    b.lineTo(f.x + c, f.y + d);\n  }\n  function Dp(a, b, c, d) {\n    var e = a.diagram;\n    if (null === e || b.w(c)) return 0;\n    for (e = e.layers; e.next();) {\n      var f = e.value;\n      if (null !== f && f.visible) {\n        f = f.Da.j;\n        for (var g = f.length, h = 0; h < g; h++) {\n          var k = f[h];\n          if (k instanceof S) {\n            if (k === a) return 0 < d.length && d.sort(function (a, b) {\n              return a - b;\n            }), d.length;\n            if (k.isVisible() && gp(k)) {\n              var l = k.routeBounds;\n              l.u() && a.routeBounds.Lc(l) && !a.usesSamePort(k) && (l = k.path, null !== l && l.Ff() && Ep(b, c, d, k));\n            }\n          }\n        }\n      }\n    }\n    0 < d.length && d.sort(function (a, b) {\n      return a - b;\n    });\n    return d.length;\n  }\n  function Ep(a, b, c, d) {\n    for (var e = K.A(a.y, b.y), f = d.pointsCount, g = d.i(0), h = J.alloc(), k = 1; k < f; k++) {\n      var l = d.i(k);\n      if (k < f - 1) {\n        var m = d.i(k + 1);\n        if (g.y === l.y && l.y === m.y) {\n          if (l.x > g.x && m.x >= l.x || l.x < g.x && m.x <= l.x) continue;\n        } else if (g.x === l.x && l.x === m.x && (l.y > g.y && m.y >= l.y || l.y < g.y && m.y <= l.y)) continue;\n      }\n      a: {\n        m = a.x;\n        var n = a.y,\n          p = b.x,\n          r = b.y,\n          q = g.x;\n        g = g.y;\n        var u = l.x,\n          v = l.y;\n        if (!K.A(m, p)) {\n          if (K.A(n, r) && K.A(q, u) && Math.min(m, p) < q && Math.max(m, p) > q && Math.min(g, v) < n && Math.max(g, v) > n && !K.A(g, v)) {\n            h.x = q;\n            h.y = n;\n            m = !0;\n            break a;\n          }\n        } else if (!K.A(n, r) && K.A(g, v) && Math.min(n, r) < g && Math.max(n, r) > g && Math.min(q, u) < m && Math.max(q, u) > m && !K.A(q, u)) {\n          h.x = m;\n          h.y = g;\n          m = !0;\n          break a;\n        }\n        h.x = 0;\n        h.y = 0;\n        m = !1;\n      }\n      m && (e ? c.push(h.x) : c.push(h.y));\n      g = l;\n    }\n    J.free(h);\n  }\n  function gp(a) {\n    a = a.curve;\n    return a === $f || a === ag;\n  }\n  function kp(a, b) {\n    if (b || gp(a)) b = a.diagram, null === b || b.animationManager.isTicking || b.Vg.contains(a) || 0 === a.Rl.width && 0 === a.Rl.height || b.Vg.add(a, a.Rl.copy());\n  }\n  S.prototype.Nq = function (a) {\n    var b = this.layer;\n    if (null !== b && b.visible && !b.isTemporary) {\n      var c = b.diagram;\n      if (null !== c && !c.animationManager.isTicking) {\n        var d = !1;\n        for (c = c.layers; c.next();) {\n          var e = c.value;\n          if (e.visible) if (e === b) {\n            d = !0;\n            var f = !1;\n            e = e.Da.j;\n            for (var g = e.length, h = 0; h < g; h++) {\n              var k = e[h];\n              k instanceof S && (k === this ? f = !0 : f && Fp(this, k, a));\n            }\n          } else if (d) for (f = e.Da.j, e = f.length, g = 0; g < e; g++) h = f[g], h instanceof S && Fp(this, h, a);\n        }\n      }\n    }\n  };\n  function Fp(a, b, c) {\n    if (null !== b && b.Ym && b.dd && gp(b)) {\n      var d = b.routeBounds;\n      d.u() && (a.routeBounds.Lc(d) || c.Lc(d)) && (a.usesSamePort(b) || b.cc());\n    }\n  }\n  S.prototype.usesSamePort = function (a) {\n    var b = this.pointsCount,\n      c = a.pointsCount;\n    if (0 < b && 0 < c) {\n      var d = this.i(0),\n        e = a.i(0);\n      if (d.Na(e)) return !0;\n      b = this.i(b - 1);\n      a = a.i(c - 1);\n      if (b.Na(a) || d.Na(a) || b.Na(e)) return !0;\n    } else if (this.fromNode === a.fromNode || this.toNode === a.toNode || this.fromNode === a.toNode || this.toNode === a.fromNode) return !0;\n    return !1;\n  };\n  S.prototype.isVisible = function () {\n    if (!U.prototype.isVisible.call(this)) return !1;\n    var a = this.containingGroup,\n      b = !0,\n      c = this.diagram;\n    null !== c && (b = c.isTreePathToChildren);\n    c = this.fromNode;\n    if (null !== c) {\n      if (this.isTreeLink && b && !c.isTreeExpanded) return !1;\n      if (c === a) return !0;\n      for (var d = c; null !== d;) {\n        if (d.labeledLink === this) return !0;\n        d = d.containingGroup;\n      }\n      c = c.findVisibleNode();\n      if (null === c || c === a) return !1;\n    }\n    c = this.toNode;\n    if (null !== c) {\n      if (this.isTreeLink && !b && !c.isTreeExpanded) return !1;\n      if (c === a) return !0;\n      for (b = c; null !== b;) {\n        if (b.labeledLink === this) return !0;\n        b = b.containingGroup;\n      }\n      b = c.findVisibleNode();\n      if (null === b || b === a) return !1;\n    }\n    return !0;\n  };\n  S.prototype.Ob = function (a) {\n    U.prototype.Ob.call(this, a);\n    null !== this.Lf && this.Lf.ym();\n    if (null !== this.hd) for (var b = this.hd.iterator; b.next();) b.value.Ob(a);\n  };\n  S.prototype.computeAdjusting = function () {\n    return this.isAvoiding && null !== this.diagram && this.diagram.animationManager.isAnimating ? cp : this.Rk;\n  };\n  function hp(a) {\n    var b = a.Ve;\n    if (null !== b) {\n      var c = a.rf;\n      if (null !== c) {\n        for (var d = a.We, e = a.sf, f = a = null, g = b.Ya.j, h = g.length, k = 0; k < h; k++) {\n          var l = g[k];\n          if (l.Ve === b && l.We === d && l.rf === c && l.sf === e || l.Ve === c && l.We === e && l.rf === b && l.sf === d) null === f ? f = l : (null === a && (a = [], a.push(f)), a.push(l));\n        }\n        if (null !== a) {\n          f = No(b, c, d, e);\n          null === f && (f = new Gp(b, d, c, e), Mo(b, f), Mo(c, f));\n          f.links = a;\n          for (b = 0; b < a.length; b++) a[b].Lf = f;\n          f.ym();\n        }\n      }\n    }\n  }\n  function ip(a) {\n    var b = a.Lf;\n    null !== b && (a.Lf = null, a = b.links.indexOf(a), 0 <= a && (Da(b.links, a), b.ym()));\n  }\n  S.prototype.Ph = function () {\n    return !0;\n  };\n  ma.Object.defineProperties(S.prototype, {\n    fromNode: {\n      get: function () {\n        return this.Ve;\n      },\n      set: function (a) {\n        var b = this.Ve;\n        if (b !== a) {\n          var c = this.fromPort;\n          null !== b && (this.rf !== b && Ro(b, this, c), ip(this), this.C(2));\n          this.Ve = a;\n          null !== a && this.Ob(a.isVisible());\n          this.Uf = null;\n          this.Ua();\n          var d = this.diagram;\n          null !== d && d.Z && d.partManager.setFromNodeForLink(this, a, b);\n          var e = this.fromPort,\n            f = this.fromPortChanged;\n          if (null !== f) {\n            var g = !0;\n            null !== d && (g = d.Z, d.Z = !0);\n            f(this, c, e);\n            null !== d && (d.Z = g);\n          }\n          null !== a && (this.rf !== a && Qo(a, this, e), hp(this), this.C(1));\n          this.g(\"fromNode\", b, a);\n          Ko(this);\n        }\n      }\n    },\n    fromPortId: {\n      get: function () {\n        return this.We;\n      },\n      set: function (a) {\n        var b = this.We;\n        if (b !== a) {\n          var c = this.fromPort;\n          null !== c && Oo(this.fromNode, c);\n          ip(this);\n          this.We = a;\n          var d = this.fromPort;\n          null !== d && Oo(this.fromNode, d);\n          var e = this.diagram;\n          if (null !== e) {\n            var f = this.data,\n              g = e.model;\n            null !== f && g.pj() && g.Bw(f, a);\n          }\n          c !== d && (this.Uf = null, this.Ua(), f = this.fromPortChanged, null !== f && (g = !0, null !== e && (g = e.Z, e.Z = !0), f(this, c, d), null !== e && (e.Z = g)));\n          hp(this);\n          this.g(\"fromPortId\", b, a);\n        }\n      }\n    },\n    fromPort: {\n      get: function () {\n        var a = this.Ve;\n        return null === a ? null : a.Kt(this.We);\n      }\n    },\n    fromPortChanged: {\n      get: function () {\n        return this.eo;\n      },\n      set: function (a) {\n        var b = this.eo;\n        b !== a && (this.eo = a, this.g(\"fromPortChanged\", b, a));\n      }\n    },\n    toNode: {\n      get: function () {\n        return this.rf;\n      },\n      set: function (a) {\n        var b = this.rf;\n        if (b !== a) {\n          var c = this.toPort;\n          null !== b && (this.Ve !== b && Ro(b, this, c), ip(this), this.C(2));\n          this.rf = a;\n          null !== a && this.Ob(a.isVisible());\n          this.Uf = null;\n          this.Ua();\n          var d = this.diagram;\n          null !== d && d.Z && d.partManager.setToNodeForLink(this, a, b);\n          var e = this.toPort,\n            f = this.toPortChanged;\n          if (null !== f) {\n            var g = !0;\n            null !== d && (g = d.Z, d.Z = !0);\n            f(this, c, e);\n            null !== d && (d.Z = g);\n          }\n          null !== a && (this.Ve !== a && Qo(a, this, e), hp(this), this.C(1));\n          this.g(\"toNode\", b, a);\n          Ko(this);\n        }\n      }\n    },\n    toPortId: {\n      get: function () {\n        return this.sf;\n      },\n      set: function (a) {\n        var b = this.sf;\n        if (b !== a) {\n          var c = this.toPort;\n          null !== c && Oo(this.toNode, c);\n          ip(this);\n          this.sf = a;\n          var d = this.toPort;\n          null !== d && Oo(this.toNode, d);\n          var e = this.diagram;\n          if (null !== e) {\n            var f = this.data,\n              g = e.model;\n            null !== f && g.pj() && g.Gw(f, a);\n          }\n          c !== d && (this.Uf = null, this.Ua(), f = this.toPortChanged, null !== f && (g = !0, null !== e && (g = e.Z, e.Z = !0), f(this, c, d), null !== e && (e.Z = g)));\n          hp(this);\n          this.g(\"toPortId\", b, a);\n        }\n      }\n    },\n    toPort: {\n      get: function () {\n        var a = this.rf;\n        return null === a ? null : a.Kt(this.sf);\n      }\n    },\n    toPortChanged: {\n      get: function () {\n        return this.kq;\n      },\n      set: function (a) {\n        var b = this.kq;\n        b !== a && (this.kq = a, this.g(\"toPortChanged\", b, a));\n      }\n    },\n    fromSpot: {\n      get: function () {\n        return null !== this.O ? this.O.ah : ad;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.ah;\n        if (!b.w(a)) {\n          a = a.G();\n          this.O.ah = a;\n          this.g(\"fromSpot\", b, a);\n          if (b.Mc() || a.Mc()) a = this.fromNode, null !== a && Oo(a, this.fromPort);\n          this.Ua();\n        }\n      }\n    },\n    fromEndSegmentLength: {\n      get: function () {\n        return null !== this.O ? this.O.Zg : NaN;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Zg;\n        b !== a && (0 > a && va(a, \">= 0\", S, \"fromEndSegmentLength\"), this.O.Zg = a, this.g(\"fromEndSegmentLength\", b, a), this.Ua());\n      }\n    },\n    fromShortLength: {\n      get: function () {\n        return null !== this.O ? this.O.$g : NaN;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.$g;\n        b !== a && (this.O.$g = a, this.cc(), this.g(\"fromShortLength\", b, a));\n      }\n    },\n    toSpot: {\n      get: function () {\n        return null !== this.O ? this.O.Ch : ad;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Ch;\n        if (!b.w(a)) {\n          a = a.G();\n          this.O.Ch = a;\n          this.g(\"toSpot\", b, a);\n          if (b.Mc() || a.Mc()) a = this.toNode, null !== a && Oo(a, this.toPort);\n          this.Ua();\n        }\n      }\n    },\n    toEndSegmentLength: {\n      get: function () {\n        return null !== this.O ? this.O.Ah : NaN;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Ah;\n        b !== a && (0 > a && va(a, \">= 0\", S, \"toEndSegmentLength\"), this.O.Ah = a, this.g(\"toEndSegmentLength\", b, a), this.Ua());\n      }\n    },\n    toShortLength: {\n      get: function () {\n        return null !== this.O ? this.O.Bh : NaN;\n      },\n      set: function (a) {\n        this.Jc();\n        var b = this.O.Bh;\n        b !== a && (this.O.Bh = a, this.cc(), this.g(\"toShortLength\", b, a));\n      }\n    },\n    isLabeledLink: {\n      get: function () {\n        return null === this.hd ? !1 : 0 < this.hd.count;\n      }\n    },\n    labelNodes: {\n      get: function () {\n        return null === this.hd ? gb : this.hd.iterator;\n      }\n    },\n    relinkableFrom: {\n      get: function () {\n        return 0 !== (this.Fa & 1);\n      },\n      set: function (a) {\n        var b = 0 !== (this.Fa & 1);\n        b !== a && (this.Fa ^= 1, this.g(\"relinkableFrom\", b, a), this.Lb());\n      }\n    },\n    relinkableTo: {\n      get: function () {\n        return 0 !== (this.Fa & 2);\n      },\n      set: function (a) {\n        var b = 0 !== (this.Fa & 2);\n        b !== a && (this.Fa ^= 2, this.g(\"relinkableTo\", b, a), this.Lb());\n      }\n    },\n    resegmentable: {\n      get: function () {\n        return 0 !== (this.Fa & 4);\n      },\n      set: function (a) {\n        var b = 0 !== (this.Fa & 4);\n        b !== a && (this.Fa ^= 4, this.g(\"resegmentable\", b, a), this.Lb());\n      }\n    },\n    isTreeLink: {\n      get: function () {\n        return 0 !== (this.Fa & 8);\n      },\n      set: function (a) {\n        var b = 0 !== (this.Fa & 8);\n        b !== a && (this.Fa ^= 8, this.g(\"isTreeLink\", b, a), null !== this.fromNode && Ek(this.fromNode), null !== this.toNode && Ek(this.toNode));\n      }\n    },\n    path: {\n      get: function () {\n        var a = this.pb();\n        return a instanceof W ? a : null;\n      }\n    },\n    routeBounds: {\n      get: function () {\n        this.wj();\n        var a = this.Rl,\n          b = Infinity,\n          c = Infinity,\n          d = this.pointsCount;\n        if (0 === d) a.h(NaN, NaN, 0, 0);else {\n          if (1 === d) d = this.i(0), b = Math.min(d.x, b), c = Math.min(d.y, c), a.h(d.x, d.y, 0, 0);else if (2 === d) {\n            d = this.i(0);\n            var e = this.i(1);\n            b = Math.min(d.x, e.x);\n            c = Math.min(d.y, e.y);\n            a.h(d.x, d.y, 0, 0);\n            a.Me(e);\n          } else if (this.computeCurve() === pg && 3 <= d && !this.isOrthogonal) {\n            if (e = this.i(0), b = e.x, c = e.y, a.h(b, c, 0, 0), 3 === d) {\n              d = this.i(1);\n              b = Math.min(d.x, b);\n              c = Math.min(d.y, c);\n              var f = this.i(2);\n              b = Math.min(f.x, b);\n              c = Math.min(f.y, c);\n              K.pm(e.x, e.y, d.x, d.y, d.x, d.y, f.x, f.y, .5, a);\n            } else for (f = 3; f < d; f += 3) {\n              var g = this.i(f - 2);\n              f + 3 >= d && (f = d - 1);\n              var h = this.i(f - 1),\n                k = this.i(f);\n              K.pm(e.x, e.y, g.x, g.y, h.x, h.y, k.x, k.y, .5, a);\n              b = Math.min(k.x, b);\n              c = Math.min(k.y, c);\n              e = k;\n            }\n          } else for (e = this.i(0), f = this.i(1), b = Math.min(e.x, f.x), c = Math.min(e.y, f.y), a.h(e.x, e.y, 0, 0), a.Me(f), e = 2; e < d; e++) f = this.i(e), b = Math.min(f.x, b), c = Math.min(f.y, c), a.Me(f);\n          this.vv.h(b - a.x, c - a.y);\n        }\n        return a;\n      }\n    },\n    midPoint: {\n      get: function () {\n        this.wj();\n        return this.computeMidPoint(new J());\n      }\n    },\n    midAngle: {\n      get: function () {\n        this.wj();\n        return this.computeMidAngle();\n      }\n    },\n    flattenedLengths: {\n      get: function () {\n        if (null === this.cs) {\n          this.dd || jp(this);\n          for (var a = this.cs = [], b = this.pointsCount, c = 0; c < b - 1; c++) {\n            var d = this.i(c);\n            var e = this.i(c + 1);\n            K.$(d.x, e.x) ? (d = e.y - d.y, 0 > d && (d = -d)) : K.$(d.y, e.y) ? (d = e.x - d.x, 0 > d && (d = -d)) : d = Math.sqrt(d.Fe(e));\n            a.push(d);\n          }\n        }\n        return this.cs;\n      }\n    },\n    flattenedTotalLength: {\n      get: function () {\n        var a = this.Pu;\n        if (isNaN(a)) {\n          for (var b = this.flattenedLengths, c = b.length, d = a = 0; d < c; d++) a += b[d];\n          this.Pu = a;\n        }\n        return a;\n      }\n    },\n    points: {\n      get: function () {\n        return this.Ab;\n      },\n      set: function (a) {\n        var b = this.Ab;\n        if (b !== a) {\n          var c = null;\n          if (Array.isArray(a)) {\n            var d = 0 === a.length % 2;\n            if (d) for (var e = 0; e < a.length; e++) if (\"number\" !== typeof a[e] || isNaN(a[e])) {\n              d = !1;\n              break;\n            }\n            if (d) for (c = new E(), d = 0; d < a.length / 2; d++) e = new J(a[2 * d], a[2 * d + 1]).freeze(), c.add(e);else {\n              d = !0;\n              for (e = 0; e < a.length; e++) {\n                var f = a[e];\n                if (!ya(f) || \"number\" !== typeof f.x || isNaN(f.x) || \"number\" !== typeof f.y || isNaN(f.y)) {\n                  d = !1;\n                  break;\n                }\n              }\n              if (d) for (c = new E(), d = 0; d < a.length; d++) e = a[d], c.add(new J(e.x, e.y).freeze());\n            }\n          } else if (a instanceof E) for (c = a.copy(), a = c.iterator; a.next();) a.value.freeze();else B(\"Link.points value is not an instance of List or Array: \" + a);\n          c.freeze();\n          this.Ab = c;\n          this.cc();\n          jp(this);\n          a = this.diagram;\n          null !== a && (a.oj || a.undoManager.isUndoingRedoing || a.Xt.add(this), a.animationManager.rc && (this.qg = c));\n          this.g(\"points\", b, c);\n        }\n      }\n    },\n    pointsCount: {\n      get: function () {\n        return this.Ab.count;\n      }\n    },\n    dd: {\n      get: function () {\n        return 0 !== (this.Fa & 16);\n      },\n      set: function (a) {\n        0 !== (this.Fa & 16) !== a && (this.Fa ^= 16);\n      }\n    },\n    suspendsRouting: {\n      get: function () {\n        return 0 !== (this.Fa & 32);\n      },\n      set: function (a) {\n        0 !== (this.Fa & 32) !== a && (this.Fa ^= 32);\n      }\n    },\n    Ct: {\n      get: function () {\n        return 0 !== (this.Fa & 64);\n      },\n      set: function (a) {\n        0 !== (this.Fa & 64) !== a && (this.Fa ^= 64);\n      }\n    },\n    defaultFromPoint: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v = a.copy();\n      }\n    },\n    defaultToPoint: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a.copy();\n      }\n    },\n    isOrthogonal: {\n      get: function () {\n        return 2 === (this.$j.value & 2);\n      }\n    },\n    isAvoiding: {\n      get: function () {\n        return 4 === (this.$j.value & 4);\n      }\n    },\n    Ym: {\n      get: function () {\n        return 0 !== (this.Fa & 128);\n      },\n      set: function (a) {\n        0 !== (this.Fa & 128) !== a && (this.Fa ^= 128);\n      }\n    },\n    geometry: {\n      get: function () {\n        this.Ym || (this.wj(), this.na = this.makeGeometry());\n        return this.na;\n      }\n    },\n    firstPickIndex: {\n      get: function () {\n        return 2 >= this.pointsCount ? 0 : this.isOrthogonal || !lp(this.computeSpot(!0)) ? 1 : 0;\n      }\n    },\n    lastPickIndex: {\n      get: function () {\n        var a = this.pointsCount;\n        return 0 === a ? 0 : 2 >= a ? a - 1 : this.isOrthogonal || !lp(this.computeSpot(!1)) ? a - 2 : a - 1;\n      }\n    },\n    adjusting: {\n      get: function () {\n        return this.Rk;\n      },\n      set: function (a) {\n        var b = this.Rk;\n        b !== a && (this.Rk = a, this.g(\"adjusting\", b, a));\n      }\n    },\n    corner: {\n      get: function () {\n        return this.Gn;\n      },\n      set: function (a) {\n        var b = this.Gn;\n        b !== a && (this.Gn = a, this.cc(), this.g(\"corner\", b, a));\n      }\n    },\n    curve: {\n      get: function () {\n        return this.In;\n      },\n      set: function (a) {\n        var b = this.In;\n        b !== a && (this.In = a, this.Ua(), this.cc(), kp(this, b === ag || b === $f || a === ag || a === $f), this.g(\"curve\", b, a));\n      }\n    },\n    curviness: {\n      get: function () {\n        return this.Jn;\n      },\n      set: function (a) {\n        var b = this.Jn;\n        b !== a && (this.Jn = a, this.Ua(), this.cc(), this.g(\"curviness\", b, a));\n      }\n    },\n    routing: {\n      get: function () {\n        return this.$j;\n      },\n      set: function (a) {\n        var b = this.$j;\n        b !== a && (this.$j = a, this.Uf = null, this.Ua(), kp(this, 2 === (b.value & 2) || 2 === (a.value & 2)), this.g(\"routing\", b, a));\n      }\n    },\n    smoothness: {\n      get: function () {\n        return this.Xp;\n      },\n      set: function (a) {\n        var b = this.Xp;\n        b !== a && (this.Xp = a, this.cc(), this.g(\"smoothness\", b, a));\n      }\n    },\n    key: {\n      get: function () {\n        var a = this.diagram;\n        if (null !== a && a.model.pj()) return a.model.Vb(this.data);\n      }\n    }\n  });\n  S.prototype.invalidateOtherJumpOvers = S.prototype.Nq;\n  S.prototype.findClosestSegment = S.prototype.Nz;\n  S.prototype.updateRoute = S.prototype.wj;\n  S.prototype.invalidateRoute = S.prototype.Ua;\n  S.prototype.rollbackRoute = S.prototype.xw;\n  S.prototype.commitRoute = S.prototype.xf;\n  S.prototype.startRoute = S.prototype.Th;\n  S.prototype.clearPoints = S.prototype.lk;\n  S.prototype.removePoint = S.prototype.sw;\n  S.prototype.addPointAt = S.prototype.vf;\n  S.prototype.addPoint = S.prototype.Be;\n  S.prototype.insertPointAt = S.prototype.m;\n  S.prototype.insertPoint = S.prototype.rA;\n  S.prototype.setPointAt = S.prototype.K;\n  S.prototype.setPoint = S.prototype.od;\n  S.prototype.getPoint = S.prototype.i;\n  S.prototype.getOtherPort = S.prototype.iA;\n  S.prototype.getOtherNode = S.prototype.Iq;\n  var bp = new D(S, \"Normal\", 1),\n    Hp = new D(S, \"Orthogonal\", 2),\n    Ip = new D(S, \"AvoidsNodes\", 6),\n    qp = new D(S, \"AvoidsNodesStraight\", 7),\n    bg = new D(S, \"None\", 0),\n    pg = new D(S, \"Bezier\", 9),\n    ag = new D(S, \"JumpGap\", 10),\n    $f = new D(S, \"JumpOver\", 11),\n    cp = new D(S, \"End\", 17),\n    dp = new D(S, \"Scale\", 18),\n    ep = new D(S, \"Stretch\", 19),\n    Um = new D(S, \"OrientAlong\", 21),\n    Nm = new D(S, \"OrientPlus90\", 22),\n    Pm = new D(S, \"OrientMinus90\", 23),\n    fp = new D(S, \"OrientOpposite\", 24),\n    Vm = new D(S, \"OrientUpright\", 25),\n    Om = new D(S, \"OrientPlus90Upright\", 26),\n    Qm = new D(S, \"OrientMinus90Upright\", 27),\n    Rm = new D(S, \"OrientUpright45\", 28),\n    sp = 16,\n    rp = 14,\n    tp = 8;\n  S.className = \"Link\";\n  S.Normal = bp;\n  S.Orthogonal = Hp;\n  S.AvoidsNodes = Ip;\n  S.AvoidsNodesStraight = qp;\n  S.None = bg;\n  S.Bezier = pg;\n  S.JumpGap = ag;\n  S.JumpOver = $f;\n  S.End = cp;\n  S.Scale = dp;\n  S.Stretch = ep;\n  S.OrientAlong = Um;\n  S.OrientPlus90 = Nm;\n  S.OrientMinus90 = Pm;\n  S.OrientOpposite = fp;\n  S.OrientUpright = Vm;\n  S.OrientPlus90Upright = Om;\n  S.OrientMinus90Upright = Qm;\n  S.OrientUpright45 = Rm;\n  S.EndSegmentStep = 8;\n  S.CurvinessStart = sp;\n  S.SpacingMin = rp;\n  S.OrthoShortCut = tp;\n  S.AvoidanceCell = 8;\n  S.AvoidanceLimit = 999;\n  function Gp(a, b, c, d) {\n    Ya(this);\n    this.oe = this.ks = !1;\n    this.$t = a;\n    this.Jy = b;\n    this.jw = c;\n    this.Ky = d;\n    this.links = [];\n  }\n  Gp.prototype.ym = function () {\n    if (!this.ks) {\n      var a = this.links;\n      0 < a.length && (a = a[0].diagram, null !== a && (a.Ru.add(this), this.oe = a.undoManager.isUndoingRedoing));\n    }\n    this.ks = !0;\n  };\n  Gp.prototype.Tw = function () {\n    if (this.ks) {\n      this.ks = !1;\n      var a = this.links;\n      if (0 < a.length) {\n        var b = a[0],\n          c = b.diagram;\n        c = null === c || c.oj && !this.oe;\n        this.oe = !1;\n        b.arrangeBundledLinks(a, c);\n        1 === a.length && (b.Lf = null, a.length = 0);\n      }\n      0 === a.length && (a = this.$t, null !== this && null !== a.Re && a.Re.remove(this), a = this.jw, null !== this && null !== a.Re && a.Re.remove(this));\n    }\n  };\n  Gp.className = \"LinkBundle\";\n  function uk() {\n    Ya(this);\n    this.Sy = this.group = null;\n    this.Rt = !0;\n    this.abort = !1;\n    this.wd = this.vd = 1;\n    this.Oo = this.No = -1;\n    this.fc = this.ec = 8;\n    this.Qb = null;\n    this.$i = this.Zi = 0;\n    this.Ty = 11;\n    this.Dy = 124;\n  }\n  uk.prototype.initialize = function (a) {\n    if (!(0 >= a.width || 0 >= a.height)) {\n      var b = a.y,\n        c = a.x + a.width,\n        d = a.y + a.height;\n      this.vd = Math.floor((a.x - this.ec) / this.ec) * this.ec;\n      this.wd = Math.floor((b - this.fc) / this.fc) * this.fc;\n      this.No = Math.ceil((c + 2 * this.ec) / this.ec) * this.ec;\n      this.Oo = Math.ceil((d + 2 * this.fc) / this.fc) * this.fc;\n      a = 1 + (Math.ceil((this.No - this.vd) / this.ec) | 0);\n      b = 1 + (Math.ceil((this.Oo - this.wd) / this.fc) | 0);\n      if (null === this.Qb || this.Zi < a - 1 || this.$i < b - 1) {\n        c = [];\n        for (d = 0; d <= a; d++) c[d] = new Uint32Array(b);\n        this.Qb = c;\n        this.Zi = a - 1;\n        this.$i = b - 1;\n      }\n      a = Jp;\n      if (null !== this.Qb) for (b = 0; b <= this.Zi; b++) if (c = this.Qb[b], c.fill) c.fill(a);else for (d = 0; d <= this.$i; d++) c[d] = a;\n    }\n  };\n  function xk(a, b, c) {\n    return a.vd <= b && b <= a.No && a.wd <= c && c <= a.Oo;\n  }\n  function vp(a, b, c) {\n    if (!xk(a, b, c)) return Jp;\n    b -= a.vd;\n    b /= a.ec;\n    c -= a.wd;\n    c /= a.fc;\n    return a.Qb[b | 0][c | 0];\n  }\n  function wk(a) {\n    if (null !== a.Qb) for (var b = 0; b <= a.Zi; b++) for (var c = a.Qb[b], d = 0; d <= a.$i; d++) c[d] >= yp && (c[d] = Jp);\n  }\n  uk.prototype.zk = function (a, b, c, d) {\n    if (a > this.No || a + c < this.vd || b > this.Oo || b + d < this.wd) return !0;\n    a = (a - this.vd) / this.ec | 0;\n    b = (b - this.wd) / this.fc | 0;\n    c = Math.max(0, c) / this.ec + 1 | 0;\n    var e = Math.max(0, d) / this.fc + 1 | 0;\n    0 > a && (c += a, a = 0);\n    0 > b && (e += b, b = 0);\n    if (0 > c || 0 > e) return !0;\n    d = Math.min(a + c - 1, this.Zi) | 0;\n    for (c = Math.min(b + e - 1, this.$i) | 0; a <= d; a++) {\n      e = this.Qb[a];\n      for (var f = b; f <= c; f++) if (e[f] === yk) return !1;\n    }\n    return !0;\n  };\n  function Kp(a, b, c, d, e, f, g, h, k) {\n    if (!(b < f || b > g || c < h || c > k)) {\n      var l = b | 0;\n      var m = c | 0;\n      var n = a.Qb[l][m];\n      if (n >= yp && n < wp) for (e ? m += d : l += d, n += 1; f <= l && l <= g && h <= m && m <= k && !(n >= a.Qb[l][m]);) a.Qb[l][m] = n, n += 1, e ? m += d : l += d;\n      l = e ? m : l;\n      if (e) {\n        if (0 < d) for (c += d; c < l; c += d) Kp(a, b, c, 1, !e, f, g, h, k), Kp(a, b, c, -1, !e, f, g, h, k);else for (c += d; c > l; c += d) Kp(a, b, c, 1, !e, f, g, h, k), Kp(a, b, c, -1, !e, f, g, h, k);\n      } else if (0 < d) for (b += d; b < l; b += d) Kp(a, b, c, 1, !e, f, g, h, k), Kp(a, b, c, -1, !e, f, g, h, k);else for (b += d; b > l; b += d) Kp(a, b, c, 1, !e, f, g, h, k), Kp(a, b, c, -1, !e, f, g, h, k);\n    }\n  }\n  function Lp(a, b, c, d, e, f, g, h, k) {\n    b |= 0;\n    c |= 0;\n    var l = yk,\n      m = yp;\n    for (a.Qb[b][c] = m; l === yk && b > f && b < g && c > h && c < k;) m += 1, a.Qb[b][c] = m, e ? c += d : b += d, l = a.Qb[b][c];\n  }\n  function Mp(a, b, c, d, e, f, g, h, k) {\n    b |= 0;\n    c |= 0;\n    var l = yk,\n      m = wp;\n    for (a.Qb[b][c] = m; l === yk && b > f && b < g && c > h && c < k;) a.Qb[b][c] = m, e ? c += d : b += d, l = a.Qb[b][c];\n  }\n  function up(a, b, c, d, e, f, g) {\n    if (null !== a.Qb) {\n      a.abort = !1;\n      var h = b.x,\n        k = b.y;\n      if (xk(a, h, k)) {\n        h -= a.vd;\n        h /= a.ec;\n        k -= a.wd;\n        k /= a.fc;\n        var l = d.x,\n          m = d.y;\n        if (xk(a, l, m)) if (l -= a.vd, l /= a.ec, m -= a.wd, m /= a.fc, 1 >= Math.abs(h - l) && 1 >= Math.abs(k - m)) a.abort = !0;else {\n          var n = f.x;\n          d = f.y;\n          b = f.x + f.width;\n          var p = f.y + f.height;\n          n -= a.vd;\n          n /= a.ec;\n          d -= a.wd;\n          d /= a.fc;\n          b -= a.vd;\n          b /= a.ec;\n          p -= a.wd;\n          p /= a.fc;\n          f = Math.max(0, Math.min(a.Zi, n | 0));\n          b = Math.min(a.Zi, Math.max(0, b | 0));\n          n = Math.max(0, Math.min(a.$i, d | 0));\n          p = Math.min(a.$i, Math.max(0, p | 0));\n          d = a.Qb;\n          h |= 0;\n          k |= 0;\n          l |= 0;\n          m |= 0;\n          var r = 0 === c || 90 === c ? 1 : -1;\n          c = 90 === c || 270 === c;\n          d[h][k] === yk ? (Lp(a, h, k, r, c, f, b, n, p), Lp(a, h, k, 1, !c, f, b, n, p), Lp(a, h, k, -1, !c, f, b, n, p)) : Lp(a, h, k, r, c, h, k, h, k);\n          d[l][m] === yk ? (Mp(a, l, m, 0 === e || 90 === e ? 1 : -1, 90 === e || 270 === e, f, b, n, p), Mp(a, l, m, 1, !(90 === e || 270 === e), f, b, n, p), Mp(a, l, m, -1, !(90 === e || 270 === e), f, b, n, p)) : Mp(a, l, m, r, c, l, m, l, m);\n          c = Ea();\n          if (g && Np(a, l, m, e, h, k, c)) {\n            if (c[0] !== l || c[1] !== m) c.unshift(m), c.unshift(l);\n            if (c[c.length - 2] !== h || c[c.length - 1] !== k) c.push(h), c.push(k);\n            a = yp;\n            e = c[c.length - 2];\n            g = c[c.length - 1];\n            d[e][g] = a++;\n            for (f = c.length - 4; 0 <= f; f -= 2) for (e = c[f + 2], g = c[f + 3], b = c[f], l = c[f + 1]; b > e ? e++ : b < e ? e-- : l > g ? g++ : l < g && g--, d[e][g] = a++, e !== b || g !== l;);\n          } else Kp(a, h, k, 1, !1, f, b, n, p), Kp(a, h, k, -1, !1, f, b, n, p), Kp(a, h, k, 1, !0, f, b, n, p), Kp(a, h, k, -1, !0, f, b, n, p);\n          Ha(c);\n        }\n      }\n    }\n  }\n  function Np(a, b, c, d, e, f, g) {\n    for (var h = a.Qb, k = b, l = c;;) {\n      if (k === e && l === f) return !0;\n      var m = k,\n        n = l;\n      if (0 === d) {\n        if (m < e) m++;else break;\n      } else if (90 === d) {\n        if (n < f) n++;else break;\n      } else if (180 === d) {\n        if (m > e) m--;else break;\n      } else if (n > f) n--;else break;\n      var p = h[m][n];\n      if (0 === p || p === Op) break;\n      k = m;\n      l = n;\n    }\n    for (;;) {\n      m = d;\n      n = k;\n      p = l;\n      0 === d ? p < f ? (m = 90, p++) : p > f && (m = 270, p--) : 90 === d ? n < e ? (m = 0, n++) : n > e && (m = 180, n--) : 180 === d ? p < f ? (m = 90, p++) : p > f && (m = 270, p--) : n < e ? (m = 0, n++) : n > e && (m = 180, n--);\n      n = h[n][p];\n      if (m !== d && 0 !== n && n !== Op) {\n        g.push(k);\n        g.push(l);\n        if (Np(a, k, l, m, e, f, g)) return !0;\n        g.pop();\n        g.pop();\n      }\n      h[k][l] = Op;\n      if (0 === d) {\n        if (k === b) return !1;\n        k--;\n      } else if (90 === d) {\n        if (l === c) return !1;\n        l--;\n      } else if (180 === d) {\n        if (k === b) return !1;\n        k++;\n      } else {\n        if (l === c) return !1;\n        l++;\n      }\n    }\n  }\n  ma.Object.defineProperties(uk.prototype, {\n    bounds: {\n      get: function () {\n        return new N(this.vd, this.wd, this.No - this.vd, this.Oo - this.wd);\n      }\n    },\n    xq: {\n      get: function () {\n        return this.ec;\n      },\n      set: function (a) {\n        0 < a && a !== this.ec && (this.ec = a, this.initialize(this.bounds));\n      }\n    },\n    wq: {\n      get: function () {\n        return this.fc;\n      },\n      set: function (a) {\n        0 < a && a !== this.fc && (this.fc = a, this.initialize(this.bounds));\n      }\n    }\n  });\n  var yk = 0,\n    yp = 1,\n    wp = 999999,\n    Jp = wp + 1,\n    Op = wp + 2;\n  uk.className = \"PositionArray\";\n  function op() {\n    Ya(this);\n    this.port = this.node = null;\n    this.$d = [];\n    this.Sq = !1;\n  }\n  op.prototype.toString = function () {\n    for (var a = this.$d, b = this.node.toString() + \" \" + a.length.toString() + \":\", c = 0; c < a.length; c++) {\n      var d = a[c];\n      null !== d && (b += \"\\n  \" + d.toString());\n    }\n    return b;\n  };\n  function Pp(a, b, c, d) {\n    b = b.offsetY;\n    switch (b) {\n      case 8:\n        return 90;\n      case 2:\n        return 180;\n      case 1:\n        return 270;\n      case 4:\n        return 0;\n    }\n    switch (b) {\n      case 9:\n        return 180 < c ? 270 : 90;\n      case 6:\n        return 90 < c && 270 >= c ? 180 : 0;\n    }\n    a = 180 * Math.atan2(a.height, a.width) / Math.PI;\n    switch (b) {\n      case 3:\n        return c > a && c <= 180 + a ? 180 : 270;\n      case 5:\n        return c > 180 - a && c <= 360 - a ? 270 : 0;\n      case 12:\n        return c > a && c <= 180 + a ? 90 : 0;\n      case 10:\n        return c > 180 - a && c <= 360 - a ? 180 : 90;\n      case 7:\n        return 90 < c && c <= 180 + a ? 180 : c > 180 + a && c <= 360 - a ? 270 : 0;\n      case 13:\n        return 180 < c && c <= 360 - a ? 270 : c > a && 180 >= c ? 90 : 0;\n      case 14:\n        return c > a && c <= 180 - a ? 90 : c > 180 - a && 270 >= c ? 180 : 0;\n      case 11:\n        return c > 180 - a && c <= 180 + a ? 180 : c > 180 + a ? 270 : 90;\n    }\n    d && 15 !== b && (c -= 15, 0 > c && (c += 360));\n    return c > a && c < 180 - a ? 90 : c >= 180 - a && c <= 180 + a ? 180 : c > 180 + a && c < 360 - a ? 270 : 0;\n  }\n  op.prototype.ym = function () {\n    this.$d.length = 0;\n  };\n  function pp(a, b) {\n    var c = a.$d;\n    if (0 === c.length) {\n      a: if (!a.Sq) {\n        c = a.Sq;\n        a.Sq = !0;\n        var d = null,\n          e = a.node,\n          f = e instanceof vf ? e : null;\n        if (null === f || f.isSubGraphExpanded) var g = e.isTreeExpanded ? e.findLinksConnected(a.port.portId) : e.my();else {\n          if (!f.actualBounds.u()) {\n            a.Sq = c;\n            break a;\n          }\n          d = f;\n          g = d.Qv();\n        }\n        f = a.$d.length = 0;\n        var h = a.port.ga(wc, J.alloc()),\n          k = a.port.ga(Hc, J.alloc());\n        e = N.allocAt(h.x, h.y, 0, 0);\n        e.Me(k);\n        J.free(h);\n        J.free(k);\n        h = J.allocAt(e.x + e.width / 2, e.y + e.height / 2);\n        k = a.port.lj();\n        for (g = g.iterator; g.next();) {\n          var l = g.value;\n          if (l.isVisible() && l.fromPort !== l.toPort) {\n            var m = l.fromPort === a.port || null !== l.fromNode && l.fromNode.Cd(d),\n              n = l.computeSpot(m, a.port);\n            if (n.Mc() && (m = m ? l.toPort : l.fromPort, null !== m)) {\n              var p = m.part;\n              if (null !== p) {\n                var r = p.findVisibleNode();\n                null !== r && r !== p && (p = r, m = p.port);\n                m = l.computeOtherPoint(p, m);\n                p = h.Sa(m);\n                p -= k;\n                0 > p ? p += 360 : 360 <= p && (p -= 360);\n                n = Pp(e, n, p, l.isOrthogonal);\n                0 === n ? (n = 4, 180 < p && (p -= 360)) : 90 === n ? (n = 8, 270 < p && (p -= 360)) : 180 === n ? n = 2 : (n = 1, 90 > p && (p += 360));\n                r = a.$d[f];\n                void 0 === r ? (r = new Qp(l, p, n), a.$d[f] = r) : (r.link = l, r.angle = p, r.Ac = n);\n                r.lw.set(m);\n                f++;\n              }\n            }\n          }\n        }\n        J.free(h);\n        a.$d.sort(op.prototype.l);\n        k = a.$d.length;\n        d = -1;\n        for (f = h = 0; f < k; f++) g = a.$d[f], void 0 !== g && (g.Ac !== d && (d = g.Ac, h = 0), g.Jq = h, h++);\n        d = -1;\n        h = 0;\n        for (f = k - 1; 0 <= f; f--) k = a.$d[f], void 0 !== k && (k.Ac !== d && (d = k.Ac, h = k.Jq + 1), k.qm = h);\n        f = a.$d;\n        n = a.port;\n        d = a.node.portSpreading;\n        h = J.alloc();\n        k = J.alloc();\n        g = J.alloc();\n        l = J.alloc();\n        n.ga(wc, h);\n        n.ga(zc, k);\n        n.ga(Hc, g);\n        n.ga(Dc, l);\n        r = p = m = n = 0;\n        if (d === Zo) for (var q = 0; q < f.length; q++) {\n          var u = f[q];\n          if (null !== u) {\n            var v = u.link.computeThickness();\n            switch (u.Ac) {\n              case 8:\n                p += v;\n                break;\n              case 2:\n                r += v;\n                break;\n              case 1:\n                n += v;\n                break;\n              default:\n              case 4:\n                m += v;\n            }\n          }\n        }\n        var w = q = 0,\n          y = 1,\n          z = u = 0;\n        for (v = 0; v < f.length; v++) {\n          var A = f[v];\n          if (null !== A) {\n            if (q !== A.Ac) {\n              q = A.Ac;\n              switch (q) {\n                case 8:\n                  var C = g;\n                  w = l;\n                  break;\n                case 2:\n                  C = l;\n                  w = h;\n                  break;\n                case 1:\n                  C = h;\n                  w = k;\n                  break;\n                default:\n                case 4:\n                  C = k, w = g;\n              }\n              u = w.x - C.x;\n              z = w.y - C.y;\n              switch (q) {\n                case 8:\n                  p > Math.abs(u) ? (y = Math.abs(u) / p, p = Math.abs(u)) : y = 1;\n                  break;\n                case 2:\n                  r > Math.abs(z) ? (y = Math.abs(z) / r, r = Math.abs(z)) : y = 1;\n                  break;\n                case 1:\n                  n > Math.abs(u) ? (y = Math.abs(u) / n, n = Math.abs(u)) : y = 1;\n                  break;\n                default:\n                case 4:\n                  m > Math.abs(z) ? (y = Math.abs(z) / m, m = Math.abs(z)) : y = 1;\n              }\n              w = 0;\n            }\n            var G = A.Qq;\n            if (d === Zo) {\n              A = A.link.computeThickness();\n              A *= y;\n              G.set(C);\n              switch (q) {\n                case 8:\n                  G.x = C.x + u / 2 + p / 2 - w - A / 2;\n                  break;\n                case 2:\n                  G.y = C.y + z / 2 + r / 2 - w - A / 2;\n                  break;\n                case 1:\n                  G.x = C.x + u / 2 - n / 2 + w + A / 2;\n                  break;\n                default:\n                case 4:\n                  G.y = C.y + z / 2 - m / 2 + w + A / 2;\n              }\n              w += A;\n            } else {\n              var L = .5;\n              d === Lo && (L = (A.Jq + 1) / (A.qm + 1));\n              G.x = C.x + u * L;\n              G.y = C.y + z * L;\n            }\n          }\n        }\n        J.free(h);\n        J.free(k);\n        J.free(g);\n        J.free(l);\n        C = a.$d;\n        for (f = 0; f < C.length; f++) d = C[f], null !== d && (d.Ov = a.computeEndSegmentLength(d));\n        a.Sq = c;\n        N.free(e);\n      }\n      c = a.$d;\n    }\n    for (a = 0; a < c.length; a++) if (e = c[a], null !== e && e.link === b) return e;\n    return null;\n  }\n  op.prototype.l = function (a, b) {\n    return a === b ? 0 : null === a ? -1 : null === b ? 1 : a.Ac < b.Ac ? -1 : a.Ac > b.Ac ? 1 : a.angle < b.angle ? -1 : a.angle > b.angle ? 1 : 0;\n  };\n  op.prototype.computeEndSegmentLength = function (a) {\n    var b = a.link,\n      c = b.computeEndSegmentLength(this.node, this.port, vc, b.fromPort === this.port),\n      d = a.Jq;\n    if (0 > d) return c;\n    var e = a.qm;\n    if (1 >= e || !b.isOrthogonal) return c;\n    b = a.lw;\n    var f = a.Qq;\n    if (2 === a.Ac || 8 === a.Ac) d = e - 1 - d;\n    return ((a = 2 === a.Ac || 4 === a.Ac) ? b.y < f.y : b.x < f.x) ? c + 8 * d : (a ? b.y === f.y : b.x === f.x) ? c : c + 8 * (e - 1 - d);\n  };\n  op.className = \"Knot\";\n  function Qp(a, b, c) {\n    this.link = a;\n    this.angle = b;\n    this.Ac = c;\n    this.lw = new J();\n    this.qm = this.Jq = 0;\n    this.Qq = new J();\n    this.Ov = 0;\n  }\n  Qp.prototype.toString = function () {\n    return this.link.toString() + \" \" + this.angle.toString() + \" \" + this.Ac.toString() + \":\" + this.Jq.toString() + \"/\" + this.qm.toString() + \" \" + this.Qq.toString() + \" \" + this.Ov.toString() + \" \" + this.lw.toString();\n  };\n  Qp.className = \"LinkInfo\";\n  function dl() {\n    this.Ch = this.ah = ad;\n    this.Bh = this.$g = this.Ah = this.Zg = NaN;\n    this.iq = this.bo = null;\n    this.jq = this.co = Infinity;\n  }\n  dl.prototype.copy = function () {\n    var a = new dl();\n    a.ah = this.ah.G();\n    a.Ch = this.Ch.G();\n    a.Zg = this.Zg;\n    a.Ah = this.Ah;\n    a.$g = this.$g;\n    a.Bh = this.Bh;\n    a.bo = this.bo;\n    a.iq = this.iq;\n    a.co = this.co;\n    a.jq = this.jq;\n    return a;\n  };\n  dl.className = \"LinkSettings\";\n  function yi() {\n    Ya(this);\n    this.v = this.B = null;\n    this.yi = this.to = !0;\n    this.yo = !1;\n    this.mn = new J(0, 0).freeze();\n    this.vo = !0;\n    this.un = this.uo = null;\n    this.xo = !1;\n    this.l = null;\n    this.I = 0;\n    this.Po = this.oq = null;\n    this.wt = !1;\n    this.yg = this.bk = null;\n    this.lt = !1;\n  }\n  yi.prototype.cloneProtected = function (a) {\n    a.to = this.to;\n    a.yi = this.yi;\n    a.yo = this.yo;\n    a.mn.assign(this.mn);\n    a.vo = this.vo;\n    a.uo = this.uo;\n    a.un = this.un;\n    a.xo = !0;\n    a.Po = this.Po;\n    a.oq = this.oq;\n  };\n  yi.prototype.copy = function () {\n    var a = new this.constructor();\n    this.cloneProtected(a);\n    return a;\n  };\n  yi.prototype.serializeLayoutProperties = function (a) {\n    a.arrangementOrigin = {\n      x: this.arrangementOrigin.x,\n      y: this.arrangementOrigin.y\n    };\n    a.isRouting = this.isRouting;\n  };\n  yi.prototype.deserializeLayoutProperties = function (a) {\n    null !== a && (this.arrangementOrigin = new J(a.arrangementOrigin.x, a.arrangementOrigin.y), this.isRouting = a.isRouting);\n  };\n  yi.prototype.hb = function () {};\n  yi.prototype.toString = function () {\n    var a = Ia(this.constructor);\n    a += \"(\";\n    null !== this.group && (a += \" in \" + this.group);\n    null !== this.diagram && (a += \" for \" + this.diagram);\n    return a + \")\";\n  };\n  yi.prototype.C = function () {\n    if (this.isValidLayout) {\n      var a = this.diagram;\n      if (null !== a && !a.undoManager.isUndoingRedoing) {\n        var b = a.animationManager;\n        !b.isTicking && (b.defaultAnimation.isAnimating && b.Nc(), this.isOngoing && a.oj || this.isInitial && !a.oj) && (this.isValidLayout = !1, a.Db());\n      }\n    }\n  };\n  yi.prototype.createNetwork = function () {\n    return new Rp(this);\n  };\n  yi.prototype.makeNetwork = function (a) {\n    var b = this.createNetwork();\n    a instanceof Q ? (b.Ag(a.nodes, !0), b.Ag(a.links, !0)) : a instanceof vf ? b.Ag(a.memberParts) : b.Ag(a.iterator);\n    return b;\n  };\n  yi.prototype.updateParts = function () {\n    this.isValidLayout = !0;\n    if (!this.workerLayout()) {\n      var a = this.diagram;\n      if (null === a && null !== this.network) for (var b = this.network.vertexes.iterator; b.next();) {\n        var c = b.value.node;\n        if (null !== c && (a = c.diagram, null !== a)) break;\n      }\n      try {\n        null !== a && a.va(\"Layout\"), this.commitLayout();\n      } finally {\n        null !== a && a.Wa(\"Layout\");\n      }\n    }\n  };\n  yi.prototype.commitLayout = function () {\n    if (null !== this.network) {\n      for (var a = this.network.vertexes.iterator; a.next();) a.value.commit();\n      if (this.isRouting) for (a = this.network.edges.iterator; a.next();) a.value.commit();\n    }\n  };\n  yi.prototype.doLayout = function (a) {\n    var b = new F();\n    a instanceof Q ? (Sp(this, b, a.nodes, !0, this.Rh, !0, !1, !0), Sp(this, b, a.parts, !0, this.Rh, !0, !1, !0)) : a instanceof vf ? Sp(this, b, a.memberParts, !1, this.Rh, !0, !1, !0) : b.addAll(a.iterator);\n    0 < b.count && (a = this.diagram, null !== a && a.va(\"Layout\"), this.doMinimalNoNetworkLayout(b), null !== a && a.Wa(\"Layout\"));\n    this.isValidLayout = !0;\n  };\n  yi.prototype.doMinimalNoNetworkLayout = function (a) {\n    var b = Math.ceil(Math.sqrt(a.count));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    var c = this.arrangementOrigin.x,\n      d = c,\n      e = this.arrangementOrigin.y,\n      f = 0,\n      g = 0;\n    for (a = a.iterator; a.next();) {\n      var h = a.value;\n      Tp(h);\n      var k = h.measuredBounds,\n        l = k.width;\n      k = k.height;\n      h.moveTo(d, e);\n      h instanceof vf && (h.Rh = !1);\n      d += Math.max(l, 50) + 20;\n      g = Math.max(g, Math.max(k, 50));\n      f >= b - 1 ? (f = 0, d = c, e += g + 20, g = 0) : f++;\n    }\n  };\n  yi.prototype.doMinimalNetworkLayout = function () {\n    var a = Math.ceil(Math.sqrt(this.network.vertexes.count));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    for (var b = this.arrangementOrigin.x, c = b, d = this.arrangementOrigin.y, e = 0, f = 0, g = this.network.vertexes.iterator; g.next();) {\n      var h = g.value.node;\n      if (!(null === h || h instanceof S) && (Tp(h), this.Rh(h))) {\n        var k = h.measuredBounds,\n          l = k.width;\n        k = k.height;\n        h.moveTo(c, d);\n        h instanceof vf && (h.Rh = !1);\n        c += Math.max(l, 50) + 20;\n        f = Math.max(f, Math.max(k, 50));\n        e >= a - 1 ? (e = 0, c = b, d += f + 20, f = 0) : e++;\n      }\n    }\n  };\n  yi.prototype.Rh = function (a) {\n    return !a.location.u() || a instanceof vf && a.Rh ? !0 : !1;\n  };\n  function Sp(a, b, c, d, e, f, g, h) {\n    for (c = c.iterator; c.next();) {\n      var k = c.value;\n      d && !k.isTopLevel || null !== e && !e(k) || !k.canLayout() || (f && k instanceof V ? k.isLinkLabel || (k instanceof vf ? null === k.layout ? Sp(a, b, k.memberParts, !1, e, f, g, h) : (Tp(k), b.add(k)) : (Tp(k), b.add(k))) : g && k instanceof S ? b.add(k) : !h || !k.Wb() || k instanceof V || (Tp(k), b.add(k)));\n    }\n  }\n  function Tp(a) {\n    var b = a.actualBounds;\n    (0 === b.width || 0 === b.height || isNaN(b.width) || isNaN(b.height)) && a.Ta();\n  }\n  yi.prototype.mj = function (a, b) {\n    var c = this.boundsComputation;\n    if (null !== c) return b || (b = new N()), c(a, this, b);\n    if (!b) return a.actualBounds;\n    b.set(a.actualBounds);\n    return b;\n  };\n  yi.prototype.Yx = function (a) {\n    var b = new F();\n    a instanceof Q ? (Sp(this, b, a.nodes, !0, null, !0, !0, !0), Sp(this, b, a.links, !0, null, !0, !0, !0), Sp(this, b, a.parts, !0, null, !0, !0, !0)) : a instanceof vf ? Sp(this, b, a.memberParts, !1, null, !0, !0, !0) : Sp(this, b, a.iterator, !1, null, !0, !0, !0);\n    return b;\n  };\n  yi.prototype.initialOrigin = function (a) {\n    var b = this.group;\n    if (null !== b) {\n      var c = b.position.copy();\n      (isNaN(c.x) || isNaN(c.y)) && c.set(a);\n      b = b.placeholder;\n      null !== b && (c = b.ga(wc), (isNaN(c.x) || isNaN(c.y)) && c.set(a), a = b.padding, c.x += a.left, c.y += a.top);\n      return c;\n    }\n    return a;\n  };\n  yi.prototype.mayUseWorker = function () {\n    return this.mayUseWorkerFunction ? this.mayUseWorkerFunction(this) : !1;\n  };\n  yi.prototype.workerLayout = function () {\n    return !1;\n  };\n  function Up(a, b) {\n    if (null !== a.workerStateChanged) {\n      var c = {\n        key: a.group ? a.group.key : null\n      };\n      void 0 !== b && (c.time = b);\n      null !== a.bk && (c.running = Vp(a.bk));\n      null !== a.yg && (c.waiting = Vp(a.yg));\n      a.workerStateChanged(c, a);\n    }\n  }\n  function Vp(a) {\n    return {\n      vertexes: a.vertexes.count,\n      edges: a.edges.count\n    };\n  }\n  yi.prototype.uz = function () {\n    var a = Wp(this.constructor);\n    a && (null !== a.Ne && a.Ne.terminate(), a.Ne = null, a.Bm.iteratorValues.each(function (a) {\n      a.wt = !1;\n      a.bk = null;\n      a.yg = null;\n      a.lt = !1;\n      Up(a);\n    }), a.Bm.clear());\n  };\n  function Xp(a, b) {\n    var c = Wp(a);\n    if (c) {\n      if (b) for (var d in b) c[d] = b[d];\n    } else throw Error(\"Unknown Layout class: \" + a);\n  }\n  function Wp(a) {\n    var b = null;\n    if (\"function\" === typeof a) {\n      if (b = Yp.get(a), !b) {\n        var c = Ia(a);\n        b = Yp.get(c);\n        b || (b = new Zp(), b.Kv = a, b.name = c, b.l = a.name, b.zy = $p, Yp.set(c, b), Yp.set(a, b), Yp.set(a.name, b));\n      }\n    } else \"string\" === typeof a && (b = Yp.get(a));\n    return b;\n  }\n  yi.prototype.Sw = function () {\n    if (\"undefined\" === typeof Worker || !aq || \"undefined\" === typeof self || \"undefined\" !== typeof self.DedicatedWorkerGlobalScope) return !1;\n    if (!this.mayUseWorker()) return this.wt && (this.lt = !0, this.yg = this.bk = null, Up(this)), !1;\n    var a = Wp(this.constructor);\n    if (null === a) return !1;\n    null === a.Ne && (a.Ne = new Worker(aq), a.Ne.onerror = function (a) {\n      a.preventDefault();\n      wa(\"Worker Error at: \" + a.filename + \" \" + a.lineno + \" \" + a.colno + \"\\n  \" + a.message);\n    }, a.Ne.l = function (a) {\n      wa(\"Worker serialization error: \" + a);\n    }, a.Ne.onmessage = function (b) {\n      var c = b.data;\n      if (\"_GoJS\" === c._GoJS) if (c.version) wa(\"GoJS v\" + Q.version + \"  Worker v\" + c.version);else if (b = a.Bm.get(c.id)) {\n        a.Bm.remove(c.id);\n        b.wt = !1;\n        b.bk = null;\n        if (b.lt) b.lt = !1, b.yg = null;else {\n          var d = bq(b, c, !1);\n          b.network = d;\n          b.updateParts();\n          b.network = null;\n          b.isValidLayout = !0;\n        }\n        Up(b, c.time);\n        c = b.yg;\n        if (null !== c) b.yg = null;else for (d = a.Bm.iteratorValues; d.next();) {\n          var e = d.value;\n          c = e.yg;\n          if (null !== c) {\n            e.yg = null;\n            break;\n          }\n        }\n        null !== c && cq(b, c);\n      }\n    }, a.Ne.postMessage({\n      _GoJS: \"_GoJS\",\n      url: a.zy\n    }), Array.isArray(a.scripts) && a.scripts.forEach(function (b) {\n      a.Ne.postMessage({\n        _GoJS: \"_GoJS\",\n        url: b\n      });\n    }), a.Ne.postMessage({\n      _GoJS: \"_GoJS\",\n      version: -1\n    }));\n    null !== this.bk ? this.yg = this.network : cq(this, this.network);\n    Up(this);\n    this.doMinimalNetworkLayout();\n    this.network = null;\n    return this.isValidLayout = !0;\n  };\n  function cq(a, b) {\n    a.wt = !0;\n    var c = Wp(a.constructor),\n      d = dq(a, b, !0);\n    d._GoJS = \"_GoJS\";\n    c.Ne.postMessage(d);\n    c.Bm.set(mb(a), a);\n    a.bk = b;\n  }\n  function dq(a, b, c) {\n    a.onNetworkSerialization(1, c, b, null);\n    var d = {};\n    a.serializeLayoutProperties(d, c);\n    var e = [];\n    b.vertexes.each(function (a) {\n      var b = {};\n      a.serializeVertexProperties(b, c);\n      e.push(b);\n    });\n    var f = [];\n    b.edges.each(function (a) {\n      var b = {};\n      a.serializeEdgeProperties(b, c);\n      f.push(b);\n    });\n    d = {\n      id: c ? mb(a) : a.id,\n      layout: Ia(a.constructor),\n      p: d,\n      cB: e,\n      Lz: f\n    };\n    a.onNetworkSerialization(2, c, b, d);\n    return d;\n  }\n  function bq(a, b, c) {\n    c && (a.id = b.id);\n    var d = a.diagram,\n      e = a.createNetwork();\n    a.onNetworkSerialization(3, c, e, b);\n    var f = b.cB,\n      g = new H();\n    f && f.forEach(function (a) {\n      var b = null;\n      null === a.key || null === d || c || (b = d.Cb(a.key));\n      null !== b ? b = e.jk(b) : (b = e.createVertex(), null !== a.key && (b.data = b), e.Bg(b));\n      c && null !== b.data && (b.data.Ci = a.key);\n      g.set(a.id, b);\n    });\n    var h = b.Lz,\n      k = new H();\n    h && h.forEach(function (a) {\n      var b = null;\n      null === a.key || null === d || c || (b = d.findLinkForKey(a.key));\n      null !== b ? b = e.Tx(b) : (b = e.createEdge(), null !== a.key && (b.data = b), e.nm(b));\n      c && null !== b.data && (b.data.Ci = a.key);\n      k.set(a.id, b);\n    });\n    a.deserializeLayoutProperties(b.p, g, k, c);\n    f && f.forEach(function (a) {\n      var b = g.get(a.id);\n      b && b.Aq(a, g, k, c);\n    });\n    h && h.forEach(function (a) {\n      var b = k.get(a.id);\n      b && b.deserializeEdgeProperties(a, g, k, c);\n    });\n    a.onNetworkSerialization(4, c, e, b);\n    return e;\n  }\n  yi.prototype.onNetworkSerialization = function () {};\n  ma.Object.defineProperties(yi.prototype, {\n    diagram: {\n      get: function () {\n        return this.B;\n      },\n      set: function (a) {\n        this.B = a;\n      }\n    },\n    group: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v !== a && (this.v = a, null !== a && (this.B = a.diagram));\n      }\n    },\n    isOngoing: {\n      get: function () {\n        return this.to;\n      },\n      set: function (a) {\n        this.to !== a && (this.to = a);\n      }\n    },\n    isInitial: {\n      get: function () {\n        return this.yi;\n      },\n      set: function (a) {\n        this.yi = a;\n        a || (this.xo = !0);\n      }\n    },\n    isViewportSized: {\n      get: function () {\n        return this.yo;\n      },\n      set: function (a) {\n        this.yo !== a && (this.yo = a) && this.C();\n      }\n    },\n    isRouting: {\n      get: function () {\n        return this.vo;\n      },\n      set: function (a) {\n        this.vo !== a && (this.vo = a);\n      }\n    },\n    isRealtime: {\n      get: function () {\n        return this.uo;\n      },\n      set: function (a) {\n        this.uo !== a && (this.uo = a);\n      }\n    },\n    isValidLayout: {\n      get: function () {\n        return this.xo;\n      },\n      set: function (a) {\n        this.xo !== a && (this.xo = a, a || (a = this.diagram, null !== a && (a.Ng = !0)));\n      }\n    },\n    network: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l !== a && (this.l = a, null !== a && (a.layout = this));\n      }\n    },\n    boundsComputation: {\n      get: function () {\n        return this.un;\n      },\n      set: function (a) {\n        this.un !== a && (this.un = a, this.C());\n      }\n    },\n    arrangementOrigin: {\n      get: function () {\n        return this.mn;\n      },\n      set: function (a) {\n        this.mn.w(a) || (this.mn.assign(a), this.C());\n      }\n    },\n    id: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I = a;\n      }\n    },\n    mayUseWorkerFunction: {\n      get: function () {\n        return this.Po;\n      },\n      set: function (a) {\n        this.Po !== a && (this.Po = a);\n      }\n    },\n    workerStateChanged: {\n      get: function () {\n        return this.oq;\n      },\n      set: function (a) {\n        this.oq !== a && (this.oq = a);\n      }\n    }\n  });\n  yi.prototype.useWorker = yi.prototype.Sw;\n  yi.declareWorkerLayout = Xp;\n  yi.prototype.cancelWorker = yi.prototype.uz;\n  yi.prototype.collectParts = yi.prototype.Yx;\n  yi.prototype.getLayoutBounds = yi.prototype.mj;\n  yi.prototype.invalidateLayout = yi.prototype.C;\n  var Yp = new H(),\n    $p = \"object\" === typeof x.document && x.document.currentScript ? x.document.currentScript.src : \"\",\n    aq = \"undefined\" !== typeof URL && \"function\" === typeof URL.createObjectURL && \"function\" === typeof Blob ? URL.createObjectURL(new Blob([\"self.onmessage=function(e){if(e.data.url){\\nimportScripts(e.data.url);}}\"], {\n      type: \"text/javascript\"\n    })) : \"\";\n  yi.className = \"Layout\";\n  yi.GoJSScriptURL = $p;\n  yi.declareWorkerLayout = Xp;\n  \"undefined\" !== typeof self && \"undefined\" !== typeof self.DedicatedWorkerGlobalScope && \"undefined\" !== typeof self && \"undefined\" !== typeof self.DedicatedWorkerGlobalScope && (self.onmessage = function (a) {\n    a = a.data;\n    if (\"_GoJS\" === a._GoJS) if (a.url) importScripts(a.url);else if (a.version) self.postMessage({\n      _GoJS: \"_GoJS\",\n      version: Q.version\n    }, void 0);else {\n      var b = performance.now(),\n        c = null;\n      a.layout && (c = Wp(a.layout));\n      var d = null;\n      c && c.Kv && (d = new c.Kv());\n      if (!d) throw Error(\"no registered Worker Layout: \" + a.layout);\n      d.network = bq(d, a, !0);\n      d.workerLayout = function () {\n        var a = dq(d, d.network, !1);\n        a._GoJS = \"_GoJS\";\n        a.time = performance.now() - b;\n        self.postMessage(a, void 0);\n        return !0;\n      };\n      d.doLayout(new E());\n    }\n  });\n  function Zp() {\n    this.Kv = null;\n    this.zy = this.l = this.name = \"\";\n    this.scripts = [];\n    this.Ne = null;\n    this.Bm = new H();\n  }\n  function Rp(a) {\n    Ya(this);\n    this.kc = a;\n    this.tf = new F();\n    this.he = new F();\n    this.au = new H();\n    this.Wt = new H();\n  }\n  Rp.prototype.clear = function () {\n    if (this.tf) for (var a = this.tf.iterator; a.next();) a.value.clear();\n    if (this.he) for (a = this.he.iterator; a.next();) a.value.clear();\n    this.tf = new F();\n    this.he = new F();\n    this.au = new H();\n    this.Wt = new H();\n  };\n  Rp.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"LayoutNetwork\" + (null !== this.layout ? \"(\" + this.layout.toString() + \")\" : \"\");\n    if (0 >= a) return b;\n    b += \" vertexes: \" + this.tf.count + \" edges: \" + this.he.count;\n    if (1 < a) {\n      for (var c = this.tf.iterator; c.next();) b += \"\\n    \" + c.value.toString(a - 1);\n      for (c = this.he.iterator; c.next();) b += \"\\n    \" + c.value.toString(a - 1);\n    }\n    return b;\n  };\n  Rp.prototype.createVertex = function () {\n    return new eq(this);\n  };\n  Rp.prototype.createEdge = function () {\n    return new fq(this);\n  };\n  Rp.prototype.Ag = function (a, b, c) {\n    if (null !== a) {\n      void 0 === b && (b = !1);\n      void 0 === c && (c = null);\n      null === c && (c = function (a) {\n        if (a instanceof V) return !a.isLinkLabel;\n        if (a instanceof S) {\n          var b = a.fromNode;\n          if (null === b || b.isLinkLabel) return !1;\n          a = a.toNode;\n          return null === a || a.isLinkLabel ? !1 : !0;\n        }\n        return !1;\n      });\n      for (a = a.iterator; a.next();) {\n        var d = a.value;\n        if (d instanceof V && (!b || d.isTopLevel) && d.canLayout() && c(d)) if (d instanceof vf && null === d.layout) this.Ag(d.memberParts, !1);else if (null === this.kj(d)) {\n          var e = this.createVertex();\n          e.node = d;\n          this.Bg(e);\n        }\n      }\n      for (a.reset(); a.next();) if (d = a.value, d instanceof S && (!b || d.isTopLevel) && d.canLayout() && c(d) && null === this.Cq(d)) {\n        var f = d.fromNode;\n        e = d.toNode;\n        null !== f && null !== e && f !== e && (f = this.findGroupVertex(f), e = this.findGroupVertex(e), null !== f && null !== e && this.Ak(f, e, d));\n      }\n    }\n  };\n  Rp.prototype.findGroupVertex = function (a) {\n    if (null === a) return null;\n    var b = a.findVisibleNode();\n    if (null === b) return null;\n    a = this.kj(b);\n    if (null !== a) return a;\n    for (b = b.containingGroup; null !== b;) {\n      a = this.kj(b);\n      if (null !== a) return a;\n      b = b.containingGroup;\n    }\n    return null;\n  };\n  t = Rp.prototype;\n  t.Bg = function (a) {\n    if (null !== a) {\n      this.tf.add(a);\n      var b = a.node;\n      null !== b && this.au.add(b, a);\n      a.network = this;\n    }\n  };\n  t.jk = function (a) {\n    if (null === a) return null;\n    var b = this.kj(a);\n    null === b && (b = this.createVertex(), b.node = a, this.Bg(b));\n    return b;\n  };\n  t.Nv = function (a) {\n    if (null !== a && gq(this, a)) {\n      for (var b = a.Le, c = b.count - 1; 0 <= c; c--) {\n        var d = b.L(c);\n        this.sk(d);\n      }\n      b = a.Ee;\n      for (a = b.count - 1; 0 <= a; a--) c = b.L(a), this.sk(c);\n    }\n  };\n  function gq(a, b) {\n    if (null === b) return !1;\n    var c = a.tf.remove(b);\n    c && (b = b.node, null !== b && a.au.remove(b));\n    return c;\n  }\n  t.Gz = function (a) {\n    null !== a && (a = this.kj(a), null !== a && this.Nv(a));\n  };\n  t.kj = function (a) {\n    return null === a ? null : this.au.H(a);\n  };\n  t.nm = function (a) {\n    if (null !== a) {\n      hq(this, a);\n      var b = a.toVertex;\n      null !== b && b.Ev(a);\n      b = a.fromVertex;\n      null !== b && b.Cv(a);\n    }\n  };\n  function hq(a, b) {\n    if (null !== b) {\n      a.he.add(b);\n      var c = b.link;\n      null !== c && null === a.Cq(c) && a.Wt.add(c, b);\n      b.network = a;\n    }\n  }\n  t.Tx = function (a) {\n    if (null === a) return null;\n    var b = a.fromNode,\n      c = a.toNode,\n      d = this.Cq(a);\n    null === d ? (d = this.createEdge(), d.link = a, null !== b && (d.fromVertex = this.jk(b)), null !== c && (d.toVertex = this.jk(c)), this.nm(d)) : (null !== b ? d.fromVertex = this.jk(b) : d.fromVertex = null, null !== c ? d.toVertex = this.jk(c) : d.toVertex = null);\n    return d;\n  };\n  t.sk = function (a) {\n    if (null !== a) {\n      var b = a.toVertex;\n      null !== b && b.Mv(a);\n      b = a.fromVertex;\n      null !== b && b.Lv(a);\n      iq(this, a);\n    }\n  };\n  function iq(a, b) {\n    null !== b && a.he.remove(b) && (b = b.link, null !== b && a.Wt.remove(b));\n  }\n  t.Fz = function (a) {\n    null !== a && (a = this.Cq(a), null !== a && this.sk(a));\n  };\n  t.Cq = function (a) {\n    return null === a ? null : this.Wt.H(a);\n  };\n  t.Ak = function (a, b, c) {\n    if (null === a || null === b) return null;\n    if (a.network === this && b.network === this) {\n      var d = this.createEdge();\n      d.link = c;\n      d.fromVertex = a;\n      d.toVertex = b;\n      this.nm(d);\n      return d;\n    }\n    return null;\n  };\n  t.Qm = function (a) {\n    if (null !== a) {\n      var b = a.fromVertex,\n        c = a.toVertex;\n      null !== b && null !== c && (b.Lv(a), c.Mv(a), a.Qm(), b.Ev(a), c.Cv(a));\n    }\n  };\n  t.zq = function () {\n    for (var a = Ea(), b = this.he.iterator; b.next();) {\n      var c = b.value;\n      c.fromVertex === c.toVertex && a.push(c);\n    }\n    b = a.length;\n    for (c = 0; c < b; c++) this.sk(a[c]);\n    Ha(a);\n  };\n  Rp.prototype.deleteArtificialVertexes = function () {\n    for (var a = Ea(), b = this.tf.iterator; b.next();) {\n      var c = b.value;\n      null === c.node && null === c.data && a.push(c);\n    }\n    c = a.length;\n    for (b = 0; b < c; b++) this.Nv(a[b]);\n    b = Ea();\n    for (c = this.he.iterator; c.next();) {\n      var d = c.value;\n      null === d.link && null === d.data && b.push(d);\n    }\n    c = b.length;\n    for (d = 0; d < c; d++) this.sk(b[d]);\n    Ha(a);\n    Ha(b);\n  };\n  function jq(a) {\n    for (var b = Ea(), c = a.he.iterator; c.next();) {\n      var d = c.value;\n      null !== d.fromVertex && null !== d.toVertex || b.push(d);\n    }\n    c = b.length;\n    for (d = 0; d < c; d++) a.sk(b[d]);\n    Ha(b);\n  }\n  Rp.prototype.Uy = function (a) {\n    void 0 === a && (a = !0);\n    a && (this.deleteArtificialVertexes(), jq(this), this.zq());\n    a = new E();\n    for (var b = !0; b;) {\n      b = !1;\n      for (var c = this.tf.iterator; c.next();) {\n        var d = c.value;\n        if (0 < d.Le.count || 0 < d.Ee.count) {\n          b = this.layout.createNetwork();\n          a.add(b);\n          kq(this, b, d);\n          b = !0;\n          break;\n        }\n      }\n    }\n    a.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : b.vertexes.count - a.vertexes.count;\n    });\n    return a;\n  };\n  function kq(a, b, c) {\n    if (null !== c && c.network !== b) {\n      gq(a, c);\n      b.Bg(c);\n      for (var d = c.sourceEdges; d.next();) {\n        var e = d.value;\n        e.network !== b && (iq(a, e), hq(b, e), kq(a, b, e.fromVertex));\n      }\n      for (d = c.destinationEdges; d.next();) c = d.value, c.network !== b && (iq(a, c), hq(b, c), kq(a, b, c.toVertex));\n    }\n  }\n  Rp.prototype.Mz = function () {\n    for (var a = new F(), b = this.tf.iterator; b.next();) a.add(b.value.node);\n    for (b = this.he.iterator; b.next();) a.add(b.value.link);\n    return a;\n  };\n  ma.Object.defineProperties(Rp.prototype, {\n    layout: {\n      get: function () {\n        return this.kc;\n      },\n      set: function (a) {\n        null !== a && (this.kc = a);\n      }\n    },\n    vertexes: {\n      get: function () {\n        return this.tf;\n      }\n    },\n    edges: {\n      get: function () {\n        return this.he;\n      }\n    }\n  });\n  Rp.prototype.findAllParts = Rp.prototype.Mz;\n  Rp.prototype.splitIntoSubNetworks = Rp.prototype.Uy;\n  Rp.prototype.deleteSelfEdges = Rp.prototype.zq;\n  Rp.prototype.reverseEdge = Rp.prototype.Qm;\n  Rp.prototype.linkVertexes = Rp.prototype.Ak;\n  Rp.prototype.findEdge = Rp.prototype.Cq;\n  Rp.prototype.deleteLink = Rp.prototype.Fz;\n  Rp.prototype.deleteEdge = Rp.prototype.sk;\n  Rp.prototype.addLink = Rp.prototype.Tx;\n  Rp.prototype.addEdge = Rp.prototype.nm;\n  Rp.prototype.findVertex = Rp.prototype.kj;\n  Rp.prototype.deleteNode = Rp.prototype.Gz;\n  Rp.prototype.deleteVertex = Rp.prototype.Nv;\n  Rp.prototype.addNode = Rp.prototype.jk;\n  Rp.prototype.addVertex = Rp.prototype.Bg;\n  Rp.prototype.addParts = Rp.prototype.Ag;\n  Rp.className = \"LayoutNetwork\";\n  function eq(a) {\n    Ya(this);\n    this.Qc = a;\n    this.l = new N(0, 0, 10, 10).freeze();\n    this.v = new J(5, 5).freeze();\n    this.Li = this.lb = null;\n    this.Le = new E();\n    this.Ee = new E();\n  }\n  eq.prototype.serializeVertexProperties = function (a) {\n    a.id = mb(this);\n    a.key = this.node ? this.node.key : this.data ? this.data.Ci : void 0;\n    void 0 === a.key && (a.key = null);\n    a.x = this.bounds.x;\n    a.y = this.bounds.y;\n    a.dB = this.bounds.width;\n    a.oA = this.bounds.height;\n    a.fx = this.focus.x;\n    a.fy = this.focus.y;\n    var b = [];\n    this.Le.each(function (a) {\n      b.push(mb(a));\n    });\n    a.Ry = b;\n    var c = [];\n    this.Ee.each(function (a) {\n      c.push(mb(a));\n    });\n    a.gy = c;\n  };\n  eq.prototype.Aq = function (a, b, c) {\n    if (null !== a) {\n      this.x = a.x;\n      this.y = a.y;\n      this.width = a.dB;\n      this.height = a.oA;\n      this.focusX = a.fx;\n      this.focusY = a.fy;\n      var d = this;\n      a.Ry && a.Ry.forEach(function (a) {\n        (a = c.get(a)) && d.Le.add(a);\n      });\n      a.gy && a.gy.forEach(function (a) {\n        (a = c.get(a)) && d.Ee.add(a);\n      });\n    }\n  };\n  eq.prototype.clear = function () {\n    this.Li = this.lb = null;\n    this.Le = new E();\n    this.Ee = new E();\n  };\n  eq.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"LayoutVertex#\" + mb(this);\n    if (0 < a && (b += null !== this.node ? \"(\" + this.node.toString() + \")\" : \"\", 1 < a)) {\n      a = \"\";\n      for (var c = !0, d = this.Le.iterator; d.next();) {\n        var e = d.value;\n        c ? c = !1 : a += \",\";\n        a += e.toString(0);\n      }\n      e = \"\";\n      c = !0;\n      for (d = this.Ee.iterator; d.next();) {\n        var f = d.value;\n        c ? c = !1 : e += \",\";\n        e += f.toString(0);\n      }\n      b += \" sources: \" + a + \" destinations: \" + e;\n    }\n    return b;\n  };\n  eq.prototype.commit = function () {\n    var a = this.lb;\n    if (null !== a) {\n      var b = this.bounds,\n        c = a.bounds;\n      ya(c) ? (c.x = b.x, c.y = b.y, c.width = b.width, c.height = b.height) : a.bounds = b.copy();\n    } else if (a = this.node, null !== a) {\n      b = this.bounds;\n      if (!(a instanceof vf)) {\n        c = N.alloc();\n        var d = this.network.layout.mj(a, c),\n          e = a.locationObject.ga(Bc);\n        if (d.u() && e.u()) {\n          a.moveTo(b.x + this.focusX - (e.x - d.x), b.y + this.focusY - (e.y - d.y));\n          N.free(c);\n          return;\n        }\n        N.free(c);\n      }\n      a.moveTo(b.x, b.y);\n    }\n  };\n  eq.prototype.Ev = function (a) {\n    null !== a && (this.Le.contains(a) || this.Le.add(a));\n  };\n  eq.prototype.Mv = function (a) {\n    null !== a && this.Le.remove(a);\n  };\n  eq.prototype.Cv = function (a) {\n    null !== a && (this.Ee.contains(a) || this.Ee.add(a));\n  };\n  eq.prototype.Lv = function (a) {\n    null !== a && this.Ee.remove(a);\n  };\n  function lq(a, b) {\n    a = a.Li;\n    b = b.Li;\n    return a ? b ? (a = a.text, b = b.text, a < b ? -1 : a > b ? 1 : 0) : 1 : null !== b ? -1 : 0;\n  }\n  ma.Object.defineProperties(eq.prototype, {\n    sourceEdgesArrayAccess: {\n      get: function () {\n        return this.Le._dataArray;\n      }\n    },\n    destinationEdgesArrayAccess: {\n      get: function () {\n        return this.Ee._dataArray;\n      }\n    },\n    data: {\n      get: function () {\n        return this.lb;\n      },\n      set: function (a) {\n        this.lb = a;\n        if (null !== a && a.bounds) {\n          var b = a.bounds;\n          a = b.x;\n          var c = b.y,\n            d = b.width;\n          b = b.height;\n          this.v.h(d / 2, b / 2);\n          this.l.h(a, c, d, b);\n        }\n      }\n    },\n    node: {\n      get: function () {\n        return this.Li;\n      },\n      set: function (a) {\n        if (this.Li !== a) {\n          this.Li = a;\n          a.Ta();\n          var b = this.network.layout,\n            c = N.alloc(),\n            d = b.mj(a, c);\n          b = d.x;\n          var e = d.y,\n            f = d.width;\n          d = d.height;\n          isNaN(b) && (b = 0);\n          isNaN(e) && (e = 0);\n          this.l.h(b, e, f, d);\n          N.free(c);\n          if (!(a instanceof vf) && (a = a.locationObject.ga(Bc), a.u())) {\n            this.v.h(a.x - b, a.y - e);\n            return;\n          }\n          this.v.h(f / 2, d / 2);\n        }\n      }\n    },\n    bounds: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l.w(a) || this.l.assign(a);\n      }\n    },\n    focus: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v.w(a) || this.v.assign(a);\n      }\n    },\n    centerX: {\n      get: function () {\n        return this.l.x + this.v.x;\n      },\n      set: function (a) {\n        var b = this.l;\n        b.x + this.v.x !== a && (b.ea(), b.x = a - this.v.x, b.freeze());\n      }\n    },\n    centerY: {\n      get: function () {\n        return this.l.y + this.v.y;\n      },\n      set: function (a) {\n        var b = this.l;\n        b.y + this.v.y !== a && (b.ea(), b.y = a - this.v.y, b.freeze());\n      }\n    },\n    focusX: {\n      get: function () {\n        return this.v.x;\n      },\n      set: function (a) {\n        var b = this.v;\n        b.x !== a && (b.ea(), b.x = a, b.freeze());\n      }\n    },\n    focusY: {\n      get: function () {\n        return this.v.y;\n      },\n      set: function (a) {\n        var b = this.v;\n        b.y !== a && (b.ea(), b.y = a, b.freeze());\n      }\n    },\n    x: {\n      get: function () {\n        return this.l.x;\n      },\n      set: function (a) {\n        var b = this.l;\n        b.x !== a && (b.ea(), b.x = a, b.freeze());\n      }\n    },\n    y: {\n      get: function () {\n        return this.l.y;\n      },\n      set: function (a) {\n        var b = this.l;\n        b.y !== a && (b.ea(), b.y = a, b.freeze());\n      }\n    },\n    width: {\n      get: function () {\n        return this.l.width;\n      },\n      set: function (a) {\n        var b = this.l;\n        b.width !== a && (b.ea(), b.width = a, b.freeze());\n      }\n    },\n    height: {\n      get: function () {\n        return this.l.height;\n      },\n      set: function (a) {\n        var b = this.l;\n        b.height !== a && (b.ea(), b.height = a, b.freeze());\n      }\n    },\n    network: {\n      get: function () {\n        return this.Qc;\n      },\n      set: function (a) {\n        this.Qc = a;\n      }\n    },\n    sourceVertexes: {\n      get: function () {\n        for (var a = new F(), b = this.sourceEdges; b.next();) a.add(b.value.fromVertex);\n        return a.iterator;\n      }\n    },\n    destinationVertexes: {\n      get: function () {\n        for (var a = new F(), b = this.destinationEdges; b.next();) a.add(b.value.toVertex);\n        return a.iterator;\n      }\n    },\n    vertexes: {\n      get: function () {\n        for (var a = new F(), b = this.sourceEdges; b.next();) a.add(b.value.fromVertex);\n        for (b = this.destinationEdges; b.next();) a.add(b.value.toVertex);\n        return a.iterator;\n      }\n    },\n    sourceEdges: {\n      get: function () {\n        return this.Le.iterator;\n      }\n    },\n    destinationEdges: {\n      get: function () {\n        return this.Ee.iterator;\n      }\n    },\n    edges: {\n      get: function () {\n        for (var a = new E(), b = this.sourceEdges; b.next();) a.add(b.value);\n        for (b = this.destinationEdges; b.next();) a.add(b.value);\n        return a.iterator;\n      }\n    },\n    edgesCount: {\n      get: function () {\n        return this.Le.count + this.Ee.count;\n      }\n    }\n  });\n  eq.prototype.deleteDestinationEdge = eq.prototype.Lv;\n  eq.prototype.addDestinationEdge = eq.prototype.Cv;\n  eq.prototype.deleteSourceEdge = eq.prototype.Mv;\n  eq.prototype.addSourceEdge = eq.prototype.Ev;\n  eq.className = \"LayoutVertex\";\n  eq.standardComparer = lq;\n  eq.smartComparer = function (a, b) {\n    if (null !== a) {\n      if (null !== b) {\n        a = a.Li;\n        var c = b.Li;\n        if (null !== a) {\n          if (null !== c) {\n            b = a.text.toLocaleLowerCase().split(/([+\\-]?[\\.]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?)/);\n            a = c.text.toLocaleLowerCase().split(/([+\\-]?[\\.]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?)/);\n            for (c = 0; c < b.length; c++) if (\"\" !== a[c] && void 0 !== a[c]) {\n              var d = parseFloat(b[c]),\n                e = parseFloat(a[c]);\n              if (isNaN(d)) {\n                if (isNaN(e)) {\n                  if (0 !== b[c].localeCompare(a[c])) return b[c].localeCompare(a[c]);\n                } else return 1;\n              } else {\n                if (isNaN(e)) return -1;\n                if (0 !== d - e) return d - e;\n              }\n            } else if (\"\" !== b[c]) return 1;\n            return \"\" !== a[c] && void 0 !== a[c] ? -1 : 0;\n          }\n          return 1;\n        }\n        return null !== c ? -1 : 0;\n      }\n      return 1;\n    }\n    return null !== b ? -1 : 0;\n  };\n  function fq(a) {\n    Ya(this);\n    this.Pc = a;\n    this.vg = this.Wf = this.Hl = this.lb = null;\n  }\n  fq.prototype.clear = function () {\n    this.vg = this.Wf = this.Hl = this.lb = null;\n  };\n  fq.prototype.serializeEdgeProperties = function (a) {\n    a.id = mb(this);\n    a.key = this.link ? this.link.key : this.data ? this.data.Ci : void 0;\n    void 0 === a.key && (a.key = null);\n    a.from = this.fromVertex ? mb(this.fromVertex) : null;\n    a.ZA = this.toVertex ? mb(this.toVertex) : null;\n  };\n  fq.prototype.deserializeEdgeProperties = function (a, b) {\n    if (null !== a) {\n      var c = b.get(a.from);\n      c && (this.fromVertex = c);\n      if (a = b.get(a.ZA)) this.toVertex = a;\n    }\n  };\n  fq.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"LayoutEdge#\" + mb(this);\n    0 < a && (b += null !== this.Hl ? \"(\" + this.Hl.toString() + \")\" : \"\", 1 < a && (b += \" \" + (this.Wf ? this.Wf.toString() : \"null\") + \" --\\x3e \" + (this.vg ? this.vg.toString() : \"null\")));\n    return b;\n  };\n  fq.prototype.Qm = function () {\n    var a = this.Wf;\n    this.Wf = this.vg;\n    this.vg = a;\n  };\n  fq.prototype.commit = function () {};\n  fq.prototype.wy = function (a) {\n    return this.vg === a ? this.Wf : this.Wf === a ? this.vg : null;\n  };\n  ma.Object.defineProperties(fq.prototype, {\n    network: {\n      get: function () {\n        return this.Pc;\n      },\n      set: function (a) {\n        this.Pc = a;\n      }\n    },\n    data: {\n      get: function () {\n        return this.lb;\n      },\n      set: function (a) {\n        this.lb !== a && (this.lb = a);\n      }\n    },\n    link: {\n      get: function () {\n        return this.Hl;\n      },\n      set: function (a) {\n        this.Hl !== a && (this.Hl = a);\n      }\n    },\n    fromVertex: {\n      get: function () {\n        return this.Wf;\n      },\n      set: function (a) {\n        this.Wf !== a && (this.Wf = a);\n      }\n    },\n    toVertex: {\n      get: function () {\n        return this.vg;\n      },\n      set: function (a) {\n        this.vg !== a && (this.vg = a);\n      }\n    }\n  });\n  fq.prototype.getOtherVertex = fq.prototype.wy;\n  fq.className = \"LayoutEdge\";\n  function Mk() {\n    yi.call(this);\n    this.isViewportSized = !0;\n    this.pq = this.qq = NaN;\n    this.Qg = new M(NaN, NaN).freeze();\n    this.kf = new M(10, 10).freeze();\n    this.yb = mq;\n    this.Eb = nq;\n    this.Yc = oq;\n    this.Tc = pq;\n  }\n  la(Mk, yi);\n  Mk.prototype.cloneProtected = function (a) {\n    yi.prototype.cloneProtected.call(this, a);\n    a.qq = this.qq;\n    a.pq = this.pq;\n    a.Qg.assign(this.Qg);\n    a.kf.assign(this.kf);\n    a.yb = this.yb;\n    a.Eb = this.Eb;\n    a.Yc = this.Yc;\n    a.Tc = this.Tc;\n  };\n  Mk.prototype.hb = function (a) {\n    a.classType === Mk ? a === oq || a === qq || a === rq || a === sq ? this.sorting = a : a === nq || a === tq ? this.arrangement = a : a === mq || a === uq ? this.alignment = a : B(\"Unknown enum value: \" + a) : yi.prototype.hb.call(this, a);\n  };\n  Mk.prototype.doLayout = function (a) {\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    var b = this.Yx(a);\n    a = this.diagram;\n    for (var c = b.copy().iterator; c.next();) {\n      var d = c.value;\n      if (!d.Ph() || null === d.fromNode && null === d.toNode) {\n        if (d.Ta(), d instanceof vf) for (d = d.memberParts; d.next();) b.remove(d.value);\n      } else b.remove(d);\n    }\n    var e = b.ma();\n    if (0 !== e.length) {\n      switch (this.sorting) {\n        case sq:\n          e.reverse();\n          break;\n        case oq:\n          e.sort(this.comparer);\n          break;\n        case qq:\n          e.sort(this.comparer), e.reverse();\n      }\n      var f = this.wrappingColumn;\n      isNaN(f) && (f = 0);\n      var g = this.wrappingWidth;\n      isNaN(g) && null !== a ? (b = a.padding, g = Math.max(a.viewportBounds.width - b.left - b.right, 0)) : g = Math.max(this.wrappingWidth, 0);\n      0 >= f && 0 >= g && (f = 1);\n      b = this.spacing.width;\n      isFinite(b) || (b = 0);\n      c = this.spacing.height;\n      isFinite(c) || (c = 0);\n      null !== a && a.va(\"Layout\");\n      d = [];\n      switch (this.alignment) {\n        case uq:\n          var h = b,\n            k = c,\n            l = N.alloc(),\n            m = Math.max(this.cellSize.width, 1);\n          if (!isFinite(m)) for (var n = m = 0; n < e.length; n++) {\n            var p = this.mj(e[n], l);\n            m = Math.max(m, p.width);\n          }\n          m = Math.max(m + h, 1);\n          n = Math.max(this.cellSize.height, 1);\n          if (!isFinite(n)) for (p = n = 0; p < e.length; p++) {\n            var r = this.mj(e[p], l);\n            n = Math.max(n, r.height);\n          }\n          n = Math.max(n + k, 1);\n          p = this.arrangement;\n          for (var q = r = this.arrangementOrigin.x, u = this.arrangementOrigin.y, v = 0, w = 0, y = 0; y < e.length; y++) {\n            var z = e[y],\n              A = this.mj(z, l),\n              C = Math.ceil((A.width + h) / m) * m,\n              G = Math.ceil((A.height + k) / n) * n;\n            switch (p) {\n              case tq:\n                var L = Math.abs(q - A.width);\n                break;\n              default:\n                L = q + A.width;\n            }\n            if (0 < f && v > f - 1 || 0 < g && 0 < v && L - r > g) d.push(new N(0, u, g + h, w)), v = 0, q = r, u += w, w = 0;\n            w = Math.max(w, G);\n            switch (p) {\n              case tq:\n                A = -A.width;\n                break;\n              default:\n                A = 0;\n            }\n            z.moveTo(q + A, u);\n            switch (p) {\n              case tq:\n                q -= C;\n                break;\n              default:\n                q += C;\n            }\n            v++;\n          }\n          d.push(new N(0, u, g + h, w));\n          N.free(l);\n          break;\n        case mq:\n          k = g;\n          m = f;\n          n = b;\n          p = c;\n          g = N.alloc();\n          r = Math.max(this.cellSize.width, 1);\n          f = u = l = 0;\n          h = J.alloc();\n          for (q = 0; q < e.length; q++) w = e[q], v = this.mj(w, g), w = w.Cf(w.locationObject, w.locationSpot, h), l = Math.max(l, w.x), u = Math.max(u, v.width - w.x), f = Math.max(f, w.y);\n          q = this.arrangement;\n          switch (q) {\n            case tq:\n              l += n;\n              break;\n            default:\n              u += n;\n          }\n          r = isFinite(r) ? Math.max(r + n, 1) : Math.max(l + u, 1);\n          var I = w = this.arrangementOrigin.x;\n          y = this.arrangementOrigin.y;\n          u = 0;\n          k >= l && (k -= l);\n          l = z = 0;\n          C = Math.max(this.cellSize.height, 1);\n          A = f = 0;\n          G = !0;\n          v = J.alloc();\n          for (L = 0; L < e.length; L++) {\n            var T = e[L],\n              R = this.mj(T, g),\n              ca = T.Cf(T.locationObject, T.locationSpot, h);\n            if (0 < u) switch (q) {\n              case tq:\n                I = (I - w - (R.width - ca.x)) / r;\n                I = K.$(Math.round(I), I) ? Math.round(I) : Math.floor(I);\n                I = I * r + w;\n                break;\n              default:\n                I = (I - w + ca.x) / r, I = K.$(Math.round(I), I) ? Math.round(I) : Math.ceil(I), I = I * r + w;\n            } else switch (q) {\n              case tq:\n                z = I + ca.x + R.width;\n                break;\n              default:\n                z = I - ca.x;\n            }\n            switch (q) {\n              case tq:\n                var qa = -(I + ca.x) + z;\n                break;\n              default:\n                qa = I + R.width - ca.x - z;\n            }\n            if (0 < m && u > m - 1 || 0 < k && 0 < u && qa > k) {\n              d.push(new N(0, G ? y - f : y, k + n, A + f + p));\n              for (I = 0; I < u && L !== u; I++) {\n                qa = e[L - u + I];\n                var O = qa.Cf(qa.locationObject, qa.locationSpot, v);\n                qa.moveTo(qa.position.x, qa.position.y + f - O.y);\n              }\n              A += p;\n              y = G ? y + A : y + (A + f);\n              u = A = f = 0;\n              I = w;\n              G = !1;\n            }\n            I === w && (l = q === tq ? Math.max(l, R.width - ca.x) : Math.min(l, -ca.x));\n            f = Math.max(f, ca.y);\n            A = Math.max(A, R.height - ca.y);\n            isFinite(C) && (A = Math.max(A, Math.max(R.height, C) - ca.y));\n            G ? T.moveTo(I - ca.x, y - ca.y) : T.moveTo(I - ca.x, y);\n            switch (q) {\n              case tq:\n                I -= ca.x + n;\n                break;\n              default:\n                I += R.width - ca.x + n;\n            }\n            u++;\n          }\n          d.push(new N(0, y, k + n, (G ? A : A + f) + p));\n          if (e.length !== u) for (k = 0; k < u; k++) m = e[e.length - u + k], n = m.Cf(m.locationObject, m.locationSpot, h), m.moveTo(m.position.x, m.position.y + f - n.y);\n          J.free(h);\n          J.free(v);\n          if (q === tq) for (e = 0; e < d.length; e++) f = d[e], f.width += l, f.x -= l;else for (e = 0; e < d.length; e++) f = d[e], f.x > l && (f.width += f.x - l, f.x = l);\n          N.free(g);\n      }\n      for (h = f = g = e = 0; h < d.length; h++) k = d[h], e = Math.min(e, k.x), g = Math.min(g, k.y), f = Math.max(f, k.x + k.width);\n      this.arrangement === tq ? this.commitLayers(d, new J(e + b / 2 - (f + e), g - c / 2)) : this.commitLayers(d, new J(e - b / 2, g - c / 2));\n      null !== a && a.Wa(\"Layout\");\n      this.isValidLayout = !0;\n    }\n  };\n  Mk.prototype.commitLayers = function () {};\n  function pq(a, b) {\n    a = a.text;\n    b = b.text;\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n  ma.Object.defineProperties(Mk.prototype, {\n    wrappingWidth: {\n      get: function () {\n        return this.qq;\n      },\n      set: function (a) {\n        this.qq !== a && (0 < a || isNaN(a)) && (this.qq = a, this.isViewportSized = isNaN(a), this.C());\n      }\n    },\n    wrappingColumn: {\n      get: function () {\n        return this.pq;\n      },\n      set: function (a) {\n        this.pq !== a && (0 < a || isNaN(a)) && (this.pq = a, this.C());\n      }\n    },\n    cellSize: {\n      get: function () {\n        return this.Qg;\n      },\n      set: function (a) {\n        this.Qg.w(a) || (this.Qg.assign(a), this.C());\n      }\n    },\n    spacing: {\n      get: function () {\n        return this.kf;\n      },\n      set: function (a) {\n        this.kf.w(a) || (this.kf.assign(a), this.C());\n      }\n    },\n    alignment: {\n      get: function () {\n        return this.yb;\n      },\n      set: function (a) {\n        this.yb === a || a !== mq && a !== uq || (this.yb = a, this.C());\n      }\n    },\n    arrangement: {\n      get: function () {\n        return this.Eb;\n      },\n      set: function (a) {\n        this.Eb === a || a !== nq && a !== tq || (this.Eb = a, this.C());\n      }\n    },\n    sorting: {\n      get: function () {\n        return this.Yc;\n      },\n      set: function (a) {\n        this.Yc === a || a !== rq && a !== sq && a !== oq && a !== qq || (this.Yc = a, this.C());\n      }\n    },\n    comparer: {\n      get: function () {\n        return this.Tc;\n      },\n      set: function (a) {\n        this.Tc !== a && (this.Tc = a, this.C());\n      }\n    }\n  });\n  var uq = new D(Mk, \"Position\", 0),\n    mq = new D(Mk, \"Location\", 1),\n    nq = new D(Mk, \"LeftToRight\", 2),\n    tq = new D(Mk, \"RightToLeft\", 3),\n    rq = new D(Mk, \"Forward\", 4),\n    sq = new D(Mk, \"Reverse\", 5),\n    oq = new D(Mk, \"Ascending\", 6),\n    qq = new D(Mk, \"Descending\", 7);\n  Mk.className = \"GridLayout\";\n  Mk.standardComparer = pq;\n  Mk.smartComparer = function (a, b) {\n    if (null !== a) {\n      if (null !== b) {\n        a = a.text.toLocaleLowerCase().split(/([+\\-]?[\\.]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?)/);\n        b = b.text.toLocaleLowerCase().split(/([+\\-]?[\\.]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?)/);\n        for (var c = 0; c < a.length; c++) if (\"\" !== b[c] && void 0 !== b[c]) {\n          var d = parseFloat(a[c]),\n            e = parseFloat(b[c]);\n          if (isNaN(d)) {\n            if (isNaN(e)) {\n              if (0 !== a[c].localeCompare(b[c])) return a[c].localeCompare(b[c]);\n            } else return 1;\n          } else {\n            if (isNaN(e)) return -1;\n            if (0 !== d - e) return d - e;\n          }\n        } else if (\"\" !== a[c]) return 1;\n        return \"\" !== b[c] && void 0 !== b[c] ? -1 : 0;\n      }\n      return 1;\n    }\n    return null !== b ? -1 : 0;\n  };\n  Mk.Position = uq;\n  Mk.Location = mq;\n  Mk.LeftToRight = nq;\n  Mk.RightToLeft = tq;\n  Mk.Forward = rq;\n  Mk.Reverse = sq;\n  Mk.Ascending = oq;\n  Mk.Descending = qq;\n  function ti() {\n    this.hp = new F();\n    this.Jo = new F();\n    this.Da = new F();\n    this.Te = new H();\n    this.Se = new H();\n    this.Nj = new H();\n    this.B = null;\n    this.pr = !1;\n  }\n  t = ti.prototype;\n  t.clear = function () {\n    this.hp.clear();\n    this.Jo.clear();\n    this.Da.clear();\n    this.Te.clear();\n    this.Se.clear();\n    this.Nj.clear();\n  };\n  t.ae = function (a) {\n    this.B = a;\n  };\n  t.nj = function (a) {\n    if (a instanceof V) {\n      if (this.hp.add(a), a instanceof vf) {\n        var b = a.containingGroup;\n        null === b ? this.B.Dh.add(a) : b.Ml.add(a);\n        b = a.layout;\n        null !== b && (b.diagram = this.B);\n      }\n    } else a instanceof S ? this.Jo.add(a) : a instanceof He || this.Da.add(a);\n    b = a.data;\n    null === b || a instanceof He || (a instanceof S ? this.Se.add(b, a) : this.Te.add(b, a));\n  };\n  t.Kc = function (a) {\n    a.kk();\n    if (a instanceof V) {\n      if (this.hp.remove(a), a instanceof vf) {\n        var b = a.containingGroup;\n        null === b ? this.B.Dh.remove(a) : b.Ml.remove(a);\n        b = a.layout;\n        null !== b && (b.diagram = null);\n      }\n    } else a instanceof S ? this.Jo.remove(a) : a instanceof He || this.Da.remove(a);\n    b = a.data;\n    null === b || a instanceof He || (a instanceof S ? this.Se.remove(b) : this.Te.remove(b));\n  };\n  t.Ed = function () {\n    for (var a = this.B.nodeTemplateMap.iterator; a.next();) {\n      var b = a.value,\n        c = a.key;\n      (!b.Wb() || b instanceof vf) && B('Invalid node template in Diagram.nodeTemplateMap: template for \"' + c + '\" must be a Node or a simple Part, not a Group or Link: ' + b);\n    }\n    for (a = this.B.groupTemplateMap.iterator; a.next();) b = a.value, c = a.key, b instanceof vf || B('Invalid group template in Diagram.groupTemplateMap: template for \"' + c + '\" must be a Group, not a normal Node or Link: ' + b);\n    for (a = this.B.linkTemplateMap.iterator; a.next();) b = a.value, c = a.key, b instanceof S || B('Invalid link template in Diagram.linkTemplateMap: template for \"' + c + '\" must be a Link, not a normal Node or simple Part: ' + b);\n    a = Ea();\n    for (b = this.B.selection.iterator; b.next();) (c = b.value.data) && a.push(c);\n    b = Ea();\n    for (c = this.B.highlighteds.iterator; c.next();) {\n      var d = c.value.data;\n      d && b.push(d);\n    }\n    c = Ea();\n    for (d = this.nodes.iterator; d.next();) {\n      var e = d.value;\n      null !== e.data && (c.push(e.data), c.push(e.location));\n    }\n    for (d = this.links.iterator; d.next();) e = d.value, null !== e.data && (c.push(e.data), c.push(e.location));\n    for (d = this.parts.iterator; d.next();) e = d.value, null !== e.data && (c.push(e.data), c.push(e.location));\n    this.removeAllModeledParts();\n    this.addAllModeledParts();\n    for (d = 0; d < a.length; d++) e = this.yc(a[d]), null !== e && (e.isSelected = !0);\n    for (d = 0; d < b.length; d++) e = this.yc(b[d]), null !== e && (e.isHighlighted = !0);\n    for (d = 0; d < c.length; d += 2) e = this.yc(c[d]), null !== e && (e.location = c[d + 1]);\n    Ha(a);\n    Ha(b);\n    Ha(c);\n  };\n  ti.prototype.addAllModeledParts = function () {\n    this.addModeledParts(this.diagram.model.nodeDataArray);\n  };\n  ti.prototype.addModeledParts = function (a, b) {\n    var c = this,\n      d = this.diagram.model;\n    a.forEach(function (a) {\n      d.Za(a) && vq(c, a, !1);\n    });\n    a.forEach(function (a) {\n      d.Za(a) && c.resolveReferencesForData(a);\n    });\n    !1 !== b && ok(this.diagram, !1);\n  };\n  function vq(a, b, c) {\n    if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.Te.contains(b)) {\n      void 0 === c && (c = !0);\n      a: {\n        if (void 0 !== b && null !== b && !a.B.undoManager.isUndoingRedoing && !a.Te.contains(b)) {\n          var d = a.Gq(b);\n          var e = Jo(a, b, d);\n          if (null !== e && (xg(e), e = e.copy(), null !== e)) {\n            var f = a.diagram.skipsModelSourceBindings;\n            a.diagram.skipsModelSourceBindings = !0;\n            e.Mf = d;\n            e.lb = b;\n            a.pr && (e.hh = \"Tool\");\n            a.diagram.add(e);\n            e.lb = null;\n            e.data = b;\n            a.diagram.skipsModelSourceBindings = f;\n            d = e;\n            break a;\n          }\n        }\n        d = null;\n      }\n      null !== d && c && a.resolveReferencesForData(b);\n    }\n  }\n  ti.prototype.insertLink = function () {\n    return null;\n  };\n  ti.prototype.resolveReferencesForData = function () {};\n  ti.prototype.Gq = function (a) {\n    return this.B.model.Gq(a);\n  };\n  function Jo(a, b, c) {\n    a = a.B;\n    var d = a.model;\n    d.yk() && d.ew(b) ? (b = a.groupTemplateMap.H(c), null === b && (b = a.groupTemplateMap.H(\"\"), null === b && (wq || (wq = !0, wa('No Group template found for category \"' + c + '\"'), wa(\"  Using default group template\")), b = a.Du))) : (b = a.nodeTemplateMap.H(c), null === b && (b = a.nodeTemplateMap.H(\"\"), null === b && (xq || (xq = !0, wa('No Node template found for category \"' + c + '\"'), wa(\"  Using default node template\")), b = a.Fu)));\n    return b;\n  }\n  ti.prototype.getLinkCategoryForData = function () {\n    return \"\";\n  };\n  ti.prototype.setLinkCategoryForData = function () {};\n  ti.prototype.setFromNodeForLink = function () {};\n  ti.prototype.setToNodeForLink = function () {};\n  ti.prototype.findLinkTemplateForCategory = function (a) {\n    var b = this.B.linkTemplateMap.H(a);\n    null === b && (b = this.B.linkTemplateMap.H(\"\"), null === b && (yq || (yq = !0, wa('No Link template found for category \"' + a + '\"'), wa(\"  Using default link template\")), b = this.B.Eu));\n    return b;\n  };\n  ti.prototype.removeAllModeledParts = function () {\n    this.fu(this.diagram.model.nodeDataArray);\n  };\n  ti.prototype.fu = function (a) {\n    var b = this;\n    a.forEach(function (a) {\n      b.ar(a);\n    });\n  };\n  ti.prototype.ar = function (a) {\n    a = this.yc(a);\n    null !== a && (Lj(this.diagram, a, !1), this.unresolveReferencesForPart(a));\n  };\n  ti.prototype.unresolveReferencesForPart = function () {};\n  ti.prototype.removeDataForLink = function () {};\n  ti.prototype.findPartForKey = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.B.model.Kb(a);\n    return null !== a ? this.Te.H(a) : null;\n  };\n  ti.prototype.Cb = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.B.model.Kb(a);\n    if (null === a) return null;\n    a = this.Te.H(a);\n    return a instanceof V ? a : null;\n  };\n  ti.prototype.findLinkForKey = function () {\n    return null;\n  };\n  t = ti.prototype;\n  t.yc = function (a) {\n    if (null === a) return null;\n    var b = this.Te.H(a);\n    return null !== b ? b : b = this.Se.H(a);\n  };\n  t.gj = function (a) {\n    if (null === a) return null;\n    a = this.Te.H(a);\n    return a instanceof V ? a : null;\n  };\n  t.xc = function (a) {\n    return null === a ? null : this.Se.H(a);\n  };\n  t.Jt = function (a) {\n    for (var b = 0; b < arguments.length; ++b);\n    b = new F();\n    for (var c = this.hp.iterator; c.next();) {\n      var d = c.value,\n        e = d.data;\n      if (null !== e) for (var f = 0; f < arguments.length; f++) {\n        var g = arguments[f];\n        if (ya(g) && zq(this, e, g)) {\n          b.add(d);\n          break;\n        }\n      }\n    }\n    return b.iterator;\n  };\n  t.It = function (a) {\n    for (var b = 0; b < arguments.length; ++b);\n    b = new F();\n    for (var c = this.Jo.iterator; c.next();) {\n      var d = c.value,\n        e = d.data;\n      if (null !== e) for (var f = 0; f < arguments.length; f++) {\n        var g = arguments[f];\n        if (ya(g) && zq(this, e, g)) {\n          b.add(d);\n          break;\n        }\n      }\n    }\n    return b.iterator;\n  };\n  function zq(a, b, c) {\n    for (var d in c) {\n      var e = b[d],\n        f = c[d];\n      if (Aa(f)) {\n        if (!Aa(e) || e.length < f.length) return !1;\n        for (var g = 0; g < e.length; g++) {\n          var h = f[g];\n          if (void 0 !== h && !Aq(a, e[g], h)) return !1;\n        }\n      } else if (!Aq(a, e, f)) return !1;\n    }\n    return !0;\n  }\n  function Aq(a, b, c) {\n    if (\"function\" === typeof c) {\n      if (!c(b)) return !1;\n    } else if (c instanceof RegExp) {\n      if (!b || !c.test(b.toString())) return !1;\n    } else if (ya(b) && ya(c)) {\n      if (!zq(a, b, c)) return !1;\n    } else if (b !== c) return !1;\n    return !0;\n  }\n  ti.prototype.doModelChanged = function (a) {\n    if (this.B) {\n      var b = this.B;\n      if (a.model === b.model) {\n        var c = a.change;\n        b.doModelChanged(a);\n        if (b.Z) {\n          b.Z = !1;\n          try {\n            var d = a.modelChange;\n            if (\"\" !== d) {\n              if (c === ve) {\n                if (\"nodeCategory\" === d) {\n                  var e = this.yc(a.object),\n                    f = a.newValue;\n                  null !== e && \"string\" === typeof f && (e.category = f);\n                } else \"nodeDataArray\" === d && (this.fu(a.oldValue), this.addModeledParts(a.newValue));\n                b.isModified = !0;\n              } else if (c === xe) {\n                var g = a.newValue;\n                \"nodeDataArray\" === d && ya(g) && vq(this, g);\n                b.isModified = !0;\n              } else if (c === ye) {\n                var h = a.oldValue;\n                \"nodeDataArray\" === d && ya(h) && this.ar(h);\n                b.isModified = !0;\n              } else c === we && (\"SourceChanged\" === d ? null !== a.object ? this.updateDataBindings(a.object, a.propertyName) : (this.kr(), this.updateAllTargetBindings()) : \"ModelDisplaced\" === d && this.Ed());\n            } else if (c === ve) {\n              var k = a.propertyName,\n                l = a.object;\n              if (l === b.model) {\n                if (\"nodeKeyProperty\" === k || \"nodeCategoryProperty\" === k) b.undoManager.isUndoingRedoing || this.Ed();\n              } else this.updateDataBindings(l, k);\n              b.isModified = !0;\n            } else if (c === xe || c === ye) {\n              var m = a.change === xe,\n                n = m ? a.newParam : a.oldParam,\n                p = m ? a.newValue : a.oldValue,\n                r = this.Nj.H(a.object);\n              if (Array.isArray(r)) for (a = 0; a < r.length; a++) {\n                var q = r[a];\n                if (m) ln(q, p, n);else if (!(0 > n)) {\n                  var u = n + dn(q);\n                  q.Kc(u, !0);\n                  pn(q, u, n);\n                }\n              }\n              b.isModified = !0;\n            }\n          } finally {\n            b.Z = !0;\n          }\n        }\n      }\n    }\n  };\n  ti.prototype.updateAllTargetBindings = function (a) {\n    void 0 === a && (a = \"\");\n    for (var b = this.parts.iterator; b.next();) b.value.Ca(a);\n    for (b = this.nodes.iterator; b.next();) b.value.Ca(a);\n    for (b = this.links.iterator; b.next();) b.value.Ca(a);\n  };\n  ti.prototype.kr = function () {\n    for (var a = this.B.model, b = new F(), c = a.nodeDataArray, d = 0; d < c.length; d++) b.add(c[d]);\n    var e = [];\n    this.nodes.each(function (a) {\n      null === a.data || b.contains(a.data) || e.push(a.data);\n    });\n    this.parts.each(function (a) {\n      null === a.data || b.contains(a.data) || e.push(a.data);\n    });\n    e.forEach(function (b) {\n      Bq(a, b, !1);\n    });\n    for (d = 0; d < c.length; d++) {\n      var f = c[d];\n      null === this.yc(f) && Cq(a, f, !1);\n    }\n    this.refreshDataBoundLinks();\n    for (c = this.parts.iterator; c.next();) c.value.updateRelationshipsFromData();\n    for (c = this.nodes.iterator; c.next();) c.value.updateRelationshipsFromData();\n    for (c = this.links.iterator; c.next();) c.value.updateRelationshipsFromData();\n  };\n  ti.prototype.refreshDataBoundLinks = function () {};\n  ti.prototype.updateRelationshipsFromData = function () {};\n  ti.prototype.updateDataBindings = function (a, b) {\n    if (\"string\" === typeof b) {\n      var c = this.yc(a);\n      if (null !== c) c.Ca(b);else {\n        c = null;\n        for (var d = this.Nj.iterator; d.next();) {\n          for (var e = d.value, f = 0; f < e.length; f++) {\n            var g = e[f].ny(a);\n            null !== g && (null === c && (c = Ea()), c.push(g));\n          }\n          if (null !== c) break;\n        }\n        if (null !== c) {\n          for (d = 0; d < c.length; d++) c[d].Ca(b);\n          Ha(c);\n        }\n      }\n      a === this.diagram.model.modelData && this.updateAllTargetBindings(b);\n    }\n  };\n  function Hj(a, b) {\n    var c = b.Bi;\n    if (Aa(c)) {\n      var d = a.Nj.H(c);\n      if (null === d) d = [], d.push(b), a.Nj.add(c, d);else {\n        for (a = 0; a < d.length; a++) if (d[a] === b) return;\n        d.push(b);\n      }\n    }\n  }\n  function Kj(a, b, c) {\n    Fj(b, function (a) {\n      a = a.W.j;\n      for (var b = a.length, d = 0; d < b; d++) ak(c, a[d]);\n    });\n    var d = b.Bi;\n    if (Aa(d)) {\n      var e = a.Nj.H(d);\n      if (null !== e) for (var f = 0; f < e.length; f++) if (e[f] === b) {\n        e.splice(f, 1);\n        0 === e.length && a.Nj.remove(d);\n        break;\n      }\n    }\n  }\n  ti.prototype.qk = function (a, b, c) {\n    var d = new H();\n    if (Aa(a)) for (var e = 0; e < a.length; e++) Dq(this, a[e], b, d, c);else for (a = a.iterator; a.next();) Dq(this, a.value, b, d, c);\n    if (null !== b) {\n      c = b.model;\n      a = b.toolManager.findTool(\"Dragging\");\n      a = null !== a ? a.dragOptions.dragsLink : b.dl.dragsLink;\n      e = new F();\n      for (var f = new H(), g = d.iterator; g.next();) {\n        var h = g.value;\n        if (h instanceof S) a || null !== h.fromNode && null !== h.toNode || e.add(h);else if (h instanceof V && null !== h.data && c.Am()) {\n          var k = h;\n          h = g.key;\n          var l = h.Fg();\n          null !== l && (l = d.H(l), null !== l ? (c.be(k.data, c.ja(l.data)), k = b.xc(k.data), h = h.jj(), null !== h && null !== k && f.add(h, k)) : c.be(k.data, void 0));\n        }\n      }\n      0 < e.count && b.gu(e, !1);\n      if (0 < f.count) for (c = f.iterator; c.next();) d.add(c.key, c.value);\n    }\n    if (null !== b && null !== this.B && (b = b.model, c = b.afterCopyFunction, null !== c)) {\n      var m = new H();\n      d.each(function (a) {\n        null !== a.key.data && m.add(a.key.data, a.value.data);\n      });\n      c(m, b, this.B.model);\n    }\n    for (b = d.iterator; b.next();) b.value.Ca();\n    return d;\n  };\n  function Dq(a, b, c, d, e) {\n    if (null === b || e && !b.canCopy()) return null;\n    if (d.contains(b)) return d.H(b);\n    var f = a.copyPartData(b, c);\n    if (!(f instanceof U)) return null;\n    f.isSelected = !1;\n    f.isHighlighted = !1;\n    d.add(b, f);\n    if (b instanceof V) {\n      for (var g = b.linksConnected; g.next();) {\n        var h = g.value;\n        if (h.fromNode === b) {\n          var k = d.H(h);\n          null !== k && (k.fromNode = f);\n        }\n        h.toNode === b && (h = d.H(h), null !== h && (h.toNode = f));\n      }\n      if (b instanceof vf && f instanceof vf) for (b = b.memberParts; b.next();) g = Dq(a, b.value, c, d, e), g instanceof S || null === g || (g.containingGroup = f);\n    } else if (b instanceof S && f instanceof S) for (g = b.fromNode, null !== g && (g = d.H(g), null !== g && (f.fromNode = g)), g = b.toNode, null !== g && (g = d.H(g), null !== g && (f.toNode = g)), b = b.labelNodes; b.next();) g = Dq(a, b.value, c, d, e), null !== g && g instanceof V && (g.labeledLink = f);\n    return f;\n  }\n  ti.prototype.copyPartData = function (a, b) {\n    var c = null,\n      d = a.data;\n    if (null !== d && null !== b) {\n      var e = b.model;\n      a instanceof S || (d = e.copyNodeData(d), ya(d) && (e.uf(d), c = b.yc(d)));\n    } else xg(a), c = a.copy(), null !== c && (e = this.B, null !== b ? b.add(c) : null !== d && null !== e && null !== e.commandHandler && e.commandHandler.copiesClipboardData && (b = e.model, e = null, c instanceof S || (e = b.copyNodeData(d)), ya(e) && (c.data = e)));\n    return c;\n  };\n  ma.Object.defineProperties(ti.prototype, {\n    nodes: {\n      get: function () {\n        return this.hp;\n      }\n    },\n    links: {\n      get: function () {\n        return this.Jo;\n      }\n    },\n    parts: {\n      get: function () {\n        return this.Da;\n      }\n    },\n    diagram: {\n      get: function () {\n        return this.B;\n      }\n    },\n    addsToTemporaryLayer: {\n      get: function () {\n        return this.pr;\n      },\n      set: function (a) {\n        this.pr = a;\n      }\n    }\n  });\n  ti.prototype.updateAllRelationshipsFromData = ti.prototype.kr;\n  ti.prototype.findLinksByExample = ti.prototype.It;\n  ti.prototype.findNodesByExample = ti.prototype.Jt;\n  ti.prototype.findLinkForData = ti.prototype.xc;\n  ti.prototype.findNodeForData = ti.prototype.gj;\n  ti.prototype.findPartForData = ti.prototype.yc;\n  ti.prototype.findNodeForKey = ti.prototype.Cb;\n  ti.prototype.removeModeledPart = ti.prototype.ar;\n  ti.prototype.removeModeledParts = ti.prototype.fu;\n  ti.prototype.rebuildParts = ti.prototype.Ed;\n  var xq = !1,\n    wq = !1,\n    yq = !1;\n  ti.className = \"PartManager\";\n  function Eq(a) {\n    ti.apply(this, arguments);\n  }\n  la(Eq, ti);\n  Eq.prototype.addAllModeledParts = function () {\n    var a = this.diagram.model;\n    this.addModeledParts(a.nodeDataArray);\n    Fq(this, a.linkDataArray);\n  };\n  Eq.prototype.addModeledParts = function (a) {\n    ti.prototype.addModeledParts.call(this, a, !1);\n    for (a = this.links.iterator; a.next();) Ko(a.value);\n    ok(this.diagram, !1);\n  };\n  function Fq(a, b) {\n    b.forEach(function (b) {\n      Gq(a, b);\n    });\n    ok(a.diagram, !1);\n  }\n  function Gq(a, b) {\n    if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.Se.contains(b)) {\n      var c = a.getLinkCategoryForData(b),\n        d = a.findLinkTemplateForCategory(c);\n      if (null !== d) {\n        xg(d);\n        var e = d.copy();\n        if (null !== e) {\n          d = a.diagram.skipsModelSourceBindings;\n          a.diagram.skipsModelSourceBindings = !0;\n          e.Mf = c;\n          e.lb = b;\n          c = a.diagram.model;\n          var f = Hq(c, b, !0);\n          \"\" !== f && (e.fromPortId = f);\n          f = Iq(c, b, !0);\n          void 0 !== f && (f = a.Cb(f), f instanceof V && (e.fromNode = f));\n          f = Hq(c, b, !1);\n          \"\" !== f && (e.toPortId = f);\n          f = Iq(c, b, !1);\n          void 0 !== f && (f = a.Cb(f), f instanceof V && (e.toNode = f));\n          c = c.Bf(b);\n          Array.isArray(c) && c.forEach(function (b) {\n            b = a.Cb(b);\n            null !== b && (b.labeledLink = e);\n          });\n          a.pr && (e.hh = \"Tool\");\n          a.diagram.add(e);\n          e.lb = null;\n          e.data = b;\n          a.diagram.skipsModelSourceBindings = d;\n        }\n      }\n    }\n  }\n  Eq.prototype.removeAllModeledParts = function () {\n    var a = this.diagram.model;\n    Jq(this, a.linkDataArray);\n    this.fu(a.nodeDataArray);\n  };\n  function Jq(a, b) {\n    b.forEach(function (b) {\n      a.ar(b);\n    });\n  }\n  Eq.prototype.getLinkCategoryForData = function (a) {\n    return this.diagram.model.Mt(a);\n  };\n  Eq.prototype.setLinkCategoryForData = function (a, b) {\n    return this.diagram.model.dr(a, b);\n  };\n  Eq.prototype.setFromNodeForLink = function (a, b) {\n    var c = this.diagram.model;\n    c.Aw(a.data, c.ja(null !== b ? b.data : null));\n  };\n  Eq.prototype.setToNodeForLink = function (a, b) {\n    var c = this.diagram.model;\n    c.Fw(a.data, c.ja(null !== b ? b.data : null));\n  };\n  Eq.prototype.removeDataForLink = function (a) {\n    this.diagram.model.Lm(a.data);\n  };\n  Eq.prototype.findPartForKey = function (a) {\n    var b = ti.prototype.findPartForKey.call(this, a);\n    return null === b && (a = this.diagram.model.Dg(a), null !== a) ? this.Se.H(a) : b;\n  };\n  Eq.prototype.findLinkForKey = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.diagram.model.Dg(a);\n    return null !== a ? this.Se.H(a) : null;\n  };\n  Eq.prototype.doModelChanged = function (a) {\n    var b = this;\n    ti.prototype.doModelChanged.call(this, a);\n    if (this.diagram) {\n      var c = this.diagram;\n      if (a.model === c.model) {\n        var d = a.change;\n        if (c.Z) {\n          c.Z = !1;\n          try {\n            var e = a.modelChange;\n            if (\"\" !== e) {\n              if (d === ve) {\n                if (\"linkFromKey\" === e) {\n                  var f = this.xc(a.object);\n                  if (null !== f) {\n                    var g = this.Cb(a.newValue);\n                    f.fromNode = g;\n                  }\n                } else if (\"linkToKey\" === e) {\n                  var h = this.xc(a.object);\n                  if (null !== h) {\n                    var k = this.Cb(a.newValue);\n                    h.toNode = k;\n                  }\n                } else if (\"linkFromPortId\" === e) {\n                  var l = this.xc(a.object);\n                  if (null !== l) {\n                    var m = a.newValue;\n                    \"string\" === typeof m && (l.fromPortId = m);\n                  }\n                } else if (\"linkToPortId\" === e) {\n                  var n = this.xc(a.object);\n                  if (null !== n) {\n                    var p = a.newValue;\n                    \"string\" === typeof p && (n.toPortId = p);\n                  }\n                } else if (\"nodeGroupKey\" === e) {\n                  var r = this.yc(a.object);\n                  if (null !== r) {\n                    var q = a.newValue;\n                    if (void 0 !== q) {\n                      var u = this.Cb(q);\n                      u instanceof vf ? r.containingGroup = u : r.containingGroup = null;\n                    } else r.containingGroup = null;\n                  }\n                } else if (\"linkLabelKeys\" === e) {\n                  var v = this.xc(a.object);\n                  if (null !== v) {\n                    var w = a.oldValue,\n                      y = a.newValue;\n                    Array.isArray(w) && w.forEach(function (a) {\n                      0 <= y.indexOf(a) || (a = b.Cb(a), null !== a && (a.labeledLink = null));\n                    });\n                    Array.isArray(y) && y.forEach(function (a) {\n                      a = b.Cb(a);\n                      null !== a && (a.labeledLink = v);\n                    });\n                  }\n                } else if (\"linkCategory\" === e) {\n                  var z = this.xc(a.object),\n                    A = a.newValue;\n                  null !== z && \"string\" === typeof A && (z.category = A);\n                } else \"linkDataArray\" === e && (Jq(this, a.oldValue), Fq(this, a.newValue));\n                c.isModified = !0;\n              } else if (d === xe) {\n                var C = a.newValue;\n                if (\"linkDataArray\" === e && \"object\" === typeof C && null !== C) Gq(this, C);else if (\"linkLabelKeys\" === e && Kq(C)) {\n                  var G = this.xc(a.object),\n                    L = this.Cb(C);\n                  null !== G && null !== L && (L.labeledLink = G);\n                }\n                c.isModified = !0;\n              } else {\n                if (d === ye) {\n                  var I = a.oldValue;\n                  if (\"linkDataArray\" === e && \"object\" === typeof I && null !== I) this.ar(I);else if (\"linkLabelKeys\" === e && Kq(I)) {\n                    var T = this.Cb(I);\n                    null !== T && (T.labeledLink = null);\n                  }\n                  c.isModified = !0;\n                }\n              }\n            } else if (d === ve) {\n              var R = a.propertyName;\n              a.object !== c.model || \"linkFromKeyProperty\" !== R && \"linkToKeyProperty\" !== R && \"linkFromPortIdProperty\" !== R && \"linkToPortIdProperty\" !== R && \"linkLabelKeysProperty\" !== R && \"nodeIsGroupProperty\" !== R && \"nodeGroupKeyProperty\" !== R && \"linkCategoryProperty\" !== R || c.undoManager.isUndoingRedoing || this.Ed();\n              c.isModified = !0;\n            }\n          } finally {\n            c.Z = !0;\n          }\n        }\n      }\n    }\n  };\n  Eq.prototype.refreshDataBoundLinks = function () {\n    var a = this,\n      b = this.diagram.model,\n      c = new F(),\n      d = b.linkDataArray;\n    d.forEach(function (a) {\n      c.add(a);\n    });\n    var e = [];\n    this.links.each(function (a) {\n      null === a.data || c.contains(a.data) || e.push(a.data);\n    });\n    e.forEach(function (a) {\n      Lq(b, a, !1);\n    });\n    d.forEach(function (c) {\n      null === a.xc(c) && Mq(b, c, !1);\n    });\n  };\n  Eq.prototype.updateRelationshipsFromData = function (a) {\n    var b = a.data;\n    if (null !== b) {\n      var c = a.diagram;\n      if (null !== c) {\n        var d = c.model;\n        if (a instanceof S) {\n          var e = Iq(d, b, !0);\n          e = c.Cb(e);\n          a.fromNode = e;\n          e = Iq(d, b, !1);\n          e = c.Cb(e);\n          a.toNode = e;\n          b = d.Bf(b);\n          if (0 < b.length || 0 < a.labelNodes.count) {\n            if (1 === b.length && 1 === a.labelNodes.count) {\n              e = b[0];\n              var f = a.labelNodes.first();\n              if (d.ja(f.data) === e) return;\n            }\n            e = new F().addAll(b);\n            var g = new F();\n            a.labelNodes.each(function (a) {\n              null !== a.data && (a = d.ja(a.data), void 0 !== a && g.add(a));\n            });\n            b = g.copy();\n            b.$q(e);\n            e = e.copy();\n            e.$q(g);\n            if (0 < b.count || 0 < e.count) b.each(function (b) {\n              b = c.Cb(b);\n              null !== b && b.labeledLink === a && (b.labeledLink = null);\n            }), e.each(function (b) {\n              b = c.Cb(b);\n              null !== b && b.labeledLink !== a && (b.labeledLink = a);\n            });\n          }\n        } else !(a instanceof He) && (b = d.Lh(b), b = c.findPartForKey(b), null === b || b instanceof vf) && (a.containingGroup = b);\n      }\n    }\n  };\n  Eq.prototype.resolveReferencesForData = function (a) {\n    var b = this.diagram.model,\n      c = b.ja(a);\n    if (void 0 !== c) {\n      var d = Nq(b, c),\n        e = this.yc(a);\n      if (null !== d && null !== e) {\n        d = d.iterator;\n        for (var f = {}; d.next();) {\n          var g = d.value;\n          b.Za(g) ? e instanceof vf && b.Lh(g) === c && (g = this.yc(g), null !== g && (g.containingGroup = e)) : (f.link = this.xc(g), null !== f.link && e instanceof V && (Iq(b, g, !0) === c && (f.link.fromNode = e), Iq(b, g, !1) === c && (f.link.toNode = e), g = b.Bf(g), Array.isArray(g) && g.some(function (a) {\n            return function (b) {\n              return b === c ? (e.labeledLink = a.link, !0) : !1;\n            };\n          }(f))));\n          f = {\n            link: f.link\n          };\n        }\n        Oq(b, c);\n      }\n      a = b.Lh(a);\n      void 0 !== a && (a = this.Cb(a), a instanceof vf && (e.containingGroup = a));\n    }\n  };\n  Eq.prototype.unresolveReferencesForPart = function (a) {\n    var b = this.diagram.model;\n    if (a instanceof V) {\n      var c = b.ja(a.data);\n      if (void 0 !== c) {\n        for (var d = a.linksConnected; d.next();) Pq(b, c, d.value.data);\n        a.isLinkLabel && (d = a.labeledLink, null !== d && Pq(b, c, d.data));\n        if (a instanceof vf) for (a = a.memberParts; a.next();) d = a.value.data, b.Za(d) && Pq(b, c, d);\n      }\n    }\n  };\n  Eq.prototype.copyPartData = function (a, b) {\n    var c = ti.prototype.copyPartData.call(this, a, b);\n    if (a instanceof S) if (a = a.data, null !== a && null !== b) {\n      var d = b.model;\n      a = d.yq(a);\n      \"object\" === typeof a && null !== a && (d.bj(a), c = b.xc(a));\n    } else null !== c && (b = this.diagram, null !== a && null !== b && null !== b.commandHandler && b.commandHandler.copiesClipboardData && (b = b.model.yq(a), \"object\" === typeof b && null !== b && (c.data = b)));\n    return c;\n  };\n  Eq.prototype.insertLink = function (a, b, c, d) {\n    var e = this.diagram,\n      f = e.model,\n      g = e.toolManager.findTool(\"Linking\"),\n      h = \"\";\n    null !== a && (null === b && (b = a), h = b.portId, null === h && (h = \"\"));\n    b = \"\";\n    null !== c && (null === d && (d = c), b = d.portId, null === b && (b = \"\"));\n    d = g.archetypeLinkData;\n    if (d instanceof S) {\n      if (xg(d), f = d.copy(), null !== f) return f.fromNode = a, f.fromPortId = h, f.toNode = c, f.toPortId = b, e.add(f), a = g.archetypeLabelNodeData, a instanceof V && (xg(a), a = a.copy(), null !== a && (a.labeledLink = f, e.add(a))), f;\n    } else if (null !== d && (d = f.yq(d), \"object\" === typeof d && null !== d)) return null !== a && Qq(f, d, f.ja(a.data), !0), Rq(f, d, h, !0), null !== c && Qq(f, d, f.ja(c.data), !1), Rq(f, d, b, !1), f.bj(d), a = g.archetypeLabelNodeData, null === a || a instanceof V || (a = f.copyNodeData(a), \"object\" === typeof a && null !== a && (f.uf(a), a = f.ja(a), void 0 !== a && f.Dv(d, a))), e.xc(d);\n    return null;\n  };\n  Eq.prototype.findLinkForKey = Eq.prototype.findLinkForKey;\n  Eq.prototype.findPartForKey = Eq.prototype.findPartForKey;\n  Eq.prototype.removeAllModeledParts = Eq.prototype.removeAllModeledParts;\n  Eq.prototype.addModeledParts = Eq.prototype.addModeledParts;\n  Eq.prototype.addAllModeledParts = Eq.prototype.addAllModeledParts;\n  Eq.className = \"GraphLinksPartManager\";\n  function Sq() {\n    ti.apply(this, arguments);\n    this.qh = null;\n  }\n  la(Sq, ti);\n  function Tq(a, b, c) {\n    if (null !== b && null !== c) {\n      var d = a.diagram.toolManager.findTool(\"Linking\"),\n        e = b,\n        f = c;\n      if (a.diagram.isTreePathToChildren) for (b = f.linksConnected; b.next();) {\n        if (b.value.toNode === f) return;\n      } else for (e = c, f = b, b = e.linksConnected; b.next();) if (b.value.fromNode === e) return;\n      if (null === d || !Pf(d, e, f, null, !0)) if (d = a.getLinkCategoryForData(c.data), b = a.findLinkTemplateForCategory(d), null !== b && (xg(b), b = b.copy(), null !== b)) {\n        var g = a.diagram.skipsModelSourceBindings;\n        a.diagram.skipsModelSourceBindings = !0;\n        b.Mf = d;\n        b.lb = c.data;\n        b.fromNode = e;\n        b.toNode = f;\n        a.diagram.add(b);\n        b.lb = null;\n        b.data = c.data;\n        a.diagram.skipsModelSourceBindings = g;\n      }\n    }\n  }\n  Sq.prototype.getLinkCategoryForData = function (a) {\n    return this.diagram.model.Ot(a);\n  };\n  Sq.prototype.setLinkCategoryForData = function (a, b) {\n    this.diagram.model.ku(a, b);\n  };\n  Sq.prototype.setFromNodeForLink = function (a, b, c) {\n    var d = this.diagram.model;\n    void 0 === c && (c = null);\n    b = null !== b ? b.data : null;\n    if (this.diagram.isTreePathToChildren) d.be(a.data, d.ja(b));else {\n      var e = this.qh;\n      this.qh = a;\n      null !== c && d.be(c.data, void 0);\n      d.be(b, d.ja(null !== a.toNode ? a.toNode.data : null));\n      this.qh = e;\n    }\n  };\n  Sq.prototype.setToNodeForLink = function (a, b, c) {\n    var d = this.diagram.model;\n    void 0 === c && (c = null);\n    b = null !== b ? b.data : null;\n    if (this.diagram.isTreePathToChildren) {\n      var e = this.qh;\n      this.qh = a;\n      null !== c && d.be(c.data, void 0);\n      d.be(b, d.ja(null !== a.fromNode ? a.fromNode.data : null));\n      this.qh = e;\n    } else d.be(a.data, d.ja(b));\n  };\n  Sq.prototype.removeDataForLink = function (a) {\n    this.diagram.model.be(a.data, void 0);\n  };\n  Sq.prototype.findLinkForKey = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.diagram.model.Kb(a);\n    return null !== a ? this.Se.H(a) : null;\n  };\n  Sq.prototype.doModelChanged = function (a) {\n    ti.prototype.doModelChanged.call(this, a);\n    if (this.diagram) {\n      var b = this.diagram;\n      if (a.model === b.model) {\n        var c = a.change;\n        if (b.Z) {\n          b.Z = !1;\n          try {\n            var d = a.modelChange;\n            if (\"\" !== d) {\n              if (c === ve) {\n                if (\"nodeParentKey\" === d) {\n                  var e = a.object,\n                    f = this.Cb(a.newValue),\n                    g = this.gj(e);\n                  if (null !== this.qh) null !== f && (this.qh.data = e, this.qh.category = this.getLinkCategoryForData(e));else if (null !== g) {\n                    var h = g.jj();\n                    null !== h ? null === f ? b.remove(h) : b.isTreePathToChildren ? h.fromNode = f : h.toNode = f : Tq(this, f, g);\n                  }\n                } else if (\"parentLinkCategory\" === d) {\n                  var k = this.gj(a.object),\n                    l = a.newValue;\n                  if (null !== k && \"string\" === typeof l) {\n                    var m = k.jj();\n                    null !== m && (m.category = l);\n                  }\n                }\n                b.isModified = !0;\n              }\n            } else if (c === ve) {\n              var n = a.propertyName;\n              a.object === b.model && \"nodeParentKeyProperty\" === n && (b.undoManager.isUndoingRedoing || this.Ed());\n              b.isModified = !0;\n            }\n          } finally {\n            b.Z = !0;\n          }\n        }\n      }\n    }\n  };\n  Sq.prototype.updateRelationshipsFromData = function (a) {\n    var b = a.data;\n    if (null !== b) {\n      var c = a.diagram;\n      if (null !== c) {\n        var d = c.model;\n        a instanceof V && (b = d.Mh(b), b = c.Cb(b), d = a.Fg(), b !== d && (d = a.jj(), null !== b ? null !== d ? c.isTreePathToChildren ? d.fromNode = b : d.toNode = b : Tq(this, b, a) : null !== d && Lj(c, d, !1)));\n      }\n    }\n  };\n  Sq.prototype.updateDataBindings = function (a, b) {\n    ti.prototype.updateDataBindings.call(this, a, b);\n    \"string\" === typeof b && null !== this.yc(a) && (a = this.xc(a), null !== a && a.Ca(b));\n  };\n  Sq.prototype.resolveReferencesForData = function (a) {\n    var b = this.diagram.model,\n      c = b.ja(a);\n    if (void 0 !== c) {\n      var d = Nq(b, c),\n        e = this.yc(a);\n      if (null !== d && null !== e) {\n        for (d = d.iterator; d.next();) {\n          var f = d.value;\n          b.Za(f) && e instanceof V && b.Mh(f) === c && Tq(this, e, this.gj(f));\n        }\n        Oq(b, c);\n      }\n      a = b.Mh(a);\n      void 0 !== a && e instanceof V && (a = this.Cb(a), Tq(this, a, e));\n    }\n  };\n  Sq.prototype.unresolveReferencesForPart = function (a) {\n    var b = this.diagram.model;\n    if (a instanceof V) {\n      var c = b.ja(a.data),\n        d = this.xc(a.data);\n      if (null !== d) {\n        d.isSelected = !1;\n        d.isHighlighted = !1;\n        var e = d.layer;\n        if (null !== e) {\n          var f = e.Kc(-1, d, !1);\n          0 <= f && this.diagram.ab(ye, \"parts\", e, d, null, f, null);\n          f = d.layerChanged;\n          null !== f && f(d, e, null);\n        }\n      }\n      d = this.diagram.isTreePathToChildren;\n      for (a = a.linksConnected; a.next();) e = a.value, e = (d ? e.toNode : e.fromNode).data, b.Za(e) && Pq(b, c, e);\n    }\n  };\n  Sq.prototype.insertLink = function (a, b, c) {\n    b = this.diagram.model;\n    var d = a,\n      e = c;\n    this.diagram.isTreePathToChildren || (d = c, e = a);\n    return null !== d && null !== e ? (b.be(e.data, b.ja(d.data)), e.jj()) : null;\n  };\n  Sq.prototype.findLinkForKey = Sq.prototype.findLinkForKey;\n  Sq.className = \"TreePartManager\";\n  function Z(a) {\n    this.Ni = new F();\n    this.Ki = new F();\n    this.su = ',\\n  \"insertedNodeKeys\": ';\n    this.jx = ',\\n  \"modifiedNodeData\": ';\n    this.uu = ',\\n  \"removedNodeKeys\": ';\n    this.Yh = null;\n    Ya(this);\n    this.Kn = this.Qa = \"\";\n    this.$f = !1;\n    this.l = {};\n    this.Fc = [];\n    this.Va = new H();\n    this.Mi = \"key\";\n    this.bl = this.Jl = null;\n    this.Bn = this.Cn = !1;\n    this.En = !0;\n    this.hn = null;\n    this.Vj = \"category\";\n    this.Sf = new H();\n    this.bv = new E();\n    this.ug = !1;\n    this.v = null;\n    this.undoManager = new Ae();\n    void 0 !== a && (this.nodeDataArray = a);\n  }\n  Z.prototype.cloneProtected = function (a) {\n    a.Qa = this.Qa;\n    a.Kn = this.Kn;\n    a.$f = this.$f;\n    a.Mi = this.Mi;\n    a.Jl = this.Jl;\n    a.bl = this.bl;\n    a.Cn = this.Cn;\n    a.Bn = this.Bn;\n    a.En = this.En;\n    a.hn = this.hn;\n    a.Vj = this.Vj;\n  };\n  Z.prototype.copy = function () {\n    var a = new this.constructor();\n    this.cloneProtected(a);\n    return a;\n  };\n  Z.prototype.clear = function () {\n    this.Fc = [];\n    this.Va.clear();\n    this.Sf.clear();\n    this.undoManager.clear();\n  };\n  Z.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    if (1 < a) return this.hr();\n    var b = (\"\" !== this.name ? this.name : \"\") + \" Model\";\n    if (0 < a) {\n      b += \"\\n node data:\";\n      a = this.nodeDataArray;\n      for (var c = a.length, d = 0; d < c; d++) {\n        var e = a[d];\n        b += \" \" + this.ja(e) + \":\" + Ja(e);\n      }\n    }\n    return b;\n  };\n  Z.prototype.$A = function (a) {\n    a.change !== we && B(\"Model.toIncrementalData argument is not a Transaction ChangedEvent:\" + a.toString());\n    var b = a.object;\n    if (!(a.isTransactionFinished && b instanceof ze)) return null;\n    Uq(this, b);\n    a = this.Ww(b, \"FinishedUndo\" === a.propertyName);\n    this.Yh = null;\n    return a;\n  };\n  Z.prototype.Ww = function (a, b) {\n    var c = this,\n      d = !1,\n      e = new F(),\n      f = new F(),\n      g = new F(),\n      h = this.Yh;\n    a.changes.each(function (a) {\n      a.model === c && (\"nodeDataArray\" === a.modelChange ? a.change === xe ? e.add(a.newValue) : a.change === ye && g.add(a.oldValue) : c.Za(a.object) ? f.add(a.object) : a.change !== ve || c.modelData !== a.object && \"modelData\" !== a.propertyName ? null !== a.object && (h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        c.Za(a) && f.add(a);\n      }) : a.object instanceof Z || c.pj() && c.wc(a.object) || Vq(c, a.object).each(function (a) {\n        f.add(a);\n      })) : d = !0);\n    });\n    var k = this.Ki;\n    k.clear();\n    e.each(function (a) {\n      k.add(c.ja(a));\n      b || f.add(a);\n    });\n    var l = this.Ni;\n    l.clear();\n    g.each(function (a) {\n      l.add(c.ja(a));\n      b && f.add(a);\n    });\n    a = c.cloneDeep(f.ma());\n    var m = null;\n    d && (null === m && (m = {}), m.modelData = this.cloneDeep(this.modelData));\n    0 < k.count && (null === m && (m = {}), b ? m.removedNodeKeys = k.ma() : m.insertedNodeKeys = k.ma());\n    0 < a.length && (null === m && (m = {}), m.modifiedNodeData = a);\n    0 < l.count && (null === m && (m = {}), b ? m.insertedNodeKeys = l.ma() : m.removedNodeKeys = l.ma());\n    l.clear();\n    k.clear();\n    return m;\n  };\n  Z.prototype.cloneDeep = function (a) {\n    return Wq(this, a, !0);\n  };\n  function Wq(a, b, c, d, e, f) {\n    function g(a, c) {\n      h ? (void 0 === a.__gohashid && f.push(a), d.set(a, c)) : (a = qb++, d.set(a, c), e.set(a, b));\n    }\n    if (!ya(b)) return b;\n    f || (f = []);\n    var h = Object.isExtensible(b);\n    d || (d = new H());\n    if (h) {\n      var k = d.get(b);\n      if (k) return k;\n    } else for (e || (e = new H()), k = e.iterator; k.next();) {\n      var l = k.key;\n      if (k.value === b && (l = d.get(l))) return l;\n    }\n    if (Array.isArray(b)) {\n      k = [];\n      g(b, k);\n      for (var m = 0; m < b.length; m++) k.push(Wq(a, b[m], !1, d, e, f));\n    } else if (b instanceof J || b instanceof M || b instanceof N || b instanceof pc || b instanceof P) k = b.copy(), g(b, k);else {\n      if (b instanceof tl || b instanceof td || b instanceof D) return b;\n      if (b instanceof E) k = new E().addAll(Wq(a, b.ma(), !1, d, e, f)), g(b, k);else if (b instanceof F) k = new F().addAll(Wq(a, b.ma(), !1, d, e, f)), g(b, k);else if (b instanceof H) k = new H().addAll(Wq(a, b.ma(), !1, d, e, f)), g(b, k);else if (b instanceof Date) k = new Date(b.getTime()), g(b, k);else if (b instanceof RegExp) k = new RegExp(b), g(b, k), k.lastIndex = b.lastIndex;else if (\"function\" === typeof b.copy) k = b.copy(), g(b, k);else for (m in k = {}, g(b, k), b) \"__gohashid\" !== m && (k[m] = Wq(a, b[m], !1, d, e, f));\n    }\n    c && f.forEach(function (a) {\n      delete a.__gohashid;\n    });\n    return k;\n  }\n  t = Z.prototype;\n  t.Nk = function () {\n    var a = \"\";\n    \"\" !== this.name && (a += ',\\n  \"name\": ' + this.quote(this.name));\n    \"\" !== this.dataFormat && (a += ',\\n  \"dataFormat\": ' + this.quote(this.dataFormat));\n    this.isReadOnly && (a += ',\\n  \"isReadOnly\": ' + this.isReadOnly);\n    \"key\" !== this.nodeKeyProperty && \"string\" === typeof this.nodeKeyProperty && (a += ',\\n  \"nodeKeyProperty\": ' + this.quote(this.nodeKeyProperty));\n    this.copiesArrays && (a += ',\\n  \"copiesArrays\": true');\n    this.copiesArrayObjects && (a += ',\\n  \"copiesArrayObjects\": true');\n    this.copiesKey || (a += ',\\n  \"copiesKey\": false');\n    \"category\" !== this.nodeCategoryProperty && \"string\" === typeof this.nodeCategoryProperty && (a += ',\\n  \"nodeCategoryProperty\": ' + this.quote(this.nodeCategoryProperty));\n    return a;\n  };\n  t.Yq = function (a) {\n    a.name && (this.name = a.name);\n    a.dataFormat && (this.dataFormat = a.dataFormat);\n    a.isReadOnly && (this.isReadOnly = !0);\n    a.nodeKeyProperty && (this.nodeKeyProperty = a.nodeKeyProperty);\n    a.copiesArrays && (this.copiesArrays = !0);\n    a.copiesArrayObjects && (this.copiesArrayObjects = !0);\n    !1 === a.copiesKey && (this.copiesKey = !1);\n    a.nodeCategoryProperty && (this.nodeCategoryProperty = a.nodeCategoryProperty);\n  };\n  function Xq(a) {\n    return ',\\n  \"modelData\": ' + Yq(a, a.modelData);\n  }\n  function Zq(a, b) {\n    b = b.modelData;\n    ya(b) && (a.Nm(b), a.modelData = b);\n  }\n  t.Xw = function () {\n    var a = this.modelData,\n      b = !1,\n      c;\n    for (c in a) if (!$q(c, a[c])) {\n      b = !0;\n      break;\n    }\n    a = \"\";\n    b && (a = Xq(this));\n    return a + ',\\n  \"nodeDataArray\": ' + ar(this, this.nodeDataArray, !0);\n  };\n  t.ow = function (a) {\n    Zq(this, a);\n    a = a.nodeDataArray;\n    Aa(a) && (this.Nm(a), this.nodeDataArray = a);\n  };\n  function br(a, b, c, d) {\n    if (b === c) return !0;\n    if (typeof b !== typeof c || \"function\" === typeof b || \"function\" === typeof c) return !1;\n    if (Array.isArray(b) && Array.isArray(c)) {\n      if (d.H(b) === c) return !0;\n      d.add(b, c);\n      if (b.length !== c.length) return !1;\n      for (var e = 0; e < b.length; e++) if (!br(a, b[e], c[e], d)) return !1;\n      return !0;\n    }\n    if (ya(b) && ya(c)) {\n      if (d.H(b) === c) return !0;\n      d.add(b, c);\n      for (var f in b) {\n        var g = b[f];\n        if (!$q(f, g)) {\n          var h = c[f];\n          if (void 0 === h || !br(a, g, h, d)) return !1;\n        }\n      }\n      for (e in c) if (f = c[e], !$q(e, f) && (g = b[e], void 0 === g || !br(a, g, f, d))) return !1;\n      return !0;\n    }\n    return !1;\n  }\n  function cr(a, b, c) {\n    a[c] !== b[c] && B(\"Model.computeJsonDifference: Model.\" + c + ' is not the same in both models: \"' + a[c] + '\" and \"' + b[c] + '\"');\n  }\n  t.mr = function (a) {\n    cr(this, a, \"nodeKeyProperty\");\n    var b = this.Ki;\n    b.clear();\n    var c = new F(),\n      d = this.Ni;\n    d.clear();\n    d.addAll(this.Va.iteratorKeys);\n    for (var e = new H(), f = a.nodeDataArray, g = f.length, h = 0; h < g; h++) {\n      var k = f[h],\n        l = a.ja(k);\n      if (void 0 !== l) {\n        d.remove(l);\n        var m = this.Kb(l);\n        null === m ? (b.add(l), c.add(k)) : br(this, m, k, e) || c.add(k);\n      } else this.Yt(k), l = this.ja(k), b.add(l), c.add(k);\n    }\n    f = \"\";\n    br(this, this.modelData, a.modelData, e) || (f += Xq(this));\n    0 < b.count && (f += this.su + ar(this, b.ma(), !0));\n    0 < c.count && (f += this.jx + ar(this, c.ma(), !0));\n    0 < d.count && (f += this.uu + ar(this, d.ma(), !0));\n    d.clear();\n    b.clear();\n    return f;\n  };\n  t.yz = function (a, b) {\n    void 0 === b && (b = dr(this, this));\n    return '{ \"class\": ' + this.quote(b) + ', \"incremental\": 1' + this.Nk() + this.mr(a) + \"}\";\n  };\n  function Uq(a, b) {\n    function c(a, b) {\n      if (b = b.part) if (b = b.data, a !== b) {\n        var c = d.get(a);\n        null === c ? (c = new F(), c.add(b), d.add(a, c)) : c.add(b);\n      }\n    }\n    var d = a.Yh;\n    null === d && (d = new H(), b.changes.each(function (a) {\n      if (null !== a.diagram) {\n        var b = a.change;\n        if (b === ve) (a = a.object.panel) && (b = a.data) && c(b, a);else if (b === xe || b === ye) a = a.object, (b = a.itemArray) && c(b, a);\n      }\n    }), a.Yh = d);\n  }\n  function Vq(a, b) {\n    for (var c = new F(), d = 0; d < a.nodeDataArray.length; d++) {\n      var e = a.nodeDataArray[d];\n      er(a, b, e, e, c);\n    }\n    return c;\n  }\n  function er(a, b, c, d, e) {\n    if (Array.isArray(c)) for (var f = 0; f < c.length; f++) {\n      var g = c[f];\n      if (g === b) return e.add(d), !0;\n      if (er(a, b, g, d, e)) return !0;\n    } else if (ya(c) && Object.getPrototypeOf(c) === Object.prototype) for (f in c) {\n      g = c[f];\n      if (g === b) return e.add(d), !0;\n      if (er(a, b, g, d, e)) return !0;\n    }\n    return !1;\n  }\n  t.Vw = function (a, b) {\n    var c = this,\n      d = !1,\n      e = new F(),\n      f = new F(),\n      g = new F(),\n      h = this.Yh;\n    a.changes.each(function (a) {\n      a.model === c && (\"nodeDataArray\" === a.modelChange ? a.change === xe ? e.add(a.newValue) : a.change === ye && g.add(a.oldValue) : c.Za(a.object) ? f.add(a.object) : a.change !== ve || c.modelData !== a.object && \"modelData\" !== a.propertyName ? null !== a.object && (h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        c.Za(a) && f.add(a);\n      }) : a.object instanceof Z || c.pj() && c.wc(a.object) || Vq(c, a.object).each(function (a) {\n        f.add(a);\n      })) : d = !0);\n    });\n    var k = this.Ki;\n    k.clear();\n    e.each(function (a) {\n      k.add(c.ja(a));\n      b || f.add(a);\n    });\n    var l = this.Ni;\n    l.clear();\n    g.each(function (a) {\n      l.add(c.ja(a));\n      b && f.add(a);\n    });\n    a = \"\";\n    d && (a += Xq(this));\n    0 < k.count && (a += (b ? this.uu : this.su) + ar(this, k.ma(), !0));\n    0 < f.count && (a += this.jx + ar(this, f.ma(), !0));\n    0 < l.count && (a += (b ? this.su : this.uu) + ar(this, l.ma(), !0));\n    l.clear();\n    k.clear();\n    return a;\n  };\n  t.Xq = function (a) {\n    (void 0 !== a.name && a.name !== this.name || void 0 !== a.dataFormat && a.dataFormat !== this.dataFormat || void 0 !== a.isReadOnly && a.isReadOnly !== this.isReadOnly || void 0 !== a.nodeKeyProperty && a.nodeKeyProperty !== this.nodeKeyProperty || void 0 !== a.copiesArrays && a.copiesArrays !== this.copiesArrays || void 0 !== a.copiesArrayObjects && a.copiesArrayObjects !== this.copiesArrayObjects || void 0 !== a.copiesKey && a.copiesKey !== this.copiesKey || void 0 !== a.nodeCategoryProperty && a.nodeCategoryProperty !== this.nodeCategoryProperty) && B(\"applyIncrementalJson cannot change Model properties\");\n    Zq(this, a);\n    var b = a.insertedNodeKeys,\n      c = a.modifiedNodeData,\n      d = new H();\n    if (Array.isArray(c)) for (var e = 0; e < c.length; e++) {\n      var f = c[e],\n        g = this.ja(f);\n      void 0 !== g && null !== g && d.set(g, f);\n    }\n    if (Array.isArray(b)) for (e = b.length, f = 0; f < e; f++) {\n      g = b[f];\n      var h = this.Kb(g);\n      null === h && (h = (h = d.get(g)) ? h : this.copyNodeData({}), this.Um(h, g), this.uf(h));\n    }\n    if (Array.isArray(c)) for (b = c.length, d = 0; d < b; d++) if (e = c[d], f = this.ja(e), f = this.Kb(f), null !== f) {\n      for (var k in e) \"__gohashid\" === k || k === this.nodeKeyProperty || this.xk() && k === this.nodeIsGroupProperty || this.setDataProperty(f, k, e[k]);\n      this.Vm(e, f);\n    }\n    a = a.removedNodeKeys;\n    if (Array.isArray(a)) for (c = a.length, k = 0; k < c; k++) b = this.Kb(a[k]), null !== b && this.Mm(b);\n  };\n  t.Vy = function (a, b) {\n    a.change !== we && B(\"Model.toIncrementalJson argument is not a Transaction ChangedEvent:\" + a.toString());\n    var c = a.object;\n    if (!(a.isTransactionFinished && c instanceof ze)) return '{ \"incremental\": 0 }';\n    void 0 === b && (b = dr(this, this));\n    Uq(this, c);\n    a = this.Vw(c, \"FinishedUndo\" === a.propertyName);\n    this.Yh = null;\n    return \"2\" === b ? '{ \"incremental\": 2' + a + \"}\" : '{ \"class\": ' + this.quote(b) + ', \"incremental\": 1' + this.Nk() + a + \"}\";\n  };\n  t.aB = function (a, b) {\n    return this.Vy(a, b);\n  };\n  t.hr = function (a) {\n    void 0 === a && (a = dr(this, this));\n    return '{ \"class\": ' + this.quote(a) + this.Nk() + this.Xw() + \"}\";\n  };\n  t.toJSON = function (a) {\n    return this.hr(a);\n  };\n  t.Wx = function (a) {\n    var b = null;\n    if (\"string\" === typeof a) try {\n      b = x.JSON.parse(a);\n    } catch (d) {} else \"object\" === typeof a ? b = a : B(\"Unable to modify a Model from: \" + a);\n    var c = b.incremental;\n    \"number\" !== typeof c && B(\"Unable to apply non-incremental changes to Model: \" + a);\n    0 !== c && (this.va(\"applyIncrementalJson\"), this.Xq(b), this.Wa(\"applyIncrementalJson\"));\n  };\n  t.pz = function (a) {\n    return this.Wx(a);\n  };\n  Z.constructGraphLinksModel = function () {\n    return new Z();\n  };\n  t = Z.prototype;\n  t.Nm = function (a) {\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n      if (ya(d)) {\n        var e = c;\n        d = this.Nm(d);\n        Array.isArray(a) ? a[e] = d : B(\"Cannot replace an object in an HTMLCollection or NodeList at \" + e);\n      }\n    } else if (ya(a)) {\n      for (c in a) if (e = a[c], ya(e) && (e = this.Nm(e), a[c] = e, \"points\" === c && Array.isArray(e))) {\n        d = 0 === e.length % 2;\n        for (var f = 0; f < e.length; f++) if (\"number\" !== typeof e[f]) {\n          d = !1;\n          break;\n        }\n        if (d) {\n          d = new E();\n          for (f = 0; f < e.length / 2; f++) d.add(new J(e[2 * f], e[2 * f + 1]));\n          d.freeze();\n          a[c] = d;\n        }\n      }\n      if (\"object\" === typeof a) {\n        c = a;\n        e = a[\"class\"] || \"\";\n        0 === e.indexOf(\"go.\") && (e = e.substr(3));\n        if (\"NaN\" === e) c = NaN;else if (\"Date\" === e) c = new Date(a.value);else if (\"Point\" === e) c = new J(fr(a.x), fr(a.y));else if (\"Size\" === e) c = new M(fr(a.width), fr(a.height));else if (\"Rect\" === e) c = new N(fr(a.x), fr(a.y), fr(a.width), fr(a.height));else if (\"Margin\" === e) c = new pc(fr(a.top), fr(a.right), fr(a.bottom), fr(a.left));else if (\"Spot\" === e) \"string\" === typeof a[\"enum\"] ? c = md(a[\"enum\"]) : c = new P(fr(a.x), fr(a.y), fr(a.offsetX), fr(a.offsetY));else if (\"Brush\" === e) {\n          if (c = new tl(), c.type = Za(tl, a.type), \"string\" === typeof a.color && (c.color = a.color), a.start instanceof P && (c.start = a.start), a.end instanceof P && (c.end = a.end), \"number\" === typeof a.startRadius && (c.startRadius = fr(a.startRadius)), \"number\" === typeof a.endRadius && (c.endRadius = fr(a.endRadius)), a = a.colorStops, ya(a)) for (b in a) c.addColorStop(parseFloat(b), a[b]);\n        } else \"Geometry\" === e ? (b = null, \"string\" === typeof a.path ? b = Jd(a.path) : b = new td(), b.type = Za(td, a.type), \"number\" === typeof a.startX && (b.startX = fr(a.startX)), \"number\" === typeof a.startY && (b.startY = fr(a.startY)), \"number\" === typeof a.endX && (b.endX = fr(a.endX)), \"number\" === typeof a.endY && (b.endY = fr(a.endY)), a.spot1 instanceof P && (b.spot1 = a.spot1), a.spot2 instanceof P && (b.spot2 = a.spot2), c = b) : \"EnumValue\" === e && (b = a.classType, 0 === b.indexOf(\"go.\") && (b = b.substr(3)), b = gr(b), \"function\" === typeof b && (c = Za(b, a.name)));\n        a = c;\n      }\n    }\n    return a;\n  };\n  t.quote = function (a) {\n    for (var b = \"\", c = a.length, d = 0; d < c; d++) {\n      var e = a[d];\n      if ('\"' === e || \"\\\\\" === e) b += \"\\\\\" + e;else if (\"\\b\" === e) b += \"\\\\b\";else if (\"\\f\" === e) b += \"\\\\f\";else if (\"\\n\" === e) b += \"\\\\n\";else if (\"\\r\" === e) b += \"\\\\r\";else if (\"\\t\" === e) b += \"\\\\t\";else {\n        var f = a.charCodeAt(d);\n        b = 16 > f ? b + (\"\\\\u000\" + a.charCodeAt(d).toString(16)) : 32 > f ? b + (\"\\\\u00\" + a.charCodeAt(d).toString(16)) : 8232 === f ? b + \"\\\\u2028\" : 8233 === f ? b + \"\\\\u2029\" : b + e;\n      }\n    }\n    return '\"' + b + '\"';\n  };\n  t.$m = function (a) {\n    return void 0 === a ? \"undefined\" : null === a ? \"null\" : !0 === a ? \"true\" : !1 === a ? \"false\" : \"string\" === typeof a ? this.quote(a) : \"number\" === typeof a ? Infinity === a ? \"9e9999\" : -Infinity === a ? \"-9e9999\" : isNaN(a) ? '{\"class\":\"NaN\"}' : a.toString() : a instanceof Date ? '{\"class\":\"Date\", \"value\":\"' + a.toJSON() + '\"}' : a instanceof Number ? this.$m(a.valueOf()) : Aa(a) ? ar(this, a) : ya(a) ? Yq(this, a) : \"function\" === typeof a ? \"null\" : a.toString();\n  };\n  function ar(a, b, c) {\n    void 0 === c && (c = !1);\n    var d = b.length;\n    if (0 >= d) return \"[]\";\n    var e = new $a();\n    e.add(\"[ \");\n    c && 1 < d && e.add(\"\\n\");\n    for (var f = 0; f < d; f++) {\n      var g = b[f];\n      void 0 !== g && (0 < f && (e.add(\",\"), c && e.add(\"\\n\")), e.add(a.$m(g)));\n    }\n    c && 1 < d && e.add(\"\\n\");\n    e.add(\" ]\");\n    return e.toString();\n  }\n  function $q(a, b) {\n    return void 0 === b || \"__gohashid\" === a || \"_\" === a[0] || \"function\" === typeof b ? !0 : !1;\n  }\n  function hr(a) {\n    return isNaN(a) ? \"NaN\" : Infinity === a ? \"9e9999\" : -Infinity === a ? \"-9e9999\" : a;\n  }\n  function Yq(a, b) {\n    var c = b;\n    if (c instanceof J) b = {\n      \"class\": \"go.Point\",\n      x: hr(c.x),\n      y: hr(c.y)\n    };else if (c instanceof M) b = {\n      \"class\": \"go.Size\",\n      width: hr(c.width),\n      height: hr(c.height)\n    };else if (c instanceof N) b = {\n      \"class\": \"go.Rect\",\n      x: hr(c.x),\n      y: hr(c.y),\n      width: hr(c.width),\n      height: hr(c.height)\n    };else if (c instanceof pc) b = {\n      \"class\": \"go.Margin\",\n      top: hr(c.top),\n      right: hr(c.right),\n      bottom: hr(c.bottom),\n      left: hr(c.left)\n    };else if (c instanceof P) c.ib() ? b = {\n      \"class\": \"go.Spot\",\n      x: hr(c.x),\n      y: hr(c.y),\n      offsetX: hr(c.offsetX),\n      offsetY: hr(c.offsetY)\n    } : b = {\n      \"class\": \"go.Spot\",\n      \"enum\": c.toString()\n    };else if (c instanceof tl) {\n      b = {\n        \"class\": \"go.Brush\",\n        type: c.type.name\n      };\n      if (c.type === wl) b.color = c.color;else if (c.type === zl || c.type === ul) b.start = c.start, b.end = c.end, c.type === ul && (0 !== c.startRadius && (b.startRadius = hr(c.startRadius)), isNaN(c.endRadius) || (b.endRadius = hr(c.endRadius)));\n      if (null !== c.colorStops) {\n        var d = {};\n        for (c = c.colorStops.iterator; c.next();) d[c.key] = c.value;\n        b.colorStops = d;\n      }\n    } else c instanceof td ? (b = {\n      \"class\": \"go.Geometry\",\n      type: c.type.name\n    }, 0 !== c.startX && (b.startX = hr(c.startX)), 0 !== c.startY && (b.startY = hr(c.startY)), 0 !== c.endX && (b.endX = hr(c.endX)), 0 !== c.endY && (b.endY = hr(c.endY)), c.spot1.w(wc) || (b.spot1 = c.spot1), c.spot2.w(Hc) || (b.spot2 = c.spot2), c.type === ud && (b.path = zd(c))) : c instanceof D && (b = {\n      \"class\": \"go.EnumValue\",\n      classType: dr(a, c.classType),\n      name: c.name\n    });\n    d = \"{\";\n    c = !0;\n    for (var e in b) {\n      var f = qn(b, e);\n      if (!$q(e, f)) if (c ? c = !1 : d += \", \", d += '\"' + e + '\":', \"points\" === e && f instanceof E) {\n        var g = \"[\";\n        for (f = f.iterator; f.next();) {\n          var h = f.value;\n          1 < g.length && (g += \",\");\n          g += a.$m(h.x);\n          g += \",\";\n          g += a.$m(h.y);\n        }\n        g += \"]\";\n        d += g;\n      } else d += a.$m(f);\n    }\n    return d + \"}\";\n  }\n  function fr(a) {\n    return \"number\" === typeof a ? a : \"NaN\" === a ? NaN : \"9e9999\" === a ? Infinity : \"-9e9999\" === a ? -Infinity : parseFloat(a);\n  }\n  t.Hh = function (a) {\n    this.bv.add(a);\n  };\n  t.Kk = function (a) {\n    this.bv.remove(a);\n  };\n  t.zt = function (a) {\n    this.skipsUndoManager || this.undoManager.$v(a);\n    for (var b = this.bv, c = b.length, d = 0; d < c; d++) b.L(d)(a);\n  };\n  t.ab = function (a, b, c, d, e, f, g) {\n    ir(this, \"\", a, b, c, d, e, f, g);\n  };\n  t.g = function (a, b, c, d, e) {\n    ir(this, \"\", ve, a, this, b, c, d, e);\n  };\n  t.du = function (a, b, c, d, e, f) {\n    ir(this, \"\", ve, b, a, c, d, e, f);\n  };\n  function ir(a, b, c, d, e, f, g, h, k) {\n    void 0 === h && (h = null);\n    void 0 === k && (k = null);\n    var l = new ue();\n    l.model = a;\n    l.change = c;\n    l.modelChange = b;\n    l.propertyName = d;\n    l.object = e;\n    l.oldValue = f;\n    l.oldParam = h;\n    l.newValue = g;\n    l.newParam = k;\n    a.zt(l);\n  }\n  Z.prototype.changeState = function (a, b) {\n    if (null !== a && a.model === this) if (a.change === ve) {\n      var c = a.object,\n        d = a.propertyName,\n        e = a.H(b);\n      d === this.nodeKeyProperty && this.Za(c) && (b = a.H(!b), void 0 !== b && this.Va.remove(b), void 0 !== e && this.Va.add(e, c));\n      Sj(c, d, e);\n    } else a.change === xe ? (c = a.newParam, \"nodeDataArray\" === a.modelChange ? (a = a.newValue, ya(a) && \"number\" === typeof c && (d = this.ja(a), b ? (this.Fc[c] === a && Da(this.Fc, c), void 0 !== d && this.Va.remove(d)) : (this.Fc[c] !== a && Ca(this.Fc, c, a), void 0 !== d && this.Va.add(d, a)))) : \"\" === a.modelChange ? ((d = a.object) && !Aa(d) && a.propertyName && (d = qn(a.object, a.propertyName)), Aa(d) && \"number\" === typeof c && (a = a.newValue, b ? Da(d, c) : Ca(d, c, a))) : B(\"unknown ChangedEvent.Insert modelChange: \" + a.toString())) : a.change === ye ? (c = a.oldParam, \"nodeDataArray\" === a.modelChange ? (a = a.oldValue, ya(a) && \"number\" === typeof c && (d = this.ja(a), b ? (this.Fc[c] !== a && Ca(this.Fc, c, a), void 0 !== d && this.Va.add(d, a)) : (this.Fc[c] === a && Da(this.Fc, c), void 0 !== d && this.Va.remove(d)))) : \"\" === a.modelChange ? ((d = a.object) && !Aa(d) && a.propertyName && (d = qn(a.object, a.propertyName)), Aa(d) && \"number\" === typeof c && (a = a.oldValue, b ? Ca(d, c, a) : Da(d, c))) : B(\"unknown ChangedEvent.Remove modelChange: \" + a.toString())) : a.change !== we && B(\"unknown ChangedEvent: \" + a.toString());\n  };\n  Z.prototype.va = function (a) {\n    return this.undoManager.va(a);\n  };\n  Z.prototype.Wa = function (a) {\n    return this.undoManager.Wa(a);\n  };\n  Z.prototype.Hf = function () {\n    return this.undoManager.Hf();\n  };\n  Z.prototype.commit = function (a, b) {\n    void 0 === b && (b = \"\");\n    var c = this.skipsUndoManager;\n    null === b && (this.skipsUndoManager = !0, b = \"\");\n    this.undoManager.va(b);\n    var d = !1;\n    try {\n      a(this), d = !0;\n    } finally {\n      d ? this.undoManager.Wa(b) : this.undoManager.Hf(), this.skipsUndoManager = c;\n    }\n  };\n  t = Z.prototype;\n  t.Ca = function (a, b) {\n    void 0 === b && (b = \"\");\n    ir(this, \"SourceChanged\", we, b, a, null, null);\n  };\n  t.ja = function (a) {\n    if (null !== a) {\n      var b = this.Mi;\n      if (\"\" !== b && (b = qn(a, b), void 0 !== b)) {\n        if (Kq(b)) return b;\n        B(\"Key value for node data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n  t.Um = function (a, b) {\n    if (null !== a) {\n      var c = this.Mi;\n      if (\"\" !== c) if (this.Za(a)) {\n        var d = qn(a, c);\n        d !== b && null === this.Kb(b) && (Sj(a, c, b), void 0 !== d && this.Va.remove(d), this.Va.add(b, a), ir(this, \"nodeKey\", ve, c, a, d, b), \"string\" === typeof c && this.Ca(a, c), this.br(d, b));\n      } else Sj(a, c, b);\n    }\n  };\n  function Kq(a) {\n    return \"number\" === typeof a || \"string\" === typeof a;\n  }\n  t.Za = function (a) {\n    var b = this.ja(a);\n    return void 0 === b ? !1 : this.Va.H(b) === a;\n  };\n  t.Kb = function (a) {\n    null === a && B(\"Model.findNodeDataForKey:key must not be null\");\n    return void 0 !== a && Kq(a) ? this.Va.H(a) : null;\n  };\n  t.Yt = function (a) {\n    if (null !== a) {\n      var b = this.Mi;\n      if (\"\" !== b) {\n        var c = this.ja(a);\n        if (void 0 === c || this.Va.contains(c)) {\n          var d = this.Jl;\n          if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.Va.contains(c))) {\n            Sj(a, b, c);\n            return;\n          }\n          if (\"string\" === typeof c) {\n            for (d = 2; this.Va.contains(c + d);) d++;\n            Sj(a, b, c + d);\n          } else if (void 0 === c || \"number\" === typeof c) {\n            for (c = -this.Va.count - 1; this.Va.contains(c);) c--;\n            Sj(a, b, c);\n          }\n        }\n      }\n    }\n  };\n  t.uf = function (a) {\n    null !== a && (ob(a), this.Za(a) || Cq(this, a, !0));\n  };\n  function Cq(a, b, c) {\n    var d = a.ja(b);\n    if (void 0 === d || a.Va.H(d) !== b) a.Yt(b), d = a.ja(b), void 0 === d ? B(\"Model.makeNodeDataKeyUnique failed on \" + b + \".  Data not added to Model.\") : (a.Va.add(d, b), d = null, c && (d = a.Fc.length, Ca(a.Fc, d, b)), ir(a, \"nodeDataArray\", xe, \"nodeDataArray\", a, null, b, null, d), a.Pm(b), a.Om(b));\n  }\n  t.lz = function (a) {\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) this.uf(a[c]);else for (a = a.iterator; a.next();) this.uf(a.value);\n  };\n  t.Mm = function (a) {\n    null !== a && Bq(this, a, !0);\n  };\n  function Bq(a, b, c) {\n    var d = a.ja(b);\n    void 0 !== d && a.Va.remove(d);\n    d = null;\n    if (c) {\n      a: if (c = a.Fc, Array.isArray(c)) d = c.indexOf(b);else {\n        d = c.length;\n        for (var e = 0; e < d; e++) if (c[e] === b) {\n          d = e;\n          break a;\n        }\n        d = -1;\n      }\n      if (0 > d) return;\n      Da(a.Fc, d);\n    }\n    ir(a, \"nodeDataArray\", ye, \"nodeDataArray\", a, b, null, d, null);\n    a.jr(b);\n  }\n  t.QA = function (a) {\n    if (Aa(a)) for (var b = a.length, c = 0; c < b; c++) this.Mm(a[c]);else for (a = a.iterator; a.next();) this.Mm(a.value);\n  };\n  t.GA = function (a) {\n    if (a !== this.nodeDataArray && Aa(a)) {\n      var b = this.Ni;\n      b.clear();\n      b.addAll(this.Va.iteratorKeys);\n      var c = this.Ki;\n      c.clear();\n      for (var d = a.length, e = 0; e < d; e++) {\n        var f = a[e],\n          g = this.ja(f);\n        if (void 0 !== g) {\n          c.add(g);\n          var h = this.Kb(g);\n          h !== f && (null !== h ? (this.tq(h, f), this.Vm(f, h)) : (f = this.cloneDeep(f), this.Um(f, g), this.uf(f)));\n        } else g = this.cloneDeep(f), this.uf(g), c.add(this.ja(g));\n      }\n      for (a = b.iterator; a.next();) d = a.value, c.contains(d) || (d = this.Kb(d)) && this.Mm(d);\n      b.clear();\n      c.clear();\n    }\n  };\n  t.br = function (a, b) {\n    void 0 !== b && (a = Nq(this, a), a instanceof F && this.Sf.add(b, a));\n  };\n  t.Qw = function () {};\n  t.Pm = function () {};\n  t.Om = function () {};\n  t.jr = function () {};\n  function Pq(a, b, c) {\n    if (void 0 !== b) {\n      var d = a.Sf.H(b);\n      null === d && (d = new F(), a.Sf.add(b, d));\n      d.add(c);\n    }\n  }\n  function Oq(a, b, c) {\n    if (void 0 !== b) {\n      var d = a.Sf.H(b);\n      d instanceof F && (void 0 === c || null === c ? a.Sf.remove(b) : (d.remove(c), 0 === d.count && a.Sf.remove(b)));\n    }\n  }\n  function Nq(a, b) {\n    if (void 0 === b) return null;\n    a = a.Sf.H(b);\n    return a instanceof F ? a : null;\n  }\n  t.xz = function (a) {\n    void 0 === a ? this.Sf.clear() : this.Sf.remove(a);\n  };\n  Z.prototype.copyNodeData = function (a) {\n    if (null === a) return null;\n    var b = this.bl;\n    a = null !== b ? b(a, this) : jr(this, a, !0);\n    ya(a) && Ya(a);\n    return a;\n  };\n  function jr(a, b, c) {\n    if (a.copiesArrays && Array.isArray(b)) {\n      var d = [];\n      for (c = 0; c < b.length; c++) {\n        var e = jr(a, b[c], a.copiesArrayObjects);\n        d.push(e);\n      }\n      Ya(d);\n      return d;\n    }\n    if (c && ya(b)) {\n      c = (c = b.constructor) ? new c() : {};\n      e = a.copiesKey || \"string\" !== typeof a.nodeKeyProperty ? null : a.nodeKeyProperty;\n      for (d in b) if (\"__gohashid\" === d) c.__gohashid = void 0;else if (d === e) c[e] = void 0;else {\n        var f = qn(b, d),\n          g = dr(a, f);\n        \"GraphObject\" === g || \"Diagram\" === g || \"Layer\" === g || \"RowColumnDefinition\" === g || \"AnimationManager\" === g || \"Tool\" === g || \"CommandHandler\" === g || \"Layout\" === g || \"InputEvent\" === g || \"DiagramEvent\" === g || f instanceof Z || f instanceof Ae || f instanceof ze || f instanceof ue ? Sj(c, d, f) : (f = jr(a, f, !1), Sj(c, d, f));\n      }\n      Ya(c);\n      return c;\n    }\n    return b instanceof J ? b.copy() : b instanceof M ? b.copy() : b instanceof N ? b.copy() : b instanceof P ? b.copy() : b instanceof pc ? b.copy() : b;\n  }\n  Z.prototype.setDataProperty = function (a, b, c) {\n    if (this.Za(a)) {\n      if (b === this.nodeKeyProperty) {\n        this.Um(a, c);\n        return;\n      }\n      if (b === this.nodeCategoryProperty) {\n        this.Tm(a, c);\n        return;\n      }\n    } else !lr && a instanceof Y && (lr = !0, wa('Model.setDataProperty is modifying a GraphObject, \"' + a.toString() + '\"'), wa(\"  Is that really your intent?\"));\n    var d = qn(a, b);\n    d !== c && (Sj(a, b, c), this.du(a, b, d, c));\n  };\n  t = Z.prototype;\n  t.set = function (a, b, c) {\n    this.setDataProperty(a, b, c);\n  };\n  t.tq = function (a, b) {\n    if (b) {\n      var c = this.Za(a),\n        d;\n      for (d in b) \"__gohashid\" === d || c && d === this.nodeKeyProperty || this.setDataProperty(a, d, b[d]);\n    }\n  };\n  t.iz = function (a, b) {\n    this.Pt(a, -1, b);\n  };\n  t.Pt = function (a, b, c) {\n    0 > b && (b = a.length);\n    Ca(a, b, c);\n    ir(this, \"\", xe, \"\", a, null, c, null, b);\n  };\n  t.qw = function (a, b) {\n    void 0 === b && (b = -1);\n    a === this.Fc && B(\"Model.removeArrayItem should not be called on the Model.nodeDataArray\");\n    -1 === b && (b = a.length - 1);\n    var c = a[b];\n    Da(a, b);\n    ir(this, \"\", ye, \"\", a, c, null, b, null);\n  };\n  t.Gq = function (a) {\n    if (null === a) return \"\";\n    var b = this.Vj;\n    if (\"\" === b) return \"\";\n    b = qn(a, b);\n    if (void 0 === b) return \"\";\n    if (\"string\" === typeof b) return b;\n    B(\"getCategoryForNodeData found a non-string category for \" + a + \": \" + b);\n    return \"\";\n  };\n  t.Tm = function (a, b) {\n    if (null !== a) {\n      var c = this.Vj;\n      if (\"\" !== c) if (this.Za(a)) {\n        var d = qn(a, c);\n        void 0 === d && (d = \"\");\n        d !== b && (Sj(a, c, b), ir(this, \"nodeCategory\", ve, c, a, d, b));\n      } else Sj(a, c, b);\n    }\n  };\n  t.Vm = function (a, b) {\n    this.Tm(b, this.Gq(a));\n  };\n  t.Am = function () {\n    return !1;\n  };\n  t.xk = function () {\n    return !1;\n  };\n  t.pj = function () {\n    return !1;\n  };\n  t.Ut = function () {\n    return !1;\n  };\n  t.yk = function () {\n    return !1;\n  };\n  function wi() {\n    return new Z();\n  }\n  function dr(a, b) {\n    if (\"function\" === typeof b) {\n      if (b.className) return b.className;\n      if (b.name) return b.name;\n    } else if (\"object\" === typeof b && null !== b && b.constructor) return dr(a, b.constructor);\n    return typeof b;\n  }\n  function gr(a) {\n    return mr[a] ? mr[a] : void 0 !== x.go && x.go[a] ? x.go[a] : null;\n  }\n  function qn(a, b) {\n    if (!a || !b) return null;\n    try {\n      if (\"function\" === typeof b) var c = b(a);else \"function\" === typeof a.getAttribute ? (c = a.getAttribute(b), null === c && (c = void 0)) : c = a[b];\n    } catch (d) {}\n    return c;\n  }\n  function Sj(a, b, c) {\n    if (a && b) try {\n      \"function\" === typeof b ? b(a, c) : \"function\" === typeof a.setAttribute ? a.setAttribute(b, c) : a[b] = c;\n    } catch (d) {}\n  }\n  ma.Object.defineProperties(Z.prototype, {\n    name: {\n      get: function () {\n        return this.Qa;\n      },\n      set: function (a) {\n        var b = this.Qa;\n        b !== a && (this.Qa = a, this.g(\"name\", b, a));\n      }\n    },\n    dataFormat: {\n      get: function () {\n        return this.Kn;\n      },\n      set: function (a) {\n        var b = this.Kn;\n        b !== a && (this.Kn = a, this.g(\"dataFormat\", b, a));\n      }\n    },\n    isReadOnly: {\n      get: function () {\n        return this.$f;\n      },\n      set: function (a) {\n        var b = this.$f;\n        b !== a && (this.$f = a, this.g(\"isReadOnly\", b, a));\n      }\n    },\n    modelData: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        var b = this.l;\n        b !== a && (this.l = a, this.g(\"modelData\", b, a), this.Ca(a));\n      }\n    },\n    undoManager: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        var b = this.v;\n        b !== a && (null !== b && b.My(this), this.v = a, null !== a && a.Ux(this));\n      }\n    },\n    skipsUndoManager: {\n      get: function () {\n        return this.ug;\n      },\n      set: function (a) {\n        this.ug = a;\n      }\n    },\n    nodeKeyProperty: {\n      get: function () {\n        return this.Mi;\n      },\n      set: function (a) {\n        var b = this.Mi;\n        b !== a && (\"\" === a && B(\"Model.nodeKeyProperty may not be the empty string\"), 0 < this.Va.count && B(\"Cannot set Model.nodeKeyProperty when there is existing node data\"), this.Mi = a, this.g(\"nodeKeyProperty\", b, a));\n      }\n    },\n    makeUniqueKeyFunction: {\n      get: function () {\n        return this.Jl;\n      },\n      set: function (a) {\n        var b = this.Jl;\n        b !== a && (this.Jl = a, this.g(\"makeUniqueKeyFunction\", b, a));\n      }\n    },\n    nodeDataArray: {\n      get: function () {\n        return this.Fc;\n      },\n      set: function (a) {\n        var b = this.Fc;\n        if (b !== a) {\n          this.Va.clear();\n          this.Qw();\n          for (var c = a.length, d = 0; d < c; d++) {\n            var e = a[d];\n            if (!ya(e)) {\n              B(\"Model.nodeDataArray must only contain Objects, not: \" + e);\n              return;\n            }\n            ob(e);\n          }\n          this.Fc = a;\n          d = new E();\n          for (e = 0; e < c; e++) {\n            var f = a[e],\n              g = this.ja(f);\n            void 0 === g ? d.add(f) : null !== this.Va.H(g) ? d.add(f) : this.Va.add(g, f);\n          }\n          for (d = d.iterator; d.next();) e = d.value, this.Yt(e), f = this.ja(e), void 0 !== f && this.Va.add(f, e);\n          ir(this, \"nodeDataArray\", ve, \"nodeDataArray\", this, b, a);\n          for (b = 0; b < c; b++) d = a[b], this.Pm(d), this.Om(d);\n          Array.isArray(a) || (this.isReadOnly = !0);\n        }\n      }\n    },\n    copyNodeDataFunction: {\n      get: function () {\n        return this.bl;\n      },\n      set: function (a) {\n        var b = this.bl;\n        b !== a && (this.bl = a, this.g(\"copyNodeDataFunction\", b, a));\n      }\n    },\n    copiesArrays: {\n      get: function () {\n        return this.Cn;\n      },\n      set: function (a) {\n        var b = this.Cn;\n        b !== a && (this.Cn = a, this.g(\"copiesArrays\", b, a));\n      }\n    },\n    copiesArrayObjects: {\n      get: function () {\n        return this.Bn;\n      },\n      set: function (a) {\n        var b = this.Bn;\n        b !== a && (this.Bn = a, this.g(\"copiesArrayObjects\", b, a));\n      }\n    },\n    copiesKey: {\n      get: function () {\n        return this.En;\n      },\n      set: function (a) {\n        var b = this.En;\n        b !== a && (this.En = a, this.g(\"copiesKey\", b, a));\n      }\n    },\n    afterCopyFunction: {\n      get: function () {\n        return this.hn;\n      },\n      set: function (a) {\n        var b = this.hn;\n        b !== a && (this.hn = a, this.g(\"afterCopyFunction\", b, a));\n      }\n    },\n    nodeCategoryProperty: {\n      get: function () {\n        return this.Vj;\n      },\n      set: function (a) {\n        var b = this.Vj;\n        b !== a && (this.Vj = a, this.g(\"nodeCategoryProperty\", b, a));\n      }\n    },\n    type: {\n      get: function () {\n        return \"Model\";\n      }\n    }\n  });\n  Z.prototype.setCategoryForNodeData = Z.prototype.Tm;\n  Z.prototype.getCategoryForNodeData = Z.prototype.Gq;\n  Z.prototype.removeArrayItem = Z.prototype.qw;\n  Z.prototype.insertArrayItem = Z.prototype.Pt;\n  Z.prototype.addArrayItem = Z.prototype.iz;\n  Z.prototype.assignAllDataProperties = Z.prototype.tq;\n  Z.prototype.set = Z.prototype.set;\n  Z.prototype.clearUnresolvedReferences = Z.prototype.xz;\n  Z.prototype.mergeNodeDataArray = Z.prototype.GA;\n  Z.prototype.removeNodeDataCollection = Z.prototype.QA;\n  Z.prototype.removeNodeData = Z.prototype.Mm;\n  Z.prototype.addNodeDataCollection = Z.prototype.lz;\n  Z.prototype.addNodeData = Z.prototype.uf;\n  Z.prototype.makeNodeDataKeyUnique = Z.prototype.Yt;\n  Z.prototype.findNodeDataForKey = Z.prototype.Kb;\n  Z.prototype.containsNodeData = Z.prototype.Za;\n  Z.prototype.setKeyForNodeData = Z.prototype.Um;\n  Z.prototype.getKeyForNodeData = Z.prototype.ja;\n  Z.prototype.updateTargetBindings = Z.prototype.Ca;\n  Z.prototype.commit = Z.prototype.commit;\n  Z.prototype.rollbackTransaction = Z.prototype.Hf;\n  Z.prototype.commitTransaction = Z.prototype.Wa;\n  Z.prototype.startTransaction = Z.prototype.va;\n  Z.prototype.raiseDataChanged = Z.prototype.du;\n  Z.prototype.raiseChanged = Z.prototype.g;\n  Z.prototype.raiseChangedEvent = Z.prototype.ab;\n  Z.prototype.removeChangedListener = Z.prototype.Kk;\n  Z.prototype.addChangedListener = Z.prototype.Hh;\n  Z.prototype.writeJsonValue = Z.prototype.$m;\n  Z.prototype.replaceJsonObjects = Z.prototype.Nm;\n  Z.prototype.applyIncrementalJSON = Z.prototype.pz;\n  Z.prototype.applyIncrementalJson = Z.prototype.Wx;\n  Z.prototype.toJSON = Z.prototype.toJSON;\n  Z.prototype.toJson = Z.prototype.hr;\n  Z.prototype.toIncrementalJSON = Z.prototype.aB;\n  Z.prototype.toIncrementalJson = Z.prototype.Vy;\n  Z.prototype.computeJsonDifference = Z.prototype.yz;\n  Z.prototype.toIncrementalData = Z.prototype.$A;\n  Z.prototype.clear = Z.prototype.clear;\n  var lr = !1,\n    mr = {};\n  Z.className = \"Model\";\n  Z.fromJSON = Z.fromJson = function (a, b) {\n    void 0 === b && (b = null);\n    var c = null;\n    if (\"string\" === typeof a) try {\n      c = x.JSON.parse(a);\n    } catch (f) {} else \"object\" === typeof a ? c = a : B(\"Unable to construct a Model from: \" + a);\n    if (null === b) {\n      a = null;\n      var d = c[\"class\"];\n      if (\"string\" === typeof d) try {\n        var e = null;\n        0 === d.indexOf(\"go.\") ? (d = d.substr(3), e = gr(d)) : (e = gr(d), null === e && (e = x[d]));\n        \"function\" === typeof e && (a = new e());\n      } catch (f) {}\n      null === a || a instanceof Z ? b = a : B(\"Unable to construct a Model of declared class: \" + c[\"class\"]);\n    }\n    null === b && (b = Z.constructGraphLinksModel());\n    b.Yq(c);\n    b.ow(c);\n    return b;\n  };\n  Z.safePropertyValue = qn;\n  Z.safePropertySet = Sj;\n  mr.Brush = tl;\n  mr.ChangedEvent = ue;\n  mr.Geometry = td;\n  mr.Margin = pc;\n  mr.Panel = X;\n  mr.Point = J;\n  mr.Rect = N;\n  mr.Size = M;\n  mr.Spot = P;\n  mr.Transaction = ze;\n  mr.UndoManager = Ae;\n  function Li(a, b, c) {\n    Ya(this);\n    this.s = !1;\n    void 0 === a && (a = \"\");\n    void 0 === b && (b = a);\n    void 0 === c && (c = null);\n    this.l = -1;\n    this.jd = null;\n    this.jm = a;\n    this.im = this.fq = 0;\n    this.ht = null;\n    this.wo = !1;\n    this.bm = b;\n    this.An = c;\n    this.Vo = nr;\n    this.tn = null;\n    this.Nu = new F();\n  }\n  Li.prototype.copy = function () {\n    var a = new Li();\n    a.jm = this.jm;\n    a.fq = this.fq;\n    a.im = this.im;\n    a.ht = this.ht;\n    a.wo = this.wo;\n    a.bm = this.bm;\n    a.An = this.An;\n    a.Vo = this.Vo;\n    a.tn = this.tn;\n    return a;\n  };\n  t = Li.prototype;\n  t.hb = function (a) {\n    a.classType === Li && (this.mode = a);\n  };\n  t.toString = function () {\n    return \"Binding(\" + this.targetProperty + \":\" + this.sourceProperty + (-1 !== this.vj ? \" \" + this.vj : \"\") + \" \" + this.mode.name + \")\";\n  };\n  t.freeze = function () {\n    this.s = !0;\n    return this;\n  };\n  t.ea = function () {\n    this.s = !1;\n    return this;\n  };\n  t.Fy = function (a) {\n    void 0 === a && (a = null);\n    this.mode = jn;\n    this.backConverter = a;\n    return this;\n  };\n  t.Uq = function (a) {\n    void 0 === a && (a = \"\");\n    this.sourceName = a;\n    this.isToModel = !1;\n    return this;\n  };\n  t.IA = function () {\n    this.sourceName = null;\n    this.isToModel = !0;\n    return this;\n  };\n  function gl(a, b, c) {\n    a = a.sourceName;\n    return null === a || \"\" === a ? b : \"/\" === a ? c.part : \".\" === a ? c : \"..\" === a ? c.panel : b.$a(a);\n  }\n  t.Rw = function (a, b, c) {\n    var d = this.bm;\n    if (void 0 === c || \"\" === d || d === c) {\n      c = this.jm;\n      var e = this.An;\n      if (null === e && \"\" === c) wa(\"Binding error: target property is the empty string: \" + this.toString());else {\n        var f = b;\n        \"\" !== d && (f = qn(b, d));\n        if (void 0 !== f) if (null === e) \"\" !== c && Sj(a, c, f);else try {\n          if (\"\" !== c) {\n            var g = e(f, a);\n            Sj(a, c, g);\n          } else e(f, a);\n        } catch (h) {}\n      }\n    }\n  };\n  t.lr = function (a, b, c, d) {\n    if (this.Vo === jn) {\n      var e = this.jm;\n      if (void 0 === c || e === c) {\n        c = this.bm;\n        var f = this.tn,\n          g = a;\n        \"\" !== e && (g = qn(a, e));\n        if (void 0 !== g && !this.Nu.contains(a)) try {\n          this.Nu.add(a);\n          var h = null !== d ? d.diagram : null,\n            k = null !== h ? h.model : null;\n          if (null === f) {\n            if (\"\" !== c) null !== k ? k.setDataProperty(b, c, g) : Sj(b, c, g);else {\n              if (null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {\n                var l = d.itemIndex,\n                  m = d.panel.itemArray;\n                k.qw(m, l);\n                k.Pt(m, l, g);\n              }\n            }\n          } else try {\n            if (\"\" !== c) {\n              var n = f(g, b, k);\n              null !== k ? k.setDataProperty(b, c, n) : Sj(b, c, n);\n            } else {\n              var p = f(g, b, k);\n              if (void 0 !== p && null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {\n                var r = d.itemIndex,\n                  q = d.panel.itemArray;\n                k.qw(q, r);\n                k.Pt(q, r, p);\n              }\n            }\n          } catch (u) {}\n        } finally {\n          this.Nu.remove(a);\n        }\n      }\n    }\n  };\n  ma.Object.defineProperties(Li.prototype, {\n    vj: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.l = a;\n      }\n    },\n    targetProperty: {\n      get: function () {\n        return this.jm;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.jm = a;\n      }\n    },\n    sourceName: {\n      get: function () {\n        return this.ht;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.ht = a;\n        null !== a && (this.wo = !1);\n      }\n    },\n    isToModel: {\n      get: function () {\n        return this.wo;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.wo = a;\n      }\n    },\n    sourceProperty: {\n      get: function () {\n        return this.bm;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.bm = a;\n      }\n    },\n    converter: {\n      get: function () {\n        return this.An;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.An = a;\n      }\n    },\n    backConverter: {\n      get: function () {\n        return this.tn;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.tn = a;\n      }\n    },\n    mode: {\n      get: function () {\n        return this.Vo;\n      },\n      set: function (a) {\n        this.s && ua(this);\n        this.Vo = a;\n      }\n    }\n  });\n  Li.prototype.updateSource = Li.prototype.lr;\n  Li.prototype.updateTarget = Li.prototype.Rw;\n  Li.prototype.ofModel = Li.prototype.IA;\n  Li.prototype.ofObject = Li.prototype.Uq;\n  Li.prototype.makeTwoWay = Li.prototype.Fy;\n  var nr = new D(Li, \"OneWay\", 1),\n    jn = new D(Li, \"TwoWay\", 2);\n  Li.className = \"Binding\";\n  Li.parseEnum = function (a, b) {\n    return function (c) {\n      c = Za(a, c);\n      return null === c ? b : c;\n    };\n  };\n  Li.toString = Ja;\n  Li.OneWay = nr;\n  Li.TwoWay = jn;\n  function or(a, b) {\n    Z.call(this);\n    this.ru = ',\\n  \"insertedLinkKeys\": ';\n    this.ix = ',\\n  \"modifiedLinkData\": ';\n    this.tu = ',\\n  \"removedLinkKeys\": ';\n    this.Wc = [];\n    this.ag = new F();\n    this.fb = new H();\n    this.Gi = \"\";\n    this.xj = this.al = this.Kl = null;\n    this.$e = \"from\";\n    this.af = \"to\";\n    this.Sj = this.Rj = \"\";\n    this.Qj = \"category\";\n    this.Td = \"\";\n    this.Ol = \"isGroup\";\n    this.ve = \"group\";\n    this.Dn = !1;\n    void 0 !== a && (this.nodeDataArray = a);\n    void 0 !== b && (this.linkDataArray = b);\n  }\n  la(or, Z);\n  or.constructGraphLinksModel = Z.constructGraphLinksModel;\n  or.prototype.cloneProtected = function (a) {\n    Z.prototype.cloneProtected.call(this, a);\n    a.Gi = this.Gi;\n    a.Kl = this.Kl;\n    a.al = this.al;\n    a.$e = this.$e;\n    a.af = this.af;\n    a.Rj = this.Rj;\n    a.Sj = this.Sj;\n    a.Qj = this.Qj;\n    a.Td = this.Td;\n    a.Ol = this.Ol;\n    a.ve = this.ve;\n    a.Dn = this.Dn;\n  };\n  t = or.prototype;\n  t.clear = function () {\n    Z.prototype.clear.call(this);\n    this.Wc = [];\n    this.fb.clear();\n    this.ag.clear();\n  };\n  t.toString = function (a) {\n    void 0 === a && (a = 0);\n    if (2 <= a) return this.hr();\n    var b = (\"\" !== this.name ? this.name : \"\") + \" GraphLinksModel\";\n    if (0 < a) {\n      b += \"\\n node data:\";\n      a = this.nodeDataArray;\n      var c = a.length,\n        d;\n      for (d = 0; d < c; d++) {\n        var e = a[d];\n        b += \" \" + this.ja(e) + \":\" + Ja(e);\n      }\n      b += \"\\n link data:\";\n      a = this.linkDataArray;\n      c = a.length;\n      for (d = 0; d < c; d++) e = a[d], b += \" \" + Iq(this, e, !0) + \"--\\x3e\" + Iq(this, e, !1);\n    }\n    return b;\n  };\n  t.Ww = function (a, b) {\n    \"\" === this.linkKeyProperty && B(\"GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalData() to succeed.\");\n    var c = Z.prototype.Ww.call(this, a, b),\n      d = this,\n      e = new F(),\n      f = new F(),\n      g = new F(),\n      h = this.Yh;\n    a.changes.each(function (a) {\n      a.model === d && (\"linkDataArray\" === a.modelChange ? a.change === xe ? e.add(a.newValue) : a.change === ye && g.add(a.oldValue) : d.wc(a.object) ? f.add(a.object) : null !== a.object && (null !== a.object && h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        d.wc(a) && f.add(a);\n      }) : a.object instanceof Z || d.Za(a.object) || pr(d, a.object).each(function (a) {\n        f.add(a);\n      })));\n    });\n    var k = this.Ki;\n    k.clear();\n    e.each(function (a) {\n      k.add(d.Vb(a));\n      b || f.add(a);\n    });\n    var l = this.Ni;\n    l.clear();\n    g.each(function (a) {\n      l.add(d.Vb(a));\n      b && f.add(a);\n    });\n    a = d.cloneDeep(f.ma());\n    0 < k.count && (null === c && (c = {}), b ? c.removedLinkKeys = k.ma() : c.insertedLinkKeys = k.ma());\n    0 < a.length && (null === c && (c = {}), c.modifiedLinkData = a);\n    0 < l.count && (null === c && (c = {}), b ? c.insertedLinkKeys = l.ma() : c.removedLinkKeys = l.ma());\n    l.clear();\n    k.clear();\n    return c;\n  };\n  t.Nk = function () {\n    var a = Z.prototype.Nk.call(this),\n      b = \"\";\n    \"category\" !== this.linkCategoryProperty && \"string\" === typeof this.linkCategoryProperty && (b += ',\\n  \"linkCategoryProperty\": ' + this.quote(this.linkCategoryProperty));\n    \"\" !== this.linkKeyProperty && \"string\" === typeof this.linkKeyProperty && (b += ',\\n  \"linkKeyProperty\": ' + this.quote(this.linkKeyProperty));\n    \"from\" !== this.linkFromKeyProperty && \"string\" === typeof this.linkFromKeyProperty && (b += ',\\n  \"linkFromKeyProperty\": ' + this.quote(this.linkFromKeyProperty));\n    \"to\" !== this.linkToKeyProperty && \"string\" === typeof this.linkToKeyProperty && (b += ',\\n  \"linkToKeyProperty\": ' + this.quote(this.linkToKeyProperty));\n    \"\" !== this.linkFromPortIdProperty && \"string\" === typeof this.linkFromPortIdProperty && (b += ',\\n  \"linkFromPortIdProperty\": ' + this.quote(this.linkFromPortIdProperty));\n    \"\" !== this.linkToPortIdProperty && \"string\" === typeof this.linkToPortIdProperty && (b += ',\\n  \"linkToPortIdProperty\": ' + this.quote(this.linkToPortIdProperty));\n    \"\" !== this.linkLabelKeysProperty && \"string\" === typeof this.linkLabelKeysProperty && (b += ',\\n  \"linkLabelKeysProperty\": ' + this.quote(this.linkLabelKeysProperty));\n    \"isGroup\" !== this.nodeIsGroupProperty && \"string\" === typeof this.nodeIsGroupProperty && (b += ',\\n  \"nodeIsGroupProperty\": ' + this.quote(this.nodeIsGroupProperty));\n    \"group\" !== this.nodeGroupKeyProperty && \"string\" === typeof this.nodeGroupKeyProperty && (b += ',\\n  \"nodeGroupKeyProperty\": ' + this.quote(this.nodeGroupKeyProperty));\n    return a + b;\n  };\n  t.Yq = function (a) {\n    Z.prototype.Yq.call(this, a);\n    a.linkKeyProperty && (this.linkKeyProperty = a.linkKeyProperty);\n    a.linkFromKeyProperty && (this.linkFromKeyProperty = a.linkFromKeyProperty);\n    a.linkToKeyProperty && (this.linkToKeyProperty = a.linkToKeyProperty);\n    a.linkFromPortIdProperty && (this.linkFromPortIdProperty = a.linkFromPortIdProperty);\n    a.linkToPortIdProperty && (this.linkToPortIdProperty = a.linkToPortIdProperty);\n    a.linkCategoryProperty && (this.linkCategoryProperty = a.linkCategoryProperty);\n    a.linkLabelKeysProperty && (this.linkLabelKeysProperty = a.linkLabelKeysProperty);\n    a.nodeIsGroupProperty && (this.nodeIsGroupProperty = a.nodeIsGroupProperty);\n    a.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = a.nodeGroupKeyProperty);\n  };\n  t.Xw = function () {\n    var a = Z.prototype.Xw.call(this),\n      b = ',\\n  \"linkDataArray\": ' + ar(this, this.linkDataArray, !0);\n    return a + b;\n  };\n  t.ow = function (a) {\n    Z.prototype.ow.call(this, a);\n    a = a.linkDataArray;\n    Array.isArray(a) && (this.Nm(a), this.linkDataArray = a);\n  };\n  t.mr = function (a) {\n    if (!(a instanceof or)) return B(\"Model.computeJsonDifference: newmodel must be a GraphLinksModel\"), \"\";\n    \"\" === this.linkKeyProperty && B(\"GraphLinksModel.linkKeyProperty must not be an empty string for .computeJsonDifference() to succeed.\");\n    var b = Z.prototype.mr.call(this, a);\n    cr(this, a, \"linkKeyProperty\");\n    cr(this, a, \"linkFromKeyProperty\");\n    cr(this, a, \"linkToKeyProperty\");\n    cr(this, a, \"linkLabelKeysProperty\");\n    cr(this, a, \"nodeIsGroupProperty\");\n    cr(this, a, \"nodeGroupKeyProperty\");\n    var c = this.Ki;\n    c.clear();\n    var d = new F(),\n      e = this.Ni;\n    e.clear();\n    e.addAll(this.fb.iteratorKeys);\n    for (var f = new H(), g = a.linkDataArray, h = g.length, k = 0; k < h; k++) {\n      var l = g[k],\n        m = a.Vb(l);\n      if (void 0 !== m) {\n        e.remove(m);\n        var n = this.Dg(m);\n        null === n ? (c.add(m), d.add(l)) : br(this, n, l, f) || d.add(l);\n      } else this.Rq(l), m = this.Vb(l), c.add(m), d.add(l);\n    }\n    a = b;\n    0 < c.count && (a += this.ru + ar(this, c.ma(), !0));\n    0 < d.count && (a += this.ix + ar(this, d.ma(), !0));\n    0 < e.count && (a += this.tu + ar(this, e.ma(), !0));\n    e.clear();\n    c.clear();\n    return a;\n  };\n  function pr(a, b) {\n    for (var c = new F(), d = 0; d < a.linkDataArray.length; d++) {\n      var e = a.linkDataArray[d];\n      er(a, b, e, e, c);\n    }\n    return c;\n  }\n  t.Vw = function (a, b) {\n    \"\" === this.linkKeyProperty && B(\"GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalJson() to succeed.\");\n    var c = Z.prototype.Vw.call(this, a, b),\n      d = this,\n      e = new F(),\n      f = new F(),\n      g = new F(),\n      h = this.Yh;\n    a.changes.each(function (a) {\n      a.model === d && (\"linkDataArray\" === a.modelChange ? a.change === xe ? e.add(a.newValue) : a.change === ye && g.add(a.oldValue) : d.wc(a.object) ? f.add(a.object) : null !== a.object && (null !== a.object && h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        d.wc(a) && f.add(a);\n      }) : a.object instanceof Z || d.Za(a.object) || pr(d, a.object).each(function (a) {\n        f.add(a);\n      })));\n    });\n    var k = this.Ki;\n    k.clear();\n    e.each(function (a) {\n      k.add(d.Vb(a));\n      b || f.add(a);\n    });\n    var l = this.Ni;\n    l.clear();\n    g.each(function (a) {\n      l.add(d.Vb(a));\n      b && f.add(a);\n    });\n    a = c;\n    0 < k.count && (a += (b ? this.tu : this.ru) + ar(this, k.ma(), !0));\n    0 < f.count && (a += this.ix + ar(this, f.ma(), !0));\n    0 < l.count && (a += (b ? this.ru : this.tu) + ar(this, l.ma(), !0));\n    l.clear();\n    k.clear();\n    return a;\n  };\n  t.Xq = function (a) {\n    (void 0 !== a.linkCategoryProperty && a.linkCategoryProperty !== this.linkCategoryProperty || void 0 !== a.linkKeyProperty && a.linkKeyProperty !== this.linkKeyProperty || void 0 !== a.linkFromKeyProperty && a.linkFromKeyProperty !== this.linkFromKeyProperty || void 0 !== a.linkToKeyProperty && a.linkToKeyProperty !== this.linkToKeyProperty || void 0 !== a.linkFromPortIdProperty && a.linkFromPortIdProperty !== this.linkFromPortIdProperty || void 0 !== a.linkToPortIdProperty && a.linkToPortIdProperty !== this.linkToPortIdProperty || void 0 !== a.linkLabelKeysProperty && a.linkLabelKeysProperty !== this.linkLabelKeysProperty || void 0 !== a.nodeIsGroupProperty && a.nodeIsGroupProperty !== this.nodeIsGroupProperty || void 0 !== a.nodeGroupKeyProperty && a.nodeGroupKeyProperty !== this.nodeGroupKeyProperty) && B(\"applyIncrementalJson cannot change Model properties\");\n    Z.prototype.Xq.call(this, a);\n    var b = a.insertedLinkKeys;\n    if (Array.isArray(b)) for (var c = b.length, d = 0; d < c; d++) {\n      var e = b[d],\n        f = this.Dg(e);\n      null === f && (f = this.yq({}), this.iu(f, e), this.bj(f));\n    }\n    b = a.modifiedLinkData;\n    if (Array.isArray(b)) for (c = b.length, d = 0; d < c; d++) if (e = b[d], f = this.Vb(e), f = this.Dg(f), null !== f) {\n      for (var g in e) \"__gohashid\" !== g && g !== this.linkKeyProperty && this.setDataProperty(f, g, e[g]);\n      qr(this, e, f);\n    }\n    a = a.removedLinkKeys;\n    if (Array.isArray(a)) for (g = a.length, b = 0; b < g; b++) c = this.Dg(a[b]), null !== c && this.Lm(c);\n  };\n  or.prototype.changeState = function (a, b) {\n    if (null !== a && a.model === this) {\n      if (a.change === ve) {\n        var c = a.object,\n          d = a.propertyName;\n        if (d === this.linkKeyProperty && this.wc(c)) {\n          var e = a.H(b);\n          b = a.H(!b);\n          void 0 !== b && this.fb.remove(b);\n          void 0 !== e && this.fb.add(e, c);\n          Sj(c, d, e);\n          return;\n        }\n      } else if (a.change === xe) {\n        c = a.newParam;\n        if (\"linkDataArray\" === a.modelChange) {\n          a = a.newValue;\n          ya(a) && \"number\" === typeof c && (d = this.Vb(a), b ? (this.ag.remove(a), this.Wc[c] === a && this.Wc.splice(c, 1), void 0 !== d && this.fb.remove(d)) : (this.ag.add(a), this.Wc[c] !== a && this.Wc.splice(c, 0, a), void 0 !== d && this.fb.add(d, a)));\n          return;\n        }\n        if (\"linkLabelKeys\" === a.modelChange) {\n          d = this.Bf(a.object);\n          Array.isArray(d) && \"number\" === typeof c && (b ? (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)) : 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue));\n          return;\n        }\n      } else if (a.change === ye) {\n        c = a.oldParam;\n        if (\"linkDataArray\" === a.modelChange) {\n          a = a.oldValue;\n          ya(a) && \"number\" === typeof c && (d = this.Vb(a), b ? (this.ag.add(a), this.Wc[c] !== a && this.Wc.splice(c, 0, a), void 0 !== d && this.fb.add(d, a)) : (this.ag.remove(a), this.Wc[c] === a && this.Wc.splice(c, 1), void 0 !== d && this.fb.remove(d)));\n          return;\n        }\n        if (\"linkLabelKeys\" === a.modelChange) {\n          d = this.Bf(a.object);\n          Array.isArray(d) && \"number\" === typeof c && (b ? 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue) : (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)));\n          return;\n        }\n      }\n      Z.prototype.changeState.call(this, a, b);\n    }\n  };\n  t = or.prototype;\n  t.Cm = function (a) {\n    if (void 0 !== a) {\n      var b = this.xj;\n      if (null !== b) {\n        var c = this.Kb(a);\n        null === c && (c = this.copyNodeData(b), Sj(c, this.nodeKeyProperty, a), this.uf(c));\n      }\n      return a;\n    }\n  };\n  t.uy = function (a) {\n    return Iq(this, a, !0);\n  };\n  t.Aw = function (a, b) {\n    Qq(this, a, b, !0);\n  };\n  t.xy = function (a) {\n    return Iq(this, a, !1);\n  };\n  t.Fw = function (a, b) {\n    Qq(this, a, b, !1);\n  };\n  function Iq(a, b, c) {\n    if (null !== b && (a = c ? a.$e : a.af, \"\" !== a && (a = qn(b, a), void 0 !== a))) {\n      if (Kq(a)) return a;\n      B((c ? \"FromKey\" : \"ToKey\") + \" value for link data \" + b + \" is not a number or a string: \" + a);\n    }\n  }\n  function Qq(a, b, c, d) {\n    null === c && (c = void 0);\n    if (null !== b) {\n      var e = d ? a.$e : a.af;\n      if (\"\" !== e) if (c = a.Cm(c), a.wc(b)) {\n        var f = qn(b, e);\n        f !== c && (Oq(a, f, b), Sj(b, e, c), null === a.Kb(c) && Pq(a, c, b), ir(a, d ? \"linkFromKey\" : \"linkToKey\", ve, e, b, f, c), \"string\" === typeof e && a.Ca(b, e));\n      } else Sj(b, e, c);\n    }\n  }\n  t.vy = function (a) {\n    return Hq(this, a, !0);\n  };\n  t.Bw = function (a, b) {\n    Rq(this, a, b, !0);\n  };\n  t.yy = function (a) {\n    return Hq(this, a, !1);\n  };\n  t.Gw = function (a, b) {\n    Rq(this, a, b, !1);\n  };\n  function Hq(a, b, c) {\n    if (null === b) return \"\";\n    a = c ? a.Rj : a.Sj;\n    if (\"\" === a) return \"\";\n    b = qn(b, a);\n    return void 0 === b ? \"\" : b;\n  }\n  function Rq(a, b, c, d) {\n    if (null !== b) {\n      var e = d ? a.Rj : a.Sj;\n      if (\"\" !== e) if (a.wc(b)) {\n        var f = qn(b, e);\n        void 0 === f && (f = \"\");\n        f !== c && (Sj(b, e, c), ir(a, d ? \"linkFromPortId\" : \"linkToPortId\", ve, e, b, f, c), \"string\" === typeof e && a.Ca(b, e));\n      } else Sj(b, e, c);\n    }\n  }\n  t.Bf = function (a) {\n    if (null === a) return rr;\n    var b = this.Td;\n    if (\"\" === b) return rr;\n    a = qn(a, b);\n    return void 0 === a ? rr : a;\n  };\n  t.ju = function (a, b) {\n    if (null !== a) {\n      var c = this.Td;\n      if (\"\" !== c) if (this.wc(a)) {\n        var d = qn(a, c);\n        void 0 === d && (d = rr);\n        if (d !== b) {\n          if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) Oq(this, d[f], a);\n          Sj(a, c, b);\n          e = b.length;\n          for (f = 0; f < e; f++) {\n            var g = b[f];\n            null === this.Kb(g) && Pq(this, g, a);\n          }\n          ir(this, \"linkLabelKeys\", ve, c, a, d, b);\n          \"string\" === typeof c && this.Ca(a, c);\n        }\n      } else Sj(a, c, b);\n    }\n  };\n  t.Dv = function (a, b) {\n    if (null !== b && void 0 !== b && null !== a) {\n      var c = this.Td;\n      if (\"\" !== c) {\n        var d = qn(a, c);\n        if (void 0 === d) c = [], c.push(b), this.ju(a, c);else if (Array.isArray(d)) {\n          var e = d.indexOf(b);\n          0 <= e || (e = d.length, d.push(b), this.wc(a) && (null === this.Kb(b) && Pq(this, b, a), ir(this, \"linkLabelKeys\", xe, c, a, null, b, null, e)));\n        } else B(c + \" property is not an Array; cannot addLabelKeyForLinkData: \" + a);\n      }\n    }\n  };\n  t.Ly = function (a, b) {\n    if (null !== b && void 0 !== b && null !== a) {\n      var c = this.Td;\n      if (\"\" !== c) {\n        var d = qn(a, c);\n        if (Array.isArray(d)) {\n          var e = d.indexOf(b);\n          0 > e || (d.splice(e, 1), this.wc(a) && (Oq(this, b, a), ir(this, \"linkLabelKeys\", ye, c, a, b, null, e, null)));\n        } else void 0 !== d && B(c + \" property is not an Array; cannot removeLabelKeyforLinkData: \" + a);\n      }\n    }\n  };\n  t.Vb = function (a) {\n    if (null !== a) {\n      var b = this.Gi;\n      if (\"\" !== b && (b = qn(a, b), void 0 !== b)) {\n        if (Kq(b)) return b;\n        B(\"Key value for link data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n  t.iu = function (a, b) {\n    if (null !== a) {\n      var c = this.Gi;\n      if (\"\" !== c) if (this.wc(a)) {\n        var d = qn(a, c);\n        d !== b && null === this.Dg(b) && (Sj(a, c, b), void 0 !== d && this.fb.remove(d), this.fb.add(b, a), ir(this, \"linkKey\", ve, c, a, d, b), \"string\" === typeof c && this.Ca(a, c));\n      } else Sj(a, c, b);\n    }\n  };\n  t.Dg = function (a) {\n    null === a && B(\"GraphLinksModel.findLinkDataForKey:key must not be null\");\n    return void 0 !== a && Kq(a) ? this.fb.H(a) : null;\n  };\n  t.Rq = function (a) {\n    if (null !== a) {\n      var b = this.Gi;\n      if (\"\" !== b) {\n        var c = this.Vb(a);\n        if (void 0 === c || this.fb.contains(c)) {\n          var d = this.Kl;\n          if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.fb.contains(c))) {\n            Sj(a, b, c);\n            return;\n          }\n          if (\"string\" === typeof c) {\n            for (d = 2; this.fb.contains(c + d);) d++;\n            Sj(a, b, c + d);\n          } else if (void 0 === c || \"number\" === typeof c) {\n            for (c = -this.fb.count - 1; this.fb.contains(c);) c--;\n            Sj(a, b, c);\n          }\n        }\n      }\n    }\n  };\n  t.wc = function (a) {\n    return null === a ? !1 : this.ag.contains(a);\n  };\n  t.bj = function (a) {\n    null !== a && (ob(a), this.wc(a) || Mq(this, a, !0));\n  };\n  function Mq(a, b, c) {\n    if (\"\" !== a.linkKeyProperty) {\n      var d = a.Vb(b);\n      if (void 0 !== d && a.fb.H(d) === b) return;\n      a.Rq(b);\n      d = a.Vb(b);\n      if (void 0 === d) {\n        B(\"GraphLinksModel.makeLinkDataKeyUnique failed on \" + b + \". Data not added to model.\");\n        return;\n      }\n      a.fb.add(d, b);\n    }\n    a.ag.add(b);\n    d = null;\n    c && (d = a.Wc.length, a.Wc.splice(d, 0, b));\n    ir(a, \"linkDataArray\", xe, \"linkDataArray\", a, null, b, null, d);\n    sr(a, b);\n  }\n  t.kz = function (a) {\n    if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++) this.bj(a[c]);else for (a = a.iterator; a.next();) this.bj(a.value);\n  };\n  t.Lm = function (a) {\n    null !== a && Lq(this, a, !0);\n  };\n  function Lq(a, b, c) {\n    a.ag.remove(b);\n    var d = a.Vb(b);\n    void 0 !== d && a.fb.remove(d);\n    d = null;\n    if (c) {\n      d = a.Wc.indexOf(b);\n      if (0 > d) return;\n      a.Wc.splice(d, 1);\n    }\n    ir(a, \"linkDataArray\", ye, \"linkDataArray\", a, b, null, d, null);\n    c = Iq(a, b, !0);\n    Oq(a, c, b);\n    c = Iq(a, b, !1);\n    Oq(a, c, b);\n    d = a.Bf(b);\n    if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) c = d[f], Oq(a, c, b);\n  }\n  t.OA = function (a) {\n    if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++) this.Lm(a[c]);else for (a = a.iterator; a.next();) this.Lm(a.value);\n  };\n  t.FA = function (a) {\n    \"\" === this.linkKeyProperty && B(\"GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed.\");\n    if (a !== this.linkDataArray && Aa(a)) {\n      var b = this.Ni;\n      b.clear();\n      b.addAll(this.fb.iteratorKeys);\n      var c = this.Ki;\n      c.clear();\n      for (var d = a.length, e = 0; e < d; e++) {\n        var f = a[e],\n          g = this.Vb(f);\n        if (void 0 !== g) {\n          c.add(g);\n          var h = this.Dg(g);\n          h !== f && (null !== h ? (this.tq(h, f), qr(this, f, h)) : (f = this.cloneDeep(f), this.iu(f, g), this.bj(f)));\n        } else g = this.cloneDeep(f), this.bj(g), c.add(this.Vb(g));\n      }\n      for (a = b.iterator; a.next();) d = a.value, c.contains(d) || (d = this.Dg(d)) && this.Lm(d);\n      b.clear();\n      c.clear();\n    }\n  };\n  function sr(a, b) {\n    var c = Iq(a, b, !0);\n    c = a.Cm(c);\n    null === a.Kb(c) && Pq(a, c, b);\n    c = Iq(a, b, !1);\n    c = a.Cm(c);\n    null === a.Kb(c) && Pq(a, c, b);\n    var d = a.Bf(b);\n    if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) c = d[f], null === a.Kb(c) && Pq(a, c, b);\n  }\n  t.yq = function (a) {\n    if (null === a) return null;\n    var b = this.al;\n    a = null !== b ? b(a, this) : jr(this, a, !0);\n    ya(a) && (Ya(a), \"\" !== this.$e && Sj(a, this.$e, void 0), \"\" !== this.af && Sj(a, this.af, void 0), \"\" !== this.Td && Sj(a, this.Td, []));\n    return a;\n  };\n  t.ew = function (a) {\n    if (null === a) return !1;\n    var b = this.Ol;\n    return \"\" === b ? !1 : qn(a, b) ? !0 : !1;\n  };\n  t.Lh = function (a) {\n    if (null !== a) {\n      var b = this.ve;\n      if (\"\" !== b && (b = qn(a, b), void 0 !== b)) {\n        if (Kq(b)) return b;\n        B(\"GroupKey value for node data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n  t.er = function (a, b) {\n    null === b && (b = void 0);\n    if (null !== a) {\n      var c = this.ve;\n      if (\"\" !== c) if (this.Za(a)) {\n        var d = qn(a, c);\n        d !== b && (Oq(this, d, a), Sj(a, c, b), null === this.Kb(b) && Pq(this, b, a), ir(this, \"nodeGroupKey\", ve, c, a, d, b), \"string\" === typeof c && this.Ca(a, c));\n      } else Sj(a, c, b);\n    }\n  };\n  or.prototype.copyNodeData = function (a) {\n    if (null === a) return null;\n    a = Z.prototype.copyNodeData.call(this, a);\n    this.nk || \"\" === this.ve || void 0 === qn(a, this.ve) || Sj(a, this.ve, void 0);\n    return a;\n  };\n  or.prototype.setDataProperty = function (a, b, c) {\n    if (this.Za(a)) {\n      if (b === this.nodeKeyProperty) {\n        this.Um(a, c);\n        return;\n      }\n      if (b === this.nodeCategoryProperty) {\n        this.Tm(a, c);\n        return;\n      }\n      if (b === this.nodeGroupKeyProperty) {\n        this.er(a, c);\n        return;\n      }\n    } else if (this.wc(a)) {\n      if (b === this.linkFromKeyProperty) {\n        Qq(this, a, c, !0);\n        return;\n      }\n      if (b === this.linkToKeyProperty) {\n        Qq(this, a, c, !1);\n        return;\n      }\n      if (b === this.linkFromPortIdProperty) {\n        Rq(this, a, c, !0);\n        return;\n      }\n      if (b === this.linkToPortIdProperty) {\n        Rq(this, a, c, !1);\n        return;\n      }\n      if (b === this.linkKeyProperty) {\n        this.iu(a, c);\n        return;\n      }\n      if (b === this.linkCategoryProperty) {\n        this.dr(a, c);\n        return;\n      }\n      if (b === this.linkLabelKeysProperty) {\n        this.ju(a, c);\n        return;\n      }\n    }\n    var d = qn(a, b);\n    d !== c && (Sj(a, b, c), this.du(a, b, d, c));\n  };\n  t = or.prototype;\n  t.tq = function (a, b) {\n    if (b) {\n      var c = this.Za(a),\n        d = this.wc(a),\n        e;\n      for (e in b) \"__gohashid\" === e || c && e === this.nodeKeyProperty || c && e === this.nodeIsGroupProperty && qn(a, e) === b[e] || d && e === this.linkKeyProperty || this.setDataProperty(a, e, b[e]);\n    }\n  };\n  t.br = function (a, b) {\n    Z.prototype.br.call(this, a, b);\n    for (var c = this.Va.iterator; c.next();) this.uw(c.value, a, b);\n    for (c = this.ag.iterator; c.next();) {\n      var d = c.value,\n        e = a,\n        f = b;\n      if (Iq(this, d, !0) === e) {\n        var g = this.$e;\n        Sj(d, g, f);\n        ir(this, \"linkFromKey\", ve, g, d, e, f);\n        \"string\" === typeof g && this.Ca(d, g);\n      }\n      Iq(this, d, !1) === e && (g = this.af, Sj(d, g, f), ir(this, \"linkToKey\", ve, g, d, e, f), \"string\" === typeof g && this.Ca(d, g));\n      g = this.Bf(d);\n      if (Array.isArray(g)) for (var h = g.length, k = this.Td, l = 0; l < h; l++) g[l] === e && (g[l] = f, ir(this, \"linkLabelKeys\", xe, k, d, e, f, l, l));\n    }\n  };\n  t.uw = function (a, b, c) {\n    if (this.Lh(a) === b) {\n      var d = this.ve;\n      Sj(a, d, c);\n      ir(this, \"nodeGroupKey\", ve, d, a, b, c);\n      \"string\" === typeof d && this.Ca(a, d);\n    }\n  };\n  t.Qw = function () {\n    Z.prototype.Qw.call(this);\n    for (var a = this.linkDataArray, b = a.length, c = 0; c < b; c++) sr(this, a[c]);\n  };\n  t.Pm = function (a) {\n    Z.prototype.Pm.call(this, a);\n    a = this.ja(a);\n    var b = Nq(this, a);\n    if (null !== b) {\n      var c = Ea();\n      for (b = b.iterator; b.next();) {\n        var d = b.value;\n        if (this.Za(d)) {\n          if (this.Lh(d) === a) {\n            var e = this.ve;\n            ir(this, \"nodeGroupKey\", ve, e, d, a, a);\n            \"string\" === typeof e && this.Ca(d, e);\n            c.push(d);\n          }\n        } else if (Iq(this, d, !0) === a && (e = this.$e, ir(this, \"linkFromKey\", ve, e, d, a, a), \"string\" === typeof e && this.Ca(d, e), c.push(d)), Iq(this, d, !1) === a && (e = this.af, ir(this, \"linkToKey\", ve, e, d, a, a), \"string\" === typeof e && this.Ca(d, e), c.push(d)), e = this.Bf(d), Array.isArray(e)) for (var f = e.length, g = this.Td, h = 0; h < f; h++) e[h] === a && (ir(this, \"linkLabelKeys\", xe, g, d, a, a, h, h), c.push(d));\n      }\n      for (b = 0; b < c.length; b++) Oq(this, a, c[b]);\n      Ha(c);\n    }\n  };\n  t.Om = function (a) {\n    Z.prototype.Om.call(this, a);\n    var b = this.Lh(a);\n    null === this.Kb(b) && Pq(this, b, a);\n  };\n  t.jr = function (a) {\n    Z.prototype.jr.call(this, a);\n    var b = this.Lh(a);\n    Oq(this, b, a);\n  };\n  t.Mt = function (a) {\n    if (null === a) return \"\";\n    var b = this.Qj;\n    if (\"\" === b) return \"\";\n    b = qn(a, b);\n    if (void 0 === b) return \"\";\n    if (\"string\" === typeof b) return b;\n    B(\"getCategoryForLinkData found a non-string category for \" + a + \": \" + b);\n    return \"\";\n  };\n  or.prototype.getLinkCategoryForData = function (a) {\n    return this.Mt(a);\n  };\n  or.prototype.dr = function (a, b) {\n    if (null !== a) {\n      var c = this.Qj;\n      if (\"\" !== c) if (this.wc(a)) {\n        var d = qn(a, c);\n        void 0 === d && (d = \"\");\n        d !== b && (Sj(a, c, b), ir(this, \"linkCategory\", ve, c, a, d, b), \"string\" === typeof c && this.Ca(a, c));\n      } else Sj(a, c, b);\n    }\n  };\n  or.prototype.setLinkCategoryForData = function (a, b) {\n    this.dr(a, b);\n  };\n  t = or.prototype;\n  t.Vm = function (a, b) {\n    Z.prototype.Vm.call(this, a, b);\n    this.er(b, this.Lh(a));\n  };\n  function qr(a, b, c) {\n    a.dr(c, a.Mt(b));\n    a.Aw(c, a.uy(b));\n    a.Fw(c, a.xy(b));\n    a.ju(c, a.Bf(b));\n    a.Bw(c, a.vy(b));\n    a.Gw(c, a.yy(b));\n  }\n  t.xk = function () {\n    return !0;\n  };\n  t.pj = function () {\n    return !0;\n  };\n  t.Ut = function () {\n    return !0;\n  };\n  t.yk = function () {\n    return !0;\n  };\n  ma.Object.defineProperties(or.prototype, {\n    archetypeNodeData: {\n      get: function () {\n        return this.xj;\n      },\n      set: function (a) {\n        var b = this.xj;\n        b !== a && (this.xj = a, this.g(\"archetypeNodeData\", b, a));\n      }\n    },\n    linkFromKeyProperty: {\n      get: function () {\n        return this.$e;\n      },\n      set: function (a) {\n        var b = this.$e;\n        b !== a && (this.$e = a, this.g(\"linkFromKeyProperty\", b, a));\n      }\n    },\n    linkToKeyProperty: {\n      get: function () {\n        return this.af;\n      },\n      set: function (a) {\n        var b = this.af;\n        b !== a && (this.af = a, this.g(\"linkToKeyProperty\", b, a));\n      }\n    },\n    linkFromPortIdProperty: {\n      get: function () {\n        return this.Rj;\n      },\n      set: function (a) {\n        var b = this.Rj;\n        b !== a && (this.Rj = a, this.g(\"linkFromPortIdProperty\", b, a));\n      }\n    },\n    linkToPortIdProperty: {\n      get: function () {\n        return this.Sj;\n      },\n      set: function (a) {\n        var b = this.Sj;\n        b !== a && (this.Sj = a, this.g(\"linkToPortIdProperty\", b, a));\n      }\n    },\n    linkLabelKeysProperty: {\n      get: function () {\n        return this.Td;\n      },\n      set: function (a) {\n        var b = this.Td;\n        b !== a && (this.Td = a, this.g(\"linkLabelKeysProperty\", b, a));\n      }\n    },\n    linkDataArray: {\n      get: function () {\n        return this.Wc;\n      },\n      set: function (a) {\n        var b = this.Wc;\n        if (b !== a) {\n          this.fb.clear();\n          for (var c = a.length, d = 0; d < c; d++) {\n            var e = a[d];\n            if (!ya(e)) {\n              B(\"GraphLinksModel.linkDataArray must only contain Objects, not: \" + e);\n              return;\n            }\n            ob(e);\n          }\n          this.Wc = a;\n          if (\"\" !== this.linkKeyProperty) {\n            d = new E();\n            for (e = 0; e < c; e++) {\n              var f = a[e],\n                g = this.Vb(f);\n              void 0 === g ? d.add(f) : null !== this.fb.H(g) ? d.add(f) : this.fb.add(g, f);\n            }\n            for (d = d.iterator; d.next();) e = d.value, this.Rq(e), f = this.Vb(e), void 0 !== f && this.fb.add(f, e);\n          }\n          d = new F();\n          for (e = 0; e < c; e++) d.add(a[e]);\n          this.ag = d;\n          ir(this, \"linkDataArray\", ve, \"linkDataArray\", this, b, a);\n          for (b = 0; b < c; b++) sr(this, a[b]);\n        }\n      }\n    },\n    linkKeyProperty: {\n      get: function () {\n        return this.Gi;\n      },\n      set: function (a) {\n        var b = this.Gi;\n        if (b !== a) {\n          this.Gi = a;\n          this.fb.clear();\n          for (var c = this.linkDataArray.length, d = 0; d < c; d++) {\n            var e = this.linkDataArray[d],\n              f = this.Vb(e);\n            void 0 === f && (this.Rq(e), f = this.Vb(e));\n            void 0 !== f && this.fb.add(f, e);\n          }\n          this.g(\"linkKeyProperty\", b, a);\n        }\n      }\n    },\n    makeUniqueLinkKeyFunction: {\n      get: function () {\n        return this.Kl;\n      },\n      set: function (a) {\n        var b = this.Kl;\n        b !== a && (this.Kl = a, this.g(\"makeUniqueLinkKeyFunction\", b, a));\n      }\n    },\n    copyLinkDataFunction: {\n      get: function () {\n        return this.al;\n      },\n      set: function (a) {\n        var b = this.al;\n        b !== a && (this.al = a, this.g(\"copyLinkDataFunction\", b, a));\n      }\n    },\n    nodeIsGroupProperty: {\n      get: function () {\n        return this.Ol;\n      },\n      set: function (a) {\n        var b = this.Ol;\n        b !== a && (this.Ol = a, this.g(\"nodeIsGroupProperty\", b, a));\n      }\n    },\n    nodeGroupKeyProperty: {\n      get: function () {\n        return this.ve;\n      },\n      set: function (a) {\n        var b = this.ve;\n        b !== a && (this.ve = a, this.g(\"nodeGroupKeyProperty\", b, a));\n      }\n    },\n    nk: {\n      get: function () {\n        return this.Dn;\n      },\n      set: function (a) {\n        this.Dn !== a && (this.Dn = a);\n      }\n    },\n    linkCategoryProperty: {\n      get: function () {\n        return this.Qj;\n      },\n      set: function (a) {\n        var b = this.Qj;\n        b !== a && (this.Qj = a, this.g(\"linkCategoryProperty\", b, a));\n      }\n    },\n    type: {\n      get: function () {\n        return \"GraphLinksModel\";\n      }\n    }\n  });\n  or.prototype.setCategoryForLinkData = or.prototype.dr;\n  or.prototype.getCategoryForLinkData = or.prototype.Mt;\n  or.prototype.assignAllDataProperties = or.prototype.tq;\n  or.prototype.setGroupKeyForNodeData = or.prototype.er;\n  or.prototype.getGroupKeyForNodeData = or.prototype.Lh;\n  or.prototype.isGroupForNodeData = or.prototype.ew;\n  or.prototype.copyLinkData = or.prototype.yq;\n  or.prototype.mergeLinkDataArray = or.prototype.FA;\n  or.prototype.removeLinkDataCollection = or.prototype.OA;\n  or.prototype.removeLinkData = or.prototype.Lm;\n  or.prototype.addLinkDataCollection = or.prototype.kz;\n  or.prototype.addLinkData = or.prototype.bj;\n  or.prototype.containsLinkData = or.prototype.wc;\n  or.prototype.makeLinkDataKeyUnique = or.prototype.Rq;\n  or.prototype.findLinkDataForKey = or.prototype.Dg;\n  or.prototype.setKeyForLinkData = or.prototype.iu;\n  or.prototype.getKeyForLinkData = or.prototype.Vb;\n  or.prototype.removeLabelKeyForLinkData = or.prototype.Ly;\n  or.prototype.addLabelKeyForLinkData = or.prototype.Dv;\n  or.prototype.setLabelKeysForLinkData = or.prototype.ju;\n  or.prototype.getLabelKeysForLinkData = or.prototype.Bf;\n  or.prototype.setToPortIdForLinkData = or.prototype.Gw;\n  or.prototype.getToPortIdForLinkData = or.prototype.yy;\n  or.prototype.setFromPortIdForLinkData = or.prototype.Bw;\n  or.prototype.getFromPortIdForLinkData = or.prototype.vy;\n  or.prototype.setToKeyForLinkData = or.prototype.Fw;\n  or.prototype.getToKeyForLinkData = or.prototype.xy;\n  or.prototype.setFromKeyForLinkData = or.prototype.Aw;\n  or.prototype.getFromKeyForLinkData = or.prototype.uy;\n  or.prototype.clear = or.prototype.clear;\n  var rr = Object.freeze([]);\n  or.className = \"GraphLinksModel\";\n  mr.GraphLinksModel = or;\n  Z.constructGraphLinksModel = Z.constructGraphLinksModel = function () {\n    return new or();\n  };\n  Z.initDiagramModel = wi = function () {\n    return new or();\n  };\n  function tr(a) {\n    Z.call(this);\n    this.we = \"parent\";\n    this.Fn = !1;\n    this.Xj = \"parentLinkCategory\";\n    void 0 !== a && (this.nodeDataArray = a);\n  }\n  la(tr, Z);\n  tr.constructGraphLinksModel = Z.constructGraphLinksModel;\n  tr.prototype.cloneProtected = function (a) {\n    Z.prototype.cloneProtected.call(this, a);\n    a.we = this.we;\n    a.Fn = this.Fn;\n    a.Xj = this.Xj;\n  };\n  t = tr.prototype;\n  t.toString = function (a) {\n    void 0 === a && (a = 0);\n    if (2 <= a) return this.hr();\n    var b = (\"\" !== this.name ? this.name : \"\") + \" TreeModel\";\n    if (0 < a) {\n      b += \"\\n node data:\";\n      a = this.nodeDataArray;\n      for (var c = a.length, d = 0; d < c; d++) {\n        var e = a[d];\n        b += \" \" + this.ja(e) + \":\" + Ja(e);\n      }\n    }\n    return b;\n  };\n  t.Nk = function () {\n    var a = Z.prototype.Nk.call(this),\n      b = \"\";\n    \"parent\" !== this.nodeParentKeyProperty && \"string\" === typeof this.nodeParentKeyProperty && (b += ',\\n  \"nodeParentKeyProperty\": ' + this.quote(this.nodeParentKeyProperty));\n    return a + b;\n  };\n  t.Yq = function (a) {\n    Z.prototype.Yq.call(this, a);\n    a.nodeParentKeyProperty && (this.nodeParentKeyProperty = a.nodeParentKeyProperty);\n  };\n  t.mr = function (a) {\n    cr(this, a, \"nodeParentKeyProperty\");\n    return Z.prototype.mr.call(this, a);\n  };\n  t.Xq = function (a) {\n    void 0 !== a.nodeParentKeyProperty && a.nodeParentKeyProperty !== this.nodeParentKeyProperty && B(\"applyIncrementalJson cannot change Model properties\");\n    Z.prototype.Xq.call(this, a);\n  };\n  t.Cm = function (a) {\n    return a;\n  };\n  t.Mh = function (a) {\n    if (null !== a) {\n      var b = this.we;\n      if (\"\" !== b && (b = qn(a, b), void 0 !== b)) {\n        if (Kq(b)) return b;\n        B(\"ParentKey value for node data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n  t.be = function (a, b) {\n    null === b && (b = void 0);\n    if (null !== a) {\n      var c = this.we;\n      if (\"\" !== c) if (b = this.Cm(b), this.Za(a)) {\n        var d = qn(a, c);\n        d !== b && (Oq(this, d, a), Sj(a, c, b), null === this.Kb(b) && Pq(this, b, a), ir(this, \"nodeParentKey\", ve, c, a, d, b), \"string\" === typeof c && this.Ca(a, c));\n      } else Sj(a, c, b);\n    }\n  };\n  t.Ot = function (a) {\n    if (null === a) return \"\";\n    var b = this.Xj;\n    if (\"\" === b) return \"\";\n    b = qn(a, b);\n    if (void 0 === b) return \"\";\n    if (\"string\" === typeof b) return b;\n    B(\"getParentLinkCategoryForNodeData found a non-string category for \" + a + \": \" + b);\n    return \"\";\n  };\n  tr.prototype.getLinkCategoryForData = function (a) {\n    return this.Ot(a);\n  };\n  tr.prototype.ku = function (a, b) {\n    if (null !== a) {\n      var c = this.Xj;\n      if (\"\" !== c) if (this.Za(a)) {\n        var d = qn(a, c);\n        void 0 === d && (d = \"\");\n        d !== b && (Sj(a, c, b), ir(this, \"parentLinkCategory\", ve, c, a, d, b), \"string\" === typeof c && this.Ca(a, c));\n      } else Sj(a, c, b);\n    }\n  };\n  tr.prototype.setLinkCategoryForData = function (a, b) {\n    this.ku(a, b);\n  };\n  tr.prototype.copyNodeData = function (a) {\n    if (null === a) return null;\n    a = Z.prototype.copyNodeData.call(this, a);\n    this.pk || \"\" === this.we || void 0 === qn(a, this.we) || Sj(a, this.we, void 0);\n    return a;\n  };\n  tr.prototype.setDataProperty = function (a, b, c) {\n    if (this.Za(a)) {\n      if (b === this.nodeKeyProperty) {\n        this.Um(a, c);\n        return;\n      }\n      if (b === this.nodeCategoryProperty) {\n        this.Tm(a, c);\n        return;\n      }\n      if (b === this.nodeParentKeyProperty) {\n        this.be(a, c);\n        return;\n      }\n    }\n    var d = qn(a, b);\n    d !== c && (Sj(a, b, c), this.du(a, b, d, c));\n  };\n  t = tr.prototype;\n  t.br = function (a, b) {\n    Z.prototype.br.call(this, a, b);\n    for (var c = this.Va.iterator; c.next();) this.uw(c.value, a, b);\n  };\n  t.uw = function (a, b, c) {\n    if (this.Mh(a) === b) {\n      var d = this.we;\n      Sj(a, d, c);\n      ir(this, \"nodeParentKey\", ve, d, a, b, c);\n      \"string\" === typeof d && this.Ca(a, d);\n    }\n  };\n  t.Pm = function (a) {\n    Z.prototype.Pm.call(this, a);\n    a = this.ja(a);\n    var b = Nq(this, a);\n    if (null !== b) {\n      var c = Ea();\n      for (b = b.iterator; b.next();) {\n        var d = b.value;\n        if (this.Za(d) && this.Mh(d) === a) {\n          var e = this.we;\n          ir(this, \"nodeParentKey\", ve, e, d, a, a);\n          \"string\" === typeof e && this.Ca(d, e);\n          c.push(d);\n        }\n      }\n      for (b = 0; b < c.length; b++) Oq(this, a, c[b]);\n      Ha(c);\n    }\n  };\n  t.Om = function (a) {\n    Z.prototype.Om.call(this, a);\n    var b = this.Mh(a);\n    b = this.Cm(b);\n    null === this.Kb(b) && Pq(this, b, a);\n  };\n  t.jr = function (a) {\n    Z.prototype.jr.call(this, a);\n    var b = this.Mh(a);\n    Oq(this, b, a);\n  };\n  t.Vm = function (a, b) {\n    Z.prototype.Vm.call(this, a, b);\n    this.ku(b, this.Ot(a));\n    this.be(b, this.Mh(a));\n  };\n  t.Am = function () {\n    return !0;\n  };\n  t.Ut = function () {\n    return !0;\n  };\n  ma.Object.defineProperties(tr.prototype, {\n    nodeParentKeyProperty: {\n      get: function () {\n        return this.we;\n      },\n      set: function (a) {\n        var b = this.we;\n        b !== a && (this.we = a, this.g(\"nodeParentKeyProperty\", b, a));\n      }\n    },\n    pk: {\n      get: function () {\n        return this.Fn;\n      },\n      set: function (a) {\n        this.Fn !== a && (this.Fn = a);\n      }\n    },\n    parentLinkCategoryProperty: {\n      get: function () {\n        return this.Xj;\n      },\n      set: function (a) {\n        var b = this.Xj;\n        b !== a && (this.Xj = a, this.g(\"parentLinkCategoryProperty\", b, a));\n      }\n    },\n    linkCategoryProperty: {\n      get: function () {\n        return this.parentLinkCategoryProperty;\n      },\n      set: function (a) {\n        this.parentLinkCategoryProperty = a;\n      }\n    },\n    type: {\n      get: function () {\n        return \"TreeModel\";\n      }\n    }\n  });\n  tr.prototype.setParentLinkCategoryForNodeData = tr.prototype.ku;\n  tr.prototype.getParentLinkCategoryForNodeData = tr.prototype.Ot;\n  tr.prototype.setParentKeyForNodeData = tr.prototype.be;\n  tr.prototype.getParentKeyForNodeData = tr.prototype.Mh;\n  tr.className = \"TreeModel\";\n  mr.TreeModel = tr;\n  function ur() {\n    yi.call(this);\n    this.tx = this.Tn = this.$b = 0;\n    this.Wr = 360;\n    this.sx = vr;\n    this.Fj = 0;\n    this.kx = new J();\n    this.Ir = this.Wd = 0;\n    this.ut = new wr();\n    this.Au = this.Wj = 0;\n    this.cz = 600;\n    this.wp = NaN;\n    this.on = 1;\n    this.$p = 0;\n    this.gm = 360;\n    this.Eb = vr;\n    this.J = xr;\n    this.Yc = yr;\n    this.Tc = lq;\n    this.kf = 6;\n    this.fp = zr;\n  }\n  la(ur, yi);\n  ur.prototype.cloneProtected = function (a) {\n    yi.prototype.cloneProtected.call(this, a);\n    a.wp = this.wp;\n    a.on = this.on;\n    a.$p = this.$p;\n    a.gm = this.gm;\n    a.Eb = this.Eb;\n    a.J = this.J;\n    a.Yc = this.Yc;\n    a.Tc = this.Tc;\n    a.kf = this.kf;\n    a.fp = this.fp;\n  };\n  ur.prototype.hb = function (a) {\n    if (a.classType === ur) {\n      if (a === Ar || a === Br || a === Cr || a === Dr || a === yr) this.sorting = a;else if (a === Er || a === Fr || a === xr || a === Gr) this.direction = a;else if (a === Hr || a === Ir || a === vr || a === Jr) this.arrangement = a;else {\n        if (a === Kr || a === zr) this.nodeDiameterFormula = a;\n      }\n    } else yi.prototype.hb.call(this, a);\n  };\n  ur.prototype.createNetwork = function () {\n    return new Lr(this);\n  };\n  ur.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    a = this.network.vertexes;\n    if (1 >= a.count) 1 === a.count && (a = a.first(), a.centerX = 0, a.centerY = 0);else {\n      var b = new E();\n      b.addAll(a.iterator);\n      a = new E();\n      var c = new E();\n      var d = this.sort(b);\n      var e,\n        f,\n        g = this.Ir;\n      var h = this.arrangement;\n      var k = this.nodeDiameterFormula;\n      var l = this.radius;\n      if (!isFinite(l) || 0 >= l) l = NaN;\n      var m = this.aspectRatio;\n      if (!isFinite(m) || 0 >= m) m = 1;\n      var n = this.startAngle;\n      isFinite(n) || (n = 0);\n      var p = this.sweepAngle;\n      if (!isFinite(p) || 360 < p || 1 > p) p = 360;\n      b = this.spacing;\n      isFinite(b) || (b = NaN);\n      h === Jr && k === Kr ? h = vr : h === Jr && k !== Kr && (h = this.arrangement);\n      if ((this.direction === Er || this.direction === Fr) && this.sorting !== yr) {\n        for (k = 0; !(k >= d.length); k += 2) {\n          a.add(d.L(k));\n          if (k + 1 >= d.length) break;\n          c.add(d.L(k + 1));\n        }\n        this.direction === Er ? (this.arrangement === Jr && a.reverse(), d = new E(), d.addAll(a), d.addAll(c)) : (this.arrangement === Jr && c.reverse(), d = new E(), d.addAll(c), d.addAll(a));\n      }\n      k = d.length;\n      for (var r = f = e = 0; r < d.length; r++) {\n        var q = n + p * f * (this.direction === xr ? 1 : -1) / k,\n          u = d.L(r).diameter;\n        isNaN(u) && (u = Mr(d.L(r), q));\n        360 > p && (0 === r || r === d.length - 1) && (u /= 2);\n        e += u;\n        f++;\n      }\n      if (isNaN(l) || h === Jr) {\n        isNaN(b) && (b = 6);\n        if (h !== vr && h !== Jr) {\n          f = -Infinity;\n          for (g = 0; g < k; g++) r = d.L(g), e = d.L(g === k - 1 ? 0 : g + 1), isNaN(r.diameter) && Mr(r, 0), isNaN(e.diameter) && Mr(e, 0), f = Math.max(f, (r.diameter + e.diameter) / 2);\n          g = f + b;\n          h === Hr ? l = (f + b) / (2 * Math.PI / k) : l = Nr(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180);\n        } else l = Nr(this, e + (360 <= p ? k : k - 1) * (h !== Jr ? b : 1.6 * b), m, n * Math.PI / 180, p * Math.PI / 180);\n        f = l * m;\n      } else if (f = l * m, r = Or(this, l, f, n * Math.PI / 180, p * Math.PI / 180), isNaN(b)) {\n        if (h === vr || h === Jr) b = (r - e) / (360 <= p ? k : k - 1);\n      } else if (h === vr || h === Jr) r = (r - e) / (360 <= p ? k : k - 1), r < b ? (l = Nr(this, e + b * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180), f = l * m) : b = r;else {\n        g = -Infinity;\n        for (e = 0; e < k; e++) q = d.L(e), u = d.L(e === k - 1 ? 0 : e + 1), isNaN(q.diameter) && Mr(q, 0), isNaN(u.diameter) && Mr(u, 0), g = Math.max(g, (q.diameter + u.diameter) / 2);\n        g += b;\n        e = Nr(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180);\n        e > l ? (l = e, f = l * m) : g = r / (360 <= p ? k : k - 1);\n      }\n      this.sx = h;\n      this.$b = l;\n      this.Tn = m;\n      this.tx = n;\n      this.Wr = p;\n      this.Fj = b;\n      this.Wd = f;\n      this.Ir = g;\n      b = d;\n      d = this.sx;\n      h = this.$b;\n      l = this.tx;\n      m = this.Wr;\n      n = this.Fj;\n      p = this.Wd;\n      k = this.Ir;\n      if (this.direction !== Er && this.direction !== Fr || d !== Jr) {\n        if (this.direction === Er || this.direction === Fr) {\n          g = 0;\n          switch (d) {\n            case Ir:\n              g = 180 * Pr(this, h, p, l, k) / Math.PI;\n              break;\n            case vr:\n              k = b = 0;\n              g = a.first();\n              null !== g && (b = Mr(g, Math.PI / 2));\n              g = c.first();\n              null !== g && (k = Mr(g, Math.PI / 2));\n              g = 180 * Pr(this, h, p, l, n + (b + k) / 2) / Math.PI;\n              break;\n            case Hr:\n              g = m / b.length;\n          }\n          if (this.direction === Er) {\n            switch (d) {\n              case Ir:\n                Qr(this, a, l, Gr);\n                break;\n              case vr:\n                Rr(this, a, l, Gr);\n                break;\n              case Hr:\n                Sr(this, a, m / 2, l, Gr);\n            }\n            switch (d) {\n              case Ir:\n                Qr(this, c, l + g, xr);\n                break;\n              case vr:\n                Rr(this, c, l + g, xr);\n                break;\n              case Hr:\n                Sr(this, c, m / 2, l + g, xr);\n            }\n          } else {\n            switch (d) {\n              case Ir:\n                Qr(this, c, l, Gr);\n                break;\n              case vr:\n                Rr(this, c, l, Gr);\n                break;\n              case Hr:\n                Sr(this, c, m / 2, l, Gr);\n            }\n            switch (d) {\n              case Ir:\n                Qr(this, a, l + g, xr);\n                break;\n              case vr:\n                Rr(this, a, l + g, xr);\n                break;\n              case Hr:\n                Sr(this, a, m / 2, l + g, xr);\n            }\n          }\n        } else switch (d) {\n          case Ir:\n            Qr(this, b, l, this.direction);\n            break;\n          case vr:\n            Rr(this, b, l, this.direction);\n            break;\n          case Hr:\n            Sr(this, b, m, l, this.direction);\n            break;\n          case Jr:\n            Tr(this, b, m, l, this.direction);\n        }\n      } else Tr(this, b, m, l - m / 2, xr);\n    }\n    this.updateParts();\n    this.network = null;\n    this.isValidLayout = !0;\n  };\n  function Sr(a, b, c, d, e) {\n    var f = a.Wr,\n      g = a.$b;\n    a = a.Wd;\n    d = d * Math.PI / 180;\n    c = c * Math.PI / 180;\n    for (var h = b.length, k = 0; k < h; k++) {\n      var l = d + (e === xr ? k * c / (360 <= f ? h : h - 1) : -(k * c) / h),\n        m = b.L(k),\n        n = g * Math.tan(l) / a;\n      n = Math.sqrt((g * g + a * a * n * n) / (1 + n * n));\n      m.centerX = n * Math.cos(l);\n      m.centerY = n * Math.sin(l);\n      m.actualAngle = 180 * l / Math.PI;\n    }\n  }\n  function Rr(a, b, c, d) {\n    var e = a.$b,\n      f = a.Wd,\n      g = a.Fj;\n    c = c * Math.PI / 180;\n    for (var h = b.length, k = 0; k < h; k++) {\n      var l = b.L(k),\n        m = b.L(k === h - 1 ? 0 : k + 1),\n        n = f * Math.sin(c);\n      l.centerX = e * Math.cos(c);\n      l.centerY = n;\n      l.actualAngle = 180 * c / Math.PI;\n      isNaN(l.diameter) && Mr(l, 0);\n      isNaN(m.diameter) && Mr(m, 0);\n      l = Pr(a, e, f, d === xr ? c : -c, (l.diameter + m.diameter) / 2 + g);\n      c += d === xr ? l : -l;\n    }\n  }\n  function Qr(a, b, c, d) {\n    var e = a.$b,\n      f = a.Wd,\n      g = a.Ir;\n    c = c * Math.PI / 180;\n    for (var h = b.length, k = 0; k < h; k++) {\n      var l = b.L(k);\n      l.centerX = e * Math.cos(c);\n      l.centerY = f * Math.sin(c);\n      l.actualAngle = 180 * c / Math.PI;\n      l = Pr(a, e, f, d === xr ? c : -c, g);\n      c += d === xr ? l : -l;\n    }\n  }\n  function Tr(a, b, c, d, e) {\n    var f = a.Wr;\n    a.Wj = 0;\n    a.ut = new wr();\n    if (360 > c) {\n      for (f = d + (e === xr ? f : -f); 0 > f;) f += 360;\n      f %= 360;\n      180 < f && (f -= 360);\n      f *= Math.PI / 180;\n      a.Au = f;\n      Ur(a, b, c, d, e);\n    } else Vr(a, b, c, d, e);\n    a.ut.commit(b);\n  }\n  function Vr(a, b, c, d, e) {\n    var f = a.$b,\n      g = a.Fj,\n      h = a.Tn,\n      k = f * Math.cos(d * Math.PI / 180),\n      l = a.Wd * Math.sin(d * Math.PI / 180),\n      m = b.ma();\n    if (3 === m.length) m[0].centerX = f, m[0].centerY = 0, m[1].centerX = m[0].centerX - m[0].width / 2 - m[1].width / 2 - g, m[1].y = m[0].y, m[2].centerX = (m[0].centerX + m[1].centerX) / 2, m[2].y = m[0].y - m[2].height - g;else if (4 === m.length) m[0].centerX = f, m[0].centerY = 0, m[2].centerX = -m[0].centerX, m[2].centerY = m[0].centerY, m[1].centerX = 0, m[1].y = Math.min(m[0].y, m[2].y) - m[1].height - g, m[3].centerX = 0, m[3].y = Math.max(m[0].y + m[0].height + g, m[2].y + m[2].height + g);else {\n      f = J.alloc();\n      for (var n = 0; n < m.length; n++) {\n        m[n].centerX = k;\n        m[n].centerY = l;\n        if (n >= m.length - 1) break;\n        Wr(a, k, l, m, n, e, f) || Xr(a, k, l, m, n, e, f);\n        k = f.x;\n        l = f.y;\n      }\n      J.free(f);\n      a.Wj++;\n      if (!(23 < a.Wj)) {\n        k = m[0].centerX;\n        l = m[0].centerY;\n        f = m[m.length - 1].centerX;\n        n = m[m.length - 1].centerY;\n        var p = Math.abs(k - f) - ((m[0].width + m[m.length - 1].width) / 2 + g),\n          r = Math.abs(l - n) - ((m[0].height + m[m.length - 1].height) / 2 + g);\n        g = 0;\n        1 > Math.abs(r) ? Math.abs(k - f) < (m[0].width + m[m.length - 1].width) / 2 && (g = 0) : g = 0 < r ? r : 1 > Math.abs(p) ? 0 : p;\n        k = Math.abs(f) > Math.abs(n) ? 0 < f !== l > n : 0 < n !== k < f;\n        if (k = e === xr ? k : !k) g = -Math.abs(g), g = Math.min(g, -m[m.length - 1].width), g = Math.min(g, -m[m.length - 1].height);\n        a.ut.compare(g, m);\n        1 < Math.abs(g) && (a.$b = 8 > a.Wj ? a.$b - g / (2 * Math.PI) : 5 > m.length && 10 < g ? a.$b / 2 : a.$b - (0 < g ? 1.7 : -2.3), a.Wd = a.$b * h, Vr(a, b, c, d, e));\n      }\n    }\n  }\n  function Ur(a, b, c, d, e) {\n    for (var f = a.$b, g = a.Wd, h = a.Tn, k = f * Math.cos(d * Math.PI / 180), l = g * Math.sin(d * Math.PI / 180), m = J.alloc(), n = b.ma(), p = 0; p < n.length; p++) {\n      n[p].centerX = k;\n      n[p].centerY = l;\n      if (p >= n.length - 1) break;\n      Wr(a, k, l, n, p, e, m) || Xr(a, k, l, n, p, e, m);\n      k = m.x;\n      l = m.y;\n    }\n    J.free(m);\n    a.Wj++;\n    if (!(23 < a.Wj)) {\n      k = Math.atan2(l, k);\n      k = e === xr ? a.Au - k : k - a.Au;\n      k = Math.abs(k) < Math.abs(k - 2 * Math.PI) ? k : k - 2 * Math.PI;\n      f = k * (f + g) / 2;\n      g = a.ut;\n      if (Math.abs(f) < Math.abs(g.vm)) for (g.vm = f, g.Ok = [], g.an = [], k = 0; k < n.length; k++) g.Ok[k] = n[k].bounds.x, g.an[k] = n[k].bounds.y;\n      1 < Math.abs(f) && (a.$b = 8 > a.Wj ? a.$b - f / (2 * Math.PI) : a.$b - (0 < f ? 1.7 : -2.3), a.Wd = a.$b * h, Ur(a, b, c, d, e));\n    }\n  }\n  function Wr(a, b, c, d, e, f, g) {\n    var h = a.$b,\n      k = a.Wd,\n      l = 0;\n    a = (d[e].width + d[e + 1].width) / 2 + a.Fj;\n    var m = !1;\n    if (0 <= c !== (f === xr)) {\n      if (f = b + a, f > h) {\n        f = b - a;\n        if (f < -h) return g.x = f, g.y = l, !1;\n        m = !0;\n      }\n    } else if (f = b - a, f < -h) {\n      f = b + a;\n      if (f > h) return g.x = f, g.y = l, !1;\n      m = !0;\n    }\n    l = Math.sqrt(1 - Math.min(1, f * f / (h * h))) * k;\n    0 > c !== m && (l = -l);\n    if (Math.abs(c - l) > (d[e].height + d[e + 1].height) / 2) return g.x = f, g.y = l, !1;\n    g.x = f;\n    g.y = l;\n    return !0;\n  }\n  function Xr(a, b, c, d, e, f, g) {\n    var h = a.$b,\n      k = a.Wd,\n      l = 0;\n    a = (d[e].height + d[e + 1].height) / 2 + a.Fj;\n    d = !1;\n    if (0 <= b !== (f === xr)) {\n      if (f = c - a, f < -k) {\n        f = c + a;\n        if (f > k) {\n          g.x = l;\n          g.y = f;\n          return;\n        }\n        d = !0;\n      }\n    } else if (f = c + a, f > k) {\n      f = c - a;\n      if (f < -k) {\n        g.x = l;\n        g.y = f;\n        return;\n      }\n      d = !0;\n    }\n    l = Math.sqrt(1 - Math.min(1, f * f / (k * k))) * h;\n    0 > b !== d && (l = -l);\n    g.x = l;\n    g.y = f;\n  }\n  ur.prototype.commitLayout = function () {\n    this.commitNodes();\n    this.isRouting && this.commitLinks();\n  };\n  ur.prototype.commitNodes = function () {\n    var a = null !== this.group && null !== this.group.placeholder && this.group.isSubGraphExpanded,\n      b = a ? this.group.location.copy() : null,\n      c = this.actualCenter;\n    a ? c = new J(0, 0) : (c.x = this.arrangementOrigin.x + this.$b, c.y = this.arrangementOrigin.y + this.Wd);\n    for (var d = this.network.vertexes.iterator; d.next();) {\n      var e = d.value;\n      e.x += c.x;\n      e.y += c.y;\n      e.commit();\n    }\n    a && (this.group.Ta(), a = this.group.position.copy(), c = this.group.location.copy(), b = b.ce(c.ce(a)), this.group.move(b), this.kx = b.ce(a));\n  };\n  ur.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator; a.next();) a.value.commit();\n  };\n  function Or(a, b, c, d, e) {\n    var f = a.cz;\n    if (.001 > Math.abs(a.Tn - 1)) return void 0 !== d && void 0 !== e ? e * b : 2 * Math.PI * b;\n    a = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c;\n    var g = 0;\n    var h = void 0 !== d && void 0 !== e ? e / (f + 1) : Math.PI / (2 * (f + 1));\n    for (var k = 0, l = 0; l <= f; l++) {\n      void 0 !== d && void 0 !== e ? k = d + l * e / f : k = l * Math.PI / (2 * f);\n      var m = Math.sin(k);\n      g += Math.sqrt(1 - a * a * m * m) * h;\n    }\n    return void 0 !== d && void 0 !== e ? (b > c ? b : c) * g : 4 * (b > c ? b : c) * g;\n  }\n  function Nr(a, b, c, d, e) {\n    return b / (void 0 !== d && void 0 !== e ? Or(a, 1, c, d, e) : Or(a, 1, c));\n  }\n  function Pr(a, b, c, d, e) {\n    if (.001 > Math.abs(a.Tn - 1)) return e / b;\n    var f = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c,\n      g = 0;\n    a = 2 * Math.PI / (700 * a.network.vertexes.count);\n    b > c && (d += Math.PI / 2);\n    for (var h = 0;; h++) {\n      var k = Math.sin(d + h * a);\n      g += (b > c ? b : c) * Math.sqrt(1 - f * f * k * k) * a;\n      if (g >= e) return h * a;\n    }\n  }\n  ur.prototype.sort = function (a) {\n    switch (this.sorting) {\n      case Cr:\n        break;\n      case Dr:\n        a.reverse();\n        break;\n      case Ar:\n        a.sort(this.comparer);\n        break;\n      case Br:\n        a.sort(this.comparer);\n        a.reverse();\n        break;\n      case yr:\n        for (var b = [], c = 0; c < a.length; c++) b.push(0);\n        c = new E();\n        for (var d = 0; d < a.length; d++) {\n          var e = -1,\n            f = -1;\n          if (0 === d) for (var g = 0; g < a.length; g++) {\n            var h = a.L(g).edgesCount;\n            h > e && (e = h, f = g);\n          } else for (g = 0; g < a.length; g++) h = b[g], h > e && (e = h, f = g);\n          c.add(a.L(f));\n          b[f] = -1;\n          f = a.L(f);\n          for (g = f.sourceEdges; g.next();) e = a.indexOf(g.value.fromVertex), 0 > e || 0 <= b[e] && b[e]++;\n          for (f = f.destinationEdges; f.next();) e = a.indexOf(f.value.toVertex), 0 > e || 0 <= b[e] && b[e]++;\n        }\n        a = [];\n        for (b = 0; b < c.length; b++) {\n          e = c.L(b);\n          a[b] = [];\n          for (f = e.destinationEdges; f.next();) d = c.indexOf(f.value.toVertex), d !== b && 0 > a[b].indexOf(d) && a[b].push(d);\n          for (e = e.sourceEdges; e.next();) d = c.indexOf(e.value.fromVertex), d !== b && 0 > a[b].indexOf(d) && a[b].push(d);\n        }\n        f = [];\n        for (b = 0; b < a.length; b++) f[b] = 0;\n        b = [];\n        g = [];\n        h = [];\n        e = [];\n        d = new E();\n        for (var k = 0, l = 0; l < a.length; l++) {\n          var m = a[l].length;\n          if (1 === m) e.push(l);else if (0 === m) d.add(c.L(l));else {\n            if (0 === k) b.push(l);else {\n              for (var n = m = Infinity, p = -1, r = [], q = 0; q < b.length; q++) 0 > a[b[q]].indexOf(b[q === b.length - 1 ? 0 : q + 1]) && r.push(q === b.length - 1 ? 0 : q + 1);\n              if (0 === r.length) for (q = 0; q < b.length; q++) r.push(q);\n              for (q = 0; q < r.length; q++) {\n                for (var u = r[q], v = a[l], w = 0, y = 0; y < g.length; y++) {\n                  var z = f[g[y]],\n                    A = f[h[y]];\n                  if (z < A) {\n                    var C = z;\n                    z = A;\n                  } else C = A;\n                  if (C < u && u <= z) for (A = 0; A < v.length; A++) {\n                    var G = v[A];\n                    0 > b.indexOf(G) || C < f[G] && f[G] < z || C === f[G] || z === f[G] || w++;\n                  } else for (A = 0; A < v.length; A++) G = v[A], 0 > b.indexOf(G) || C < f[G] && f[G] < z && C !== f[G] && z !== f[G] && w++;\n                }\n                v = w;\n                for (y = w = 0; y < a[l].length; y++) C = b.indexOf(a[l][y]), 0 <= C && (C = Math.abs(u - (C >= u ? C + 1 : C)), w += C < b.length + 1 - C ? C : b.length + 1 - C);\n                for (y = 0; y < g.length; y++) C = f[g[y]], z = f[h[y]], C >= u && C++, z >= u && z++, C > z && (A = z, z = C, C = A), z - C < (b.length + 2) / 2 === (C < u && u <= z) && w++;\n                if (v < m || v === m && w < n) m = v, n = w, p = u;\n              }\n              b.splice(p, 0, l);\n              for (m = 0; m < b.length; m++) f[b[m]] = m;\n              for (m = 0; m < a[l].length; m++) n = a[l][m], 0 <= b.indexOf(n) && (g.push(l), h.push(n));\n            }\n            k++;\n          }\n        }\n        for (g = b.length;;) {\n          f = !0;\n          for (h = 0; h < e.length; h++) if (k = e[h], l = a[k][0], m = b.indexOf(l), 0 <= m) {\n            for (p = n = 0; p < a[l].length; p++) r = b.indexOf(a[l][p]), 0 > r || r === m || (q = r > m ? r - m : m - r, n += r < m !== q > g - q ? 1 : -1);\n            b.splice(0 > n ? m : m + 1, 0, k);\n            e.splice(h, 1);\n            h--;\n          } else f = !1;\n          if (f) break;else b.push(e[0]), e.splice(0, 1);\n        }\n        for (a = 0; a < b.length; a++) d.add(c.L(b[a]));\n        return d;\n      default:\n        B(\"Invalid sorting type.\");\n    }\n    return a;\n  };\n  ma.Object.defineProperties(ur.prototype, {\n    radius: {\n      get: function () {\n        return this.wp;\n      },\n      set: function (a) {\n        this.wp !== a && (0 < a || isNaN(a)) && (this.wp = a, this.C());\n      }\n    },\n    aspectRatio: {\n      get: function () {\n        return this.on;\n      },\n      set: function (a) {\n        this.on !== a && 0 < a && (this.on = a, this.C());\n      }\n    },\n    startAngle: {\n      get: function () {\n        return this.$p;\n      },\n      set: function (a) {\n        this.$p !== a && (this.$p = a, this.C());\n      }\n    },\n    sweepAngle: {\n      get: function () {\n        return this.gm;\n      },\n      set: function (a) {\n        this.gm !== a && (0 < a && 360 >= a ? this.gm = a : this.gm = 360, this.C());\n      }\n    },\n    arrangement: {\n      get: function () {\n        return this.Eb;\n      },\n      set: function (a) {\n        this.Eb === a || a !== Jr && a !== vr && a !== Ir && a !== Hr || (this.Eb = a, this.C());\n      }\n    },\n    direction: {\n      get: function () {\n        return this.J;\n      },\n      set: function (a) {\n        this.J === a || a !== xr && a !== Gr && a !== Er && a !== Fr || (this.J = a, this.C());\n      }\n    },\n    sorting: {\n      get: function () {\n        return this.Yc;\n      },\n      set: function (a) {\n        this.Yc === a || a !== Cr && a !== Dr && a !== Ar && !Br && a !== yr || (this.Yc = a, this.C());\n      }\n    },\n    comparer: {\n      get: function () {\n        return this.Tc;\n      },\n      set: function (a) {\n        this.Tc !== a && (this.Tc = a, this.C());\n      }\n    },\n    spacing: {\n      get: function () {\n        return this.kf;\n      },\n      set: function (a) {\n        this.kf !== a && (this.kf = a, this.C());\n      }\n    },\n    nodeDiameterFormula: {\n      get: function () {\n        return this.fp;\n      },\n      set: function (a) {\n        this.fp === a || a !== zr && a !== Kr || (this.fp = a, this.C());\n      }\n    },\n    actualXRadius: {\n      get: function () {\n        return this.$b;\n      }\n    },\n    actualYRadius: {\n      get: function () {\n        return this.Wd;\n      }\n    },\n    actualSpacing: {\n      get: function () {\n        return this.Fj;\n      }\n    },\n    actualCenter: {\n      get: function () {\n        return this.kx;\n      }\n    }\n  });\n  var vr = new D(ur, \"ConstantSpacing\", 0),\n    Ir = new D(ur, \"ConstantDistance\", 1),\n    Hr = new D(ur, \"ConstantAngle\", 2),\n    Jr = new D(ur, \"Packed\", 3),\n    xr = new D(ur, \"Clockwise\", 4),\n    Gr = new D(ur, \"Counterclockwise\", 5),\n    Er = new D(ur, \"BidirectionalLeft\", 6),\n    Fr = new D(ur, \"BidirectionalRight\", 7),\n    Cr = new D(ur, \"Forwards\", 8),\n    Dr = new D(ur, \"Reverse\", 9),\n    Ar = new D(ur, \"Ascending\", 10),\n    Br = new D(ur, \"Descending\", 11),\n    yr = new D(ur, \"Optimized\", 12),\n    zr = new D(ur, \"Pythagorean\", 13),\n    Kr = new D(ur, \"Circular\", 14);\n  ur.className = \"CircularLayout\";\n  ur.ConstantSpacing = vr;\n  ur.ConstantDistance = Ir;\n  ur.ConstantAngle = Hr;\n  ur.Packed = Jr;\n  ur.Clockwise = xr;\n  ur.Counterclockwise = Gr;\n  ur.BidirectionalLeft = Er;\n  ur.BidirectionalRight = Fr;\n  ur.Forwards = Cr;\n  ur.Reverse = Dr;\n  ur.Ascending = Ar;\n  ur.Descending = Br;\n  ur.Optimized = yr;\n  ur.Pythagorean = zr;\n  ur.Circular = Kr;\n  function wr() {\n    this.vm = -Infinity;\n    this.an = this.Ok = null;\n  }\n  wr.prototype.compare = function (a, b) {\n    if (0 < a && 0 > this.vm || Math.abs(a) < Math.abs(this.vm) && !(0 > a && 0 < this.vm)) for (this.vm = a, this.Ok = [], this.an = [], a = 0; a < b.length; a++) this.Ok[a] = b[a].bounds.x, this.an[a] = b[a].bounds.y;\n  };\n  wr.prototype.commit = function (a) {\n    if (null !== this.Ok && null !== this.an) for (var b = 0; b < this.Ok.length; b++) {\n      var c = a.L(b);\n      c.x = this.Ok[b];\n      c.y = this.an[b];\n    }\n  };\n  wr.className = \"VertexArrangement\";\n  function Lr(a) {\n    Rp.call(this, a);\n  }\n  la(Lr, Rp);\n  Lr.prototype.createVertex = function () {\n    return new Yr(this);\n  };\n  Lr.prototype.createEdge = function () {\n    return new Zr(this);\n  };\n  Lr.className = \"CircularNetwork\";\n  function Yr(a) {\n    eq.call(this, a);\n    this.I = this.Dj = NaN;\n  }\n  la(Yr, eq);\n  function Mr(a, b) {\n    var c = a.network;\n    if (null === c) return NaN;\n    c = c.layout;\n    if (null === c) return NaN;\n    if (c.arrangement === Jr) {\n      if (c.nodeDiameterFormula === Kr) a.Dj = Math.max(a.width, a.height);else {\n        c = Math.abs(Math.sin(b));\n        b = Math.abs(Math.cos(b));\n        if (0 === c) return a.width;\n        if (0 === b) return a.height;\n        a.Dj = Math.min(a.height / c, a.width / b);\n      }\n    } else a.Dj = c.nodeDiameterFormula === Kr ? Math.max(a.width, a.height) : Math.sqrt(a.width * a.width + a.height * a.height);\n    return a.Dj;\n  }\n  ma.Object.defineProperties(Yr.prototype, {\n    diameter: {\n      get: function () {\n        return this.Dj;\n      },\n      set: function (a) {\n        this.Dj !== a && (this.Dj = a);\n      }\n    },\n    actualAngle: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I !== a && (this.I = a);\n      }\n    }\n  });\n  Yr.className = \"CircularVertex\";\n  function Zr(a) {\n    fq.call(this, a);\n  }\n  la(Zr, fq);\n  Zr.className = \"CircularEdge\";\n  function $r() {\n    yi.call(this);\n    this.Fh = null;\n    this.Ao = 0;\n    this.Hd = new M(100, 100).freeze();\n    this.nn = !1;\n    this.hf = !0;\n    this.ed = !1;\n    this.Ll = 100;\n    this.Wn = 1;\n    this.Xf = 1E3;\n    this.Yo = 10;\n    this.xp = Math;\n    this.hl = .05;\n    this.gl = 50;\n    this.el = 150;\n    this.fl = 0;\n    this.Nn = 10;\n    this.Mn = 5;\n  }\n  la($r, yi);\n  $r.prototype.cloneProtected = function (a) {\n    yi.prototype.cloneProtected.call(this, a);\n    a.Hd.assign(this.Hd);\n    a.nn = this.nn;\n    a.hf = this.hf;\n    a.ed = this.ed;\n    a.Ll = this.Ll;\n    a.Wn = this.Wn;\n    a.Xf = this.Xf;\n    a.Yo = this.Yo;\n    a.xp = this.xp;\n    a.hl = this.hl;\n    a.gl = this.gl;\n    a.el = this.el;\n    a.fl = this.fl;\n    a.Nn = this.Nn;\n    a.Mn = this.Mn;\n  };\n  $r.prototype.serializeLayoutProperties = function (a, b) {\n    yi.prototype.serializeLayoutProperties.call(this, a, b);\n    a.arrangementSpacing = {\n      width: this.arrangementSpacing.width,\n      height: this.arrangementSpacing.height\n    };\n    a.arrangesToOrigin = this.arrangesToOrigin;\n    a.setsPortSpots = this.setsPortSpots;\n    a.comments = this.comments;\n    a.maxIterations = this.maxIterations;\n    a.epsilonDistance = this.epsilonDistance;\n    a.infinityDistance = this.infinityDistance;\n    a.moveLimit = this.moveLimit;\n    a.defaultSpringStiffness = this.defaultSpringStiffness;\n    a.defaultSpringLength = this.defaultSpringLength;\n    a.defaultElectricalCharge = this.defaultElectricalCharge;\n    a.defaultGravitationalMass = this.defaultGravitationalMass;\n    a.defaultCommentSpringLength = this.defaultCommentSpringLength;\n    a.defaultCommentElectricalCharge = this.defaultCommentElectricalCharge;\n  };\n  $r.prototype.deserializeLayoutProperties = function (a, b, c, d) {\n    yi.prototype.deserializeLayoutProperties.call(this, a, b, c, d);\n    this.arrangementSpacing = new M(a.arrangementSpacing.width, a.arrangementSpacing.height);\n    this.arrangesToOrigin = a.arrangesToOrigin;\n    this.setsPortSpots = a.setsPortSpots;\n    this.comments = a.comments;\n    this.maxIterations = a.maxIterations;\n    this.epsilonDistance = a.epsilonDistance;\n    this.infinityDistance = a.infinityDistance;\n    this.moveLimit = a.moveLimit;\n    this.defaultSpringStiffness = a.defaultSpringStiffness;\n    this.defaultSpringLength = a.defaultSpringLength;\n    this.defaultElectricalCharge = a.defaultElectricalCharge;\n    this.defaultGravitationalMass = a.defaultGravitationalMass;\n    this.defaultCommentSpringLength = a.defaultCommentSpringLength;\n    this.defaultCommentElectricalCharge = a.defaultCommentElectricalCharge;\n  };\n  $r.prototype.createNetwork = function () {\n    return new as(this);\n  };\n  $r.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    if (!this.Sw()) {\n      a = this.maxIterations;\n      if (0 < this.network.vertexes.count) {\n        this.network.zq();\n        for (var b = this.network.vertexes.iterator; b.next();) {\n          var c = b.value;\n          c.charge = this.electricalCharge(c);\n          c.mass = this.gravitationalMass(c);\n        }\n        for (b = this.network.edges.iterator; b.next();) c = b.value, c.stiffness = this.springStiffness(c), c.length = this.springLength(c);\n        this.Fv();\n        this.Ao = 0;\n        if (this.needsClusterLayout()) {\n          b = this.network;\n          c = b.Uy();\n          for (var d = c.iterator; d.next();) {\n            this.network = d.value;\n            for (var e = this.network.vertexes.iterator; e.next();) {\n              var f = e.value;\n              f.Dd = f.vertexes.count;\n              f.Sh = 1;\n              f.mk = null;\n              f.Ke = null;\n            }\n            bs(this, 0, a);\n          }\n          this.network = b;\n          var g = d = c.iterator;\n          d = this.arrangementSpacing;\n          var h = g.count,\n            k = !0;\n          f = e = 0;\n          for (var l = Ea(), m = 0; m < h + b.vertexes.count + 2; m++) l[m] = null;\n          h = 0;\n          g.reset();\n          for (var n = N.alloc(); g.next();) if (m = g.value, this.computeBounds(m, n), k) k = !1, e = n.x + n.width / 2, f = n.y + n.height / 2, l[0] = new J(n.x + n.width + d.width, n.y), l[1] = new J(n.x, n.y + n.height + d.height), h = 2;else {\n            var p = cs(l, h, e, f, n.width, n.height, d),\n              r = l[p],\n              q = new J(r.x + n.width + d.width, r.y),\n              u = new J(r.x, r.y + n.height + d.height);\n            p + 1 < h && l.splice(p + 1, 0, null);\n            l[p] = q;\n            l[p + 1] = u;\n            h++;\n            p = r.x - n.x;\n            r = r.y - n.y;\n            for (m = m.vertexes.iterator; m.next();) q = m.value, q.centerX += p, q.centerY += r;\n          }\n          N.free(n);\n          for (m = b.vertexes.iterator; m.next();) g = m.value, p = g.bounds, 2 > h ? (e = p.x + p.width / 2, f = p.y + p.height / 2, l[0] = new J(p.x + p.width + d.width, p.y), l[1] = new J(p.x, p.y + p.height + d.height), h = 2) : (k = cs(l, h, e, f, p.width, p.height, d), n = l[k], r = new J(n.x + p.width + d.width, n.y), p = new J(n.x, n.y + p.height + d.height), k + 1 < h && l.splice(k + 1, 0, null), l[k] = r, l[k + 1] = p, h++, g.centerX = n.x + g.width / 2, g.centerY = n.y + g.height / 2);\n          Ha(l);\n          for (d = c.iterator; d.next();) {\n            c = d.value;\n            for (e = c.vertexes.iterator; e.next();) b.Bg(e.value);\n            for (c = c.edges.iterator; c.next();) b.nm(c.value);\n          }\n        }\n        ds(this, a);\n        this.updateParts();\n      }\n      this.Ll = a;\n      this.network = null;\n      this.isValidLayout = !0;\n    }\n  };\n  $r.prototype.needsClusterLayout = function () {\n    if (3 > this.network.vertexes.count) return !1;\n    for (var a = 0, b = 0, c = this.network.vertexes.first().bounds, d = this.network.vertexes.iterator; d.next();) {\n      if (d.value.bounds.Lc(c) && (a++, 2 < a)) return !0;\n      if (10 < b) break;\n      b++;\n    }\n    return !1;\n  };\n  $r.prototype.computeBounds = function (a, b) {\n    var c = !0;\n    for (a = a.vertexes.iterator; a.next();) {\n      var d = a.value;\n      c ? (c = !1, b.set(d.bounds)) : b.Oc(d.bounds);\n    }\n    return b;\n  };\n  function bs(a, b, c) {\n    if (es(a, b)) {\n      var d = a.Xf;\n      a.Xf *= 1 + 1 / (b + 1);\n      var e = fs(a, b),\n        f = Math.max(0, Math.max(Math.min(a.network.vertexes.count, c * (b + 1) / 11), 10));\n      a.maxIterations += f;\n      bs(a, b + 1, c);\n      ds(a, f);\n      gs(a, e);\n      b = e.vertexes.ma();\n      b.sort(function (a, b) {\n        return null === a || null === b || a === b ? 0 : b.Dd - a.Dd;\n      });\n      for (c = 0; c < b.length; c++) hs(a, b[c]);\n      a.Xf = d;\n    }\n  }\n  function es(a, b) {\n    if (10 < b || 3 > a.network.vertexes.count) return !1;\n    a.Fh = a.network.vertexes.ma();\n    a = a.Fh;\n    a.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : b.Dd - a.Dd;\n    });\n    for (b = a.length - 1; 0 <= b && 1 >= a[b].Dd;) b--;\n    return 1 < a.length - b;\n  }\n  function fs(a, b) {\n    for (var c = a.network, d = new as(a), e = 0; e < a.Fh.length; e++) {\n      var f = a.Fh[e];\n      if (1 < f.Dd) {\n        d.Bg(f);\n        var g = new is();\n        g.pu = f.Dd;\n        g.qu = f.width;\n        g.ou = f.height;\n        g.Yw = f.focus.x;\n        g.Zw = f.focus.y;\n        null === f.Ke && (f.Ke = new E());\n        f.Ke.add(g);\n        f.yw = f.Ke.count - 1;\n      } else break;\n    }\n    for (f = c.edges.iterator; f.next();) {\n      var h = f.value;\n      e = h.fromVertex;\n      g = h.toVertex;\n      e.network === d && g.network === d ? d.nm(h) : e.network === d ? (h = e.mk, null === h && (h = new E(), e.mk = h), h.add(g), e.Dd--, e.Sh += g.Sh) : g.network === d && (h = g.mk, null === h && (h = new E(), g.mk = h), h.add(e), g.Dd--, g.Sh += e.Sh);\n    }\n    for (e = d.edges.iterator; e.next();) f = e.value, f.length *= Math.max(1, K.sqrt((f.fromVertex.Sh + f.toVertex.Sh) / (4 * b + 1)));\n    for (b = d.vertexes.iterator; b.next();) {\n      e = b.value;\n      var k = e.mk;\n      if (null !== k && 0 < k.count && (g = e.Ke.L(e.Ke.count - 1).pu - e.Dd, !(0 >= g))) {\n        for (var l = h = 0, m = k.count - g; m < k.count; m++) {\n          var n = k.L(m),\n            p = null;\n          for (f = n.edges.iterator; f.next();) {\n            var r = f.value;\n            if (r.wy(n) === e) {\n              p = r;\n              break;\n            }\n          }\n          null !== p && (l += p.length, h += n.width * n.height);\n        }\n        f = e.centerX;\n        k = e.centerY;\n        m = e.width;\n        n = e.height;\n        p = e.focus;\n        r = m * n;\n        1 > r && (r = 1);\n        h = K.sqrt((h + r + l * l * 4 / (g * g)) / r);\n        g = (h - 1) * m / 2;\n        h = (h - 1) * n / 2;\n        e.bounds = new N(f - p.x - g, k - p.y - h, m + 2 * g, n + 2 * h);\n        e.focus = new J(p.x + g, p.y + h);\n      }\n    }\n    a.network = d;\n    return c;\n  }\n  function gs(a, b) {\n    for (var c = a.network.vertexes.iterator; c.next();) {\n      var d = c.value;\n      d.network = b;\n      if (null !== d.Ke) {\n        var e = d.Ke.L(d.yw);\n        d.Dd = e.pu;\n        var f = e.Yw,\n          g = e.Zw;\n        d.bounds = new N(d.centerX - f, d.centerY - g, e.qu, e.ou);\n        d.focus = new J(f, g);\n        d.yw--;\n      }\n    }\n    for (c = a.network.edges.iterator; c.next();) c.value.network = b;\n    a.network = b;\n  }\n  function hs(a, b) {\n    var c = b.mk;\n    if (null !== c && 0 !== c.count) {\n      var d = b.centerX,\n        e = b.centerY,\n        f = b.width,\n        g = b.height;\n      null !== b.Ke && 0 < b.Ke.count && (g = b.Ke.L(0), f = g.qu, g = g.ou);\n      f = K.sqrt(f * f + g * g) / 2;\n      for (var h = !1, k = g = 0, l = 0, m = b.vertexes.iterator; m.next();) {\n        var n = m.value;\n        1 >= n.Dd ? k++ : (h = !0, l++, g += Math.atan2(b.centerY - n.centerY, b.centerX - n.centerX));\n      }\n      if (0 !== k) for (0 < l && (g /= l), l = b = 0, b = h ? 2 * Math.PI / (k + 1) : 2 * Math.PI / k, 0 === k % 2 && (l = b / 2), 1 < c.count && c.sort(function (a, b) {\n        return null === a || null === b || a === b ? 0 : b.width * b.height - a.width * a.height;\n      }), h = 0 === k % 2 ? 0 : 1, c = c.iterator; c.next();) if (k = c.value, !(1 < k.Dd || a.isFixed(k))) {\n        m = null;\n        for (n = k.edges.iterator; n.next();) {\n          m = n.value;\n          break;\n        }\n        n = k.width;\n        var p = k.height;\n        n = K.sqrt(n * n + p * p) / 2;\n        m = f + m.length + n;\n        n = g + (b * (h / 2 >> 1) + l) * (0 === h % 2 ? 1 : -1);\n        k.centerX = d + m * Math.cos(n);\n        k.centerY = e + m * Math.sin(n);\n        h++;\n      }\n    }\n  }\n  function cs(a, b, c, d, e, f, g) {\n    var h = 9E19,\n      k = -1,\n      l = 0;\n    a: for (; l < b; l++) {\n      var m = a[l],\n        n = m.x - c,\n        p = m.y - d;\n      n = n * n + p * p;\n      if (n < h) {\n        for (p = l - 1; 0 <= p; p--) if (a[p].y > m.y && a[p].x - m.x < e + g.width) continue a;\n        for (p = l + 1; p < b; p++) if (a[p].x > m.x && a[p].y - m.y < f + g.height) continue a;\n        k = l;\n        h = n;\n      }\n    }\n    return k;\n  }\n  $r.prototype.Fv = function () {\n    if (this.comments) for (var a = this.network.vertexes.iterator; a.next();) this.addComments(a.value);\n  };\n  $r.prototype.addComments = function (a) {\n    var b = a.node;\n    if (null !== b) for (b = b.Rv(); b.next();) {\n      var c = b.value;\n      if (\"Comment\" === c.category && c.isVisible()) {\n        var d = this.network.kj(c);\n        null === d && (d = this.network.jk(c));\n        d.charge = this.defaultCommentElectricalCharge;\n        c = null;\n        for (var e = d.destinationEdges; e.next();) {\n          var f = e.value;\n          if (f.toVertex === a) {\n            c = f;\n            break;\n          }\n        }\n        if (null === c) for (e = d.sourceEdges; e.next();) if (f = e.value, f.fromVertex === a) {\n          c = f;\n          break;\n        }\n        null === c && (c = this.network.Ak(a, d, null));\n        c.length = this.defaultCommentSpringLength;\n      }\n    }\n  };\n  function js(a, b) {\n    var c = a.bounds,\n      d = c.x;\n    a = c.y;\n    var e = c.width;\n    c = c.height;\n    var f = b.bounds,\n      g = f.x;\n    b = f.y;\n    var h = f.width;\n    f = f.height;\n    return d + e < g ? a > b + f ? (c = d + e - g, a = a - b - f, K.sqrt(c * c + a * a)) : a + c < b ? (d = d + e - g, a = a + c - b, K.sqrt(d * d + a * a)) : g - (d + e) : d > g + h ? a > b + f ? (c = d - g - h, a = a - b - f, K.sqrt(c * c + a * a)) : a + c < b ? (d = d - g - h, a = a + c - b, K.sqrt(d * d + a * a)) : d - (g + h) : a > b + f ? a - (b + f) : a + c < b ? b - (a + c) : .1;\n  }\n  function ds(a, b) {\n    a.Fh = null;\n    for (b = a.Ao + b; a.Ao < b && (a.Ao++, ks(a)););\n    a.Fh = null;\n  }\n  function ks(a) {\n    null === a.Fh && (a.Fh = a.network.vertexes.ma());\n    var b = a.Fh;\n    if (0 >= b.length) return !1;\n    var c = b[0];\n    c.forceX = 0;\n    c.forceY = 0;\n    for (var d = c.centerX, e = d, f = c = c.centerY, g = 1; g < b.length; g++) {\n      var h = b[g];\n      h.forceX = 0;\n      h.forceY = 0;\n      var k = h.centerX;\n      h = h.centerY;\n      d = Math.min(d, k);\n      e = Math.max(e, k);\n      c = Math.min(c, h);\n      f = Math.max(f, h);\n    }\n    (e = e - d > f - c) ? b.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : a.centerX - b.centerX;\n    }) : b.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : a.centerY - b.centerY;\n    });\n    c = a.Xf;\n    var l = d = h = 0;\n    for (f = 0; f < b.length; f++) {\n      g = b[f];\n      d = g.bounds;\n      h = g.focus;\n      k = d.x + h.x;\n      var m = d.y + h.y;\n      d = g.charge * a.electricalFieldX(k, m);\n      l = g.charge * a.electricalFieldY(k, m);\n      d += g.mass * a.gravitationalFieldX(k, m);\n      l += g.mass * a.gravitationalFieldY(k, m);\n      g.forceX += d;\n      g.forceY += l;\n      for (var n = f + 1; n < b.length; n++) {\n        var p = b[n];\n        if (p !== g) {\n          d = p.bounds;\n          h = p.focus;\n          l = d.x + h.x;\n          var r = d.y + h.y;\n          if (k - l > c || l - k > c) {\n            if (e) break;\n          } else if (m - r > c || r - m > c) {\n            if (!e) break;\n          } else {\n            var q = js(g, p);\n            1 > q ? (d = a.randomNumberGenerator, null === d && (a.randomNumberGenerator = d = new ls()), q = d.random(), h = d.random(), k > l ? (d = Math.abs(p.bounds.right - g.bounds.x), d = (1 + d) * q) : k < l ? (d = Math.abs(p.bounds.x - g.bounds.right), d = -(1 + d) * q) : (d = Math.max(p.width, g.width), d = (1 + d) * q - d / 2), m > r ? (l = Math.abs(p.bounds.bottom - g.bounds.y), l = (1 + l) * h) : k < l ? (l = Math.abs(p.bounds.y - g.bounds.bottom), l = -(1 + l) * h) : (l = Math.max(p.height, g.height), l = (1 + l) * h - l / 2)) : (h = -(g.charge * p.charge) / (q * q), d = (l - k) / q * h, l = (r - m) / q * h);\n            g.forceX += d;\n            g.forceY += l;\n            p.forceX -= d;\n            p.forceY -= l;\n          }\n        }\n      }\n    }\n    for (e = a.network.edges.iterator; e.next();) h = e.value, c = h.fromVertex, f = h.toVertex, g = c.bounds, k = c.focus, d = g.x + k.x, g = g.y + k.y, m = f.bounds, n = f.focus, k = m.x + n.x, m = m.y + n.y, n = js(c, f), 1 > n ? (n = a.randomNumberGenerator, null === n && (a.randomNumberGenerator = n = new ls()), h = n.random(), n = n.random(), d = (d > k ? 1 : -1) * (1 + (f.width > c.width ? f.width : c.width)) * h, l = (g > m ? 1 : -1) * (1 + (f.height > c.height ? f.height : c.height)) * n) : (h = h.stiffness * (n - h.length), d = (k - d) / n * h, l = (m - g) / n * h), c.forceX += d, c.forceY += l, f.forceX -= d, f.forceY -= l;\n    for (e = d = 0; e < b.length; e++) c = b[e], a.isFixed(c) ? a.moveFixedVertex(c) : d = Math.max(d, a.moveVertex(c) || 0);\n    return d > a.epsilonDistance * a.epsilonDistance;\n  }\n  $r.prototype.moveVertex = function (a) {\n    var b = a.forceX,\n      c = a.forceY,\n      d = this.moveLimit;\n    b < -d ? b = -d : b > d && (b = d);\n    c < -d ? c = -d : c > d && (c = d);\n    a.centerX += b;\n    a.centerY += c;\n    return b * b + c * c;\n  };\n  $r.prototype.moveFixedVertex = function () {};\n  $r.prototype.commitLayout = function () {\n    this.Cw();\n    this.commitNodes();\n    this.isRouting && this.commitLinks();\n  };\n  $r.prototype.Cw = function () {\n    if (this.setsPortSpots) for (var a = this.network.edges.iterator; a.next();) {\n      var b = a.value.link;\n      null !== b && (b.fromSpot = ad, b.toSpot = ad);\n    }\n  };\n  $r.prototype.commitNodes = function () {\n    var a = 0,\n      b = 0;\n    if (this.arrangesToOrigin) {\n      var c = N.alloc();\n      this.computeBounds(this.network, c);\n      b = this.arrangementOrigin;\n      a = b.x - c.x;\n      b = b.y - c.y;\n      N.free(c);\n    }\n    c = N.alloc();\n    for (var d = this.network.vertexes.iterator; d.next();) {\n      var e = d.value;\n      if (0 !== a || 0 !== b) c.assign(e.bounds), c.x += a, c.y += b, e.bounds = c;\n      e.commit();\n    }\n    N.free(c);\n  };\n  $r.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator; a.next();) a.value.commit();\n  };\n  $r.prototype.springStiffness = function (a) {\n    a = a.stiffness;\n    return isNaN(a) ? this.hl : a;\n  };\n  $r.prototype.springLength = function (a) {\n    a = a.length;\n    return isNaN(a) ? this.gl : a;\n  };\n  $r.prototype.electricalCharge = function (a) {\n    a = a.charge;\n    return isNaN(a) ? this.el : a;\n  };\n  $r.prototype.electricalFieldX = function () {\n    return 0;\n  };\n  $r.prototype.electricalFieldY = function () {\n    return 0;\n  };\n  $r.prototype.gravitationalMass = function (a) {\n    a = a.mass;\n    return isNaN(a) ? this.fl : a;\n  };\n  $r.prototype.gravitationalFieldX = function () {\n    return 0;\n  };\n  $r.prototype.gravitationalFieldY = function () {\n    return 0;\n  };\n  $r.prototype.isFixed = function (a) {\n    return a.isFixed;\n  };\n  ma.Object.defineProperties($r.prototype, {\n    currentIteration: {\n      get: function () {\n        return this.Ao;\n      }\n    },\n    arrangementSpacing: {\n      get: function () {\n        return this.Hd;\n      },\n      set: function (a) {\n        this.Hd.w(a) || (this.Hd.assign(a), this.C());\n      }\n    },\n    arrangesToOrigin: {\n      get: function () {\n        return this.nn;\n      },\n      set: function (a) {\n        this.nn !== a && (this.nn = a, this.C());\n      }\n    },\n    setsPortSpots: {\n      get: function () {\n        return this.hf;\n      },\n      set: function (a) {\n        this.hf !== a && (this.hf = a, this.C());\n      }\n    },\n    comments: {\n      get: function () {\n        return this.ed;\n      },\n      set: function (a) {\n        this.ed !== a && (this.ed = a, this.C());\n      }\n    },\n    maxIterations: {\n      get: function () {\n        return this.Ll;\n      },\n      set: function (a) {\n        this.Ll !== a && 0 <= a && (this.Ll = a, this.C());\n      }\n    },\n    epsilonDistance: {\n      get: function () {\n        return this.Wn;\n      },\n      set: function (a) {\n        this.Wn !== a && 0 < a && (this.Wn = a, this.C());\n      }\n    },\n    infinityDistance: {\n      get: function () {\n        return this.Xf;\n      },\n      set: function (a) {\n        this.Xf !== a && 1 < a && (this.Xf = a, this.C());\n      }\n    },\n    moveLimit: {\n      get: function () {\n        return this.Yo;\n      },\n      set: function (a) {\n        this.Yo !== a && 1 < a && (this.Yo = a, this.C());\n      }\n    },\n    randomNumberGenerator: {\n      get: function () {\n        return this.xp;\n      },\n      set: function (a) {\n        this.xp !== a && (null !== a && \"function\" !== typeof a.random && B('ForceDirectedLayout.randomNumberGenerator must have a \"random()\" function on it: ' + a), this.xp = a);\n      }\n    },\n    defaultSpringStiffness: {\n      get: function () {\n        return this.hl;\n      },\n      set: function (a) {\n        this.hl !== a && (this.hl = a, this.C());\n      }\n    },\n    defaultSpringLength: {\n      get: function () {\n        return this.gl;\n      },\n      set: function (a) {\n        this.gl !== a && (this.gl = a, this.C());\n      }\n    },\n    defaultElectricalCharge: {\n      get: function () {\n        return this.el;\n      },\n      set: function (a) {\n        this.el !== a && (this.el = a, this.C());\n      }\n    },\n    defaultGravitationalMass: {\n      get: function () {\n        return this.fl;\n      },\n      set: function (a) {\n        this.fl !== a && (this.fl = a, this.C());\n      }\n    },\n    defaultCommentSpringLength: {\n      get: function () {\n        return this.Nn;\n      },\n      set: function (a) {\n        this.Nn !== a && (this.Nn = a, this.C());\n      }\n    },\n    defaultCommentElectricalCharge: {\n      get: function () {\n        return this.Mn;\n      },\n      set: function (a) {\n        this.Mn !== a && (this.Mn = a, this.C());\n      }\n    }\n  });\n  $r.className = \"ForceDirectedLayout\";\n  function is() {\n    this.Zw = this.Yw = this.ou = this.qu = this.pu = 0;\n  }\n  is.className = \"ForceDirectedSubnet\";\n  function as(a) {\n    Rp.call(this, a);\n  }\n  la(as, Rp);\n  as.prototype.createVertex = function () {\n    return new ms(this);\n  };\n  as.prototype.createEdge = function () {\n    return new ns(this);\n  };\n  as.className = \"ForceDirectedNetwork\";\n  function ms(a) {\n    eq.call(this, a);\n    this.Ka = !1;\n    this.cb = this.I = NaN;\n    this.Sh = this.Dd = this.Ja = this.T = 0;\n    this.Ke = this.mk = null;\n    this.yw = 0;\n  }\n  la(ms, eq);\n  ms.prototype.serializeVertexProperties = function (a, b) {\n    eq.prototype.serializeVertexProperties.call(this, a, b);\n    a.isFixed = this.isFixed;\n    a.charge = this.charge;\n    a.mass = this.mass;\n  };\n  ms.prototype.Aq = function (a, b, c, d) {\n    eq.prototype.Aq.call(this, a, b, c, d);\n    this.isFixed = a.isFixed;\n    this.charge = a.charge;\n    this.mass = a.mass;\n  };\n  ma.Object.defineProperties(ms.prototype, {\n    isFixed: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka !== a && (this.Ka = a);\n      }\n    },\n    charge: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I !== a && (this.I = a);\n      }\n    },\n    mass: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb !== a && (this.cb = a);\n      }\n    },\n    forceX: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T !== a && (this.T = a);\n      }\n    },\n    forceY: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja !== a && (this.Ja = a);\n      }\n    }\n  });\n  ms.className = \"ForceDirectedVertex\";\n  function ns(a) {\n    fq.call(this, a);\n    this.l = this.v = NaN;\n  }\n  la(ns, fq);\n  ns.prototype.serializeEdgeProperties = function (a, b) {\n    fq.prototype.serializeEdgeProperties.call(this, a, b);\n    a.stiffness = this.stiffness;\n    a.length = this.length;\n  };\n  ns.prototype.deserializeEdgeProperties = function (a, b, c, d) {\n    fq.prototype.deserializeEdgeProperties.call(this, a, b, c, d);\n    this.stiffness = a.stiffness;\n    this.length = a.length;\n  };\n  ma.Object.defineProperties(ns.prototype, {\n    stiffness: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v !== a && (this.v = a);\n      }\n    },\n    length: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l !== a && (this.l = a);\n      }\n    }\n  });\n  ns.className = \"ForceDirectedEdge\";\n  function ls() {\n    var a = 0;\n    void 0 === a && (a = 42);\n    this.seed = a;\n    this.Wy = 48271;\n    this.Yy = 2147483647;\n    this.Q = 44488.07041494893;\n    this.Zy = 3399;\n    this.Xy = 1 / 2147483647;\n    this.random();\n  }\n  ls.prototype.random = function () {\n    var a = this.seed % this.Q * this.Wy - this.seed / this.Q * this.Zy;\n    0 < a ? this.seed = a : this.seed = a + this.Yy;\n    return this.seed * this.Xy;\n  };\n  ls.className = \"RandomNumberGenerator\";\n  function os() {\n    yi.call(this);\n    this.Zb = this.qe = 25;\n    this.J = 0;\n    this.cl = ps;\n    this.Gl = qs;\n    this.vl = rs;\n    this.Oj = 4;\n    this.Sk = ss;\n    this.ng = 7;\n    this.hf = !0;\n    this.Io = 4;\n    this.Ba = this.Ii = this.ra = -1;\n    this.oc = this.lh = 0;\n    this.Ia = this.td = this.ud = this.Sd = this.zb = null;\n    this.nh = 0;\n    this.ap = this.Tj = null;\n    this.Ec = 0;\n    this.bp = null;\n    this.Sc = new J();\n    this.te = [];\n    this.te.length = 100;\n  }\n  la(os, yi);\n  os.prototype.cloneProtected = function (a) {\n    yi.prototype.cloneProtected.call(this, a);\n    a.qe = this.qe;\n    a.Zb = this.Zb;\n    a.J = this.J;\n    a.cl = this.cl;\n    a.Gl = this.Gl;\n    a.vl = this.vl;\n    a.Oj = this.Oj;\n    a.Sk = this.Sk;\n    a.ng = this.ng;\n    a.hf = this.hf;\n    a.Io = this.Io;\n  };\n  os.prototype.serializeLayoutProperties = function (a, b) {\n    yi.prototype.serializeLayoutProperties.call(this, a, b);\n    a.layerSpacing = this.layerSpacing;\n    a.columnSpacing = this.columnSpacing;\n    a.direction = this.direction;\n    a.cycleRemoveOption = this.cycleRemoveOption.name;\n    a.layeringOption = this.layeringOption.name;\n    a.initializeOption = this.initializeOption.name;\n    a.iterations = this.iterations;\n    a.aggressiveOption = this.aggressiveOption.name;\n    a.packOption = this.packOption;\n    a.setsPortSpots = this.setsPortSpots;\n    a.linkSpacing = this.linkSpacing;\n    a.ra = this.ra;\n    a.Ii = this.Ii;\n    a.Ba = this.Ba;\n    a.lh = this.lh;\n    a.oc = this.oc;\n    a.zb = this.zb;\n    a.nh = this.nh;\n    a.Ec = this.Ec;\n    a.Sc = {\n      x: this.Sc.x,\n      y: this.Sc.y\n    };\n  };\n  os.prototype.deserializeLayoutProperties = function (a, b, c, d) {\n    yi.prototype.deserializeLayoutProperties.call(this, a, b, c, d);\n    this.layerSpacing = a.layerSpacing;\n    this.columnSpacing = a.columnSpacing;\n    this.direction = a.direction;\n    this.cycleRemoveOption = Za(os, a.cycleRemoveOption);\n    this.layeringOption = Za(os, a.layeringOption);\n    this.initializeOption = Za(os, a.initializeOption);\n    this.iterations = a.iterations;\n    this.aggressiveOption = Za(os, a.aggressiveOption);\n    this.packOption = a.packOption;\n    this.setsPortSpots = a.setsPortSpots;\n    this.linkSpacing = a.linkSpacing;\n    this.ra = a.ra;\n    this.Ii = a.Ii;\n    this.Ba = a.Ba;\n    this.lh = a.lh;\n    this.oc = a.oc;\n    this.zb = a.zb;\n    this.nh = a.nh;\n    this.Ec = a.Ec;\n    this.Sc = new J(this.Sc.x, this.Sc.y);\n  };\n  os.prototype.hb = function (a) {\n    a.classType === os ? 0 === a.name.indexOf(\"Aggressive\") ? this.aggressiveOption = a : 0 === a.name.indexOf(\"Cycle\") ? this.cycleRemoveOption = a : 0 === a.name.indexOf(\"Init\") ? this.initializeOption = a : 0 === a.name.indexOf(\"Layer\") ? this.layeringOption = a : B(\"Unknown enum value: \" + a) : yi.prototype.hb.call(this, a);\n  };\n  os.prototype.createNetwork = function () {\n    return new ts(this);\n  };\n  os.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    this.Ii = -1;\n    this.oc = this.lh = 0;\n    this.bp = this.ap = this.Tj = null;\n    for (a = 0; a < this.te.length; a++) this.te[a] = null;\n    if (0 < this.network.vertexes.count) {\n      this.network.zq();\n      if (this.Sw()) return;\n      this.cycleRemoveOption !== us && this.removeCycles();\n      for (a = this.network.vertexes.iterator; a.next();) a.value.layer = -1;\n      this.ra = -1;\n      this.assignLayers();\n      for (a.reset(); a.next();) this.ra = Math.max(this.ra, a.value.layer);\n      this.cycleRemoveOption === us && this.removeCycles();\n      a = this.network;\n      for (var b = [], c = a.edges.iterator; c.next();) {\n        var d = c.value;\n        d.valid = !1;\n        b.push(d);\n      }\n      for (c = 0; c < b.length; c++) {\n        d = b[c];\n        var e = d.fromVertex,\n          f = d.toVertex;\n        if (!(d.valid || (null === e.node && null === e.data || null === f.node && null === f.data) && e.layer === f.layer)) {\n          var g = 0,\n            h = 0,\n            k = 0,\n            l = 0;\n          if (null !== d.link) {\n            h = d.link;\n            if (null === h) continue;\n            var m = e.node;\n            g = f.node;\n            if (null === m || null === g) continue;\n            var n = h.fromNode;\n            k = h.toNode;\n            var p = h.fromPort;\n            h = h.toPort;\n            if (d.rev) {\n              l = n;\n              var r = p;\n              n = k;\n              p = h;\n              k = l;\n              h = r;\n            }\n            var q = e.focus;\n            l = f.focus;\n            var u = d.rev ? f.bounds : e.bounds;\n            r = J.alloc();\n            m !== n ? u.u() && n.isVisible() ? n.actualBounds.u() ? (n.Cf(p, Bc, r), r.x += n.actualBounds.x - u.x, r.y += n.actualBounds.y - u.y) : (n.Cf(p, Bc, r), r.u() || r.assign(q)) : r.assign(q) : u.u() ? (n.Cf(p, Bc, r), r.u() || r.assign(q)) : r.assign(q);\n            n = d.rev ? e.bounds : f.bounds;\n            m = J.alloc();\n            g !== k ? n.u() && k.isVisible() ? k.actualBounds.u() ? (k.Cf(h, Bc, m), m.x += k.actualBounds.x - n.x, m.y += k.actualBounds.y - n.y) : (k.Cf(h, Bc, m), m.u() || m.assign(l)) : m.assign(l) : n.u() ? (k.Cf(h, Bc, m), m.u() || m.assign(l)) : m.assign(l);\n            90 === this.J || 270 === this.J ? (g = Math.round((r.x - q.x) / this.Zb), k = r.x, h = Math.round((m.x - l.x) / this.Zb), l = m.x) : (g = Math.round((r.y - q.y) / this.Zb), k = r.y, h = Math.round((m.y - l.y) / this.Zb), l = m.y);\n            J.free(r);\n            J.free(m);\n            d.portFromColOffset = g;\n            d.portFromPos = k;\n            d.portToColOffset = h;\n            d.portToPos = l;\n          } else d.portFromColOffset = 0, d.portFromPos = 0, d.portToColOffset = 0, d.portToPos = 0;\n          r = e.layer;\n          m = f.layer;\n          n = 0;\n          u = d.link;\n          if (null !== u) {\n            var v = u.fromPort,\n              w = u.toPort;\n            if (null !== v && null !== w) {\n              var y = u.fromNode;\n              p = u.toNode;\n              if (null !== y && null !== p) {\n                var z = vs(this, !0),\n                  A = vs(this, !1),\n                  C = this.setsPortSpots ? z : u.computeSpot(!0, v);\n                q = this.setsPortSpots ? A : u.computeSpot(!1, w);\n                var G = u.isOrthogonal;\n                C.Mc() && C.Df(A) && q.Mc() && q.Df(z) ? n = 0 : (z = u.getLinkPoint(y, v, C, !0, G, p, w, J.alloc()), A = u.getLinkDirection(y, v, z, C, !0, G, p, w), J.free(z), C.Vt() || A !== ws(this, d, !0) ? this.setsPortSpots && null !== y && 1 === y.ports.count && d.rev && (n += 1) : n += 1, C = u.getLinkPoint(p, w, q, !1, G, y, v, J.alloc()), u = u.getLinkDirection(p, w, C, q, !1, G, y, v), J.free(C), q.Vt() || u !== ws(this, d, !1) ? this.setsPortSpots && null !== p && 1 === p.ports.count && d.rev && (n += 2) : n += 2);\n              }\n            }\n          }\n          p = n;\n          n = 1 === p || 3 === p ? !0 : !1;\n          if (p = 2 === p || 3 === p ? !0 : !1) q = a.createVertex(), q.node = null, q.wf = 1, q.layer = r, q.near = e, a.Bg(q), e = a.Ak(e, q, d.link), e.valid = !1, e.rev = d.rev, e.portFromColOffset = g, e.portToColOffset = 0, e.portFromPos = k, e.portToPos = 0, e = q;\n          u = 1;\n          n && u--;\n          if (r - m > u && 0 < r) {\n            d.valid = !1;\n            q = a.createVertex();\n            q.node = null;\n            q.wf = 2;\n            q.layer = r - 1;\n            a.Bg(q);\n            e = a.Ak(e, q, d.link);\n            e.valid = !0;\n            e.rev = d.rev;\n            e.portFromColOffset = p ? 0 : g;\n            e.portToColOffset = 0;\n            e.portFromPos = p ? 0 : k;\n            e.portToPos = 0;\n            e = q;\n            for (r--; r - m > u && 0 < r;) q = a.createVertex(), q.node = null, q.wf = 3, q.layer = r - 1, a.Bg(q), e = a.Ak(e, q, d.link), e.valid = !0, e.rev = d.rev, e.portFromColOffset = 0, e.portToColOffset = 0, e.portFromPos = 0, e.portToPos = 0, e = q, r--;\n            e = a.Ak(q, f, d.link);\n            e.valid = !n;\n            n && (q.near = f);\n            e.rev = d.rev;\n            e.portFromColOffset = 0;\n            e.portToColOffset = h;\n            e.portFromPos = 0;\n            e.portToPos = l;\n          } else d.valid = !0;\n        }\n      }\n      a = this.zb = [];\n      for (b = 0; b <= this.ra; b++) a[b] = 0;\n      for (b = this.network.vertexes.iterator; b.next();) b.value.index = -1;\n      this.initializeIndices();\n      this.Ii = -1;\n      for (c = this.oc = this.lh = 0; c <= this.ra; c++) a[c] > a[this.oc] && (this.Ii = a[c] - 1, this.oc = c), a[c] < a[this.lh] && (this.lh = c);\n      this.bp = [];\n      for (c = 0; c < a.length; c++) this.bp[c] = [];\n      for (b.reset(); b.next();) a = b.value, this.bp[a.layer][a.index] = a;\n      this.Ba = -1;\n      for (a = 0; a <= this.ra; a++) {\n        b = xs(this, a);\n        c = 0;\n        d = this.zb[a];\n        for (f = 0; f < d; f++) e = b[f], c += this.nodeMinColumnSpace(e, !0), e.column = c, c += 1, c += this.nodeMinColumnSpace(e, !1);\n        this.Ba = Math.max(this.Ba, c - 1);\n        ys(this, a, b);\n      }\n      this.reduceCrossings();\n      this.straightenAndPack();\n      this.updateParts();\n    }\n    this.network = null;\n    this.isValidLayout = !0;\n  };\n  os.prototype.linkMinLength = function () {\n    return 1;\n  };\n  function zs(a) {\n    var b = a.fromVertex.node || a.fromVertex.data;\n    a = a.toVertex.node || a.toVertex.data;\n    return null === b && null === a ? 8 : null === b || null === a ? 4 : 1;\n  }\n  os.prototype.nodeMinLayerSpace = function (a, b) {\n    return null === a.node && null === a.data ? 0 : 90 === this.J || 270 === this.J ? b ? a.focus.y + 10 : a.bounds.height - a.focus.y + 10 : b ? a.focus.x + 10 : a.bounds.width - a.focus.x + 10;\n  };\n  os.prototype.nodeMinColumnSpace = function (a, b) {\n    if (null === a.node && null === a.data) return 0;\n    var c = b ? a.Ik : a.Hk;\n    if (null !== c) return c;\n    c = this.J;\n    return 90 === c || 270 === c ? b ? a.Ik = a.focus.x / this.Zb + 1 | 0 : a.Hk = (a.bounds.width - a.focus.x) / this.Zb + 1 | 0 : b ? a.Ik = a.focus.y / this.Zb + 1 | 0 : a.Hk = (a.bounds.height - a.focus.y) / this.Zb + 1 | 0;\n  };\n  function As(a) {\n    null === a.Tj && (a.Tj = []);\n    for (var b = 0, c = a.network.vertexes.iterator; c.next();) {\n      var d = c.value;\n      a.Tj[b] = d.layer;\n      b++;\n      a.Tj[b] = d.column;\n      b++;\n      a.Tj[b] = d.index;\n      b++;\n    }\n    return a.Tj;\n  }\n  function Bs(a, b) {\n    var c = 0;\n    for (a = a.network.vertexes.iterator; a.next();) {\n      var d = a.value;\n      d.layer = b[c];\n      c++;\n      d.column = b[c];\n      c++;\n      d.index = b[c];\n      c++;\n    }\n  }\n  function Cs(a, b, c) {\n    var d = xs(a, b),\n      e = a.zb[b];\n    if (null === a.ap || a.ap.length < e * e) a.ap = [];\n    for (var f = a.ap, g = 0; g < e; g++) {\n      var h = 0,\n        k = d[g],\n        l = k.near;\n      if (null !== l && l.layer === k.layer) if (k = l.index, k > g) for (var m = g + 1; m < k; m++) {\n        var n = d[m];\n        n.near === l && n.wf === l.wf || h++;\n      } else for (m = g - 1; m > k; m--) n = d[m], n.near === l && n.wf === l.wf || h++;\n      var p;\n      if (0 <= c) for (k = d[g].sourceEdgesArrayAccess, l = 0; l < k.length; l++) {\n        var r = k[l];\n        if (r.valid && r.fromVertex.layer !== b) for (n = r.fromVertex.index, m = r.portToPos, r = r.portFromPos, p = l + 1; p < k.length; p++) {\n          var q = k[p];\n          if (q.valid && q.fromVertex.layer !== b) {\n            var u = q.fromVertex.index;\n            var v = q.portToPos;\n            q = q.portFromPos;\n            m < v && (n > u || n === u && r > q) && h++;\n            v < m && (u > n || u === n && q > r) && h++;\n          }\n        }\n      }\n      if (0 >= c) for (k = d[g].destinationEdgesArrayAccess, l = 0; l < k.length; l++) if (r = k[l], r.valid && r.toVertex.layer !== b) for (n = r.toVertex.index, m = r.portToPos, r = r.portFromPos, p = l + 1; p < k.length; p++) q = k[p], q.valid && q.toVertex.layer !== b && (u = q.toVertex.index, v = q.portToPos, q = q.portFromPos, r < q && (n > u || n === u && m > v) && h++, q < r && (u > n || u === n && v > m) && h++);\n      f[g * e + g] = h;\n      for (k = g + 1; k < e; k++) {\n        var w = 0,\n          y = 0;\n        if (0 <= c) {\n          h = d[g].sourceEdgesArrayAccess;\n          var z = d[k].sourceEdgesArrayAccess;\n          for (l = 0; l < h.length; l++) if (r = h[l], r.valid && r.fromVertex.layer !== b) for (n = r.fromVertex.index, r = r.portFromPos, p = 0; p < z.length; p++) q = z[p], q.valid && q.fromVertex.layer !== b && (u = q.fromVertex.index, q = q.portFromPos, (n < u || n === u && r < q) && y++, (u < n || u === n && q < r) && w++);\n        }\n        if (0 >= c) for (h = d[g].destinationEdgesArrayAccess, z = d[k].destinationEdgesArrayAccess, l = 0; l < h.length; l++) if (r = h[l], r.valid && r.toVertex.layer !== b) for (n = r.toVertex.index, m = r.portToPos, p = 0; p < z.length; p++) q = z[p], q.valid && q.toVertex.layer !== b && (u = q.toVertex.index, v = q.portToPos, (n < u || n === u && m < v) && y++, (u < n || u === n && v < m) && w++);\n        f[g * e + k] = w;\n        f[k * e + g] = y;\n      }\n    }\n    ys(a, b, d);\n    return f;\n  }\n  os.prototype.countCrossings = function () {\n    for (var a = 0, b = 0; b <= this.ra; b++) for (var c = Cs(this, b, 1), d = this.zb[b], e = 0; e < d; e++) for (var f = e; f < d; f++) a += c[e * d + f];\n    return a;\n  };\n  function Ds(a) {\n    for (var b = 0, c = 0; c <= a.ra; c++) {\n      for (var d = a, e = c, f = xs(d, e), g = d.zb[e], h = 0, k = 0; k < g; k++) {\n        var l = f[k].destinationEdgesArrayAccess;\n        if (null !== l) for (var m = 0; m < l.length; m++) {\n          var n = l[m];\n          if (n.valid && n.toVertex.layer !== e) {\n            var p = n.fromVertex.column + n.portFromColOffset;\n            var r = n.toVertex.column + n.portToColOffset;\n            h += (Math.abs(p - r) + 1) * zs(n);\n          }\n        }\n      }\n      ys(d, e, f);\n      b += h;\n    }\n    return b;\n  }\n  os.prototype.normalize = function () {\n    var a = Infinity;\n    this.Ba = -1;\n    for (var b = this.network.vertexes.iterator; b.next();) {\n      var c = b.value;\n      a = Math.min(a, c.column - this.nodeMinColumnSpace(c, !0));\n      this.Ba = Math.max(this.Ba, c.column + this.nodeMinColumnSpace(c, !1));\n    }\n    for (b.reset(); b.next();) b.value.column -= a;\n    this.Ba -= a;\n  };\n  function Es(a, b, c) {\n    for (var d = xs(a, b), e = a.zb[b], f = [], g = 0; g < e; g++) {\n      var h = d[g],\n        k = null;\n      0 >= c && (k = h.sourceEdgesArrayAccess);\n      var l = null;\n      0 <= c && (l = h.destinationEdgesArrayAccess);\n      var m = 0,\n        n = 0,\n        p = h.near;\n      null !== p && p.layer === h.layer && (m += p.column - 1, n++);\n      if (null !== k) for (p = 0; p < k.length; p++) {\n        h = k[p];\n        var r = h.fromVertex;\n        h.valid && !h.rev && r.layer !== b && (m += r.column, n++);\n      }\n      if (null !== l) for (k = 0; k < l.length; k++) h = l[k], p = h.toVertex, h.valid && !h.rev && p.layer !== b && (m += p.column, n++);\n      f[g] = 0 === n ? -1 : m / n;\n    }\n    ys(a, b, d);\n    return f;\n  }\n  function Fs(a, b, c) {\n    for (var d = xs(a, b), e = a.zb[b], f = [], g = 0; g < e; g++) {\n      var h = d[g],\n        k = null;\n      0 >= c && (k = h.sourceEdgesArrayAccess);\n      var l = null;\n      0 <= c && (l = h.destinationEdgesArrayAccess);\n      var m = 0,\n        n = [],\n        p = h.near;\n      null !== p && p.layer === h.layer && (n[m] = p.column - 1, m++);\n      h = void 0;\n      if (null !== k) for (p = 0; p < k.length; p++) {\n        h = k[p];\n        var r = h.fromVertex;\n        h.valid && !h.rev && r.layer !== b && (n[m] = r.column + h.portFromColOffset, m++);\n      }\n      if (null !== l) for (k = 0; k < l.length; k++) h = l[k], p = h.toVertex, h.valid && !h.rev && p.layer !== b && (n[m] = p.column + h.portToColOffset, m++);\n      0 === m ? f[g] = -1 : (n.sort(function (a, b) {\n        return a - b;\n      }), l = m >> 1, f[g] = 0 !== (m & 1) ? n[l] : n[l - 1] + n[l] >> 1);\n    }\n    ys(a, b, d);\n    return f;\n  }\n  function Gs(a, b, c, d, e, f) {\n    if (b.component === d) {\n      b.component = c;\n      if (e) for (var g = b.destinationEdges; g.next();) {\n        var h = g.value;\n        var k = h.toVertex;\n        var l = b.layer - k.layer;\n        h = a.linkMinLength(h);\n        l === h && Gs(a, k, c, d, e, f);\n      }\n      if (f) for (g = b.sourceEdges; g.next();) h = g.value, k = h.fromVertex, l = k.layer - b.layer, h = a.linkMinLength(h), l === h && Gs(a, k, c, d, e, f);\n    }\n  }\n  function Hs(a, b, c, d, e, f) {\n    if (b.component === d) {\n      b.component = c;\n      if (e) for (var g = b.destinationEdges; g.next();) Hs(a, g.value.toVertex, c, d, e, f);\n      if (f) for (b = b.sourceEdges; b.next();) Hs(a, b.value.fromVertex, c, d, e, f);\n    }\n  }\n  os.prototype.removeCycles = function () {\n    for (var a = this.network.edges.iterator; a.next();) a.value.rev = !1;\n    switch (this.cl) {\n      default:\n      case Is:\n        a = this.network;\n        var b = 0,\n          c = a.vertexes.count - 1,\n          d = [];\n        d.length = c + 1;\n        for (var e = a.vertexes.iterator; e.next();) e.value.valid = !0;\n        for (; null !== Js(a);) {\n          for (e = Ks(a); null !== e;) d[c] = e, c--, e.valid = !1, e = Ks(a);\n          for (e = Ls(a); null !== e;) d[b] = e, b++, e.valid = !1, e = Ls(a);\n          e = null;\n          for (var f = 0, g = this.network.vertexes.iterator; g.next();) {\n            var h = g.value;\n            if (h.valid) {\n              for (var k = 0, l = h.destinationEdges; l.next();) l.value.toVertex.valid && k++;\n              l = 0;\n              for (var m = h.sourceEdges; m.next();) m.value.fromVertex.valid && l++;\n              if (null === e || f < k - l) e = h, f = k - l;\n            }\n          }\n          null !== e && (d[b] = e, b++, e.valid = !1);\n        }\n        for (b = 0; b < a.vertexes.count; b++) d[b].index = b;\n        for (d = a.edges.iterator; d.next();) b = d.value, b.fromVertex.index > b.toVertex.index && (a.Qm(b), b.rev = !0);\n        break;\n      case ps:\n        for (d = this.network.vertexes.iterator; d.next();) a = d.value, a.Cg = -1, a.finish = -1;\n        for (a = this.network.edges.iterator; a.next();) a.value.forest = !1;\n        this.nh = 0;\n        for (d.reset(); d.next();) b = d.value, 0 === b.sourceEdges.count && Ms(this, b);\n        for (d.reset(); d.next();) b = d.value, -1 === b.Cg && Ms(this, b);\n        for (a.reset(); a.next();) d = a.value, d.forest || (b = d.fromVertex, c = b.finish, e = d.toVertex, f = e.finish, e.Cg < b.Cg && c < f && (this.network.Qm(d), d.rev = !0));\n        break;\n      case us:\n        a = this.network;\n        b = a.vertexes.iterator;\n        for (d = Infinity; b.next();) d = Math.min(d, b.value.layer);\n        if (Infinity > d) {\n          if (0 > d) for (b.reset(); b.next();) b.value.layer -= d;\n          d = [];\n          for (b.reset(); b.next();) c = b.value, e = d[c.layer], void 0 === e ? d[c.layer] = [c] : e.push(c);\n          for (c = b = 0; c < d.length; c++) if (e = d[c], !e || 0 === e.length) b++;else if (0 < c) for (f = 0; f < e.length; f++) e[f].layer -= b;\n          for (d = a.edges.iterator; d.next();) b = d.value, b.fromVertex.layer < b.toVertex.layer && (a.Qm(b), b.rev = !0);\n        }\n    }\n  };\n  function Js(a) {\n    for (a = a.vertexes.iterator; a.next();) {\n      var b = a.value;\n      if (b.valid) return b;\n    }\n    return null;\n  }\n  function Ks(a) {\n    for (a = a.vertexes.iterator; a.next();) {\n      var b = a.value;\n      if (b.valid) {\n        for (var c = !0, d = b.destinationEdges; d.next();) if (d.value.toVertex.valid) {\n          c = !1;\n          break;\n        }\n        if (c) return b;\n      }\n    }\n    return null;\n  }\n  function Ls(a) {\n    for (a = a.vertexes.iterator; a.next();) {\n      var b = a.value;\n      if (b.valid) {\n        for (var c = !0, d = b.sourceEdges; d.next();) if (d.value.fromVertex.valid) {\n          c = !1;\n          break;\n        }\n        if (c) return b;\n      }\n    }\n    return null;\n  }\n  function Ms(a, b) {\n    b.Cg = a.nh;\n    a.nh++;\n    for (var c = b.destinationEdges; c.next();) {\n      var d = c.value,\n        e = d.toVertex;\n      -1 === e.Cg && (d.forest = !0, Ms(a, e));\n    }\n    b.finish = a.nh;\n    a.nh++;\n  }\n  os.prototype.assignLayers = function () {\n    switch (this.Gl) {\n      case Ns:\n        Os(this);\n        break;\n      case Ps:\n        for (var a, b = this.network.vertexes.iterator; b.next();) a = Qs(this, b.value), this.ra = Math.max(a, this.ra);\n        for (b.reset(); b.next();) a = b.value, a.layer = this.ra - a.layer;\n        break;\n      default:\n      case qs:\n        Os(this);\n        for (b = this.network.vertexes.iterator; b.next();) b.value.valid = !1;\n        for (b.reset(); b.next();) a = b.value, 0 === a.sourceEdges.count && Rs(this, a);\n        a = Infinity;\n        for (b.reset(); b.next();) a = Math.min(a, b.value.layer);\n        this.ra = -1;\n        for (b.reset(); b.next();) {\n          var c = b.value;\n          c.layer -= a;\n          this.ra = Math.max(this.ra, c.layer);\n        }\n    }\n  };\n  function Os(a) {\n    for (var b = a.network.vertexes.iterator; b.next();) {\n      var c = Ss(a, b.value);\n      a.ra = Math.max(c, a.ra);\n    }\n  }\n  function Ss(a, b) {\n    var c = 0;\n    if (-1 === b.layer) {\n      for (var d = b.destinationEdges; d.next();) {\n        var e = d.value,\n          f = e.toVertex;\n        e = a.linkMinLength(e);\n        c = Math.max(c, Ss(a, f) + e);\n      }\n      b.layer = c;\n    } else c = b.layer;\n    return c;\n  }\n  function Qs(a, b) {\n    var c = 0;\n    if (-1 === b.layer) {\n      for (var d = b.sourceEdges; d.next();) {\n        var e = d.value,\n          f = e.fromVertex;\n        e = a.linkMinLength(e);\n        c = Math.max(c, Qs(a, f) + e);\n      }\n      b.layer = c;\n    } else c = b.layer;\n    return c;\n  }\n  function Rs(a, b) {\n    if (!b.valid) {\n      b.valid = !0;\n      for (var c = b.destinationEdges; c.next();) Rs(a, c.value.toVertex);\n      for (c = a.network.vertexes.iterator; c.next();) c.value.component = -1;\n      for (var d = b.sourceEdgesArrayAccess, e = d.length, f = 0; f < e; f++) {\n        var g = d[f],\n          h = g.fromVertex,\n          k = g.toVertex;\n        g = a.linkMinLength(g);\n        h.layer - k.layer > g && Gs(a, h, 0, -1, !0, !1);\n      }\n      for (Gs(a, b, 1, -1, !0, !0); 0 !== b.component;) {\n        f = 0;\n        d = Infinity;\n        h = 0;\n        k = null;\n        for (g = a.network.vertexes.iterator; g.next();) {\n          var l = g.value;\n          if (1 === l.component) {\n            var m = 0,\n              n = !1,\n              p = l.sourceEdgesArrayAccess;\n            e = p.length;\n            for (var r = 0; r < e; r++) {\n              var q = p[r],\n                u = q.fromVertex;\n              m += 1;\n              1 !== u.component && (f += 1, u = u.layer - l.layer, q = a.linkMinLength(q), d = Math.min(d, u - q));\n            }\n            p = l.destinationEdgesArrayAccess;\n            e = p.length;\n            for (r = 0; r < e; r++) q = p[r].toVertex, --m, 1 !== q.component ? --f : n = !0;\n            (null === k || m < h) && !n && (k = l, h = m);\n          }\n        }\n        if (0 < f) {\n          for (c.reset(); c.next();) e = c.value, 1 === e.component && (e.layer += d);\n          b.component = 0;\n        } else k.component = 0;\n      }\n      for (c = a.network.vertexes.iterator; c.next();) c.value.component = -1;\n      for (Gs(a, b, 1, -1, !0, !1); 0 !== b.component;) {\n        d = 0;\n        e = Infinity;\n        f = 0;\n        h = null;\n        for (k = a.network.vertexes.iterator; k.next();) if (g = k.value, 1 === g.component) {\n          l = 0;\n          m = !1;\n          p = g.sourceEdgesArrayAccess;\n          n = p.length;\n          for (r = 0; r < n; r++) q = p[r].fromVertex, l += 1, 1 !== q.component ? d += 1 : m = !0;\n          p = g.destinationEdgesArrayAccess;\n          n = p.length;\n          for (r = 0; r < n; r++) q = p[r], u = q.toVertex, --l, 1 !== u.component && (--d, u = g.layer - u.layer, q = a.linkMinLength(q), e = Math.min(e, u - q));\n          (null === h || l > f) && !m && (h = g, f = l);\n        }\n        if (0 > d) {\n          for (c.reset(); c.next();) d = c.value, 1 === d.component && (d.layer -= e);\n          b.component = 0;\n        } else h.component = 0;\n      }\n    }\n  }\n  function ws(a, b, c) {\n    return 90 === a.J ? c && !b.rev || !c && b.rev ? 270 : 90 : 180 === a.J ? c && !b.rev || !c && b.rev ? 0 : 180 : 270 === a.J ? c && !b.rev || !c && b.rev ? 90 : 270 : c && !b.rev || !c && b.rev ? 180 : 0;\n  }\n  os.prototype.initializeIndices = function () {\n    switch (this.vl) {\n      default:\n      case Ts:\n        for (var a = this.network.vertexes.iterator; a.next();) {\n          var b = a.value,\n            c = b.layer;\n          b.index = this.zb[c];\n          this.zb[c]++;\n        }\n        break;\n      case rs:\n        a = this.network.vertexes.iterator;\n        for (b = this.ra; 0 <= b; b--) for (a.reset(); a.next();) c = a.value, c.layer === b && -1 === c.index && Us(this, c);\n        break;\n      case Vs:\n        for (a = this.network.vertexes.iterator, b = 0; b <= this.ra; b++) for (a.reset(); a.next();) c = a.value, c.layer === b && -1 === c.index && Ws(this, c);\n    }\n  };\n  function Us(a, b) {\n    var c = b.layer;\n    b.index = a.zb[c];\n    a.zb[c]++;\n    b = b.destinationEdgesArrayAccess;\n    for (c = !0; c;) {\n      c = !1;\n      for (var d = 0; d < b.length - 1; d++) {\n        var e = b[d],\n          f = b[d + 1];\n        e.portFromColOffset > f.portFromColOffset && (c = !0, b[d] = f, b[d + 1] = e);\n      }\n    }\n    for (c = 0; c < b.length; c++) d = b[c], d.valid && (d = d.toVertex, -1 === d.index && Us(a, d));\n  }\n  function Ws(a, b) {\n    var c = b.layer;\n    b.index = a.zb[c];\n    a.zb[c]++;\n    b = b.sourceEdgesArrayAccess;\n    for (var d = !0; d;) for (d = !1, c = 0; c < b.length - 1; c++) {\n      var e = b[c],\n        f = b[c + 1];\n      e.portToColOffset > f.portToColOffset && (d = !0, b[c] = f, b[c + 1] = e);\n    }\n    for (c = 0; c < b.length; c++) d = b[c], d.valid && (d = d.fromVertex, -1 === d.index && Ws(a, d));\n  }\n  os.prototype.reduceCrossings = function () {\n    var a = this.countCrossings(),\n      b = As(this),\n      c,\n      d;\n    for (c = 0; c < this.Oj; c++) {\n      for (d = 0; d <= this.ra; d++) Xs(this, d, 1), Ys(this, d, 1);\n      var e = this.countCrossings();\n      e < a && (a = e, b = As(this));\n      for (d = this.ra; 0 <= d; d--) Xs(this, d, -1), Ys(this, d, -1);\n      e = this.countCrossings();\n      e < a && (a = e, b = As(this));\n    }\n    Bs(this, b);\n    for (c = 0; c < this.Oj; c++) {\n      for (d = 0; d <= this.ra; d++) Xs(this, d, 0), Ys(this, d, 0);\n      e = this.countCrossings();\n      e < a && (a = e, b = As(this));\n      for (d = this.ra; 0 <= d; d--) Xs(this, d, 0), Ys(this, d, 0);\n      e = this.countCrossings();\n      e < a && (a = e, b = As(this));\n    }\n    Bs(this, b);\n    var f, g, h;\n    switch (this.Sk) {\n      case Zs:\n        break;\n      case $s:\n        for (h = a + 1; (d = this.countCrossings()) < h;) for (h = d, c = this.ra; 0 <= c; c--) for (g = 0; g <= c; g++) {\n          for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = Ys(this, d, -1) || f;\n          e = this.countCrossings();\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = Ys(this, d, 1) || f;\n          e = this.countCrossings();\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = Ys(this, d, 1) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = Ys(this, d, -1) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = Ys(this, d, 0) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = Ys(this, d, 0) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n        }\n        break;\n      default:\n      case ss:\n        for (c = this.ra, g = 0, h = a + 1; (d = this.countCrossings()) < h;) {\n          h = d;\n          for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = Ys(this, d, -1) || f;\n          e = this.countCrossings();\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = Ys(this, d, 1) || f;\n          e = this.countCrossings();\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = Ys(this, d, 1) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = Ys(this, d, -1) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = Ys(this, d, 0) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n          for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = Ys(this, d, 0) || f;\n          e >= a ? Bs(this, b) : (a = e, b = As(this));\n        }\n    }\n    Bs(this, b);\n  };\n  function Xs(a, b, c) {\n    var d = xs(a, b),\n      e = a.zb[b],\n      f = Fs(a, b, c),\n      g = Es(a, b, c);\n    for (c = 0; c < e; c++) -1 === g[c] && (g[c] = d[c].column), -1 === f[c] && (f[c] = d[c].column);\n    for (var h = !0, k; h;) for (h = !1, c = 0; c < e - 1; c++) if (f[c + 1] < f[c] || f[c + 1] === f[c] && g[c + 1] < g[c]) h = !0, k = f[c], f[c] = f[c + 1], f[c + 1] = k, k = g[c], g[c] = g[c + 1], g[c + 1] = k, k = d[c], d[c] = d[c + 1], d[c + 1] = k;\n    for (c = f = 0; c < e; c++) k = d[c], k.index = c, f += a.nodeMinColumnSpace(k, !0), k.column = f, f += 1, f += a.nodeMinColumnSpace(k, !1);\n    ys(a, b, d);\n  }\n  function Ys(a, b, c) {\n    var d = xs(a, b),\n      e = a.zb[b];\n    c = Cs(a, b, c);\n    var f;\n    var g = [];\n    for (f = 0; f < e; f++) g[f] = -1;\n    var h = [];\n    for (f = 0; f < e; f++) h[f] = -1;\n    for (var k = !1, l = !0; l;) for (l = !1, f = 0; f < e - 1; f++) {\n      var m = c[d[f].index * e + d[f + 1].index],\n        n = c[d[f + 1].index * e + d[f].index],\n        p = 0,\n        r = 0,\n        q = d[f].column,\n        u = d[f + 1].column,\n        v = a.nodeMinColumnSpace(d[f], !0),\n        w = a.nodeMinColumnSpace(d[f], !1),\n        y = a.nodeMinColumnSpace(d[f + 1], !0),\n        z = a.nodeMinColumnSpace(d[f + 1], !1);\n      v = q - v + y;\n      w = u - w + z;\n      var A = d[f].sourceEdges.iterator;\n      for (A.reset(); A.next();) if (y = A.value, z = y.fromVertex, y.valid && z.layer === b) {\n        for (y = 0; d[y] !== z;) y++;\n        y < f && (p += 2 * (f - y), r += 2 * (f + 1 - y));\n        y === f + 1 && (p += 1);\n        y > f + 1 && (p += 4 * (y - f), r += 4 * (y - (f + 1)));\n      }\n      A = d[f].destinationEdges.iterator;\n      for (A.reset(); A.next();) if (y = A.value, z = y.toVertex, y.valid && z.layer === b) {\n        for (y = 0; d[y] !== z;) y++;\n        y === f + 1 && (r += 1);\n      }\n      A = d[f + 1].sourceEdges.iterator;\n      for (A.reset(); A.next();) if (y = A.value, z = y.fromVertex, y.valid && z.layer === b) {\n        for (y = 0; d[y] !== z;) y++;\n        y < f && (p += 2 * (f + 1 - y), r += 2 * (f - y));\n        y === f && (r += 1);\n        y > f + 1 && (p += 4 * (y - (f + 1)), r += 4 * (y - f));\n      }\n      A = d[f + 1].destinationEdges.iterator;\n      for (A.reset(); A.next();) if (y = A.value, z = y.toVertex, y.valid && z.layer === b) {\n        for (y = 0; d[y] !== z;) y++;\n        y === f && (p += 1);\n      }\n      y = z = 0;\n      A = g[d[f].index];\n      var C = h[d[f].index],\n        G = g[d[f + 1].index],\n        L = h[d[f + 1].index];\n      -1 !== A && (z += Math.abs(A - q), y += Math.abs(A - w));\n      -1 !== C && (z += Math.abs(C - q), y += Math.abs(C - w));\n      -1 !== G && (z += Math.abs(G - u), y += Math.abs(G - v));\n      -1 !== L && (z += Math.abs(L - u), y += Math.abs(L - v));\n      if (r < p - .5 || r === p && n < m - .5 || r === p && n === m && y < z - .5) l = k = !0, d[f].column = w, d[f + 1].column = v, m = d[f], d[f] = d[f + 1], d[f + 1] = m;\n    }\n    for (f = 0; f < e; f++) d[f].index = f;\n    ys(a, b, d);\n    return k;\n  }\n  os.prototype.straightenAndPack = function () {\n    var a = 0 !== (this.ng & 1);\n    var b = 7 === this.ng;\n    1E3 < this.network.edges.count && !b && (a = !1);\n    if (a) {\n      var c = [];\n      for (b = 0; b <= this.ra; b++) c[b] = 0;\n      for (var d, e = this.network.vertexes.iterator; e.next();) {\n        var f = e.value;\n        b = f.layer;\n        d = f.column;\n        f = this.nodeMinColumnSpace(f, !1);\n        c[b] = Math.max(c[b], d + f);\n      }\n      for (e.reset(); e.next();) f = e.value, b = f.layer, d = f.column, f.column = (8 * (this.Ba - c[b]) >> 1) + 8 * d;\n      this.Ba *= 8;\n    }\n    if (0 !== (this.ng & 2)) for (c = !0; c;) {\n      c = !1;\n      for (b = this.oc + 1; b <= this.ra; b++) c = at(this, b, 1) || c;\n      for (b = this.oc - 1; 0 <= b; b--) c = at(this, b, -1) || c;\n      c = at(this, this.oc, 0) || c;\n    }\n    if (0 !== (this.ng & 4)) {\n      for (b = this.oc + 1; b <= this.ra; b++) bt(this, b, 1);\n      for (b = this.oc - 1; 0 <= b; b--) bt(this, b, -1);\n      bt(this, this.oc, 0);\n    }\n    a && (ct(this, -1), ct(this, 1));\n    if (0 !== (this.ng & 2)) for (c = !0; c;) {\n      c = !1;\n      c = at(this, this.oc, 0) || c;\n      for (b = this.oc + 1; b <= this.ra; b++) c = at(this, b, 0) || c;\n      for (b = this.oc - 1; 0 <= b; b--) c = at(this, b, 0) || c;\n    }\n  };\n  function at(a, b, c) {\n    for (var d = !1; dt(a, b, c);) d = !0;\n    return d;\n  }\n  function dt(a, b, c) {\n    var d,\n      e = xs(a, b),\n      f = a.zb[b],\n      g = Es(a, b, -1);\n    if (0 < c) for (d = 0; d < f; d++) g[d] = -1;\n    var h = Es(a, b, 1);\n    if (0 > c) for (d = 0; d < f; d++) h[d] = -1;\n    for (var k = !1, l = !0; l;) for (l = !1, d = 0; d < f; d++) {\n      var m = e[d].column,\n        n = a.nodeMinColumnSpace(e[d], !0),\n        p = a.nodeMinColumnSpace(e[d], !1),\n        r = 0;\n      0 > d - 1 || m - e[d - 1].column - 1 > n + a.nodeMinColumnSpace(e[d - 1], !1) ? r = m - 1 : r = m;\n      n = d + 1 >= f || e[d + 1].column - m - 1 > p + a.nodeMinColumnSpace(e[d + 1], !0) ? m + 1 : m;\n      var q = p = 0,\n        u = 0;\n      if (0 >= c) for (var v = e[d].sourceEdges.iterator; v.next();) {\n        var w = v.value;\n        var y = w.fromVertex;\n        if (w.valid && y.layer !== b) {\n          var z = zs(w);\n          var A = w.portFromColOffset;\n          w = w.portToColOffset;\n          y = y.column;\n          p += (Math.abs(m + w - (y + A)) + 1) * z;\n          q += (Math.abs(r + w - (y + A)) + 1) * z;\n          u += (Math.abs(n + w - (y + A)) + 1) * z;\n        }\n      }\n      if (0 <= c) for (v = e[d].destinationEdges.iterator; v.next();) w = v.value, y = w.toVertex, w.valid && y.layer !== b && (z = zs(w), A = w.portFromColOffset, w = w.portToColOffset, y = y.column, p += (Math.abs(m + A - (y + w)) + 1) * z, q += (Math.abs(r + A - (y + w)) + 1) * z, u += (Math.abs(n + A - (y + w)) + 1) * z);\n      w = A = z = 0;\n      v = g[e[d].index];\n      y = h[e[d].index];\n      -1 !== v && (z += Math.abs(v - m), A += Math.abs(v - r), w += Math.abs(v - n));\n      -1 !== y && (z += Math.abs(y - m), A += Math.abs(y - r), w += Math.abs(y - n));\n      if (q < p || q === p && A < z) l = k = !0, e[d].column = r;else if (u < p || u === p && w < z) l = k = !0, e[d].column = n;\n    }\n    ys(a, b, e);\n    a.normalize();\n    return k;\n  }\n  function bt(a, b, c) {\n    var d = xs(a, b),\n      e = a.zb[b],\n      f = Fs(a, b, c),\n      g = [];\n    for (c = 0; c < e; c++) g[c] = f[c];\n    for (f = !0; f;) for (f = !1, c = 0; c < e; c++) {\n      var h = d[c].column,\n        k = a.nodeMinColumnSpace(d[c], !0),\n        l = a.nodeMinColumnSpace(d[c], !1),\n        m = 0;\n      if (-1 === g[c]) {\n        if (0 === c && c === e - 1) m = h;else if (0 === c) {\n          var n = d[c + 1].column;\n          n - h === l + a.nodeMinColumnSpace(d[c + 1], !0) ? m = h - 1 : m = h;\n        } else c === e - 1 ? (n = d[c - 1].column, m = h - n === k + a.nodeMinColumnSpace(d[c - 1], !1) ? h + 1 : h) : (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = (k + l) / 2 | 0);\n      } else 0 === c && c === e - 1 ? m = g[c] : 0 === c ? (n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = Math.min(g[c], l)) : c === e - 1 ? (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, m = Math.max(g[c], k)) : (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, k < g[c] && g[c] < l ? m = g[c] : k >= g[c] ? m = k : l <= g[c] && (m = l));\n      m !== h && (f = !0, d[c].column = m);\n    }\n    ys(a, b, d);\n    a.normalize();\n  }\n  function et(a, b) {\n    for (var c = !0, d = a.network.vertexes.iterator; d.next();) {\n      var e = d.value,\n        f = a.nodeMinColumnSpace(e, !0),\n        g = a.nodeMinColumnSpace(e, !1);\n      if (e.column - f <= b && e.column + g >= b) {\n        c = !1;\n        break;\n      }\n    }\n    a = !1;\n    if (c) for (d.reset(); d.next();) c = d.value, c.column > b && (--c.column, a = !0);\n    return a;\n  }\n  function ft(a, b) {\n    var c = b + 1;\n    var d,\n      e = [],\n      f = [];\n    for (d = 0; d <= a.ra; d++) e[d] = !1, f[d] = !1;\n    for (var g = a.network.vertexes.iterator; g.next();) {\n      d = g.value;\n      var h = d.column - a.nodeMinColumnSpace(d, !0),\n        k = d.column + a.nodeMinColumnSpace(d, !1);\n      h <= b && k >= b && (e[d.layer] = !0);\n      h <= c && k >= c && (f[d.layer] = !0);\n    }\n    h = !0;\n    c = !1;\n    for (d = 0; d <= a.ra; d++) h = h && !(e[d] && f[d]);\n    if (h) for (g.reset(); g.next();) a = g.value, a.column > b && (--a.column, c = !0);\n    return c;\n  }\n  function ct(a, b) {\n    for (var c = 0; c <= a.Ba; c++) for (; et(a, c););\n    a.normalize();\n    for (c = 0; c < a.Ba; c++) for (; ft(a, c););\n    a.normalize();\n    var d;\n    if (0 < b) for (c = 0; c <= a.Ba; c++) {\n      var e = As(a);\n      var f = Ds(a);\n      for (d = f + 1; f < d;) {\n        d = f;\n        gt(a, c, 1);\n        var g = Ds(a);\n        g > f ? Bs(a, e) : g < f && (f = g, e = As(a));\n      }\n    }\n    if (0 > b) for (c = a.Ba; 0 <= c; c--) for (e = As(a), f = Ds(a), d = f + 1; f < d;) d = f, gt(a, c, -1), g = Ds(a), g > f ? Bs(a, e) : g < f && (f = g, e = As(a));\n    a.normalize();\n  }\n  function gt(a, b, c) {\n    a.Ec = 0;\n    for (var d = a.network.vertexes.iterator; d.next();) d.value.component = -1;\n    if (0 < c) for (d.reset(); d.next();) {\n      var e = d.value;\n      e.column - a.nodeMinColumnSpace(e, !0) <= b && (e.component = a.Ec);\n    }\n    if (0 > c) for (d.reset(); d.next();) e = d.value, e.column + a.nodeMinColumnSpace(e, !1) >= b && (e.component = a.Ec);\n    a.Ec++;\n    for (d.reset(); d.next();) b = d.value, -1 === b.component && (Hs(a, b, a.Ec, -1, !0, !0), a.Ec++);\n    var f;\n    b = [];\n    for (f = 0; f < a.Ec * a.Ec; f++) b[f] = !1;\n    e = [];\n    for (f = 0; f < (a.ra + 1) * (a.Ba + 1); f++) e[f] = -1;\n    for (d.reset(); d.next();) {\n      f = d.value;\n      for (var g = f.layer, h = Math.max(0, f.column - a.nodeMinColumnSpace(f, !0)), k = Math.min(a.Ba, f.column + a.nodeMinColumnSpace(f, !1)); h <= k; h++) e[g * (a.Ba + 1) + h] = f.component;\n    }\n    for (f = 0; f <= a.ra; f++) {\n      if (0 < c) for (g = 0; g < a.Ba; g++) -1 !== e[f * (a.Ba + 1) + g] && -1 !== e[f * (a.Ba + 1) + g + 1] && e[f * (a.Ba + 1) + g] !== e[f * (a.Ba + 1) + g + 1] && (b[e[f * (a.Ba + 1) + g] * a.Ec + e[f * (a.Ba + 1) + g + 1]] = !0);\n      if (0 > c) for (g = a.Ba; 0 < g; g--) -1 !== e[f * (a.Ba + 1) + g] && -1 !== e[f * (a.Ba + 1) + g - 1] && e[f * (a.Ba + 1) + g] !== e[f * (a.Ba + 1) + g - 1] && (b[e[f * (a.Ba + 1) + g] * a.Ec + e[f * (a.Ba + 1) + g - 1]] = !0);\n    }\n    e = [];\n    for (f = 0; f < a.Ec; f++) e[f] = !0;\n    g = [];\n    for (g.push(0); 0 !== g.length;) if (k = g[g.length - 1], g.pop(), e[k]) for (e[k] = !1, f = 0; f < a.Ec; f++) b[k * a.Ec + f] && g.splice(0, 0, f);\n    if (0 < c) for (d.reset(); d.next();) a = d.value, e[a.component] && --a.column;\n    if (0 > c) for (d.reset(); d.next();) c = d.value, e[c.component] && (c.column += 1);\n  }\n  os.prototype.commitLayout = function () {\n    if (this.setsPortSpots) for (var a = vs(this, !0), b = vs(this, !1), c = this.network.edges.iterator; c.next();) {\n      var d = c.value.link;\n      null !== d && (d.fromSpot = a, d.toSpot = b);\n    }\n    this.commitNodes();\n    this.Hv();\n    this.isRouting && this.commitLinks();\n  };\n  function vs(a, b) {\n    return 270 === a.J ? b ? fd : id : 90 === a.J ? b ? id : fd : 180 === a.J ? b ? gd : hd : b ? hd : gd;\n  }\n  os.prototype.commitNodes = function () {\n    this.Sd = [];\n    this.ud = [];\n    this.td = [];\n    this.Ia = [];\n    for (var a = 0; a <= this.ra; a++) this.Sd[a] = 0, this.ud[a] = 0, this.td[a] = 0, this.Ia[a] = 0;\n    for (a = this.network.vertexes.iterator; a.next();) {\n      var b = a.value,\n        c = b.layer;\n      this.Sd[c] = Math.max(this.Sd[c], this.nodeMinLayerSpace(b, !0));\n      this.ud[c] = Math.max(this.ud[c], this.nodeMinLayerSpace(b, !1));\n    }\n    b = 0;\n    c = this.qe;\n    for (var d = 0; d <= this.ra; d++) {\n      var e = c;\n      0 >= this.Sd[d] + this.ud[d] && (e = 0);\n      0 < d && (b += e / 2);\n      90 === this.J || 0 === this.J ? (b += this.ud[d], this.td[d] = b, b += this.Sd[d]) : (b += this.Sd[d], this.td[d] = b, b += this.ud[d]);\n      d < this.ra && (b += e / 2);\n      this.Ia[d] = b;\n    }\n    c = b;\n    b = this.arrangementOrigin;\n    for (d = 0; d <= this.ra; d++) 270 === this.J ? this.td[d] = b.y + this.td[d] : 90 === this.J ? (this.td[d] = b.y + c - this.td[d], this.Ia[d] = c - this.Ia[d]) : 180 === this.J ? this.td[d] = b.x + this.td[d] : (this.td[d] = b.x + c - this.td[d], this.Ia[d] = c - this.Ia[d]);\n    a.reset();\n    for (c = d = Infinity; a.next();) {\n      e = a.value;\n      var f = e.layer,\n        g = e.column | 0;\n      if (270 === this.J || 90 === this.J) {\n        var h = b.x + this.Zb * g;\n        f = this.td[f];\n      } else h = this.td[f], f = b.y + this.Zb * g;\n      e.centerX = h;\n      e.centerY = f;\n      d = Math.min(e.x, d);\n      c = Math.min(e.y, c);\n    }\n    d = b.x - d;\n    b = b.y - c;\n    this.Sc = new J(d, b);\n    for (a.reset(); a.next();) c = a.value, c.x += d, c.y += b, c.commit();\n  };\n  os.prototype.Hv = function () {\n    for (var a = 0, b = this.qe, c = 0; c <= this.ra; c++) a += this.Sd[c], a += this.ud[c];\n    a += this.ra * b;\n    b = [];\n    c = this.Zb * this.Ba;\n    for (var d = this.maxLayer; 0 <= d; d--) 270 === this.J ? 0 === d ? b.push(new N(0, 0, c, Math.abs(this.Ia[0]))) : b.push(new N(0, this.Ia[d - 1], c, Math.abs(this.Ia[d - 1] - this.Ia[d]))) : 90 === this.J ? 0 === d ? b.push(new N(0, this.Ia[0], c, Math.abs(this.Ia[0] - a))) : b.push(new N(0, this.Ia[d], c, Math.abs(this.Ia[d - 1] - this.Ia[d]))) : 180 === this.J ? 0 === d ? b.push(new N(0, 0, Math.abs(this.Ia[0]), c)) : b.push(new N(this.Ia[d - 1], 0, Math.abs(this.Ia[d - 1] - this.Ia[d]), c)) : 0 === d ? b.push(new N(this.Ia[0], 0, Math.abs(this.Ia[0] - a), c)) : b.push(new N(this.Ia[d], 0, Math.abs(this.Ia[d - 1] - this.Ia[d]), c));\n    this.commitLayers(b, this.Sc);\n  };\n  os.prototype.commitLayers = function () {};\n  os.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator, b; a.next();) b = a.value.link, null !== b && (b.Th(), b.lk(), b.xf());\n    for (a.reset(); a.next();) b = a.value.link, null !== b && b.wj();\n    for (a.reset(); a.next();) {\n      var c = a.value;\n      b = c.link;\n      if (null !== b) {\n        b.Th();\n        var d = b,\n          e = d.fromNode,\n          f = d.toNode,\n          g = d.fromPort,\n          h = d.toPort;\n        if (null !== e) {\n          var k = e.findVisibleNode();\n          null !== k && k !== e && (e = k, g = k.port);\n        }\n        null !== f && (k = f.findVisibleNode(), null !== k && k !== f && (f = k, h = k.port));\n        var l = b.computeSpot(!0, g);\n        k = b.computeSpot(!1, h);\n        var m = c.fromVertex,\n          n = c.toVertex;\n        if (c.valid) {\n          if (b.curve === pg && 4 === b.pointsCount) if (m.column === n.column) c = b.getLinkPoint(e, g, l, !0, !1, f, h), g = b.getLinkPoint(f, h, k, !1, !1, e, g), c.u() || c.set(e.actualBounds.center), g.u() || g.set(f.actualBounds.center), b.lk(), b.vf(c.x, c.y), b.vf((2 * c.x + g.x) / 3, (2 * c.y + g.y) / 3), b.vf((c.x + 2 * g.x) / 3, (c.y + 2 * g.y) / 3), b.vf(g.x, g.y);else {\n            var p = !1,\n              r = !1;\n            null !== g && l === vc && (p = !0);\n            null !== h && k === vc && (r = !0);\n            if (p || r) {\n              var q = b.i(0).x;\n              c = b.i(0).y;\n              m = b.i(3).x;\n              d = b.i(3).y;\n              p && (90 === this.J || 270 === this.J ? (p = q, n = (c + d) / 2) : (p = (q + m) / 2, n = c), b.K(1, p, n), l = b.getLinkPoint(e, g, l, !0, !1, f, h), l.u() || l.set(e.actualBounds.center), b.K(0, l.x, l.y));\n              r && (90 === this.J || 270 === this.J ? (l = m, c = (c + d) / 2) : (l = (q + m) / 2, c = d), b.K(2, l, c), e = b.getLinkPoint(f, h, k, !1, !1, e, g), e.u() || e.set(f.actualBounds.center), b.K(3, e.x, e.y));\n            }\n          }\n          b.xf();\n        } else if (m.layer === n.layer) b.xf();else {\n          p = r = !1;\n          q = b.firstPickIndex + 1;\n          if (b.isOrthogonal) {\n            p = !0;\n            var u = b.pointsCount;\n            4 < u && b.points.removeRange(2, u - 3);\n          } else if (b.curve === pg) r = !0, u = b.pointsCount, 4 < u && b.points.removeRange(2, u - 3), 4 === u && (q = 2);else {\n            u = b.pointsCount;\n            var v = l === vc,\n              w = k === vc;\n            2 < u && v && w ? b.points.removeRange(1, u - 2) : 3 < u && v && !w ? b.points.removeRange(1, u - 3) : 3 < u && !v && w ? b.points.removeRange(2, u - 2) : 4 < u && !v && !w && b.points.removeRange(2, u - 3);\n          }\n          if (c.rev) {\n            for (; null !== n && m !== n;) {\n              var y = u = null;\n              for (v = n.sourceEdges.iterator; v.next() && (w = v.value, w.link !== c.link || (u = w.fromVertex, y = w.toVertex, null !== u.node)););\n              if (u !== m) {\n                v = b.i(q - 1).x;\n                w = b.i(q - 1).y;\n                var z = u.centerX;\n                var A = u.centerY;\n                if (p) 180 === this.J || 0 === this.J ? q === b.firstPickIndex + 1 ? (b.m(q++, v, w), b.m(q++, v, A)) : (null !== y ? y.centerY : w) !== A && (y = this.Ia[u.layer - 1] + this.Sc.x, b.m(q++, y, w), b.m(q++, y, A)) : q === b.firstPickIndex + 1 ? (b.m(q++, v, w), b.m(q++, z, w)) : (null !== y ? y.centerX : v) !== z && (y = this.Ia[u.layer - 1] + this.Sc.y, b.m(q++, v, y), b.m(q++, z, y));else if (q === b.firstPickIndex + 1) {\n                  y = Math.max(10, this.Sd[n.layer]);\n                  var C = Math.max(10, this.ud[n.layer]);\n                  if (r) 180 === this.J ? z <= n.bounds.x ? (n = n.bounds.x, b.m(q++, n - y, A), b.m(q++, n, A), b.m(q++, n + C, A)) : (b.m(q++, z - y, A), b.m(q++, z, A), b.m(q++, z + C, A)) : 90 === this.J ? A >= n.bounds.bottom ? (n = n.bounds.y + n.bounds.height, b.m(q++, z, n + C), b.m(q++, z, n), b.m(q++, z, n - y)) : (b.m(q++, z, A + C), b.m(q++, z, A), b.m(q++, z, A - y)) : 270 === this.J ? A <= n.bounds.y ? (n = n.bounds.y, b.m(q++, z, n - y), b.m(q++, z, n), b.m(q++, z, n + C)) : (b.m(q++, z, A - y), b.m(q++, z, A), b.m(q++, z, A + C)) : 0 === this.J && (z >= n.bounds.right ? (n = n.bounds.x + n.bounds.width, b.m(q++, n + C, A), b.m(q++, n, A), b.m(q++, n - y, A)) : (b.m(q++, z + C, A), b.m(q++, z, A), b.m(q++, z - y, A)));else {\n                    b.m(q++, v, w);\n                    var G = 0;\n                    if (180 === this.J || 0 === this.J) {\n                      if (180 === this.J ? z >= n.bounds.right : z <= n.bounds.x) G = (0 === this.J ? -y : C) / 2;\n                      b.m(q++, v + G, A);\n                    } else {\n                      if (270 === this.J ? A >= n.bounds.bottom : A <= n.bounds.y) G = (90 === this.J ? -y : C) / 2;\n                      b.m(q++, z, w + G);\n                    }\n                    b.m(q++, z, A);\n                  }\n                } else y = Math.max(10, this.Sd[u.layer]), C = Math.max(10, this.ud[u.layer]), 180 === this.J ? (r && b.m(q++, z - y, A), b.m(q++, z, A), r && b.m(q++, z + C, A)) : 90 === this.J ? (r && b.m(q++, z, A + C), b.m(q++, z, A), r && b.m(q++, z, A - y)) : 270 === this.J ? (r && b.m(q++, z, A - y), b.m(q++, z, A), r && b.m(q++, z, A + C)) : (r && b.m(q++, z + C, A), b.m(q++, z, A), r && b.m(q++, z - y, A));\n              }\n              n = u;\n            }\n            if (null === h || l !== vc || p) if (v = b.i(q - 1).x, w = b.i(q - 1).y, z = b.i(q).x, A = b.i(q).y, p) n = this.ud[m.layer], 180 === this.J || 0 === this.J ? (p = w, p >= m.bounds.y && p <= m.bounds.bottom && (180 === this.J ? z >= m.bounds.x : z <= m.bounds.right) && (n = m.centerX + (180 === this.J ? -n : n), p < m.bounds.y + m.bounds.height / 2 ? p = m.bounds.y - this.Zb / 2 : p = m.bounds.bottom + this.Zb / 2, b.m(q++, n, w), b.m(q++, n, p)), b.m(q++, z, p)) : (p = v, p >= m.bounds.x && p <= m.bounds.right && (270 === this.J ? A >= m.bounds.y : A <= m.bounds.bottom) && (n = m.centerY + (270 === this.J ? -n : n), p < m.bounds.x + m.bounds.width / 2 ? p = m.bounds.x - this.Zb / 2 : p = m.bounds.right + this.Zb / 2, b.m(q++, v, n), b.m(q++, p, n)), b.m(q++, p, A)), b.m(q++, z, A);else if (r) y = Math.max(10, this.Sd[m.layer]), C = Math.max(10, this.ud[m.layer]), 180 === this.J && z >= m.bounds.x ? (n = m.bounds.x + m.bounds.width, b.K(q - 2, n, w), b.K(q - 1, n + C, w)) : 90 === this.J && A <= m.bounds.bottom ? (n = m.bounds.y, b.K(q - 2, v, n), b.K(q - 1, v, n - y)) : 270 === this.J && A >= m.bounds.y ? (n = m.bounds.y + m.bounds.height, b.K(q - 2, v, n), b.K(q - 1, v, n + C)) : 0 === this.J && z <= m.bounds.right && (n = m.bounds.x, b.K(q - 2, n, w), b.K(q - 1, n - y, w));else {\n              y = Math.max(10, this.Sd[m.layer]);\n              C = Math.max(10, this.ud[m.layer]);\n              p = 0;\n              if (180 === this.J || 0 === this.J) {\n                if (180 === this.J ? z <= m.bounds.x : z >= m.bounds.right) p = (0 === this.J ? C : -y) / 2;\n                b.m(q++, z + p, w);\n              } else {\n                if (270 === this.J ? A <= m.bounds.y : A >= m.bounds.bottom) p = (90 === this.J ? C : -y) / 2;\n                b.m(q++, v, A + p);\n              }\n              b.m(q++, z, A);\n            }\n          } else {\n            for (; null !== m && m !== n;) {\n              y = u = null;\n              for (m = m.destinationEdges.iterator; m.next() && (v = m.value, v.link !== c.link || (u = v.toVertex, y = v.fromVertex, null !== y.node && (y = null), null !== u.node)););\n              u !== n && (v = b.i(q - 1).x, w = b.i(q - 1).y, z = u.centerX, A = u.centerY, p ? 180 === this.J || 0 === this.J ? (null !== y ? y.centerY : w) !== A && (y = this.Ia[u.layer] + this.Sc.x, q === b.firstPickIndex + 1 && (y = 0 === this.J ? Math.max(y, v) : Math.min(y, v)), b.m(q++, y, w), b.m(q++, y, A)) : (null !== y ? y.centerX : v) !== z && (y = this.Ia[u.layer] + this.Sc.y, q === b.firstPickIndex + 1 && (y = 90 === this.J ? Math.max(y, w) : Math.min(y, w)), b.m(q++, v, y), b.m(q++, z, y)) : (y = Math.max(10, this.Sd[u.layer]), C = Math.max(10, this.ud[u.layer]), 180 === this.J ? (b.m(q++, z + C, A), r && b.m(q++, z, A), b.m(q++, z - y, A)) : 90 === this.J ? (b.m(q++, z, A - y), r && b.m(q++, z, A), b.m(q++, z, A + C)) : 270 === this.J ? (b.m(q++, z, A + C), r && b.m(q++, z, A), b.m(q++, z, A - y)) : (b.m(q++, z - y, A), r && b.m(q++, z, A), b.m(q++, z + C, A))));\n              m = u;\n            }\n            p && (v = b.i(q - 1).x, w = b.i(q - 1).y, z = b.i(q).x, A = b.i(q).y, 180 === this.J || 0 === this.J ? w !== A && (y = 0 === this.J ? Math.min(Math.max((z + v) / 2, this.Ia[n.layer] + this.Sc.x), z) : Math.max(Math.min((z + v) / 2, this.Ia[n.layer] + this.Sc.x), z), b.m(q++, y, w), b.m(q++, y, A)) : v !== z && (y = 90 === this.J ? Math.min(Math.max((A + w) / 2, this.Ia[n.layer] + this.Sc.y), A) : Math.max(Math.min((A + w) / 2, this.Ia[n.layer] + this.Sc.y), A), b.m(q++, v, y), b.m(q++, z, y)));\n          }\n          null !== d && r && (null !== g && (l === vc && (l = b.i(0), d = b.i(2), l.w(d) || b.K(1, (l.x + d.x) / 2, (l.y + d.y) / 2)), l = b.getLinkPoint(e, g, vc, !0, !1, f, h), l.u() || l.set(e.actualBounds.center), b.K(0, l.x, l.y)), null !== h && (k === vc && (k = b.i(b.pointsCount - 1), l = b.i(b.pointsCount - 3), k.w(l) || b.K(b.pointsCount - 2, (k.x + l.x) / 2, (k.y + l.y) / 2)), e = b.getLinkPoint(f, h, vc, !1, !1, e, g), e.u() || e.set(f.actualBounds.center), b.K(b.pointsCount - 1, e.x, e.y)));\n          b.xf();\n          c.commit();\n        }\n      }\n    }\n    this.avoidOrthogonalOverlaps();\n  };\n  os.prototype.avoidOrthogonalOverlaps = function () {\n    if (!(0 >= this.linkSpacing)) {\n      for (var a = new E(), b = this.network.edges.iterator; b.next();) {\n        var c = b.value.link;\n        null !== c && c.isOrthogonal && !a.contains(c) && a.add(c);\n      }\n      if (0 < a.count) if (90 === this.J || 270 === this.J) {\n        b = 0;\n        c = [];\n        for (a = a.iterator; a.next();) {\n          var d = a.value;\n          if (null !== d && d.isOrthogonal) for (var e = 2; e < d.pointsCount - 3; e++) {\n            var f = d.i(e);\n            var g = d.i(e + 1);\n            if (this.A(f.y, g.y) && !this.A(f.x, g.x)) {\n              var h = new ht();\n              h.layer = Math.floor(f.y / 2);\n              var k = d.i(0),\n                l = d.i(d.pointsCount - 1);\n              h.first = k.x * k.x + k.y;\n              h.Xb = l.x * l.x + l.y;\n              h.ad = Math.min(f.x, g.x);\n              h.uc = Math.max(f.x, g.x);\n              h.index = e;\n              h.link = d;\n              if (e + 2 < d.pointsCount) {\n                k = d.i(e - 1);\n                l = d.i(e + 2);\n                var m = 0;\n                k.y < f.y ? m = l.y < f.y ? 3 : f.x < g.x ? 2 : 1 : k.y > f.y && (m = l.y > f.y ? 0 : g.x < f.x ? 2 : 1);\n                h.l = m;\n              }\n              c.push(h);\n            }\n          }\n        }\n        if (1 < c.length) for (c.sort(this.Oy), a = 0; a < c.length;) {\n          f = c[a].layer;\n          for (d = a + 1; d < c.length && c[d].layer === f;) d++;\n          if (1 < d - a) for (f = a; f < d;) {\n            g = c[f].uc;\n            for (e = a + 1; e < d && c[e].ad < g;) g = Math.max(g, c[e].uc), e++;\n            g = e - f;\n            if (1 < g) {\n              this.tj(c, this.hu, f, f + g);\n              m = 1;\n              h = c[f].Xb;\n              for (k = f; k < e; k++) l = c[k], l.Xb !== h && (m++, h = l.Xb);\n              this.tj(c, this.Ny, f, f + g);\n              var n = 1;\n              h = c[f].first;\n              for (k = f; k < e; k++) l = c[k], l.first !== h && (n++, h = l.first);\n              k = !0;\n              l = n;\n              m < n ? (k = !1, l = m, h = c[f].Xb, this.tj(c, this.hu, f, f + g)) : h = c[f].first;\n              m = 0;\n              for (n = f; n < e; n++) {\n                var p = c[n];\n                (k ? p.first : p.Xb) !== h && (m++, h = k ? p.first : p.Xb);\n                var r = p.link;\n                f = r.i(p.index);\n                g = r.i(p.index + 1);\n                var q = this.linkSpacing * (m - (l - 1) / 2);\n                b++;\n                r.Th();\n                r.K(p.index, f.x, f.y + q);\n                r.K(p.index + 1, g.x, g.y + q);\n                r.xf();\n              }\n            }\n            f = e;\n          }\n          a = d;\n        }\n      } else {\n        b = 0;\n        c = [];\n        for (a = a.iterator; a.next();) if (d = a.value, null !== d && d.isOrthogonal) for (e = 2; e < d.pointsCount - 3; e++) f = d.i(e), g = d.i(e + 1), this.A(f.x, g.x) && !this.A(f.y, g.y) && (h = new ht(), h.layer = Math.floor(f.x / 2), k = d.i(0), l = d.i(d.pointsCount - 1), h.first = k.x + k.y * k.y, h.Xb = l.x + l.y * l.y, h.ad = Math.min(f.y, g.y), h.uc = Math.max(f.y, g.y), h.index = e, h.link = d, e + 2 < d.pointsCount && (k = d.i(e - 1), l = d.i(e + 2), m = 0, k.x < f.x ? m = l.x < f.x ? 3 : f.y < g.y ? 2 : 1 : k.x > f.x && (m = l.x > f.x ? 0 : g.y < f.y ? 2 : 1), h.l = m), c.push(h));\n        if (1 < c.length) for (c.sort(this.Oy), a = 0; a < c.length;) {\n          f = c[a].layer;\n          for (d = a + 1; d < c.length && c[d].layer === f;) d++;\n          if (1 < d - a) for (f = a; f < d;) {\n            g = c[f].uc;\n            for (e = a + 1; e < d && c[e].ad < g;) g = Math.max(g, c[e].uc), e++;\n            g = e - f;\n            if (1 < g) {\n              this.tj(c, this.hu, f, f + g);\n              m = 1;\n              h = c[f].Xb;\n              for (k = f; k < e; k++) l = c[k], l.Xb !== h && (m++, h = l.Xb);\n              this.tj(c, this.Ny, f, f + g);\n              n = 1;\n              h = c[f].first;\n              for (k = f; k < e; k++) l = c[k], l.first !== h && (n++, h = l.first);\n              k = !0;\n              l = n;\n              m < n ? (k = !1, l = m, h = c[f].Xb, this.tj(c, this.hu, f, f + g)) : h = c[f].first;\n              m = 0;\n              for (n = f; n < e; n++) p = c[n], (k ? p.first : p.Xb) !== h && (m++, h = k ? p.first : p.Xb), r = p.link, f = r.i(p.index), g = r.i(p.index + 1), q = this.linkSpacing * (m - (l - 1) / 2), b++, r.Th(), r.K(p.index, f.x + q, f.y), r.K(p.index + 1, g.x + q, g.y), r.xf();\n            }\n            f = e;\n          }\n          a = d;\n        }\n      }\n    }\n  };\n  t = os.prototype;\n  t.Oy = function (a, b) {\n    return a instanceof ht && b instanceof ht && a !== b ? a.layer < b.layer ? -1 : a.layer > b.layer ? 1 : a.ad < b.ad ? -1 : a.ad > b.ad ? 1 : a.uc < b.uc ? -1 : a.uc > b.uc ? 1 : 0 : 0;\n  };\n  t.Ny = function (a, b) {\n    return a instanceof ht && b instanceof ht && a !== b ? a.first < b.first ? -1 : a.first > b.first || a.l < b.l ? 1 : a.l > b.l || a.ad < b.ad ? -1 : a.ad > b.ad ? 1 : a.uc < b.uc ? -1 : a.uc > b.uc ? 1 : 0 : 0;\n  };\n  t.hu = function (a, b) {\n    return a instanceof ht && b instanceof ht && a !== b ? a.Xb < b.Xb ? -1 : a.Xb > b.Xb || a.l < b.l ? 1 : a.l > b.l || a.ad < b.ad ? -1 : a.ad > b.ad ? 1 : a.uc < b.uc ? -1 : a.uc > b.uc ? 1 : 0 : 0;\n  };\n  t.A = function (a, b) {\n    a -= b;\n    return -1 < a && 1 > a;\n  };\n  t.tj = function (a, b, c, d) {\n    var e = a.length,\n      f = d - c;\n    if (!(1 >= f)) if ((0 > c || c >= e - 1) && B(\"not in range 0 <= from < length: \" + c), 2 === f) d = a[c], e = a[c + 1], 0 < b(d, e) && (a[c] = e, a[c + 1] = d);else if (0 === c) {\n      if (d >= e) a.sort(b);else for (c = a.slice(0, d), c.sort(b), b = 0; b < d; b++) a[b] = c[b];\n    } else if (d >= e) for (d = a.slice(c), d.sort(b), b = c; b < e; b++) a[b] = d[b - c];else for (e = a.slice(c, d), e.sort(b), b = c; b < d; b++) a[b] = e[b - c];\n  };\n  function xs(a, b) {\n    var c = a.zb[b];\n    if (c >= a.te.length) {\n      var d = [];\n      for (var e = 0; e < a.te.length; e++) d[e] = a.te[e];\n      a.te = d;\n    }\n    void 0 === a.te[c] || null === a.te[c] ? d = [] : (d = a.te[c], a.te[c] = null);\n    a = a.bp[b];\n    for (b = 0; b < a.length; b++) c = a[b], d[c.index] = c;\n    return d;\n  }\n  function ys(a, b, c) {\n    a.te[a.zb[b]] = c;\n  }\n  ma.Object.defineProperties(os.prototype, {\n    layerSpacing: {\n      get: function () {\n        return this.qe;\n      },\n      set: function (a) {\n        this.qe !== a && 0 <= a && (this.qe = a, this.C());\n      }\n    },\n    columnSpacing: {\n      get: function () {\n        return this.Zb;\n      },\n      set: function (a) {\n        this.Zb !== a && 0 < a && (this.Zb = a, this.C());\n      }\n    },\n    direction: {\n      get: function () {\n        return this.J;\n      },\n      set: function (a) {\n        this.J !== a && (0 === a || 90 === a || 180 === a || 270 === a ? (this.J = a, this.C()) : B(\"LayeredDigraphLayout.direction must be 0, 90, 180, or 270\"));\n      }\n    },\n    cycleRemoveOption: {\n      get: function () {\n        return this.cl;\n      },\n      set: function (a) {\n        this.cl === a || a !== Is && a !== ps && a !== us || (this.cl = a, this.C());\n      }\n    },\n    layeringOption: {\n      get: function () {\n        return this.Gl;\n      },\n      set: function (a) {\n        this.Gl === a || a !== qs && a !== Ns && a !== Ps || (this.Gl = a, this.C());\n      }\n    },\n    initializeOption: {\n      get: function () {\n        return this.vl;\n      },\n      set: function (a) {\n        this.vl === a || a !== rs && a !== Vs && a !== Ts || (this.vl = a, this.C());\n      }\n    },\n    iterations: {\n      get: function () {\n        return this.Oj;\n      },\n      set: function (a) {\n        this.Oj !== a && 0 <= a && (this.Oj = a, this.C());\n      }\n    },\n    aggressiveOption: {\n      get: function () {\n        return this.Sk;\n      },\n      set: function (a) {\n        this.Sk === a || a !== Zs && a !== ss && a !== $s || (this.Sk = a, this.C());\n      }\n    },\n    packOption: {\n      get: function () {\n        return this.ng;\n      },\n      set: function (a) {\n        this.ng !== a && 0 <= a && 8 > a && (this.ng = a, this.C());\n      }\n    },\n    setsPortSpots: {\n      get: function () {\n        return this.hf;\n      },\n      set: function (a) {\n        this.hf !== a && (this.hf = a, this.C());\n      }\n    },\n    linkSpacing: {\n      get: function () {\n        return this.Io;\n      },\n      set: function (a) {\n        this.Io !== a && 0 <= a && (this.Io = a, this.C());\n      }\n    },\n    maxLayer: {\n      get: function () {\n        return this.ra;\n      }\n    },\n    maxIndex: {\n      get: function () {\n        return this.Ii;\n      }\n    },\n    maxColumn: {\n      get: function () {\n        return this.Ba;\n      }\n    },\n    minIndexLayer: {\n      get: function () {\n        return this.lh;\n      }\n    },\n    maxIndexLayer: {\n      get: function () {\n        return this.oc;\n      }\n    }\n  });\n  var ps = new D(os, \"CycleDepthFirst\", 0),\n    Is = new D(os, \"CycleGreedy\", 1),\n    us = new D(os, \"CycleFromLayers\", 2),\n    qs = new D(os, \"LayerOptimalLinkLength\", 0),\n    Ns = new D(os, \"LayerLongestPathSink\", 1),\n    Ps = new D(os, \"LayerLongestPathSource\", 2),\n    rs = new D(os, \"InitDepthFirstOut\", 0),\n    Vs = new D(os, \"InitDepthFirstIn\", 1),\n    Ts = new D(os, \"InitNaive\", 2),\n    Zs = new D(os, \"AggressiveNone\", 0),\n    ss = new D(os, \"AggressiveLess\", 1),\n    $s = new D(os, \"AggressiveMore\", 2);\n  os.className = \"LayeredDigraphLayout\";\n  os.CycleDepthFirst = ps;\n  os.CycleGreedy = Is;\n  os.CycleFromLayers = us;\n  os.LayerOptimalLinkLength = qs;\n  os.LayerLongestPathSink = Ns;\n  os.LayerLongestPathSource = Ps;\n  os.InitDepthFirstOut = rs;\n  os.InitDepthFirstIn = Vs;\n  os.InitNaive = Ts;\n  os.AggressiveNone = Zs;\n  os.AggressiveLess = ss;\n  os.AggressiveMore = $s;\n  os.PackNone = 0;\n  os.PackExpand = 1;\n  os.PackStraighten = 2;\n  os.PackMedian = 4;\n  os.PackAll = 7;\n  function ht() {\n    this.index = this.uc = this.ad = this.Xb = this.first = this.layer = 0;\n    this.link = null;\n    this.l = 0;\n  }\n  ht.className = \"SegInfo\";\n  function ts(a) {\n    Rp.call(this, a);\n  }\n  la(ts, Rp);\n  ts.prototype.createVertex = function () {\n    return new it(this);\n  };\n  ts.prototype.createEdge = function () {\n    return new jt(this);\n  };\n  ts.className = \"LayeredDigraphNetwork\";\n  function it(a) {\n    eq.call(this, a);\n    this.Pa = this.Rg = this.Ei = -1;\n    this.I = NaN;\n    this.T = null;\n    this.valid = !1;\n    this.finish = this.Cg = NaN;\n    this.wf = 0;\n    this.Hk = this.Ik = null;\n  }\n  la(it, eq);\n  it.prototype.serializeVertexProperties = function (a, b) {\n    eq.prototype.serializeVertexProperties.call(this, a, b);\n    a.layer = this.layer;\n    a.column = this.column;\n    a.index = this.index;\n    a.component = this.component;\n    a.near = this.near ? mb(this.near) : null;\n    a.valid = this.valid;\n    a.Cg = this.Cg;\n    a.finish = this.finish;\n    a.wf = this.wf;\n    a.Ik = this.Ik;\n    a.Hk = this.Hk;\n  };\n  it.prototype.Aq = function (a, b, c, d) {\n    eq.prototype.Aq.call(this, a, b, c, d);\n    this.layer = a.layer;\n    this.column = a.column;\n    this.index = a.index;\n    this.component = a.component;\n    if (b = b.get(a.near)) this.near = b;\n    this.valid = a.valid;\n    this.Cg = a.Cg;\n    this.finish = a.finish;\n    this.wf = a.wf;\n    this.Ik = a.Ik;\n    this.Hk = a.Hk;\n  };\n  ma.Object.defineProperties(it.prototype, {\n    layer: {\n      get: function () {\n        return this.Ei;\n      },\n      set: function (a) {\n        this.Ei !== a && (this.Ei = a);\n      }\n    },\n    column: {\n      get: function () {\n        return this.Rg;\n      },\n      set: function (a) {\n        this.Rg !== a && (this.Rg = a);\n      }\n    },\n    index: {\n      get: function () {\n        return this.Pa;\n      },\n      set: function (a) {\n        this.Pa !== a && (this.Pa = a);\n      }\n    },\n    component: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I !== a && (this.I = a);\n      }\n    },\n    near: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T !== a && (this.T = a);\n      }\n    }\n  });\n  it.className = \"LayeredDigraphVertex\";\n  function jt(a) {\n    fq.call(this, a);\n    this.l = this.Ka = this.cb = !1;\n    this.Ja = this.I = NaN;\n    this.T = this.v = 0;\n  }\n  la(jt, fq);\n  jt.prototype.serializeEdgeProperties = function (a, b) {\n    fq.prototype.serializeEdgeProperties.call(this, a, b);\n    a.valid = this.valid;\n    a.rev = this.rev;\n    a.forest = this.forest;\n    a.portFromPos = this.portFromPos;\n    a.portToPos = this.portToPos;\n    a.portFromColOffset = this.portFromColOffset;\n    a.portToColOffset = this.portToColOffset;\n  };\n  jt.prototype.deserializeEdgeProperties = function (a, b, c, d) {\n    fq.prototype.deserializeEdgeProperties.call(this, a, b, c, d);\n    this.valid = a.valid;\n    this.rev = a.rev;\n    this.forest = a.forest;\n    this.portFromPos = a.portFromPos;\n    this.portToPos = a.portToPos;\n    this.portFromColOffset = a.portFromColOffset;\n    this.portToColOffset = a.portToColOffset;\n  };\n  ma.Object.defineProperties(jt.prototype, {\n    valid: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb !== a && (this.cb = a);\n      }\n    },\n    rev: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka !== a && (this.Ka = a);\n      }\n    },\n    forest: {\n      get: function () {\n        return this.l;\n      },\n      set: function (a) {\n        this.l !== a && (this.l = a);\n      }\n    },\n    portFromPos: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        this.I !== a && (this.I = a);\n      }\n    },\n    portToPos: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja !== a && (this.Ja = a);\n      }\n    },\n    portFromColOffset: {\n      get: function () {\n        return this.v;\n      },\n      set: function (a) {\n        this.v !== a && (this.v = a);\n      }\n    },\n    portToColOffset: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T !== a && (this.T = a);\n      }\n    }\n  });\n  jt.className = \"LayeredDigraphEdge\";\n  function kt() {\n    yi.call(this);\n    this.Jb = new F();\n    this.qp = lt;\n    this.fd = mt;\n    this.mq = nt;\n    this.vs = ot;\n    this.lx = [];\n    this.ed = !0;\n    this.Eb = pt;\n    this.Hd = new M(10, 10).freeze();\n    var a = new qt(this);\n    this.U = new rt(a);\n    this.V = new rt(a);\n    this.uv = [];\n  }\n  la(kt, yi);\n  kt.prototype.cloneProtected = function (a) {\n    yi.prototype.cloneProtected.call(this, a);\n    a.qp = this.qp;\n    a.mq = this.mq;\n    a.vs = this.vs;\n    a.ed = this.ed;\n    a.Eb = this.Eb;\n    a.Hd.assign(this.Hd);\n    a.U.copyInheritedPropertiesFrom(this.U);\n    a.V.copyInheritedPropertiesFrom(this.V);\n  };\n  kt.prototype.hb = function (a) {\n    a.classType === kt ? 0 === a.name.indexOf(\"Alignment\") ? this.alignment = a : 0 === a.name.indexOf(\"Arrangement\") ? this.arrangement = a : 0 === a.name.indexOf(\"Compaction\") ? this.compaction = a : 0 === a.name.indexOf(\"Path\") ? this.path = a : 0 === a.name.indexOf(\"Sorting\") ? this.sorting = a : 0 === a.name.indexOf(\"Style\") ? this.treeStyle = a : B(\"Unknown enum value: \" + a) : yi.prototype.hb.call(this, a);\n  };\n  kt.prototype.createNetwork = function () {\n    return new qt(this);\n  };\n  kt.prototype.makeNetwork = function (a) {\n    function b(a) {\n      if (a instanceof V) return !a.isLinkLabel && \"Comment\" !== a.category;\n      if (a instanceof S) {\n        var b = a.fromNode;\n        if (null === b || b.isLinkLabel || \"Comment\" === b.category) return !1;\n        a = a.toNode;\n        return null === a || a.isLinkLabel || \"Comment\" === a.category ? !1 : !0;\n      }\n      return !1;\n    }\n    var c = this.createNetwork();\n    a instanceof Q ? (c.Ag(a.nodes, !0, b), c.Ag(a.links, !0, b)) : a instanceof vf ? c.Ag(a.memberParts, !1, b) : c.Ag(a.iterator, !1, b);\n    return c;\n  };\n  kt.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    this.arrangement !== st && (this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin));\n    var b = this.diagram;\n    null === b && a instanceof Q && (b = a);\n    this.path === lt && null !== b ? this.fd = b.isTreePathToChildren ? mt : tt : this.fd = this.path === lt ? mt : this.path;\n    if (0 < this.network.vertexes.count) {\n      this.network.zq();\n      for (a = this.network.vertexes.iterator; a.next();) b = a.value, b.initialized = !1, b.level = 0, b.parent = null, b.children = [];\n      if (0 < this.Jb.count) {\n        a = new F();\n        for (b = this.Jb.iterator; b.next();) {\n          var c = b.value;\n          c instanceof V ? (c = this.network.kj(c), null !== c && a.add(c)) : c instanceof rt && a.add(c);\n        }\n        this.Jb = a;\n      }\n      0 === this.Jb.count && this.findRoots();\n      for (a = this.Jb.copy().iterator; a.next();) b = a.value, b.initialized || (b.initialized = !0, ut(this, b));\n      b = this.network.vertexes;\n      for (a = null; a = vt(b), 0 < a.count;) b = wt(this, a), null !== b && this.Jb.add(b), b.initialized = !0, ut(this, b), b = a;\n      for (a = this.Jb.iterator; a.next();) b = a.value, b instanceof rt && xt(this, b);\n      for (a = this.Jb.iterator; a.next();) b = a.value, b instanceof rt && yt(this, b);\n      for (a = this.Jb.iterator; a.next();) b = a.value, b instanceof rt && zt(this, b);\n      this.Fv();\n      if (this.layerStyle === At) {\n        a = [];\n        for (b = this.network.vertexes.iterator; b.next();) {\n          c = b.value;\n          var d = c.parent;\n          null === d && (d = c);\n          d = 0 === d.angle || 180 === d.angle;\n          var e = a[c.level];\n          void 0 === e && (e = 0);\n          a[c.level] = Math.max(e, d ? c.width : c.height);\n        }\n        for (b = 0; b < a.length; b++) void 0 === a[b] && (a[b] = 0);\n        this.lx = a;\n        for (b = this.network.vertexes.iterator; b.next();) c = b.value, d = c.parent, null === d && (d = c), 0 === d.angle || 180 === d.angle ? (180 === d.angle && (c.focusX += a[c.level] - c.width), c.width = a[c.level]) : (270 === d.angle && (c.focusY += a[c.level] - c.height), c.height = a[c.level]);\n      } else if (this.layerStyle === Bt) for (a = this.network.vertexes.iterator; a.next();) {\n        b = a.value;\n        c = 0 === b.angle || 180 === b.angle;\n        d = -1;\n        for (e = 0; e < b.children.length; e++) {\n          var f = b.children[e];\n          d = Math.max(d, c ? f.width : f.height);\n        }\n        if (0 <= d) for (e = 0; e < b.children.length; e++) f = b.children[e], c ? (180 === b.angle && (f.focusX += d - f.width), f.width = d) : (270 === b.angle && (f.focusY += d - f.height), f.height = d);\n      }\n      for (a = this.Jb.iterator; a.next();) b = a.value, b instanceof rt && this.layoutTree(b);\n      this.arrangeTrees();\n      this.updateParts();\n    }\n    this.network = null;\n    this.Jb = new F();\n    this.isValidLayout = !0;\n  };\n  function vt(a) {\n    var b = new F();\n    for (a = a.iterator; a.next();) {\n      var c = a.value;\n      c.initialized || b.add(c);\n    }\n    return b;\n  }\n  kt.prototype.findRoots = function () {\n    for (var a = this.network.vertexes, b = a.iterator; b.next();) {\n      var c = b.value;\n      switch (this.fd) {\n        case mt:\n          0 === c.sourceEdges.count && this.Jb.add(c);\n          break;\n        case tt:\n          0 === c.destinationEdges.count && this.Jb.add(c);\n          break;\n        default:\n          B(\"Unhandled path value \" + this.fd.toString());\n      }\n    }\n    0 === this.Jb.count && (a = wt(this, a), null !== a && this.Jb.add(a));\n  };\n  function wt(a, b) {\n    var c = 999999,\n      d = null;\n    for (b = b.iterator; b.next();) {\n      var e = b.value;\n      switch (a.fd) {\n        case mt:\n          e.sourceEdges.count < c && (c = e.sourceEdges.count, d = e);\n          break;\n        case tt:\n          e.destinationEdges.count < c && (c = e.destinationEdges.count, d = e);\n          break;\n        default:\n          B(\"Unhandled path value \" + a.fd.toString());\n      }\n    }\n    return d;\n  }\n  function ut(a, b) {\n    if (null !== b) {\n      switch (a.fd) {\n        case mt:\n          if (0 < b.destinationEdges.count) {\n            for (var c = new E(), d = b.destinationVertexes; d.next();) {\n              var e = d.value;\n              Ct(a, b, e) && c.add(e);\n            }\n            0 < c.count && (b.children = c.ma());\n          }\n          break;\n        case tt:\n          if (0 < b.sourceEdges.count) {\n            c = new E();\n            for (d = b.sourceVertexes; d.next();) e = d.value, Ct(a, b, e) && c.add(e);\n            0 < c.count && (b.children = c.ma());\n          }\n          break;\n        default:\n          B(\"Unhandled path value\" + a.fd.toString());\n      }\n      c = b.children;\n      d = c.length;\n      for (e = 0; e < d; e++) {\n        var f = c[e];\n        f.initialized = !0;\n        f.level = b.level + 1;\n        f.parent = b;\n        a.Jb.remove(f);\n      }\n      for (b = 0; b < d; b++) ut(a, c[b]);\n    }\n  }\n  function Ct(a, b, c) {\n    if (c.initialized) {\n      if (null === b) var d = !1;else {\n        for (d = b.parent; null !== d && d !== c;) d = d.parent;\n        d = d === c;\n      }\n      if (d || c.level > b.level) return !1;\n      a.removeChild(c.parent, c);\n    }\n    return !0;\n  }\n  kt.prototype.removeChild = function (a, b) {\n    if (null !== a && null !== b) {\n      for (var c = a.children, d = 0, e = 0; e < c.length; e++) c[e] === b && d++;\n      if (0 < d) {\n        d = Array(c.length - d);\n        for (var f = e = 0; f < c.length; f++) c[f] !== b && (d[e++] = c[f]);\n        a.children = d;\n      }\n    }\n  };\n  function xt(a, b) {\n    if (null !== b) {\n      a.initializeTreeVertexValues(b);\n      b.alignment === Dt && a.sortTreeVertexChildren(b);\n      for (var c = 0, d = b.childrenCount, e = 0, f = b.children, g = f.length, h = 0; h < g; h++) {\n        var k = f[h];\n        xt(a, k);\n        c += k.descendantCount + 1;\n        d = Math.max(d, k.maxChildrenCount);\n        e = Math.max(e, k.maxGenerationCount);\n      }\n      b.descendantCount = c;\n      b.maxChildrenCount = d;\n      b.maxGenerationCount = 0 < d ? e + 1 : 0;\n    }\n  }\n  function Et(a, b) {\n    switch (a.mq) {\n      default:\n      case nt:\n        return null !== b.parent ? b.parent : a.U;\n      case Ft:\n        return null === b.parent ? a.U : null === b.parent.parent ? a.V : b.parent;\n      case Gt:\n        return null !== b.parent ? null !== b.parent.parent ? b.parent.parent : a.V : a.U;\n      case Ht:\n        var c = !0;\n        if (0 === b.childrenCount) c = !1;else for (var d = b.children, e = d.length, f = 0; f < e; f++) if (0 < d[f].childrenCount) {\n          c = !1;\n          break;\n        }\n        return c && null !== b.parent ? a.V : null !== b.parent ? b.parent : a.U;\n    }\n  }\n  kt.prototype.initializeTreeVertexValues = function (a) {\n    a.copyInheritedPropertiesFrom(Et(this, a));\n    if (null !== a.parent && a.parent.alignment === Dt) {\n      for (var b = a.angle, c = a.parent.children, d = 0; d < c.length && a !== c[d];) d++;\n      0 === d % 2 ? d !== c.length - 1 && (b = 90 === b ? 180 : 180 === b ? 270 : 270 === b ? 180 : 270) : b = 90 === b ? 0 : 180 === b ? 90 : 270 === b ? 0 : 90;\n      a.angle = b;\n    }\n    a.initialized = !0;\n  };\n  function yt(a, b) {\n    if (null !== b) {\n      a.assignTreeVertexValues(b);\n      b = b.children;\n      for (var c = b.length, d = 0; d < c; d++) yt(a, b[d]);\n    }\n  }\n  kt.prototype.assignTreeVertexValues = function () {};\n  function zt(a, b) {\n    if (null !== b) {\n      b.alignment !== Dt && a.sortTreeVertexChildren(b);\n      b = b.children;\n      for (var c = b.length, d = 0; d < c; d++) zt(a, b[d]);\n    }\n  }\n  kt.prototype.sortTreeVertexChildren = function (a) {\n    switch (a.sorting) {\n      case It:\n        break;\n      case Jt:\n        a.children.reverse();\n        break;\n      case Kt:\n        a.children.sort(a.comparer);\n        break;\n      case Lt:\n        a.children.sort(a.comparer);\n        a.children.reverse();\n        break;\n      default:\n        B(\"Unhandled sorting value \" + a.sorting.toString());\n    }\n  };\n  kt.prototype.Fv = function () {\n    if (this.comments) for (var a = this.network.vertexes.iterator; a.next();) this.addComments(a.value);\n  };\n  kt.prototype.addComments = function (a) {\n    var b = a.angle,\n      c = a.parent,\n      d = 0;\n    var e = !1;\n    null !== c && (d = c.angle, e = c.alignment, e = Mt(e));\n    b = 90 === b || 270 === b;\n    d = 90 === d || 270 === d;\n    c = 0 === a.childrenCount;\n    var f = 0,\n      g = 0,\n      h = 0,\n      k = a.commentSpacing;\n    if (null !== a.node) for (var l = a.node.Rv(); l.next();) {\n      var m = l.value;\n      \"Comment\" === m.category && m.canLayout() && (null === a.comments && (a.comments = []), a.comments.push(m), m.Ta(), m = m.measuredBounds, b && !c || !e && !d && c || e && d && c ? (f = Math.max(f, m.width), g += m.height + Math.abs(h)) : (f += m.width + Math.abs(h), g = Math.max(g, m.height)), h = k);\n    }\n    null !== a.comments && (b && !c || !e && !d && c || e && d && c ? (f += Math.abs(a.commentMargin), g = Math.max(0, g - a.height)) : (g += Math.abs(a.commentMargin), f = Math.max(0, f - a.width)), e = N.allocAt(0, 0, a.bounds.width + f, a.bounds.height + g), a.bounds = e, N.free(e));\n  };\n  function Mt(a) {\n    return a === Nt || a === Dt || a === Ot || a === Pt;\n  }\n  function Qt(a) {\n    return a === Nt || a === Dt;\n  }\n  function Rt(a) {\n    var b = a.parent;\n    if (null !== b) {\n      var c = b.alignment;\n      if (Mt(c)) {\n        if (Qt(c)) {\n          b = b.children;\n          for (c = 0; c < b.length && a !== b[c];) c++;\n          return 0 === c % 2;\n        }\n        if (c === Ot) return !0;\n      }\n    }\n    return !1;\n  }\n  kt.prototype.layoutComments = function (a) {\n    if (null !== a.comments) {\n      var b = a.node.measuredBounds,\n        c = a.parent,\n        d = a.angle,\n        e = 0;\n      var f = !1;\n      null !== c && (e = c.angle, f = c.alignment, f = Mt(f));\n      d = 90 === d || 270 === d;\n      c = 90 === e || 270 === e;\n      for (var g = 0 === a.childrenCount, h = Rt(a), k = 0, l = a.comments, m = l.length, n = J.alloc(), p = 0; p < m; p++) {\n        var r = l[p],\n          q = r.measuredBounds;\n        if (d && !g || !f && !c && g || f && c && g) {\n          if (135 < e && !f || c && h) {\n            if (0 <= a.commentMargin) for (n.h(a.bounds.x - a.commentMargin - q.width, a.bounds.y + k), r.move(n), r = r.Bd(); r.next();) {\n              var u = r.value;\n              u.fromSpot = gd;\n              u.toSpot = hd;\n            } else for (n.h(a.bounds.x + 2 * a.focus.x - a.commentMargin, a.bounds.y + k), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = hd, u.toSpot = gd;\n          } else if (0 <= a.commentMargin) for (n.h(a.bounds.x + 2 * a.focus.x + a.commentMargin, a.bounds.y + k), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = hd, u.toSpot = gd;else for (n.h(a.bounds.x + a.commentMargin - q.width, a.bounds.y + k), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = gd, u.toSpot = hd;\n          k = 0 <= a.commentSpacing ? k + (q.height + a.commentSpacing) : k + (a.commentSpacing - q.height);\n        } else {\n          if (135 < e && !f || !c && h) {\n            if (0 <= a.commentMargin) for (n.h(a.bounds.x + k, a.bounds.y - a.commentMargin - q.height), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = fd, u.toSpot = id;else for (n.h(a.bounds.x + k, a.bounds.y + 2 * a.focus.y - a.commentMargin), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = id, u.toSpot = fd;\n          } else if (0 <= a.commentMargin) for (n.h(a.bounds.x + k, a.bounds.y + 2 * a.focus.y + a.commentMargin), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = id, u.toSpot = fd;else for (n.h(a.bounds.x + k, a.bounds.y + a.commentMargin - q.height), r.move(n), r = r.Bd(); r.next();) u = r.value, u.fromSpot = fd, u.toSpot = id;\n          k = 0 <= a.commentSpacing ? k + (q.width + a.commentSpacing) : k + (a.commentSpacing - q.width);\n        }\n      }\n      J.free(n);\n      b = k - a.commentSpacing - (d ? b.height : b.width);\n      if (this.fd === mt) for (a = a.destinationEdges; a.next();) e = a.value.link, null === e || e.isAvoiding || (e.fromEndSegmentLength = 0 < b ? b : NaN);else for (a = a.sourceEdges; a.next();) e = a.value.link, null === e || e.isAvoiding || (e.toEndSegmentLength = 0 < b ? b : NaN);\n    }\n  };\n  kt.prototype.layoutTree = function (a) {\n    if (null !== a) {\n      for (var b = a.children, c = b.length, d = 0; d < c; d++) this.layoutTree(b[d]);\n      switch (a.compaction) {\n        case St:\n          Tt(this, a);\n          break;\n        case Ut:\n          if (a.alignment === Dt) Tt(this, a);else if (0 === a.childrenCount) d = a.parent, c = !1, b = 0, null !== d && (b = d.angle, c = d.alignment, c = Mt(c)), d = Rt(a), a.S.h(0, 0), a.ua.h(a.width, a.height), null === a.parent || null === a.comments || (180 !== b && 270 !== b || c) && !d ? a.da.h(0, 0) : 180 === b && !c || (90 === b || 270 === b) && d ? a.da.h(a.width - 2 * a.focus.x, 0) : a.da.h(0, a.height - 2 * a.focus.y), a.Pq = null, a.cr = null;else {\n            var e = Vt(a);\n            b = 90 === e || 270 === e;\n            var f = 0,\n              g = a.children,\n              h = g.length;\n            for (c = 0; c < h; c++) d = g[c], f = Math.max(f, b ? d.ua.width : d.ua.height);\n            var k = a.alignment,\n              l = k === Wt,\n              m = Mt(k),\n              n = Math.max(0, a.breadthLimit);\n            c = bu(a);\n            var p = a.nodeSpacing,\n              r = cu(a),\n              q = a.rowSpacing,\n              u = 0;\n            if (k === du || l || a.Rm || a.Sm && 1 === a.maxGenerationCount) u = Math.max(0, a.rowIndent);\n            d = a.width;\n            var v = a.height,\n              w = 0,\n              y = 0,\n              z = 0,\n              A = null,\n              C = null,\n              G = 0,\n              L = 0,\n              I = 0,\n              T = 0,\n              R = 0,\n              ca = 0,\n              qa = 0,\n              O = 0;\n            m && !Qt(k) && 135 < e && g.reverse();\n            if (Qt(k)) if (1 < h) for (var za = 0; za < h; za++) 0 === za % 2 && za !== h - 1 && (O = Math.max(O, b ? g[za].ua.width : g[za].ua.height));else 1 === h && (O = b ? g[0].ua.width : g[0].ua.height);\n            if (m) {\n              switch (k) {\n                case Nt:\n                  y = 135 > e ? eu(a, g, O, w, y) : fu(a, g, O, w, y);\n                  O = y.x;\n                  w = y.width;\n                  y = y.height;\n                  break;\n                case Ot:\n                  for (A = 0; A < h; A++) C = g[A], n = C.ua, z = 0 === ca ? 0 : q, b ? (C.S.h(f - n.width, T + z), w = Math.max(w, n.width), y = Math.max(y, T + z + n.height), T += z + n.height) : (C.S.h(I + z, f - n.height), w = Math.max(w, I + z + n.width), y = Math.max(y, n.height), I += z + n.width), ca++;\n                  break;\n                case Pt:\n                  for (A = 0; A < h; A++) C = g[A], f = C.ua, n = 0 === ca ? 0 : q, b ? (C.S.h(p / 2 + a.focus.x, T + n), w = Math.max(w, f.width), y = Math.max(y, T + n + f.height), T += n + f.height) : (C.S.h(I + n, p / 2 + a.focus.y), w = Math.max(w, I + n + f.width), y = Math.max(y, f.height), I += n + f.width), ca++;\n              }\n              A = gu(this, 2);\n              C = gu(this, 2);\n              b ? (A[0].h(0, 0), A[1].h(0, y), C[0].h(w, 0)) : (A[0].h(0, 0), A[1].h(w, 0), C[0].h(0, y));\n              C[1].h(w, y);\n            } else for (za = 0; za < h; za++) {\n              var Ma = g[za],\n                jb = Ma.ua;\n              if (b) {\n                0 < n && 0 < ca && I + p + jb.width > n && (I < f && hu(a, k, f - I, 0, qa, za - 1), R++, ca = 0, qa = za, z = y, I = 0, T = 135 < e ? -y - q : y + q);\n                iu(this, Ma, 0, T);\n                var Fa = 0;\n                if (0 === ca) {\n                  if (A = Ma.Pq, C = Ma.cr, G = jb.width, L = jb.height, null === A || null === C || e !== Vt(Ma)) A = gu(this, 2), C = gu(this, 2), A[0].h(0, 0), A[1].h(0, L), C[0].h(G, 0), C[1].h(G, L);\n                } else {\n                  var yb = Ea();\n                  L = ju(this, a, Ma, A, C, G, L, yb);\n                  Fa = L.x;\n                  A = yb[0];\n                  C = yb[1];\n                  G = L.width;\n                  L = L.height;\n                  Ha(yb);\n                  I < jb.width && 0 > Fa && (ku(a, -Fa, 0, qa, za - 1), lu(A, -Fa, 0), lu(C, -Fa, 0), Fa = 0);\n                }\n                Ma.S.h(Fa, T);\n                w = Math.max(w, G);\n                y = Math.max(y, z + (0 === R ? 0 : q) + jb.height);\n                I = G;\n              } else {\n                0 < n && 0 < ca && T + p + jb.height > n && (T < f && hu(a, k, 0, f - T, qa, za - 1), R++, ca = 0, qa = za, z = w, T = 0, I = 135 < e ? -w - q : w + q);\n                iu(this, Ma, I, 0);\n                Fa = 0;\n                if (0 === ca) {\n                  if (A = Ma.Pq, C = Ma.cr, G = jb.width, L = jb.height, null === A || null === C || e !== Vt(Ma)) A = gu(this, 2), C = gu(this, 2), A[0].h(0, 0), A[1].h(G, 0), C[0].h(0, L), C[1].h(G, L);\n                } else yb = Ea(), L = ju(this, a, Ma, A, C, G, L, yb), Fa = L.x, A = yb[0], C = yb[1], G = L.width, L = L.height, Ha(yb), T < jb.height && 0 > Fa && (ku(a, 0, -Fa, qa, za - 1), lu(A, 0, -Fa), lu(C, 0, -Fa), Fa = 0);\n                Ma.S.h(I, Fa);\n                y = Math.max(y, L);\n                w = Math.max(w, z + (0 === R ? 0 : q) + jb.width);\n                T = L;\n              }\n              ca++;\n            }\n            0 < R && (b ? (y += Math.max(0, c), I < w && hu(a, k, w - I, 0, qa, h - 1), 0 < u && (l || ku(a, u, 0, 0, h - 1), w += u)) : (w += Math.max(0, c), T < y && hu(a, k, 0, y - T, qa, h - 1), 0 < u && (l || ku(a, 0, u, 0, h - 1), y += u)));\n            u = l = 0;\n            switch (k) {\n              case mu:\n                b ? l += w / 2 - a.focus.x - r / 2 : u += y / 2 - a.focus.y - r / 2;\n                break;\n              case nu:\n                0 < R ? b ? l += w / 2 - a.focus.x - r / 2 : u += y / 2 - a.focus.y - r / 2 : b ? (O = g[0].S.x + g[0].da.x, l += O + (g[h - 1].S.x + g[h - 1].da.x + 2 * g[h - 1].focus.x - O) / 2 - a.focus.x - r / 2) : (O = g[0].S.y + g[0].da.y, u += O + (g[h - 1].S.y + g[h - 1].da.y + 2 * g[h - 1].focus.y - O) / 2 - a.focus.y - r / 2);\n                break;\n              case du:\n                b ? (l -= r, w += r) : (u -= r, y += r);\n                break;\n              case Wt:\n                b ? (l += w - a.width + r, w += r) : (u += y - a.height + r, y += r);\n                break;\n              case Nt:\n                b ? 1 < h ? l += O + p / 2 - a.focus.x : l += g[0].focus.x - a.focus.x + g[0].da.x : 1 < h ? u += O + p / 2 - a.focus.y : u += g[0].focus.y - a.focus.y + g[0].da.y;\n                break;\n              case Ot:\n                b ? l += w + p / 2 - a.focus.x : u += y + p / 2 - a.focus.y;\n                break;\n              case Pt:\n                break;\n              default:\n                B(\"Unhandled alignment value \" + k.toString());\n            }\n            for (r = 0; r < h; r++) O = g[r], b ? O.S.h(O.S.x + O.da.x - l, O.S.y + (135 < e ? (m ? -y : -O.ua.height) + O.da.y - c : v + c + O.da.y)) : O.S.h(O.S.x + (135 < e ? (m ? -w : -O.ua.width) + O.da.x - c : d + c + O.da.x), O.S.y + O.da.y - u);\n            h = g = 0;\n            m ? b ? (w = ou(a, w, l), 0 > l && (l = 0), 135 < e && (u += y + c), y += v + c, k === Pt && (g += p / 2 + a.focus.x), h += v + c) : (135 < e && (l += w + c), w += d + c, y = pu(a, y, u), 0 > u && (u = 0), k === Pt && (h += p / 2 + a.focus.y), g += d + c) : b ? (null === a.comments ? d > w && (w = qu(k, d - w, 0), g = w.x, h = w.y, w = d, l = 0) : w = ou(a, w, l), 0 > l && (g -= l, l = 0), 135 < e && (u += y + c), y = Math.max(Math.max(y, v), y + v + c), h += v + c) : (135 < e && (l += w + c), w = Math.max(Math.max(w, d), w + d + c), null === a.comments ? v > y && (y = qu(k, 0, v - y), g = y.x, h = y.y, y = v, u = 0) : y = pu(a, y, u), 0 > u && (h -= u, u = 0), g += d + c);\n            if (0 < R) e = gu(this, 4), R = gu(this, 4), b ? (e[2].h(0, v + c), e[3].h(e[2].x, y), R[2].h(w, e[2].y), R[3].h(R[2].x, e[3].y)) : (e[2].h(d + c, 0), e[3].h(w, e[2].y), R[2].h(e[2].x, y), R[3].h(e[3].x, R[2].y));else {\n              e = gu(this, A.length + 2);\n              R = gu(this, C.length + 2);\n              for (k = 0; k < A.length; k++) m = A[k], e[k + 2].h(m.x + g, m.y + h);\n              for (k = 0; k < C.length; k++) m = C[k], R[k + 2].h(m.x + g, m.y + h);\n            }\n            b ? (e[0].h(l, 0), e[1].h(e[0].x, v), e[2].y < e[1].y && (e[2].x > e[0].x ? e[2].assign(e[1]) : e[1].assign(e[2])), e[3].y < e[2].y && (e[3].x > e[0].x ? e[3].assign(e[2]) : e[2].assign(e[3])), R[0].h(l + d, 0), R[1].h(R[0].x, v), R[2].y < R[1].y && (R[2].x < R[0].x ? R[2].assign(R[1]) : R[1].assign(R[2])), R[3].y < R[2].y && (R[3].x < R[0].x ? R[3].assign(R[2]) : R[2].assign(R[3])), e[2].y -= c / 2, R[2].y -= c / 2) : (e[0].h(0, u), e[1].h(d, e[0].y), e[2].x < e[1].x && (e[2].y > e[0].y ? e[2].assign(e[1]) : e[1].assign(e[2])), e[3].x < e[2].x && (e[3].y > e[0].y ? e[3].assign(e[2]) : e[2].assign(e[3])), R[0].h(0, u + v), R[1].h(d, R[0].y), R[2].x < R[1].x && (R[2].y < R[0].y ? R[2].assign(R[1]) : R[1].assign(R[2])), R[3].x < R[2].x && (R[3].y < R[0].y ? R[3].assign(R[2]) : R[2].assign(R[3])), e[2].x -= c / 2, R[2].x -= c / 2);\n            ru(this, A);\n            ru(this, C);\n            a.Pq = e;\n            a.cr = R;\n            a.da.h(l, u);\n            a.ua.h(w, y);\n          }\n          break;\n        default:\n          B(\"Unhandled compaction value \" + a.compaction.toString());\n      }\n    }\n  };\n  function Tt(a, b) {\n    if (0 === b.childrenCount) {\n      var c = !1,\n        d = 0;\n      null !== b.parent && (d = b.parent.angle, c = b.parent.alignment, c = Mt(c));\n      var e = Rt(b);\n      b.S.h(0, 0);\n      b.ua.h(b.width, b.height);\n      null === b.parent || null === b.comments || (180 !== d && 270 !== d || c) && !e ? b.da.h(0, 0) : 180 === d && !c || (90 === d || 270 === d) && e ? b.da.h(b.width - 2 * b.focus.x, 0) : b.da.h(0, b.height - 2 * b.focus.y);\n    } else {\n      d = Vt(b);\n      c = 90 === d || 270 === d;\n      var f = 0;\n      e = b.children;\n      for (var g = e.length, h = 0; h < g; h++) {\n        var k = e[h];\n        f = Math.max(f, c ? k.ua.width : k.ua.height);\n      }\n      var l = b.alignment,\n        m = l === du,\n        n = l === Wt;\n      h = Mt(l);\n      var p = Math.max(0, b.breadthLimit);\n      k = bu(b);\n      var r = b.nodeSpacing,\n        q = cu(b),\n        u = m || n ? 0 : q / 2,\n        v = b.rowSpacing,\n        w = 0;\n      if (m || n || b.Rm || b.Sm && 1 === b.maxGenerationCount) w = Math.max(0, b.rowIndent);\n      m = b.width;\n      var y = b.height,\n        z = 0,\n        A = 0,\n        C = 0,\n        G = 0,\n        L = 0,\n        I = 0,\n        T = 0,\n        R = 0,\n        ca = 0;\n      h && !Qt(l) && 135 < d && e.reverse();\n      if (Qt(l)) if (1 < g) for (var qa = 0; qa < g; qa++) {\n        var O = e[qa],\n          za = O.ua;\n        0 === qa % 2 && qa !== g - 1 && (ca = Math.max(ca, (c ? za.width : za.height) + su(O) - r));\n      } else 1 === g && (ca = c ? e[0].ua.width : e[0].ua.height);\n      if (h) switch (l) {\n        case Nt:\n        case Dt:\n          A = 135 > d ? eu(b, e, ca, z, A) : fu(b, e, ca, z, A);\n          ca = A.x;\n          z = A.width;\n          A = A.height;\n          break;\n        case Ot:\n          for (a = 0; a < g; a++) p = e[a], u = p.ua, C = 0 === T ? 0 : v, c ? (p.S.h(f - u.width, L + C), z = Math.max(z, u.width), A = Math.max(A, L + C + u.height), L += C + u.height) : (p.S.h(G + C, f - u.height), z = Math.max(z, G + C + u.width), A = Math.max(A, u.height), G += C + u.width), T++;\n          break;\n        case Pt:\n          for (f = 0; f < g; f++) a = e[f], p = a.ua, u = 0 === T ? 0 : v, c ? (a.S.h(r / 2 + b.focus.x, L + u), z = Math.max(z, p.width), A = Math.max(A, L + u + p.height), L += u + p.height) : (a.S.h(G + u, r / 2 + b.focus.y), z = Math.max(z, G + u + p.width), A = Math.max(A, p.height), G += u + p.width), T++;\n      } else for (qa = 0; qa < g; qa++) {\n        O = e[qa];\n        za = O.ua;\n        if (c) {\n          0 < p && 0 < T && G + r + za.width > p && (G < f && hu(b, l, f - G, 0, R, qa - 1), I++, T = 0, R = qa, C = A, G = 0, L = 135 < d ? -A - v : A + v);\n          var Ma = 0 === T ? u : r;\n          iu(a, O, 0, L);\n          O.S.h(G + Ma, L);\n          z = Math.max(z, G + Ma + za.width);\n          A = Math.max(A, C + (0 === I ? 0 : v) + za.height);\n          G += Ma + za.width;\n        } else 0 < p && 0 < T && L + r + za.height > p && (L < f && hu(b, l, 0, f - L, R, qa - 1), I++, T = 0, R = qa, C = z, L = 0, G = 135 < d ? -z - v : z + v), Ma = 0 === T ? u : r, iu(a, O, G, 0), O.S.h(G, L + Ma), A = Math.max(A, L + Ma + za.height), z = Math.max(z, C + (0 === I ? 0 : v) + za.width), L += Ma + za.height;\n        T++;\n      }\n      0 < I && (c ? (A += Math.max(0, k), G < z && hu(b, l, z - G, 0, R, g - 1), 0 < w && (n || ku(b, w, 0, 0, g - 1), z += w)) : (z += Math.max(0, k), L < A && hu(b, l, 0, A - L, R, g - 1), 0 < w && (n || ku(b, 0, w, 0, g - 1), A += w)));\n      w = n = 0;\n      switch (l) {\n        case mu:\n          c ? n += z / 2 - b.focus.x - q / 2 : w += A / 2 - b.focus.y - q / 2;\n          break;\n        case nu:\n          0 < I ? c ? n += z / 2 - b.focus.x - q / 2 : w += A / 2 - b.focus.y - q / 2 : c ? (l = e[0].S.x + e[0].da.x, n += l + (e[g - 1].S.x + e[g - 1].da.x + 2 * e[g - 1].focus.x - l) / 2 - b.focus.x - q / 2) : (l = e[0].S.y + e[0].da.y, w += l + (e[g - 1].S.y + e[g - 1].da.y + 2 * e[g - 1].focus.y - l) / 2 - b.focus.y - q / 2);\n          break;\n        case du:\n          c ? (n -= q, z += q) : (w -= q, A += q);\n          break;\n        case Wt:\n          c ? (n += z - b.width + q, z += q) : (w += A - b.height + q, A += q);\n          break;\n        case Nt:\n        case Dt:\n          c ? 1 < g ? n += ca + r / 2 - b.focus.x : n += e[0].focus.x - b.focus.x + e[0].da.x : 1 < g ? w += ca + r / 2 - b.focus.y : w += e[0].focus.y - b.focus.y + e[0].da.y;\n          break;\n        case Ot:\n          c ? n += z + r / 2 - b.focus.x : w += A + r / 2 - b.focus.y;\n          break;\n        case Pt:\n          break;\n        default:\n          B(\"Unhandled alignment value \" + l.toString());\n      }\n      for (q = 0; q < g; q++) l = e[q], c ? l.S.h(l.S.x + l.da.x - n, l.S.y + (135 < d ? (h ? -A : -l.ua.height) + l.da.y - k : y + k + l.da.y)) : l.S.h(l.S.x + (135 < d ? (h ? -z : -l.ua.width) + l.da.x - k : m + k + l.da.x), l.S.y + l.da.y - w);\n      c ? (z = ou(b, z, n), 0 > n && (n = 0), 135 < d && (w += A + k), A = Math.max(Math.max(A, y), A + y + k)) : (135 < d && (n += z + k), z = Math.max(Math.max(z, m), z + m + k), A = pu(b, A, w), 0 > w && (w = 0));\n      b.da.h(n, w);\n      b.ua.h(z, A);\n    }\n  }\n  function eu(a, b, c, d, e) {\n    var f = b.length;\n    if (0 === f) return new N(c, 0, d, e);\n    if (1 === f) return a = b[0], d = a.ua.width, e = a.ua.height, new N(c, 0, d, e);\n    for (var g = a.nodeSpacing, h = a.rowSpacing, k = 90 === Vt(a), l = 0, m = 0, n = 0, p = 0; p < f; p++) if (!(0 !== p % 2 || 1 < f && p === f - 1)) {\n      var r = b[p],\n        q = r.ua,\n        u = 0 === l ? 0 : h;\n      if (k) {\n        var v = su(r) - g;\n        r.S.h(c - (q.width + v), n + u);\n        d = Math.max(d, q.width + v);\n        e = Math.max(e, n + u + q.height);\n        n += u + q.height;\n      } else v = su(r) - g, r.S.h(m + u, c - (q.height + v)), e = Math.max(e, q.height + v), d = Math.max(d, m + u + q.width), m += u + q.width;\n      l++;\n    }\n    l = 0;\n    r = m;\n    p = n;\n    k ? (m = c + g, n = 0) : (m = 0, n = c + g);\n    for (q = 0; q < f; q++) if (0 !== q % 2) {\n      u = b[q];\n      v = u.ua;\n      var w = 0 === l ? 0 : h;\n      if (k) {\n        var y = su(u) - g;\n        u.S.h(m + y, n + w);\n        d = Math.max(d, m + v.width + y);\n        e = Math.max(e, n + w + v.height);\n        n += w + v.height;\n      } else y = su(u) - g, u.S.h(m + w, n + y), d = Math.max(d, m + w + v.width), e = Math.max(e, n + v.height + y), m += w + v.width;\n      l++;\n    }\n    1 < f && 1 === f % 2 && (b = b[f - 1], f = b.ua, h = null === b.parent ? 0 : b.parent.rowSpacing, k ? (b.S.h(c + g / 2 - b.focus.x - b.da.x, e + h), k = c + g / 2 - b.focus.x - b.da.x, d = Math.max(d, k + f.width), 0 > k && (d -= k), e = Math.max(e, Math.max(p, n) + h + f.height), 0 > b.S.x && (c = tu(a, b.S.x, !1, c, g))) : (b.S.h(d + h, c + g / 2 - b.focus.y - b.da.y), d = Math.max(d, Math.max(r, m) + h + f.width), n = c + g / 2 - b.focus.y - b.da.y, e = Math.max(e, n + f.height), 0 > n && (e -= n), 0 > b.S.y && (c = tu(a, b.S.y, !0, c, g))));\n    return new N(c, 0, d, e);\n  }\n  function fu(a, b, c, d, e) {\n    var f = b.length;\n    if (0 === f) return new N(c, 0, d, e);\n    if (1 === f) return b = b[0], d = b.ua.width, e = b.ua.height, new N(c, 0, d, e);\n    for (var g = a.nodeSpacing, h = a.rowSpacing, k = 270 === Vt(a), l = 0, m = 0, n = 0, p = 0; p < f; p++) if (!(0 !== p % 2 || 1 < f && p === f - 1)) {\n      var r = b[p],\n        q = r.ua,\n        u = 0 === l ? 0 : h;\n      if (k) {\n        var v = su(r) - g;\n        n -= u + q.height;\n        r.S.h(c - (q.width + v), n);\n        d = Math.max(d, q.width + v);\n        e = Math.max(e, Math.abs(n));\n      } else v = su(r) - g, m -= u + q.width, r.S.h(m, c - (q.height + v)), e = Math.max(e, q.height + v), d = Math.max(d, Math.abs(m));\n      l++;\n    }\n    l = 0;\n    r = m;\n    p = n;\n    k ? (m = c + g, n = 0) : (m = 0, n = c + g);\n    for (q = 0; q < f; q++) if (0 !== q % 2) {\n      u = b[q];\n      v = u.ua;\n      var w = 0 === l ? 0 : h;\n      if (k) {\n        var y = su(u) - g;\n        n -= w + v.height;\n        u.S.h(m + y, n);\n        d = Math.max(d, m + v.width + y);\n        e = Math.max(e, Math.abs(n));\n      } else y = su(u) - g, m -= w + v.width, u.S.h(m, n + y), e = Math.max(e, n + v.height + y), d = Math.max(d, Math.abs(m));\n      l++;\n    }\n    1 < f && 1 === f % 2 && (h = b[f - 1], l = h.ua, q = null === h.parent ? 0 : h.parent.rowSpacing, k ? (h.S.h(c + g / 2 - h.focus.x - h.da.x, -e - l.height - q), m = c + g / 2 - h.focus.x - h.da.x, d = Math.max(d, m + l.width), 0 > m && (d -= m), e = Math.max(e, Math.abs(Math.min(p, n)) + q + l.height), 0 > h.S.x && (c = tu(a, h.S.x, !1, c, g))) : (h.S.h(-d - l.width - q, c + g / 2 - h.focus.y - h.da.y), d = Math.max(d, Math.abs(Math.min(r, m)) + q + l.width), n = c + g / 2 - h.focus.y - h.da.y, e = Math.max(e, n + l.height), 0 > n && (e -= n), 0 > h.S.y && (c = tu(a, h.S.y, !0, c, g))));\n    for (a = 0; a < f; a++) g = b[a], k ? g.S.h(g.S.x, g.S.y + e) : g.S.h(g.S.x + d, g.S.y);\n    return new N(c, 0, d, e);\n  }\n  function su(a) {\n    return null === a.parent ? 0 : a.parent.nodeSpacing;\n  }\n  function tu(a, b, c, d, e) {\n    a = a.children;\n    for (var f = a.length, g = 0; g < f; g++) c ? a[g].S.h(a[g].S.x, a[g].S.y - b) : a[g].S.h(a[g].S.x - b, a[g].S.y);\n    b = a[f - 1];\n    return Math.max(d, c ? b.da.y + b.focus.y - e / 2 : b.da.x + b.focus.x - e / 2);\n  }\n  function ou(a, b, c) {\n    switch (a.alignment) {\n      case nu:\n      case mu:\n        return c + a.width > b && (b = c + a.width), 0 > c && (b -= c), b;\n      case du:\n        return a.width > b ? a.width : b;\n      case Wt:\n        return 2 * a.focus.x > b ? a.width : b + a.width - 2 * a.focus.x;\n      case Nt:\n      case Dt:\n        return Math.max(a.width, Math.max(b, c + a.width) - Math.min(0, c));\n      case Ot:\n        return a.width - a.focus.x + a.nodeSpacing / 2 + b;\n      case Pt:\n        return Math.max(a.width, a.focus.x + a.nodeSpacing / 2 + b);\n      default:\n        return b;\n    }\n  }\n  function pu(a, b, c) {\n    switch (a.alignment) {\n      case nu:\n      case mu:\n        return c + a.height > b && (b = c + a.height), 0 > c && (b -= c), b;\n      case du:\n        return a.height > b ? a.height : b;\n      case Wt:\n        return 2 * a.focus.y > b ? a.height : b + a.height - 2 * a.focus.y;\n      case Nt:\n      case Dt:\n        return Math.max(a.height, Math.max(b, c + a.height) - Math.min(0, c));\n      case Ot:\n        return a.height - a.focus.y + a.nodeSpacing / 2 + b;\n      case Pt:\n        return Math.max(a.height, a.focus.y + a.nodeSpacing / 2 + b);\n      default:\n        return b;\n    }\n  }\n  function qu(a, b, c) {\n    switch (a) {\n      case mu:\n        b /= 2;\n        c /= 2;\n        break;\n      case nu:\n        b /= 2;\n        c /= 2;\n        break;\n      case du:\n        c = b = 0;\n        break;\n      case Wt:\n        break;\n      default:\n        B(\"Unhandled alignment value \" + a.toString());\n    }\n    return new J(b, c);\n  }\n  function hu(a, b, c, d, e, f) {\n    b = qu(b, c, d);\n    ku(a, b.x, b.y, e, f);\n  }\n  function ku(a, b, c, d, e) {\n    if (0 !== b || 0 !== c) for (a = a.children; d <= e; d++) {\n      var f = a[d].S;\n      f.x += b;\n      f.y += c;\n    }\n  }\n  function iu(a, b, c, d) {\n    var e = b.parent;\n    switch (a.fd) {\n      case mt:\n        for (a = b.sourceEdges; a.next();) b = a.value, b.fromVertex === e && b.relativePoint.h(c, d);\n        break;\n      case tt:\n        for (a = b.destinationEdges; a.next();) b = a.value, b.toVertex === e && b.relativePoint.h(c, d);\n        break;\n      default:\n        B(\"Unhandled path value \" + a.fd.toString());\n    }\n  }\n  function lu(a, b, c) {\n    for (var d = 0; d < a.length; d++) {\n      var e = a[d];\n      e.x += b;\n      e.y += c;\n    }\n  }\n  function ju(a, b, c, d, e, f, g, h) {\n    var k = Vt(b),\n      l = 90 === k || 270 === k,\n      m = b.nodeSpacing;\n    b = d;\n    var n = e;\n    d = f;\n    var p = g,\n      r = c.Pq,\n      q = c.cr;\n    g = c.ua;\n    var u = l ? Math.max(p, g.height) : Math.max(d, g.width);\n    if (null === r || k !== Vt(c)) r = gu(a, 2), q = gu(a, 2), l ? (r[0].h(0, 0), r[1].h(0, g.height), q[0].h(g.width, 0), q[1].h(q[0].x, r[1].y)) : (r[0].h(0, 0), r[1].h(g.width, 0), q[0].h(0, g.height), q[1].h(r[1].x, q[0].y));\n    if (l) {\n      p = 9999999;\n      if (!(null === n || 2 > n.length || null === r || 2 > r.length)) for (e = c = 0; c < n.length && e < r.length;) {\n        f = n[c];\n        var v = r[e];\n        k = v.x;\n        l = v.y;\n        k += d;\n        var w = f;\n        c + 1 < n.length && (w = n[c + 1]);\n        var y = v;\n        v = y.x;\n        y = y.y;\n        e + 1 < r.length && (y = r[e + 1], v = y.x, y = y.y, v += d);\n        var z = p;\n        f.y === l ? z = k - f.x : f.y > l && f.y < y ? z = k + (f.y - l) / (y - l) * (v - k) - f.x : l > f.y && l < w.y && (z = k - (f.x + (l - f.y) / (w.y - f.y) * (w.x - f.x)));\n        z < p && (p = z);\n        w.y <= f.y ? c++ : y <= l ? e++ : (w.y <= y && c++, y <= w.y && e++);\n      }\n      p = d - p;\n      p += m;\n      c = r;\n      e = p;\n      if (null === b || 2 > b.length || null === c || 2 > c.length) d = null;else {\n        m = gu(a, b.length + c.length);\n        for (d = f = k = 0; f < c.length && c[f].y < b[0].y;) l = c[f++], m[d++].h(l.x + e, l.y);\n        for (; k < b.length;) l = b[k++], m[d++].h(l.x, l.y);\n        for (k = b[b.length - 1].y; f < c.length && c[f].y <= k;) f++;\n        for (; f < c.length && c[f].y > k;) l = c[f++], m[d++].h(l.x + e, l.y);\n        c = gu(a, d);\n        for (k = 0; k < d; k++) c[k].assign(m[k]);\n        ru(a, m);\n        d = c;\n      }\n      f = q;\n      k = p;\n      if (null === n || 2 > n.length || null === f || 2 > f.length) e = null;else {\n        m = gu(a, n.length + f.length);\n        for (e = l = c = 0; c < n.length && n[c].y < f[0].y;) w = n[c++], m[e++].h(w.x, w.y);\n        for (; l < f.length;) w = f[l++], m[e++].h(w.x + k, w.y);\n        for (f = f[f.length - 1].y; c < n.length && n[c].y <= f;) c++;\n        for (; c < n.length && n[c].y > f;) k = n[c++], m[e++].h(k.x, k.y);\n        f = gu(a, e);\n        for (c = 0; c < e; c++) f[c].assign(m[c]);\n        ru(a, m);\n        e = f;\n      }\n      f = Math.max(0, p) + g.width;\n      g = u;\n      ru(a, b);\n      ru(a, r);\n      ru(a, n);\n      ru(a, q);\n      h[0] = d;\n      h[1] = e;\n      return new N(p, 0, f, g);\n    }\n    d = 9999999;\n    if (!(null === n || 2 > n.length || null === r || 2 > r.length)) for (e = c = 0; c < n.length && e < r.length;) f = n[c], v = r[e], k = v.x, l = v.y, l += p, w = f, c + 1 < n.length && (w = n[c + 1]), y = v, v = y.x, y = y.y, e + 1 < r.length && (y = r[e + 1], v = y.x, y = y.y, y += p), z = d, f.x === k ? z = l - f.y : f.x > k && f.x < v ? z = l + (f.x - k) / (v - k) * (y - l) - f.y : k > f.x && k < w.x && (z = l - (f.y + (k - f.x) / (w.x - f.x) * (w.y - f.y))), z < d && (d = z), w.x <= f.x ? c++ : v <= k ? e++ : (w.x <= v && c++, v <= w.x && e++);\n    p -= d;\n    p += m;\n    c = r;\n    e = p;\n    if (null === b || 2 > b.length || null === c || 2 > c.length) d = null;else {\n      m = gu(a, b.length + c.length);\n      for (d = f = k = 0; f < c.length && c[f].x < b[0].x;) l = c[f++], m[d++].h(l.x, l.y + e);\n      for (; k < b.length;) l = b[k++], m[d++].h(l.x, l.y);\n      for (k = b[b.length - 1].x; f < c.length && c[f].x <= k;) f++;\n      for (; f < c.length && c[f].x > k;) l = c[f++], m[d++].h(l.x, l.y + e);\n      c = gu(a, d);\n      for (k = 0; k < d; k++) c[k].assign(m[k]);\n      ru(a, m);\n      d = c;\n    }\n    f = q;\n    k = p;\n    if (null === n || 2 > n.length || null === f || 2 > f.length) e = null;else {\n      m = gu(a, n.length + f.length);\n      for (e = l = c = 0; c < n.length && n[c].x < f[0].x;) w = n[c++], m[e++].h(w.x, w.y);\n      for (; l < f.length;) w = f[l++], m[e++].h(w.x, w.y + k);\n      for (f = f[f.length - 1].x; c < n.length && n[c].x <= f;) c++;\n      for (; c < n.length && n[c].x > f;) k = n[c++], m[e++].h(k.x, k.y);\n      f = gu(a, e);\n      for (c = 0; c < e; c++) f[c].assign(m[c]);\n      ru(a, m);\n      e = f;\n    }\n    f = u;\n    g = Math.max(0, p) + g.height;\n    ru(a, b);\n    ru(a, r);\n    ru(a, n);\n    ru(a, q);\n    h[0] = d;\n    h[1] = e;\n    return new N(p, 0, f, g);\n  }\n  function gu(a, b) {\n    a = a.uv[b];\n    if (void 0 !== a && (a = a.pop(), void 0 !== a)) return a;\n    a = [];\n    for (var c = 0; c < b; c++) a[c] = new J();\n    return a;\n  }\n  function ru(a, b) {\n    var c = b.length,\n      d = a.uv[c];\n    void 0 === d && (d = [], a.uv[c] = d);\n    d.push(b);\n  }\n  kt.prototype.arrangeTrees = function () {\n    if (this.Eb === st) for (var a = this.Jb.iterator; a.next();) {\n      var b = a.value;\n      if (b instanceof rt) {\n        var c = b.node;\n        if (null !== c) {\n          var d = c.position;\n          c = d.x;\n          d = d.y;\n          isFinite(c) || (c = 0);\n          isFinite(d) || (d = 0);\n          uu(this, b, c, d);\n        }\n      }\n    } else {\n      a = [];\n      for (b = this.Jb.iterator; b.next();) c = b.value, c instanceof rt && a.push(c);\n      switch (this.sorting) {\n        case It:\n          break;\n        case Jt:\n          a.reverse();\n          break;\n        case Kt:\n          a.sort(this.comparer);\n          break;\n        case Lt:\n          a.sort(this.comparer);\n          a.reverse();\n          break;\n        default:\n          B(\"Unhandled sorting value \" + this.sorting.toString());\n      }\n      c = this.arrangementOrigin;\n      b = c.x;\n      c = c.y;\n      for (d = 0; d < a.length; d++) {\n        var e = a[d];\n        uu(this, e, b + e.da.x, c + e.da.y);\n        switch (this.Eb) {\n          case pt:\n            c += e.ua.height + this.Hd.height;\n            break;\n          case vu:\n            b += e.ua.width + this.Hd.width;\n            break;\n          default:\n            B(\"Unhandled arrangement value \" + this.Eb.toString());\n        }\n      }\n    }\n  };\n  function uu(a, b, c, d) {\n    if (null !== b) {\n      b.x = c;\n      b.y = d;\n      b = b.children;\n      for (var e = b.length, f = 0; f < e; f++) {\n        var g = b[f];\n        uu(a, g, c + g.S.x, d + g.S.y);\n      }\n    }\n  }\n  kt.prototype.commitLayout = function () {\n    this.Cw();\n    this.commitNodes();\n    this.Hv();\n    this.isRouting && this.commitLinks();\n  };\n  kt.prototype.commitNodes = function () {\n    for (var a = this.network.vertexes.iterator; a.next();) a.value.commit();\n    for (a.reset(); a.next();) this.layoutComments(a.value);\n  };\n  kt.prototype.Hv = function () {\n    if (this.layerStyle === At) {\n      for (var a = this.lx, b = [], c = null, d = this.network.vertexes.iterator; d.next();) {\n        var e = d.value;\n        null === c ? c = e.bounds.copy() : c.Oc(e.bounds);\n        var f = b[e.level];\n        void 0 === f ? f = bu(e) : f = Math.max(f, bu(e));\n        b[e.level] = f;\n      }\n      for (d = 0; d < b.length; d++) void 0 === b[d] && (b[d] = 0);\n      90 === this.angle || 270 === this.angle ? (c.Ic(this.nodeSpacing / 2, this.layerSpacing), d = new J(-this.nodeSpacing / 2, -this.layerSpacing / 2)) : (c.Ic(this.layerSpacing, this.nodeSpacing / 2), d = new J(-this.layerSpacing / 2, -this.nodeSpacing / 2));\n      e = [];\n      c = 90 === this.angle || 270 === this.angle ? c.width : c.height;\n      f = 0;\n      if (180 === this.angle || 270 === this.angle) for (var g = 0; g < a.length; g++) f += a[g] + b[g];\n      for (g = 0; g < a.length; g++) {\n        var h = a[g] + b[g];\n        270 === this.angle ? (f -= h, e.push(new N(0, f, c, h))) : 90 === this.angle ? (e.push(new N(0, f, c, h)), f += h) : 180 === this.angle ? (f -= h, e.push(new N(f, 0, h, c))) : (e.push(new N(f, 0, h, c)), f += h);\n      }\n      this.commitLayers(e, d);\n    }\n  };\n  kt.prototype.commitLayers = function () {};\n  kt.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator; a.next();) a.value.commit();\n  };\n  kt.prototype.Cw = function () {\n    for (var a = this.Jb.iterator; a.next();) {\n      var b = a.value;\n      b instanceof rt && wu(this, b);\n    }\n  };\n  function wu(a, b) {\n    if (null !== b) {\n      a.setPortSpots(b);\n      b = b.children;\n      for (var c = b.length, d = 0; d < c; d++) wu(a, b[d]);\n    }\n  }\n  kt.prototype.setPortSpots = function (a) {\n    var b = a.alignment;\n    if (Mt(b)) {\n      var c = this.fd === mt,\n        d = Vt(a);\n      switch (d) {\n        case 0:\n          var e = hd;\n          break;\n        case 90:\n          e = id;\n          break;\n        case 180:\n          e = gd;\n          break;\n        default:\n          e = fd;\n      }\n      var f = a.children,\n        g = f.length;\n      switch (b) {\n        case Nt:\n        case Dt:\n          for (b = 0; b < g; b++) {\n            var h = f[b];\n            h = (c ? h.sourceEdges : h.destinationEdges).first();\n            if (null !== h && (h = h.link, null !== h)) {\n              var k = 90 === d || 270 === d ? gd : fd;\n              if (1 === g || b === g - 1 && 1 === g % 2) switch (d) {\n                case 0:\n                  k = gd;\n                  break;\n                case 90:\n                  k = fd;\n                  break;\n                case 180:\n                  k = hd;\n                  break;\n                default:\n                  k = id;\n              } else 0 === b % 2 && (k = 90 === d || 270 === d ? hd : id);\n              c ? (a.setsPortSpot && (h.fromSpot = e), a.setsChildPortSpot && (h.toSpot = k)) : (a.setsPortSpot && (h.fromSpot = k), a.setsChildPortSpot && (h.toSpot = e));\n            }\n          }\n          break;\n        case Ot:\n          d = 90 === d || 270 === d ? hd : id;\n          for (f = c ? a.destinationEdges : a.sourceEdges; f.next();) g = f.value.link, null !== g && (c ? (a.setsPortSpot && (g.fromSpot = e), a.setsChildPortSpot && (g.toSpot = d)) : (a.setsPortSpot && (g.fromSpot = d), a.setsChildPortSpot && (g.toSpot = e)));\n          break;\n        case Pt:\n          for (d = 90 === d || 270 === d ? gd : fd, f = c ? a.destinationEdges : a.sourceEdges; f.next();) g = f.value.link, null !== g && (c ? (a.setsPortSpot && (g.fromSpot = e), a.setsChildPortSpot && (g.toSpot = d)) : (a.setsPortSpot && (g.fromSpot = d), a.setsChildPortSpot && (g.toSpot = e)));\n      }\n    } else if (c = Vt(a), this.fd === mt) for (e = a.destinationEdges; e.next();) {\n      if (d = e.value.link, null !== d) {\n        if (a.setsPortSpot) if (a.portSpot.Mb()) switch (c) {\n          case 0:\n            d.fromSpot = hd;\n            break;\n          case 90:\n            d.fromSpot = id;\n            break;\n          case 180:\n            d.fromSpot = gd;\n            break;\n          default:\n            d.fromSpot = fd;\n        } else d.fromSpot = a.portSpot;\n        if (a.setsChildPortSpot) if (a.childPortSpot.Mb()) switch (c) {\n          case 0:\n            d.toSpot = gd;\n            break;\n          case 90:\n            d.toSpot = fd;\n            break;\n          case 180:\n            d.toSpot = hd;\n            break;\n          default:\n            d.toSpot = id;\n        } else d.toSpot = a.childPortSpot;\n      }\n    } else for (e = a.sourceEdges; e.next();) if (d = e.value.link, null !== d) {\n      if (a.setsPortSpot) if (a.portSpot.Mb()) switch (c) {\n        case 0:\n          d.toSpot = hd;\n          break;\n        case 90:\n          d.toSpot = id;\n          break;\n        case 180:\n          d.toSpot = gd;\n          break;\n        default:\n          d.toSpot = fd;\n      } else d.toSpot = a.portSpot;\n      if (a.setsChildPortSpot) if (a.childPortSpot.Mb()) switch (c) {\n        case 0:\n          d.fromSpot = gd;\n          break;\n        case 90:\n          d.fromSpot = fd;\n          break;\n        case 180:\n          d.fromSpot = hd;\n          break;\n        default:\n          d.fromSpot = id;\n      } else d.fromSpot = a.childPortSpot;\n    }\n  };\n  function Vt(a) {\n    a = a.angle;\n    return 45 >= a ? 0 : 135 >= a ? 90 : 225 >= a ? 180 : 315 >= a ? 270 : 0;\n  }\n  function bu(a) {\n    var b = Vt(a);\n    b = 90 === b || 270 === b;\n    var c = a.layerSpacing;\n    if (0 < a.layerSpacingParentOverlap) {\n      var d = Math.min(1, a.layerSpacingParentOverlap);\n      c -= b ? a.height * d : a.width * d;\n    }\n    c < (b ? -a.height : -a.width) && (c = b ? -a.height : -a.width);\n    return c;\n  }\n  function cu(a) {\n    var b = Vt(a),\n      c = a.nodeIndent;\n    if (0 < a.nodeIndentPastParent) {\n      var d = Math.min(1, a.nodeIndentPastParent);\n      c += 90 === b || 270 === b ? a.width * d : a.height * d;\n    }\n    return c = Math.max(0, c);\n  }\n  ma.Object.defineProperties(kt.prototype, {\n    roots: {\n      get: function () {\n        return this.Jb;\n      },\n      set: function (a) {\n        this.Jb !== a && (this.Jb = a, this.C());\n      }\n    },\n    path: {\n      get: function () {\n        return this.qp;\n      },\n      set: function (a) {\n        this.qp !== a && (this.qp = a, this.C());\n      }\n    },\n    treeStyle: {\n      get: function () {\n        return this.mq;\n      },\n      set: function (a) {\n        this.Eb === a || a !== nt && a !== Gt && a !== Ht && a !== Ft || (this.mq = a, this.C());\n      }\n    },\n    layerStyle: {\n      get: function () {\n        return this.vs;\n      },\n      set: function (a) {\n        this.Eb === a || a !== ot && a !== Bt && a !== At || (this.vs = a, this.C());\n      }\n    },\n    comments: {\n      get: function () {\n        return this.ed;\n      },\n      set: function (a) {\n        this.ed !== a && (this.ed = a, this.C());\n      }\n    },\n    arrangement: {\n      get: function () {\n        return this.Eb;\n      },\n      set: function (a) {\n        this.Eb === a || a !== pt && a !== vu && a !== st || (this.Eb = a, this.C());\n      }\n    },\n    arrangementSpacing: {\n      get: function () {\n        return this.Hd;\n      },\n      set: function (a) {\n        this.Hd.w(a) || (this.Hd.assign(a), this.C());\n      }\n    },\n    rootDefaults: {\n      get: function () {\n        return this.U;\n      },\n      set: function (a) {\n        this.U !== a && (this.U = a, this.C());\n      }\n    },\n    alternateDefaults: {\n      get: function () {\n        return this.V;\n      },\n      set: function (a) {\n        this.V !== a && (this.V = a, this.C());\n      }\n    },\n    sorting: {\n      get: function () {\n        return this.U.sorting;\n      },\n      set: function (a) {\n        this.U.sorting === a || a !== It && a !== Jt && a !== Kt && !Lt || (this.U.sorting = a, this.C());\n      }\n    },\n    comparer: {\n      get: function () {\n        return this.U.comparer;\n      },\n      set: function (a) {\n        this.U.comparer !== a && (this.U.comparer = a, this.C());\n      }\n    },\n    angle: {\n      get: function () {\n        return this.U.angle;\n      },\n      set: function (a) {\n        this.U.angle !== a && (0 === a || 90 === a || 180 === a || 270 === a ? (this.U.angle = a, this.C()) : B(\"TreeLayout.angle must be 0, 90, 180, or 270\"));\n      }\n    },\n    alignment: {\n      get: function () {\n        return this.U.alignment;\n      },\n      set: function (a) {\n        this.U.alignment !== a && (this.U.alignment = a, this.C());\n      }\n    },\n    nodeIndent: {\n      get: function () {\n        return this.U.nodeIndent;\n      },\n      set: function (a) {\n        this.U.nodeIndent !== a && 0 <= a && (this.U.nodeIndent = a, this.C());\n      }\n    },\n    nodeIndentPastParent: {\n      get: function () {\n        return this.U.nodeIndentPastParent;\n      },\n      set: function (a) {\n        this.U.nodeIndentPastParent !== a && 0 <= a && 1 >= a && (this.U.nodeIndentPastParent = a, this.C());\n      }\n    },\n    nodeSpacing: {\n      get: function () {\n        return this.U.nodeSpacing;\n      },\n      set: function (a) {\n        this.U.nodeSpacing !== a && (this.U.nodeSpacing = a, this.C());\n      }\n    },\n    layerSpacing: {\n      get: function () {\n        return this.U.layerSpacing;\n      },\n      set: function (a) {\n        this.U.layerSpacing !== a && (this.U.layerSpacing = a, this.C());\n      }\n    },\n    layerSpacingParentOverlap: {\n      get: function () {\n        return this.U.layerSpacingParentOverlap;\n      },\n      set: function (a) {\n        this.U.layerSpacingParentOverlap !== a && 0 <= a && 1 >= a && (this.U.layerSpacingParentOverlap = a, this.C());\n      }\n    },\n    compaction: {\n      get: function () {\n        return this.U.compaction;\n      },\n      set: function (a) {\n        this.U.compaction === a || a !== St && a !== Ut || (this.U.compaction = a, this.C());\n      }\n    },\n    breadthLimit: {\n      get: function () {\n        return this.U.breadthLimit;\n      },\n      set: function (a) {\n        this.U.breadthLimit !== a && 0 <= a && (this.U.breadthLimit = a, this.C());\n      }\n    },\n    rowSpacing: {\n      get: function () {\n        return this.U.rowSpacing;\n      },\n      set: function (a) {\n        this.U.rowSpacing !== a && (this.U.rowSpacing = a, this.C());\n      }\n    },\n    rowIndent: {\n      get: function () {\n        return this.U.rowIndent;\n      },\n      set: function (a) {\n        this.U.rowIndent !== a && 0 <= a && (this.U.rowIndent = a, this.C());\n      }\n    },\n    commentSpacing: {\n      get: function () {\n        return this.U.commentSpacing;\n      },\n      set: function (a) {\n        this.U.commentSpacing !== a && (this.U.commentSpacing = a, this.C());\n      }\n    },\n    commentMargin: {\n      get: function () {\n        return this.U.commentMargin;\n      },\n      set: function (a) {\n        this.U.commentMargin !== a && (this.U.commentMargin = a, this.C());\n      }\n    },\n    setsPortSpot: {\n      get: function () {\n        return this.U.setsPortSpot;\n      },\n      set: function (a) {\n        this.U.setsPortSpot !== a && (this.U.setsPortSpot = a, this.C());\n      }\n    },\n    portSpot: {\n      get: function () {\n        return this.U.portSpot;\n      },\n      set: function (a) {\n        this.U.portSpot.w(a) || (this.U.portSpot = a, this.C());\n      }\n    },\n    setsChildPortSpot: {\n      get: function () {\n        return this.U.setsChildPortSpot;\n      },\n      set: function (a) {\n        this.U.setsChildPortSpot !== a && (this.U.setsChildPortSpot = a, this.C());\n      }\n    },\n    childPortSpot: {\n      get: function () {\n        return this.U.childPortSpot;\n      },\n      set: function (a) {\n        this.U.childPortSpot.w(a) || (this.U.childPortSpot = a, this.C());\n      }\n    },\n    alternateSorting: {\n      get: function () {\n        return this.V.sorting;\n      },\n      set: function (a) {\n        this.V.sorting === a || a !== It && a !== Jt && a !== Kt && !Lt || (this.V.sorting = a, this.C());\n      }\n    },\n    alternateComparer: {\n      get: function () {\n        return this.V.comparer;\n      },\n      set: function (a) {\n        this.V.comparer !== a && (this.V.comparer = a, this.C());\n      }\n    },\n    alternateAngle: {\n      get: function () {\n        return this.V.angle;\n      },\n      set: function (a) {\n        this.V.angle === a || 0 !== a && 90 !== a && 180 !== a && 270 !== a || (this.V.angle = a, this.C());\n      }\n    },\n    alternateAlignment: {\n      get: function () {\n        return this.V.alignment;\n      },\n      set: function (a) {\n        this.V.alignment !== a && (this.V.alignment = a, this.C());\n      }\n    },\n    alternateNodeIndent: {\n      get: function () {\n        return this.V.nodeIndent;\n      },\n      set: function (a) {\n        this.V.nodeIndent !== a && 0 <= a && (this.V.nodeIndent = a, this.C());\n      }\n    },\n    alternateNodeIndentPastParent: {\n      get: function () {\n        return this.V.nodeIndentPastParent;\n      },\n      set: function (a) {\n        this.V.nodeIndentPastParent !== a && 0 <= a && 1 >= a && (this.V.nodeIndentPastParent = a, this.C());\n      }\n    },\n    alternateNodeSpacing: {\n      get: function () {\n        return this.V.nodeSpacing;\n      },\n      set: function (a) {\n        this.V.nodeSpacing !== a && (this.V.nodeSpacing = a, this.C());\n      }\n    },\n    alternateLayerSpacing: {\n      get: function () {\n        return this.V.layerSpacing;\n      },\n      set: function (a) {\n        this.V.layerSpacing !== a && (this.V.layerSpacing = a, this.C());\n      }\n    },\n    alternateLayerSpacingParentOverlap: {\n      get: function () {\n        return this.V.layerSpacingParentOverlap;\n      },\n      set: function (a) {\n        this.V.layerSpacingParentOverlap !== a && 0 <= a && 1 >= a && (this.V.layerSpacingParentOverlap = a, this.C());\n      }\n    },\n    alternateCompaction: {\n      get: function () {\n        return this.V.compaction;\n      },\n      set: function (a) {\n        this.V.compaction === a || a !== St && a !== Ut || (this.V.compaction = a, this.C());\n      }\n    },\n    alternateBreadthLimit: {\n      get: function () {\n        return this.V.breadthLimit;\n      },\n      set: function (a) {\n        this.V.breadthLimit !== a && 0 <= a && (this.V.breadthLimit = a, this.C());\n      }\n    },\n    alternateRowSpacing: {\n      get: function () {\n        return this.V.rowSpacing;\n      },\n      set: function (a) {\n        this.V.rowSpacing !== a && (this.V.rowSpacing = a, this.C());\n      }\n    },\n    alternateRowIndent: {\n      get: function () {\n        return this.V.rowIndent;\n      },\n      set: function (a) {\n        this.V.rowIndent !== a && 0 <= a && (this.V.rowIndent = a, this.C());\n      }\n    },\n    alternateCommentSpacing: {\n      get: function () {\n        return this.V.commentSpacing;\n      },\n      set: function (a) {\n        this.V.commentSpacing !== a && (this.V.commentSpacing = a, this.C());\n      }\n    },\n    alternateCommentMargin: {\n      get: function () {\n        return this.V.commentMargin;\n      },\n      set: function (a) {\n        this.V.commentMargin !== a && (this.V.commentMargin = a, this.C());\n      }\n    },\n    alternateSetsPortSpot: {\n      get: function () {\n        return this.V.setsPortSpot;\n      },\n      set: function (a) {\n        this.V.setsPortSpot !== a && (this.V.setsPortSpot = a, this.C());\n      }\n    },\n    alternatePortSpot: {\n      get: function () {\n        return this.V.portSpot;\n      },\n      set: function (a) {\n        this.V.portSpot.w(a) || (this.V.portSpot = a, this.C());\n      }\n    },\n    alternateSetsChildPortSpot: {\n      get: function () {\n        return this.V.setsChildPortSpot;\n      },\n      set: function (a) {\n        this.V.setsChildPortSpot !== a && (this.V.setsChildPortSpot = a, this.C());\n      }\n    },\n    alternateChildPortSpot: {\n      get: function () {\n        return this.V.childPortSpot;\n      },\n      set: function (a) {\n        this.V.childPortSpot.w(a) || (this.V.childPortSpot = a, this.C());\n      }\n    }\n  });\n  var lt = new D(kt, \"PathDefault\", -1),\n    mt = new D(kt, \"PathDestination\", 0),\n    tt = new D(kt, \"PathSource\", 1),\n    It = new D(kt, \"SortingForwards\", 10),\n    Jt = new D(kt, \"SortingReverse\", 11),\n    Kt = new D(kt, \"SortingAscending\", 12),\n    Lt = new D(kt, \"SortingDescending\", 13),\n    mu = new D(kt, \"AlignmentCenterSubtrees\", 20),\n    nu = new D(kt, \"AlignmentCenterChildren\", 21),\n    du = new D(kt, \"AlignmentStart\", 22),\n    Wt = new D(kt, \"AlignmentEnd\", 23),\n    Nt = new D(kt, \"AlignmentBus\", 24),\n    Dt = new D(kt, \"AlignmentBusBranching\", 25),\n    Ot = new D(kt, \"AlignmentTopLeftBus\", 26),\n    Pt = new D(kt, \"AlignmentBottomRightBus\", 27),\n    St = new D(kt, \"CompactionNone\", 30),\n    Ut = new D(kt, \"CompactionBlock\", 31),\n    nt = new D(kt, \"StyleLayered\", 40),\n    Ht = new D(kt, \"StyleLastParents\", 41),\n    Gt = new D(kt, \"StyleAlternating\", 42),\n    Ft = new D(kt, \"StyleRootOnly\", 43),\n    pt = new D(kt, \"ArrangementVertical\", 50),\n    vu = new D(kt, \"ArrangementHorizontal\", 51),\n    st = new D(kt, \"ArrangementFixedRoots\", 52),\n    ot = new D(kt, \"LayerIndividual\", 60),\n    Bt = new D(kt, \"LayerSiblings\", 61),\n    At = new D(kt, \"LayerUniform\", 62);\n  kt.className = \"TreeLayout\";\n  kt.PathDefault = lt;\n  kt.PathDestination = mt;\n  kt.PathSource = tt;\n  kt.SortingForwards = It;\n  kt.SortingReverse = Jt;\n  kt.SortingAscending = Kt;\n  kt.SortingDescending = Lt;\n  kt.AlignmentCenterSubtrees = mu;\n  kt.AlignmentCenterChildren = nu;\n  kt.AlignmentStart = du;\n  kt.AlignmentEnd = Wt;\n  kt.AlignmentBus = Nt;\n  kt.AlignmentBusBranching = Dt;\n  kt.AlignmentTopLeftBus = Ot;\n  kt.AlignmentBottomRightBus = Pt;\n  kt.CompactionNone = St;\n  kt.CompactionBlock = Ut;\n  kt.StyleLayered = nt;\n  kt.StyleLastParents = Ht;\n  kt.StyleAlternating = Gt;\n  kt.StyleRootOnly = Ft;\n  kt.ArrangementVertical = pt;\n  kt.ArrangementHorizontal = vu;\n  kt.ArrangementFixedRoots = st;\n  kt.LayerIndividual = ot;\n  kt.LayerSiblings = Bt;\n  kt.LayerUniform = At;\n  function qt(a) {\n    Rp.call(this, a);\n  }\n  la(qt, Rp);\n  qt.prototype.createVertex = function () {\n    return new rt(this);\n  };\n  qt.prototype.createEdge = function () {\n    return new xu(this);\n  };\n  qt.className = \"TreeNetwork\";\n  function rt(a) {\n    eq.call(this, a);\n    this.Ja = !1;\n    this.Bc = null;\n    this.I = [];\n    this.Pc = this.cb = this.T = this.Ka = 0;\n    this.ed = null;\n    this.S = new J(0, 0);\n    this.ua = new M(0, 0);\n    this.da = new J(0, 0);\n    this.Sm = this.Rm = this.SA = !1;\n    this.cr = this.Pq = null;\n    this.Yc = It;\n    this.Tc = lq;\n    this.Yb = 0;\n    this.yb = nu;\n    this.Fs = this.Es = 0;\n    this.Gs = 20;\n    this.qe = 50;\n    this.us = 0;\n    this.Gr = Ut;\n    this.yr = 0;\n    this.Ts = 25;\n    this.Fr = this.Ss = 10;\n    this.Er = 20;\n    this.ft = !0;\n    this.Ps = ad;\n    this.et = !0;\n    this.Br = ad;\n  }\n  la(rt, eq);\n  rt.prototype.copyInheritedPropertiesFrom = function (a) {\n    null !== a && (this.Yc = a.sorting, this.Tc = a.comparer, this.Yb = a.angle, this.yb = a.alignment, this.Es = a.nodeIndent, this.Fs = a.nodeIndentPastParent, this.Gs = a.nodeSpacing, this.qe = a.layerSpacing, this.us = a.layerSpacingParentOverlap, this.Gr = a.compaction, this.yr = a.breadthLimit, this.Ts = a.rowSpacing, this.Ss = a.rowIndent, this.Fr = a.commentSpacing, this.Er = a.commentMargin, this.ft = a.setsPortSpot, this.Ps = a.portSpot, this.et = a.setsChildPortSpot, this.Br = a.childPortSpot);\n  };\n  ma.Object.defineProperties(rt.prototype, {\n    initialized: {\n      get: function () {\n        return this.Ja;\n      },\n      set: function (a) {\n        this.Ja !== a && (this.Ja = a);\n      }\n    },\n    parent: {\n      get: function () {\n        return this.Bc;\n      },\n      set: function (a) {\n        this.Bc !== a && (this.Bc = a);\n      }\n    },\n    children: {\n      get: function () {\n        return this.I;\n      },\n      set: function (a) {\n        if (this.I !== a) {\n          if (null !== a) for (var b = a.length, c = 0; c < b; c++);\n          this.I = a;\n        }\n      }\n    },\n    level: {\n      get: function () {\n        return this.Ka;\n      },\n      set: function (a) {\n        this.Ka !== a && (this.Ka = a);\n      }\n    },\n    descendantCount: {\n      get: function () {\n        return this.T;\n      },\n      set: function (a) {\n        this.T !== a && (this.T = a);\n      }\n    },\n    maxChildrenCount: {\n      get: function () {\n        return this.cb;\n      },\n      set: function (a) {\n        this.cb !== a && (this.cb = a);\n      }\n    },\n    maxGenerationCount: {\n      get: function () {\n        return this.Pc;\n      },\n      set: function (a) {\n        this.Pc !== a && (this.Pc = a);\n      }\n    },\n    comments: {\n      get: function () {\n        return this.ed;\n      },\n      set: function (a) {\n        if (this.ed !== a) {\n          if (null !== a) for (var b = a.length, c = 0; c < b; c++);\n          this.ed = a;\n        }\n      }\n    },\n    sorting: {\n      get: function () {\n        return this.Yc;\n      },\n      set: function (a) {\n        this.Yc !== a && (this.Yc = a);\n      }\n    },\n    comparer: {\n      get: function () {\n        return this.Tc;\n      },\n      set: function (a) {\n        this.Tc !== a && (this.Tc = a);\n      }\n    },\n    angle: {\n      get: function () {\n        return this.Yb;\n      },\n      set: function (a) {\n        this.Yb !== a && (this.Yb = a);\n      }\n    },\n    alignment: {\n      get: function () {\n        return this.yb;\n      },\n      set: function (a) {\n        this.yb !== a && (this.yb = a);\n      }\n    },\n    nodeIndent: {\n      get: function () {\n        return this.Es;\n      },\n      set: function (a) {\n        this.Es !== a && (this.Es = a);\n      }\n    },\n    nodeIndentPastParent: {\n      get: function () {\n        return this.Fs;\n      },\n      set: function (a) {\n        this.Fs !== a && (this.Fs = a);\n      }\n    },\n    nodeSpacing: {\n      get: function () {\n        return this.Gs;\n      },\n      set: function (a) {\n        this.Gs !== a && (this.Gs = a);\n      }\n    },\n    layerSpacing: {\n      get: function () {\n        return this.qe;\n      },\n      set: function (a) {\n        this.qe !== a && (this.qe = a);\n      }\n    },\n    layerSpacingParentOverlap: {\n      get: function () {\n        return this.us;\n      },\n      set: function (a) {\n        this.us !== a && (this.us = a);\n      }\n    },\n    compaction: {\n      get: function () {\n        return this.Gr;\n      },\n      set: function (a) {\n        this.Gr !== a && (this.Gr = a);\n      }\n    },\n    breadthLimit: {\n      get: function () {\n        return this.yr;\n      },\n      set: function (a) {\n        this.yr !== a && (this.yr = a);\n      }\n    },\n    rowSpacing: {\n      get: function () {\n        return this.Ts;\n      },\n      set: function (a) {\n        this.Ts !== a && (this.Ts = a);\n      }\n    },\n    rowIndent: {\n      get: function () {\n        return this.Ss;\n      },\n      set: function (a) {\n        this.Ss !== a && (this.Ss = a);\n      }\n    },\n    commentSpacing: {\n      get: function () {\n        return this.Fr;\n      },\n      set: function (a) {\n        this.Fr !== a && (this.Fr = a);\n      }\n    },\n    commentMargin: {\n      get: function () {\n        return this.Er;\n      },\n      set: function (a) {\n        this.Er !== a && (this.Er = a);\n      }\n    },\n    setsPortSpot: {\n      get: function () {\n        return this.ft;\n      },\n      set: function (a) {\n        this.ft !== a && (this.ft = a);\n      }\n    },\n    portSpot: {\n      get: function () {\n        return this.Ps;\n      },\n      set: function (a) {\n        this.Ps.w(a) || (this.Ps = a);\n      }\n    },\n    setsChildPortSpot: {\n      get: function () {\n        return this.et;\n      },\n      set: function (a) {\n        this.et !== a && (this.et = a);\n      }\n    },\n    childPortSpot: {\n      get: function () {\n        return this.Br;\n      },\n      set: function (a) {\n        this.Br.w(a) || (this.Br = a);\n      }\n    },\n    childrenCount: {\n      get: function () {\n        return this.children.length;\n      }\n    },\n    relativePosition: {\n      get: function () {\n        return this.S;\n      },\n      set: function (a) {\n        this.S.set(a);\n      }\n    },\n    subtreeSize: {\n      get: function () {\n        return this.ua;\n      },\n      set: function (a) {\n        this.ua.set(a);\n      }\n    },\n    subtreeOffset: {\n      get: function () {\n        return this.da;\n      },\n      set: function (a) {\n        this.da.set(a);\n      }\n    }\n  });\n  rt.className = \"TreeVertex\";\n  function xu(a) {\n    fq.call(this, a);\n    this.kv = new J(0, 0);\n  }\n  la(xu, fq);\n  xu.prototype.commit = function () {\n    var a = this.link;\n    if (null !== a && !a.isAvoiding) {\n      var b = this.network.layout,\n        c = null,\n        d = null;\n      switch (b.fd) {\n        case mt:\n          c = this.fromVertex;\n          d = this.toVertex;\n          break;\n        case tt:\n          c = this.toVertex;\n          d = this.fromVertex;\n          break;\n        default:\n          B(\"Unhandled path value \" + b.fd.toString());\n      }\n      if (null !== c && null !== d) if (b = this.kv, 0 !== b.x || 0 !== b.y || c.SA) {\n        d = c.bounds;\n        var e = Vt(c),\n          f = bu(c),\n          g = c.rowSpacing;\n        a.wj();\n        var h = a.curve === pg,\n          k = a.isOrthogonal,\n          l;\n        a.Th();\n        if (k || h) {\n          for (l = 2; 4 < a.pointsCount;) a.sw(2);\n          var m = a.i(1);\n          var n = a.i(2);\n        } else {\n          for (l = 1; 3 < a.pointsCount;) a.sw(1);\n          m = a.i(0);\n          n = a.i(a.pointsCount - 1);\n        }\n        var p = a.i(a.pointsCount - 1);\n        0 === e ? (c.alignment === Wt ? (e = d.bottom + b.y, 0 === b.y && m.y > p.y + c.rowIndent && (e = Math.min(e, Math.max(m.y, e - cu(c))))) : c.alignment === du ? (e = d.top + b.y, 0 === b.y && m.y < p.y - c.rowIndent && (e = Math.max(e, Math.min(m.y, e + cu(c))))) : e = c.Rm || c.Sm && 1 === c.maxGenerationCount ? d.top - c.da.y + b.y : d.y + d.height / 2 + b.y, h ? (a.m(l, m.x, e), l++, a.m(l, d.right + f, e), l++, a.m(l, d.right + f + (b.x - g) / 3, e), l++, a.m(l, d.right + f + 2 * (b.x - g) / 3, e), l++, a.m(l, d.right + f + (b.x - g), e), l++, a.m(l, n.x, e)) : (k && (a.m(l, d.right + f / 2, m.y), l++), a.m(l, d.right + f / 2, e), l++, a.m(l, d.right + f + b.x - (k ? g / 2 : g), e), l++, k && a.m(l, a.i(l - 1).x, n.y))) : 90 === e ? (c.alignment === Wt ? (e = d.right + b.x, 0 === b.x && m.x > p.x + c.rowIndent && (e = Math.min(e, Math.max(m.x, e - cu(c))))) : c.alignment === du ? (e = d.left + b.x, 0 === b.x && m.x < p.x - c.rowIndent && (e = Math.max(e, Math.min(m.x, e + cu(c))))) : e = c.Rm || c.Sm && 1 === c.maxGenerationCount ? d.left - c.da.x + b.x : d.x + d.width / 2 + b.x, h ? (a.m(l, e, m.y), l++, a.m(l, e, d.bottom + f), l++, a.m(l, e, d.bottom + f + (b.y - g) / 3), l++, a.m(l, e, d.bottom + f + 2 * (b.y - g) / 3), l++, a.m(l, e, d.bottom + f + (b.y - g)), l++, a.m(l, e, n.y)) : (k && (a.m(l, m.x, d.bottom + f / 2), l++), a.m(l, e, d.bottom + f / 2), l++, a.m(l, e, d.bottom + f + b.y - (k ? g / 2 : g)), l++, k && a.m(l, n.x, a.i(l - 1).y))) : 180 === e ? (c.alignment === Wt ? (e = d.bottom + b.y, 0 === b.y && m.y > p.y + c.rowIndent && (e = Math.min(e, Math.max(m.y, e - cu(c))))) : c.alignment === du ? (e = d.top + b.y, 0 === b.y && m.y < p.y - c.rowIndent && (e = Math.max(e, Math.min(m.y, e + cu(c))))) : e = c.Rm || c.Sm && 1 === c.maxGenerationCount ? d.top - c.da.y + b.y : d.y + d.height / 2 + b.y, h ? (a.m(l, m.x, e), l++, a.m(l, d.left - f, e), l++, a.m(l, d.left - f + (b.x + g) / 3, e), l++, a.m(l, d.left - f + 2 * (b.x + g) / 3, e), l++, a.m(l, d.left - f + (b.x + g), e), l++, a.m(l, n.x, e)) : (k && (a.m(l, d.left - f / 2, m.y), l++), a.m(l, d.left - f / 2, e), l++, a.m(l, d.left - f + b.x + (k ? g / 2 : g), e), l++, k && a.m(l, a.i(l - 1).x, n.y))) : 270 === e ? (c.alignment === Wt ? (e = d.right + b.x, 0 === b.x && m.x > p.x + c.rowIndent && (e = Math.min(e, Math.max(m.x, e - cu(c))))) : c.alignment === du ? (e = d.left + b.x, 0 === b.x && m.x < p.x - c.rowIndent && (e = Math.max(e, Math.min(m.x, e + cu(c))))) : e = c.Rm || c.Sm && 1 === c.maxGenerationCount ? d.left - c.da.x + b.x : d.x + d.width / 2 + b.x, h ? (a.m(l, e, m.y), l++, a.m(l, e, d.top - f), l++, a.m(l, e, d.top - f + (b.y + g) / 3), l++, a.m(l, e, d.top - f + 2 * (b.y + g) / 3), l++, a.m(l, e, d.top - f + (b.y + g)), l++, a.m(l, e, n.y)) : (k && (a.m(l, m.x, d.top - f / 2), l++), a.m(l, e, d.top - f / 2), l++, a.m(l, e, d.top - f + b.y + (k ? g / 2 : g)), l++, k && a.m(l, n.x, a.i(l - 1).y))) : B(\"Invalid angle \" + e);\n        a.xf();\n      } else a = this.link, f = Vt(c), f !== Vt(d) && (g = bu(c), h = c.bounds, c = d.bounds, 0 === f && c.left - h.right < g + 1 || 90 === f && c.top - h.bottom < g + 1 || 180 === f && h.left - c.right < g + 1 || 270 === f && h.top - c.bottom < g + 1 || (a.wj(), c = a.curve === pg, b = a.isOrthogonal, d = Mt(this.fromVertex.alignment), a.Th(), 0 === f ? (f = h.right + g / 2, c ? 4 === a.pointsCount && (c = a.i(3).y, a.K(1, f - 20, a.i(1).y), a.m(2, f - 20, c), a.m(3, f, c), a.m(4, f + 20, c), a.K(5, a.i(5).x, c)) : b ? d ? a.K(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.K(2, f, a.i(2).y), a.K(3, f, a.i(3).y)) : 4 === a.pointsCount ? a.m(2, f, a.i(2).y) : 3 === a.pointsCount ? a.K(1, f, a.i(2).y) : 2 === a.pointsCount && a.m(1, f, a.i(1).y)) : 90 === f ? (f = h.bottom + g / 2, c ? 4 === a.pointsCount && (c = a.i(3).x, a.K(1, a.i(1).x, f - 20), a.m(2, c, f - 20), a.m(3, c, f), a.m(4, c, f + 20), a.K(5, c, a.i(5).y)) : b ? d ? a.K(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.K(2, a.i(2).x, f), a.K(3, a.i(3).x, f)) : 4 === a.pointsCount ? a.m(2, a.i(2).x, f) : 3 === a.pointsCount ? a.K(1, a.i(2).x, f) : 2 === a.pointsCount && a.m(1, a.i(1).x, f)) : 180 === f ? (f = h.left - g / 2, c ? 4 === a.pointsCount && (c = a.i(3).y, a.K(1, f + 20, a.i(1).y), a.m(2, f + 20, c), a.m(3, f, c), a.m(4, f - 20, c), a.K(5, a.i(5).x, c)) : b ? d ? a.K(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.K(2, f, a.i(2).y), a.K(3, f, a.i(3).y)) : 4 === a.pointsCount ? a.m(2, f, a.i(2).y) : 3 === a.pointsCount ? a.K(1, f, a.i(2).y) : 2 === a.pointsCount && a.m(1, f, a.i(1).y)) : 270 === f && (f = h.top - g / 2, c ? 4 === a.pointsCount && (c = a.i(3).x, a.K(1, a.i(1).x, f + 20), a.m(2, c, f + 20), a.m(3, c, f), a.m(4, c, f - 20), a.K(5, c, a.i(5).y)) : b ? d ? a.K(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.K(2, a.i(2).x, f), a.K(3, a.i(3).x, f)) : 4 === a.pointsCount ? a.m(2, a.i(2).x, f) : 3 === a.pointsCount ? a.K(1, a.i(2).x, f) : 2 === a.pointsCount && a.m(1, a.i(1).x, f)), a.xf()));\n    }\n  };\n  ma.Object.defineProperties(xu.prototype, {\n    relativePoint: {\n      get: function () {\n        return this.kv;\n      },\n      set: function (a) {\n        this.kv.set(a);\n      }\n    }\n  });\n  xu.className = \"TreeEdge\";\n  Oa.prototype.initializeStandardTools = function () {\n    this.Xa(\"Action\", new Dg(), this.mouseDownTools);\n    this.Xa(\"Relinking\", new Ze(), this.mouseDownTools);\n    this.Xa(\"LinkReshaping\", new cg(), this.mouseDownTools);\n    this.Xa(\"Rotating\", new Bg(), this.mouseDownTools);\n    this.Xa(\"Resizing\", new ug(), this.mouseDownTools);\n    this.Xa(\"Linking\", new Wf(), this.mouseMoveTools);\n    this.Xa(\"Dragging\", new Se(), this.mouseMoveTools);\n    this.Xa(\"DragSelecting\", new Gg(), this.mouseMoveTools);\n    this.Xa(\"Panning\", new Hg(), this.mouseMoveTools);\n    this.Xa(\"ContextMenu\", new Jg(), this.mouseUpTools);\n    this.Xa(\"TextEditing\", new Ug(), this.mouseUpTools);\n    this.Xa(\"ClickCreating\", new Eg(), this.mouseUpTools);\n    this.Xa(\"ClickSelecting\", new Cg(), this.mouseUpTools);\n  };\n  rn(\"Horizontal\", new xm());\n  rn(\"Spot\", new zm());\n  rn(\"Table\", new Dm());\n  rn(\"Viewbox\", new Im());\n  rn(\"TableRow\", new Gm());\n  rn(\"TableColumn\", new Hm());\n  rn(\"Graduated\", new Sm());\n  rn(\"Grid\", new Jm());\n  si.add(\"GraphLinksModel\", Eq);\n  si.add(\"TreeModel\", Sq);\n  Xp($r, null);\n  Xp(os, null);\n  var yu = x.go,\n    zu = {\n      get licenseKey() {\n        return Q.licenseKey;\n      },\n      set licenseKey(a) {\n        Q.licenseKey = a;\n      },\n      get version() {\n        return Q.version;\n      },\n      Group: vf,\n      EnumValue: D,\n      List: E,\n      Set: F,\n      Map: H,\n      Point: J,\n      Size: M,\n      Rect: N,\n      Margin: pc,\n      Spot: P,\n      Geometry: td,\n      PathFigure: he,\n      PathSegment: pe,\n      InputEvent: re,\n      DiagramEvent: te,\n      ChangedEvent: ue,\n      Model: Z,\n      GraphLinksModel: or,\n      TreeModel: tr,\n      Binding: Li,\n      Transaction: ze,\n      UndoManager: Ae,\n      CommandHandler: Rk,\n      Tool: Ce,\n      DraggingTool: Se,\n      DraggingInfo: $e,\n      DraggingOptions: Te,\n      LinkingBaseTool: Lf,\n      LinkingTool: Wf,\n      RelinkingTool: Ze,\n      LinkReshapingTool: cg,\n      ResizingTool: ug,\n      RotatingTool: Bg,\n      ClickSelectingTool: Cg,\n      ActionTool: Dg,\n      ClickCreatingTool: Eg,\n      HTMLInfo: Qe,\n      ContextMenuTool: Jg,\n      DragSelectingTool: Gg,\n      PanningTool: Hg,\n      TextEditingTool: Ug,\n      ToolManager: Oa,\n      Animation: ph,\n      AnimationManager: lh,\n      AnimationTrigger: di,\n      Layer: ii,\n      Diagram: Q,\n      Palette: Kk,\n      Overview: Nk,\n      Brush: tl,\n      GraphObject: Y,\n      Panel: X,\n      RowColumnDefinition: Tj,\n      Shape: W,\n      TextBlock: Vg,\n      TextBlockMetrics: io,\n      Picture: Zj,\n      Part: U,\n      Adornment: He,\n      Node: V,\n      Link: S,\n      Placeholder: wg,\n      Layout: yi,\n      LayoutNetwork: Rp,\n      LayoutVertex: eq,\n      LayoutEdge: fq,\n      GridLayout: Mk,\n      PanelLayout: Ol,\n      CircularLayout: ur,\n      CircularNetwork: Lr,\n      CircularVertex: Yr,\n      CircularEdge: Zr,\n      ForceDirectedLayout: $r,\n      ForceDirectedNetwork: as,\n      ForceDirectedVertex: ms,\n      ForceDirectedEdge: ns,\n      LayeredDigraphLayout: os,\n      LayeredDigraphNetwork: ts,\n      LayeredDigraphVertex: it,\n      LayeredDigraphEdge: jt,\n      TreeLayout: kt,\n      TreeNetwork: qt,\n      TreeVertex: rt,\n      TreeEdge: xu\n    };\n  \"object\" === typeof yu && yu.version && B(\"WARNING: a `go` object on the root object is already defined.  \" + (\"Debug\" in yu ? \"debug \" : \"\") + \"version: \" + yu.version + \", replaced with version: \" + zu.version);\n  Q.prototype.go = zu;\n  x.go = zu;\n  (\"undefined\" === typeof x || \"undefined\" === typeof x.module || \"object\" !== typeof x.module.exports) && x.define && \"function\" === typeof x.define && x.define.amd && x.define(zu);\n  'undefined' !== typeof module && 'object' === typeof module.exports && (module.exports = 'undefined' !== typeof global ? global.go : self.go);\n})();","map":null,"metadata":{},"sourceType":"script"}