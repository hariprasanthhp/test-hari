{"ast":null,"code":"import { DatePipe } from '@angular/common';\nimport * as moment from 'moment';\nimport * as Highcharts from 'highcharts';\nimport { DateTime } from 'luxon';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"./fa-utils.service\";\nimport * as i3 from \"src/app/shared-utils/date-utils.service\";\nimport * as i4 from \"src/app/shared/services/export-excel.service\";\nimport * as i5 from \"src/app/shared/services/custom-translate.service\";\nimport * as i6 from \"src/app/shared/services/sso-auth.service\";\nimport * as i7 from \"../reports/service/report-api.service\";\nexport let OptionsManagerService = /*#__PURE__*/(() => {\n  class OptionsManagerService {\n    constructor(router, utils, dateUtils, excel, customTranslateService, sso, service) {\n      this.router = router;\n      this.utils = utils;\n      this.dateUtils = dateUtils;\n      this.excel = excel;\n      this.customTranslateService = customTranslateService;\n      this.sso = sso;\n      this.service = service;\n      /***begin-aswin-06-05-2021-localstorage-realtime-graphdata */\n      this.defaultData = {\n        downData: [],\n        downPercentage: \"\",\n        downTotal: \"\",\n        graphType: \"\",\n        sendTime: new Date().getTime(),\n        upData: [],\n        upPercentage: \"\",\n        upTotal: \"\"\n      };\n      this.language = this.customTranslateService.defualtLanguage;\n      this.customTranslateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n    }\n    makeOptionsForTraffic(data, type, params) {\n      var that = this;\n      let pipe = new DatePipe('en-US');\n      let upUsage,\n        upUsageTotal = 0;\n      let downUsage,\n        downUsageTotal = 0;\n      // let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let timezoneName = that.language['Coordinated Universal Time']; //'Coordinated Universal Time';\n      let diff = moment(params.endDate).diff(moment(params.startDate), \"hour\");\n      let subTitle = '';\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      for (let i = 0; i < data.length; i++) {\n        let period = this.dateUtils.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true);\n        if (params['granularity'] === '1hour') {\n          period = this.dateUtils.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true, 'MM/dd HH:mm');\n        }\n        categories.push(period);\n        seriesData1.push(data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : null);\n        seriesData2.push(data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : null);\n        upUsageTotal += data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : 0;\n        downUsageTotal += data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : 0;\n      }\n      let upUsageUnit = this.getStackedUnit(upUsageTotal);\n      let downUsageUnit = this.getStackedUnit(downUsageTotal);\n      upUsage = (upUsageTotal / upUsageUnit[0]).toFixed(2) + ' ' + upUsageUnit[1];\n      downUsage = (downUsageTotal / downUsageUnit[0]).toFixed(2) + ' ' + downUsageUnit[1];\n      const self = this;\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: this.language['subscriberUsage']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n              s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' : ' ' + unit[1]);\n              return s;\n            }\n          },\n          opposite: false,\n          tickLength: 2\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: false\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            //color: '#E87B00',\n            colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            // cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        exporting: {\n          filename: 'Subscriber_Usage',\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  let subscriber = ``;\n                  if (that.sso.getTrafficReportChartSubscriberInfo()) {\n                    subscriber = `${self.language.Subscriber}: ${that.sso.getTrafficReportChartSubscriberInfo()}\\r\\n`;\n                  }\n                  extraData = `${self.language.subscriberUsage}\\r\\n${subscriber}${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\n${that.language['upUsageTitle']}: ${upUsage}    ${that.language['downUsageTitle']}: ${downUsage}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      [self.language['Date Time']]: that.dateUtils.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'),\n                      [self.language['Up Usage(Byte)']]: data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets.toLocaleString() : 0,\n                      [self.language['Down Usage(Byte)']]: data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets.toLocaleString() : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('Subscriber_Usage', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var name = this.x || this.point.name;\n            var unit = that.getUnit(m);\n            return '<p><strong>' + name + '</strong><br/><span> ' + this.series.name + ': <strong>' + (this.y / unit[0]).toFixed(2) + ' ' + unit[1] + '</strong><br/></span></p>';\n          }\n        }\n      };\n      options.series = [{\n        name: this.language['upUsageTitle'],\n        data: seriesData1,\n        color: \"#82BF00\" // green\n      }, {\n        name: this.language['downUsageTitle'],\n        data: seriesData2,\n        color: \"#0279FF\" // blue\n      }];\n\n      options.xAxis['categories'] = categories;\n      let subscriber = ``;\n      if (this.sso.getTrafficReportChartSubscriberInfo()) {\n        subscriber = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Subscriber']}: ${this.sso.getTrafficReportChartSubscriberInfo()}</span><span style=\"font-size:16px; color:#ffffff\">...</span>`;\n      }\n      subTitle = `${subscriber}<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span><br/>\n    <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['upUsageTitle']}: ${upUsage}    ${this.language['downUsageTitle']}: ${downUsage}</span>`;\n      options.subtitle.text = subTitle;\n      return options;\n    }\n    dataFormingForRTBC(data, dataType) {\n      let categories = [];\n      let seriesData1 = [];\n      if (dataType === 'upData') {\n        data.upData = data.upData.slice(0, 5);\n        for (let i = 0; i < data.upData.length; i++) {\n          categories.push(data.upData[i].name);\n          seriesData1.push({\n            y: data.upData[i].value,\n            id: data.upData[i].id,\n            name: data.upData[i].name\n          });\n        }\n      } else {\n        data.downData = data.downData.slice(0, 5);\n        for (let i = 0; i < data.downData.length; i++) {\n          categories.push(data.downData[i].name);\n          seriesData1.push({\n            y: data.downData[i].value,\n            id: data.downData[i].id,\n            name: data.downData[i].name\n          });\n        }\n      }\n      let series = [{\n        name: dataType,\n        data: seriesData1\n      }];\n    }\n    makeOptionsForRTBC(data, type, dataType, sliceNum, fsView) {\n      let that = this;\n      sliceNum = sliceNum ? sliceNum : 5;\n      let categories = [];\n      let seriesData1 = [];\n      let tickAmount = fsView ? 6 : 3;\n      let options = {\n        chart: {\n          type: 'bar',\n          zoomType: \"xy\",\n          height: 180,\n          renderTo: 'container'\n        },\n        title: {\n          text: ''\n        },\n        credits: {\n          enabled: false\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          opposite: true,\n          tickLength: 2,\n          tickAmount: tickAmount,\n          startOnTick: false,\n          endOnTick: false,\n          labels: {\n            formatter: function () {\n              // let ret = `${that.utils.bitsToSize(this.value, true)}`\n              let ret = `${that.bitsToSize(this.value, false)}`;\n              return ret;\n            },\n            rotation: 0\n          }\n        },\n        legend: {\n          enabled: false\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            color: '#0027FF',\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        tooltip: {\n          formatter: function () {\n            let ret = `${this.x} <br/> ${that.utils.bitsToSize(this.y, false)}`;\n            return ret;\n          }\n        }\n      };\n      let xData = [],\n        ids = [];\n      if (type === 'bar') {\n        if (dataType === 'upData') {\n          data.upData = data.upData.slice(0, sliceNum);\n          for (let i = 0; i < data.upData.length; i++) {\n            categories.push(data.upData[i].name);\n            seriesData1.push(data.upData[i].value);\n            xData.push(data.upData[i].name);\n            ids.push(data.upData[i].id);\n          }\n        } else {\n          data.downData = data.downData.slice(0, sliceNum);\n          for (let i = 0; i < data.downData.length; i++) {\n            categories.push(data.downData[i].name);\n            seriesData1.push(data.downData[i].value);\n            xData.push(data.downData[i].name);\n            ids.push(data.downData[i].id);\n          }\n        }\n        options.series = [{\n          data: seriesData1\n          // xData: xData,\n          // id: ids\n        }];\n      }\n\n      options.xAxis['categories'] = categories;\n      return options;\n    }\n    makeOptionsForAreaChart(data, dType, params) {\n      let categories = [];\n      let seriesData = [];\n      let options = {\n        chart: {\n          type: 'area',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: ''\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          }\n        },\n        legend: {\n          reversed: true\n        },\n        plotOptions: {\n          area: {\n            stacking: 'normal',\n            lineColor: '#666666',\n            lineWidth: 1,\n            marker: {\n              lineWidth: 1,\n              lineColor: '#666666'\n            }\n          }\n        },\n        series: []\n      };\n      let cData = [];\n      for (let i = 0; i < data.length; i++) {\n        if (dType == 'up') {\n          cData.push({\n            name: data[i].name,\n            data: [data[i].usOctets]\n          });\n        } else {\n          cData.push({\n            name: data[i].name,\n            data: [data[i].dsOctets]\n          });\n        }\n      }\n      options.xAxis.categories = [params.startDate];\n      options.series = cData;\n      return options;\n    }\n    makeOptionsForLineChart(data, dType, params) {\n      let up = this.language['max_up_rate'];\n      let down = this.language['max_down_rate'];\n      let that = this;\n      let categories = [];\n      let upData = [];\n      let downData = [];\n      let subsId = `${this.sso.getReportChartSubscriberInfo()}`;\n      if (params['rateSelected'] == 'Average') {\n        up = this.language['Average_Up_Rate'];\n        down = this.language['Average_Down_Rate'];\n      }\n      let pipe = new DatePipe('en-US');\n      let startDate = new Date(params.startDate);\n      let endDate = new Date(params.endDate);\n      let granularity = this.service.getGranularityByChart(startDate, endDate, 'rate');\n      for (let i = 0; i < data.length; i++) {\n        categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'));\n        // upData.push(data[i].peakUsRate);\n        // downData.push(data[i].dsRate);\n        // upRateTotal += data[i].peakUsRate ? data[i].peakUsRate : 0;\n        // downRateTotal += data[i].peakDsRate ? data[i].peakDsRate : 0;\n      }\n\n      let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      // let timezoneName = 'UTC';\n      let diff = moment(params.endDate).diff(moment(params.startDate), \"hour\");\n      let subscriber = ``;\n      if (this.sso.getTrafficReportChartSubscriberInfo()) {\n        subscriber = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Subscriber']}: ${this.sso.getTrafficReportChartSubscriberInfo()}</span><span style=\"font-size:16px; color:#ffffff\">...</span>`;\n      }\n      let subTitle = `${subscriber}<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">Rate: ${this.language[params['rateSelected']]}</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>`;\n      let options = {\n        chart: {\n          type: 'line'\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: this.language['subscriberRate']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: [],\n          labels: {\n            rotation: -65,\n            formatter: function () {\n              let label = this.value;\n              if (this.isLast) {\n                let len = this.axis.categories.length;\n                // label = this.axis.categories[len - 1];\n              }\n\n              return label;\n            }\n          }\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              return that.utils.bitsToSize(this.value, true);\n            }\n          },\n          min: 0,\n          minRange: 1\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          align: 'center',\n          verticalAlign: 'bottom',\n          layout: 'horizontal',\n          symbolRadius: 0\n        },\n        tooltip: {\n          formatter: function () {\n            return '<b>' + this.x + ' <b><br/>' + this.series.name + ': <b>' + that.utils.bitsToSize(this.y, false) + '</b>';\n          }\n        },\n        plotOptions: {\n          series: {\n            marker: {\n              enabled: false\n            }\n          },\n          column: {\n            stacking: 'normal',\n            dataLabels: {\n              enabled: false\n              //color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'\n            }\n          }\n        },\n\n        series: [{\n          name: up,\n          color: '#82BF00',\n          data: []\n        }, {\n          name: down,\n          color: '#0279FF',\n          data: []\n        }],\n        exporting: {\n          filename: 'Subscriber_Rate',\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  let subscriber = ``;\n                  if (that.sso.getTrafficReportChartSubscriberInfo()) {\n                    subscriber = `${that.language['Subscriber']}: ${that.sso.getTrafficReportChartSubscriberInfo()}\\r\\n`;\n                  }\n                  extraData = `Subscriber Rate\\r\\n${subscriber}${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nRate: ${params['rateSelected']}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'),\n                      'Max Up Rate(bps)': data[i].peakUsRate && data[i].peakUsRate !== -1 ? data[i].peakUsRate : 0,\n                      // 'Max Up Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate.toLocaleString() : 0,\n                      'Max Down Rate(bps)': data[i].peakDsRate && data[i].peakDsRate !== -1 ? data[i].peakDsRate : 0,\n                      'Average Up Rate(bps)': data[i].usRate && data[i].usRate !== -1 ? data[i].usRate : 0,\n                      'Average Down Rate(bps)': data[i].dsRate && data[i].dsRate !== -1 ? data[i].dsRate : 0\n                      // 'Max Down Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate.toLocaleString() : 0,\n                      // 'Average Up Rate(bps)': data[i].usRate ? data[i].usRate.toLocaleString() : 0,\n                      // 'Average Down Rate(bps)': data[i].dsRate ? data[i].dsRate.toLocaleString() : 0,\n                    });\n                  }\n\n                  that.excel.downLoadCSV('Subscriber_Rate', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        }\n      };\n      let cData = [];\n      for (let i = 0; i < data.length; i++) {\n        categories.push(this.getDateTime(data[i].startPeriodSec, true, 'MM/dd HH:mm'));\n        if (params['rateSelected'] == 'Average') {\n          upData.push(data[i].usRate);\n          downData.push(data[i].dsRate);\n        } else {\n          upData.push(data[i].peakUsRate);\n          downData.push(data[i].peakDsRate);\n        }\n      }\n      options.xAxis.categories = categories;\n      if (categories && categories.length <= 45) {\n        options.xAxis['tickInterval'] = 1;\n      } else if (categories && categories.length > 45) {\n        options.xAxis['tickInterval'] = Math.floor(categories.length / 45);\n      }\n      options.series[0].data = upData;\n      options.series[1].data = downData;\n      return options;\n    }\n    makeOptionsForMonthlyUsage(data, type, params) {\n      //data = JSON.parse(\"[{\\\"dateMonth\\\":\\\"2020-08\\\",\\\"upUsage\\\":12774687764,\\\"downUsage\\\":347449409818},{\\\"dateMonth\\\":\\\"2020-09\\\",\\\"upUsage\\\":16539630495,\\\"downUsage\\\":587600950182},{\\\"dateMonth\\\":\\\"2020-10\\\",\\\"upUsage\\\":14156405546,\\\"downUsage\\\":509860217630}]\");\n      var that = this;\n      let pipe = new DatePipe('en-US');\n      // let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let timezoneName = that.language['Coordinated Universal Time']; //'Coordinated Universal Time';\n      let date = new Date();\n      let monthCount = params.monthCount ? params.monthCount : 1;\n      let firstDay = new Date(date.getFullYear(), date.getMonth() - monthCount, 1);\n      let lastDay = new Date(date.getFullYear(), date.getMonth(), 0);\n      let startDate = this.dateUtils.getMonthYear(firstDay);\n      let subsId = '';\n      let endDate = this.dateUtils.getMonthYear(lastDay);\n      let subTitle = '';\n      let upUsage,\n        upUsageTotal = 0;\n      let downUsage,\n        downUsageTotal = 0;\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      for (let i = 0; i < data.length; i++) {\n        //let period = this.dateUtils.getChartFormatDate(data[i].startPeriodSec, 'MM/yyyy');\n        let period = this.dateUtils.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true, 'MM/yyyy');\n        categories.push(period);\n        seriesData1.push(data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : null);\n        seriesData2.push(data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : null);\n        upUsageTotal += data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets : 0;\n        downUsageTotal += data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets : 0;\n      }\n      let upUsageUnit = this.getStackedUnit(upUsageTotal);\n      let downUsageUnit = this.getStackedUnit(downUsageTotal);\n      upUsage = (upUsageTotal / upUsageUnit[0]).toFixed(2) + ' ' + upUsageUnit[1];\n      downUsage = (downUsageTotal / downUsageUnit[0]).toFixed(2) + ' ' + downUsageUnit[1];\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: this.language['subscriberMonthlyUsage']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              let y = this;\n              var m = y.axis.series[0].dataMax;\n              var s;\n              var unit = m > 1000000000000 ? [1000000000000, 'TB'] : m > 1000000000 ? [1000000000, 'GB'] : m > 1000000 ? [1000000, 'MB'] : m > 1000 ? [1000, 'KB'] : [1, 'B'];\n              s = (y.value / unit[0]).toFixed(1) + (y.isFirst ? ' ' : ' ' + unit[1]);\n              return s;\n            }\n          },\n          opposite: false,\n          tickLength: 2\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: false\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            //color: '#E87B00',\n            colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            // cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        exporting: {\n          filename: 'Subscriber_Monthly_Usage',\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  let subscriber = ``;\n                  if (that.sso.getTrafficReportChartSubscriberInfo()) {\n                    subscriber = `${that.language['Subscriber']}: ${that.sso.getTrafficReportChartSubscriberInfo()}\\r\\n`;\n                  }\n                  extraData = `${that.language['subscriberMonthlyUsage']}\\r\\n${subscriber}${that.language['time_win']}: ${startDate} - ${endDate} [${timezoneName}]\\r\\n${that.language['upUsageTitle']}: ${upUsage}    ${that.language['downUsageTitle']}: ${downUsage}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.dateUtils.getUTCDateFormatFromUTCTime(data[i].startPeriodSec, true, 'MM/yyyy'),\n                      'Up Usage(Byte)': data[i].usOctets && data[i].usOctets !== -1 ? data[i].usOctets.toLocaleString() : 0,\n                      'Down Usage(Byte)': data[i].dsOctets && data[i].dsOctets !== -1 ? data[i].dsOctets.toLocaleString() : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('Subscriber_Monthly_Usage', dataExport, extraData);\n                }\n              }],\n              text: 'Export'\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var name = this.x || this.point.name;\n            var unit = that.getUnit(m);\n            return '<p><strong>' + name + '</strong><br/><span> ' + this.series.name + ': <strong>' + (this.y / unit[0]).toFixed(2) + ' ' + unit[1] + '</strong><br/></span></p>';\n          }\n        }\n      };\n      options.series = [{\n        name: this.language['upUsageTitle'],\n        data: seriesData1,\n        color: \"#82BF00\" // green\n      }, {\n        name: this.language['downUsageTitle'],\n        data: seriesData2,\n        color: \"#0279FF\" // blue\n      }];\n\n      options.xAxis['categories'] = categories;\n      let subscriber = ``;\n      if (this.sso.getTrafficReportChartSubscriberInfo()) {\n        subscriber = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['Subscriber']}: ${this.sso.getTrafficReportChartSubscriberInfo()}</span><span style=\"font-size:16px; color:#ffffff\">...</span>`;\n      }\n      subTitle = `${subscriber}<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${startDate} to ${endDate} [${timezoneName}]</span><br/>\n    <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['upUsageTitle']}: ${upUsage}    ${this.language['downUsageTitle']}:  ${downUsage}</span>`;\n      options.subtitle.text = subTitle;\n      return options;\n    }\n    convertDate(ts) {\n      var date = new Date(ts);\n      var mm = (date.getMonth() + 1).toString();\n      var dd = date.getDate().toString();\n      var mmChars = mm.split('');\n      var ddChars = dd.split('');\n      return (mmChars[1] ? mm : \"0\" + mmChars[0]) + '/' + (ddChars[1] ? dd : \"0\" + ddChars[0]);\n    }\n    /**\r\n     * setTopEP\r\n     */\n    setTopEP(data) {\n      if (data) {\n        localStorage.setItem('calix.topep_data', JSON.stringify(data));\n      } else {\n        localStorage.removeItem('calix.topep_data');\n      }\n    }\n    getTopEP() {\n      return localStorage.getItem('calix.topep_data') ? JSON.parse(localStorage.getItem('calix.topep_data')) : [];\n    }\n    setTopApp(data) {\n      if (data) {\n        localStorage.setItem('calix.topapp_data', JSON.stringify(data));\n      } else {\n        localStorage.removeItem('calix.topapp_data');\n      }\n    }\n    getTopApp() {\n      return localStorage.getItem('calix.topapp_data') ? JSON.parse(localStorage.getItem('calix.topapp_data')) : [];\n    }\n    setTopLoc(data) {\n      if (data) {\n        localStorage.setItem('calix.toploc_data', JSON.stringify(data));\n      } else {\n        localStorage.removeItem('calix.toploc_data');\n      }\n    }\n    getTopLoc() {\n      return localStorage.getItem('calix.toploc_data') ? JSON.parse(localStorage.getItem('calix.toploc_data')) : [];\n    }\n    getStackedUnit(m) {\n      let unit;\n      if (m > 1000000000000) {\n        unit = [1000000000000, 'TB']; //1099511627776\n      } else if (m > 1000000000) {\n        unit = [1000000000, 'GB']; //1073741824\n      } else if (m > 1000000) {\n        unit = [1000000, 'MB']; //1048576\n      } else if (m > 1000) {\n        unit = [1000, 'KB']; //1024\n      } else {\n        unit = [1, ''];\n      }\n      return unit;\n    }\n    setNetworkRealTimeGraphData(key, data) {\n      if (data) {\n        localStorage.setItem(key, JSON.stringify(data));\n      } else {\n        localStorage.removeItem(key);\n      }\n    }\n    getNetworkRealTimeGraphData(key) {\n      this.defaultData['graphType'] = key;\n      return localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : this.defaultData;\n    }\n    /***end-aswin-06-05-2021-localstorage-realtime-graphdata */\n    bitsToSize(bits, round) {\n      let bytes = bits;\n      let sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];\n      if (bytes == 0) return '0 bps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      if (round) {\n        return Math.round(bytes / Math.pow(1000, i)) + ' ' + sizes[i];\n      }\n      if (i < 0) {\n        i = 0;\n      }\n      let n = 1;\n      if (Number.isInteger(+Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 1))) {\n        n = 0;\n      }\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), n) + ' ' + sizes[i];\n    }\n    getDateTime(time, utc, format) {\n      let offset = -1 * (new Date().getTimezoneOffset() * 60);\n      if (utc) {\n        time = parseInt(time + offset) * 1000;\n      } else {\n        time = parseInt(time) * 1000;\n      }\n      let date = DateTime.fromMillis(time);\n      let dateString = '';\n      if (format) {\n        dateString = date.toUTC().toFormat(format);\n      } else {\n        dateString = date.toUTC().toFormat('MM/dd/yyyy');\n      }\n      return dateString;\n    }\n    getUnit(m) {\n      let unit;\n      if (m > 1000000000000) {\n        unit = [1000000000000, 'TB'];\n      } else if (m > 1000000000) {\n        unit = [1000000000, 'GB'];\n      } else if (m > 1000000) {\n        unit = [1000000, 'MB'];\n      } else if (m > 1000) {\n        unit = [1000, 'KB'];\n      } else {\n        unit = [1, 'KB'];\n      }\n      return unit;\n    }\n  }\n  OptionsManagerService.ɵfac = function OptionsManagerService_Factory(t) {\n    return new (t || OptionsManagerService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.FaUtilsService), i0.ɵɵinject(i3.DateUtilsService), i0.ɵɵinject(i4.ExportExcelService), i0.ɵɵinject(i5.CustomTranslateService), i0.ɵɵinject(i6.SsoAuthService), i0.ɵɵinject(i7.ReportApiService));\n  };\n  OptionsManagerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: OptionsManagerService,\n    factory: OptionsManagerService.ɵfac,\n    providedIn: 'root'\n  });\n  return OptionsManagerService;\n})();","map":null,"metadata":{},"sourceType":"module"}