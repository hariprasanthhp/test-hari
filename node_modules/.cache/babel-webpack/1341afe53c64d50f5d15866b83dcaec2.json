{"ast":null,"code":"/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DygraphOptions is responsible for parsing and returning\n * information about options.\n */\n\n// TODO: remove this jshint directive & fix the warnings.\n/*jshint sub:true */\n\"use strict\";\n\nimport * as utils from './dygraph-utils';\nimport DEFAULT_ATTRS from './dygraph-default-attrs';\nimport OPTIONS_REFERENCE from './dygraph-options-reference';\n\n/*\n * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)\n * global_ - global attributes (common among all graphs, AIUI)\n * user - attributes set by the user\n * series_ - { seriesName -> { idx, yAxis, options }}\n */\n\n/**\n * This parses attributes into an object that can be easily queried.\n *\n * It doesn't necessarily mean that all options are available, specifically\n * if labels are not yet available, since those drive details of the per-series\n * and per-axis options.\n *\n * @param {Dygraph} dygraph The chart to which these options belong.\n * @constructor\n */\nvar DygraphOptions = function (dygraph) {\n  /**\n   * The dygraph.\n   * @type {!Dygraph}\n   */\n  this.dygraph_ = dygraph;\n\n  /**\n   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }\n   * @type {Array.<{series : Array.<string>, options : Object}>} @private\n   */\n  this.yAxes_ = [];\n\n  /**\n   * Contains x-axis specific options, which are stored in the options key.\n   * This matches the yAxes_ object structure (by being a dictionary with an\n   * options element) allowing for shared code.\n   * @type {options: Object} @private\n   */\n  this.xAxis_ = {};\n  this.series_ = {};\n\n  // Once these two objects are initialized, you can call get();\n  this.global_ = this.dygraph_.attrs_;\n  this.user_ = this.dygraph_.user_attrs_ || {};\n\n  /**\n   * A list of series in columnar order.\n   * @type {Array.<string>}\n   */\n  this.labels_ = [];\n  this.highlightSeries_ = this.get(\"highlightSeriesOpts\") || {};\n  this.reparseSeries();\n};\n\n/**\n * Not optimal, but does the trick when you're only using two axes.\n * If we move to more axes, this can just become a function.\n *\n * @type {Object.<number>}\n * @private\n */\nDygraphOptions.AXIS_STRING_MAPPINGS_ = {\n  'y': 0,\n  'Y': 0,\n  'y1': 0,\n  'Y1': 0,\n  'y2': 1,\n  'Y2': 1\n};\n\n/**\n * @param {string|number} axis\n * @private\n */\nDygraphOptions.axisToIndex_ = function (axis) {\n  if (typeof axis == \"string\") {\n    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {\n      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];\n    }\n    throw \"Unknown axis : \" + axis;\n  }\n  if (typeof axis == \"number\") {\n    if (axis === 0 || axis === 1) {\n      return axis;\n    }\n    throw \"Dygraphs only supports two y-axes, indexed from 0-1.\";\n  }\n  if (axis) {\n    throw \"Unknown axis : \" + axis;\n  }\n  // No axis specification means axis 0.\n  return 0;\n};\n\n/**\n * Reparses options that are all related to series. This typically occurs when\n * options are either updated, or source data has been made available.\n *\n * TODO(konigsberg): The method name is kind of weak; fix.\n */\nDygraphOptions.prototype.reparseSeries = function () {\n  var labels = this.get(\"labels\");\n  if (!labels) {\n    return; // -- can't do more for now, will parse after getting the labels.\n  }\n\n  this.labels_ = labels.slice(1);\n  this.yAxes_ = [{\n    series: [],\n    options: {}\n  }]; // Always one axis at least.\n  this.xAxis_ = {\n    options: {}\n  };\n  this.series_ = {};\n\n  // Series are specified in the series element:\n  //\n  // {\n  //   labels: [ \"X\", \"foo\", \"bar\" ],\n  //   pointSize: 3,\n  //   series : {\n  //     foo : {}, // options for foo\n  //     bar : {} // options for bar\n  //   }\n  // }\n  //\n  // So, if series is found, it's expected to contain per-series data, otherwise set a\n  // default.\n  var seriesDict = this.user_.series || {};\n  for (var idx = 0; idx < this.labels_.length; idx++) {\n    var seriesName = this.labels_[idx];\n    var optionsForSeries = seriesDict[seriesName] || {};\n    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries[\"axis\"]);\n    this.series_[seriesName] = {\n      idx: idx,\n      yAxis: yAxis,\n      options: optionsForSeries\n    };\n    if (!this.yAxes_[yAxis]) {\n      this.yAxes_[yAxis] = {\n        series: [seriesName],\n        options: {}\n      };\n    } else {\n      this.yAxes_[yAxis].series.push(seriesName);\n    }\n  }\n  var axis_opts = this.user_[\"axes\"] || {};\n  utils.update(this.yAxes_[0].options, axis_opts[\"y\"] || {});\n  if (this.yAxes_.length > 1) {\n    utils.update(this.yAxes_[1].options, axis_opts[\"y2\"] || {});\n  }\n  utils.update(this.xAxis_.options, axis_opts[\"x\"] || {});\n\n  // For \"production\" code, this gets removed by uglifyjs.\n  if (typeof process !== 'undefined') {\n    if (process.env.NODE_ENV != 'production') {\n      this.validateOptions_();\n    }\n  }\n};\n\n/**\n * Get a global value.\n *\n * @param {string} name the name of the option.\n */\nDygraphOptions.prototype.get = function (name) {\n  var result = this.getGlobalUser_(name);\n  if (result !== null) {\n    return result;\n  }\n  return this.getGlobalDefault_(name);\n};\nDygraphOptions.prototype.getGlobalUser_ = function (name) {\n  if (this.user_.hasOwnProperty(name)) {\n    return this.user_[name];\n  }\n  return null;\n};\nDygraphOptions.prototype.getGlobalDefault_ = function (name) {\n  if (this.global_.hasOwnProperty(name)) {\n    return this.global_[name];\n  }\n  if (DEFAULT_ATTRS.hasOwnProperty(name)) {\n    return DEFAULT_ATTRS[name];\n  }\n  return null;\n};\n\n/**\n * Get a value for a specific axis. If there is no specific value for the axis,\n * the global value is returned.\n *\n * @param {string} name the name of the option.\n * @param {string|number} axis the axis to search. Can be the string representation\n * (\"y\", \"y2\") or the axis number (0, 1).\n */\nDygraphOptions.prototype.getForAxis = function (name, axis) {\n  var axisIdx;\n  var axisString;\n\n  // Since axis can be a number or a string, straighten everything out here.\n  if (typeof axis == 'number') {\n    axisIdx = axis;\n    axisString = axisIdx === 0 ? \"y\" : \"y2\";\n  } else {\n    if (axis == \"y1\") {\n      axis = \"y\";\n    } // Standardize on 'y'. Is this bad? I think so.\n    if (axis == \"y\") {\n      axisIdx = 0;\n    } else if (axis == \"y2\") {\n      axisIdx = 1;\n    } else if (axis == \"x\") {\n      axisIdx = -1; // simply a placeholder for below.\n    } else {\n      throw \"Unknown axis \" + axis;\n    }\n    axisString = axis;\n  }\n  var userAxis = axisIdx == -1 ? this.xAxis_ : this.yAxes_[axisIdx];\n\n  // Search the user-specified axis option first.\n  if (userAxis) {\n    // This condition could be removed if we always set up this.yAxes_ for y2.\n    var axisOptions = userAxis.options;\n    if (axisOptions.hasOwnProperty(name)) {\n      return axisOptions[name];\n    }\n  }\n\n  // User-specified global options second.\n  // But, hack, ignore globally-specified 'logscale' for 'x' axis declaration.\n  if (!(axis === 'x' && name === 'logscale')) {\n    var result = this.getGlobalUser_(name);\n    if (result !== null) {\n      return result;\n    }\n  }\n  // Default axis options third.\n  var defaultAxisOptions = DEFAULT_ATTRS.axes[axisString];\n  if (defaultAxisOptions.hasOwnProperty(name)) {\n    return defaultAxisOptions[name];\n  }\n\n  // Default global options last.\n  return this.getGlobalDefault_(name);\n};\n\n/**\n * Get a value for a specific series. If there is no specific value for the series,\n * the value for the axis is returned (and afterwards, the global value.)\n *\n * @param {string} name the name of the option.\n * @param {string} series the series to search.\n */\nDygraphOptions.prototype.getForSeries = function (name, series) {\n  // Honors indexes as series.\n  if (series === this.dygraph_.getHighlightSeries()) {\n    if (this.highlightSeries_.hasOwnProperty(name)) {\n      return this.highlightSeries_[name];\n    }\n  }\n  if (!this.series_.hasOwnProperty(series)) {\n    throw \"Unknown series: \" + series;\n  }\n  var seriesObj = this.series_[series];\n  var seriesOptions = seriesObj[\"options\"];\n  if (seriesOptions.hasOwnProperty(name)) {\n    return seriesOptions[name];\n  }\n  return this.getForAxis(name, seriesObj[\"yAxis\"]);\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraphOptions.prototype.numAxes = function () {\n  return this.yAxes_.length;\n};\n\n/**\n * Return the y-axis for a given series, specified by name.\n */\nDygraphOptions.prototype.axisForSeries = function (series) {\n  return this.series_[series].yAxis;\n};\n\n/**\n * Returns the options for the specified axis.\n */\n// TODO(konigsberg): this is y-axis specific. Support the x axis.\nDygraphOptions.prototype.axisOptions = function (yAxis) {\n  return this.yAxes_[yAxis].options;\n};\n\n/**\n * Return the series associated with an axis.\n */\nDygraphOptions.prototype.seriesForAxis = function (yAxis) {\n  return this.yAxes_[yAxis].series;\n};\n\n/**\n * Return the list of all series, in their columnar order.\n */\nDygraphOptions.prototype.seriesNames = function () {\n  return this.labels_;\n};\n\n// For \"production\" code, this gets removed by uglifyjs.\nif (typeof process !== 'undefined') {\n  if (process.env.NODE_ENV != 'production') {\n    /**\n     * Validate all options.\n     * This requires OPTIONS_REFERENCE, which is only available in debug builds.\n     * @private\n     */\n    DygraphOptions.prototype.validateOptions_ = function () {\n      if (typeof OPTIONS_REFERENCE === 'undefined') {\n        throw 'Called validateOptions_ in prod build.';\n      }\n      var that = this;\n      var validateOption = function (optionName) {\n        if (!OPTIONS_REFERENCE[optionName]) {\n          that.warnInvalidOption_(optionName);\n        }\n      };\n      var optionsDicts = [this.xAxis_.options, this.yAxes_[0].options, this.yAxes_[1] && this.yAxes_[1].options, this.global_, this.user_, this.highlightSeries_];\n      var names = this.seriesNames();\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (this.series_.hasOwnProperty(name)) {\n          optionsDicts.push(this.series_[name].options);\n        }\n      }\n      for (var i = 0; i < optionsDicts.length; i++) {\n        var dict = optionsDicts[i];\n        if (!dict) continue;\n        for (var optionName in dict) {\n          if (dict.hasOwnProperty(optionName)) {\n            validateOption(optionName);\n          }\n        }\n      }\n    };\n    var WARNINGS = {}; // Only show any particular warning once.\n\n    /**\n     * Logs a warning about invalid options.\n     * TODO: make this throw for testing\n     * @private\n     */\n    DygraphOptions.prototype.warnInvalidOption_ = function (optionName) {\n      if (!WARNINGS[optionName]) {\n        WARNINGS[optionName] = true;\n        var isSeries = this.labels_.indexOf(optionName) >= 0;\n        if (isSeries) {\n          console.warn('Use new-style per-series options (saw ' + optionName + ' as top-level options key). See http://bit.ly/1tceaJs');\n        } else {\n          console.warn('Unknown option ' + optionName + ' (full list of options at dygraphs.com/options.html');\n        }\n        throw \"invalid option \" + optionName;\n      }\n    };\n\n    // Reset list of previously-shown warnings. Used for testing.\n    DygraphOptions.resetWarnings_ = function () {\n      WARNINGS = {};\n    };\n  }\n}\nexport default DygraphOptions;","map":null,"metadata":{},"sourceType":"module"}