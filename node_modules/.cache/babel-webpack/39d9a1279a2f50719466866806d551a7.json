{"ast":null,"code":"import { of } from 'rxjs';\nimport * as Highcharts from \"highcharts/highstock\";\nimport More from \"highcharts/highcharts-more\";\nimport Drilldown from \"highcharts/modules/drilldown\";\n//Load the exporting module.\nimport Exporting from \"highcharts/modules/exporting\";\nimport customEvents from \"highcharts-custom-events\";\nimport { DatePipe, TitleCasePipe } from '@angular/common';\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app-services/translate.service\";\nimport * as i2 from \"src/app/shared-utils/date-utils.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"src/app/cco/health/service/health.service\";\nimport * as i5 from \"../../service/issue.service\";\nrequire('highcharts/highcharts-more')(Highcharts);\nrequire('highcharts/modules/solid-gauge')(Highcharts);\nconst IndicatorsCore = require(\"highcharts/indicators/indicators\");\nIndicatorsCore(Highcharts);\nconst IndicatorZigZag = require(\"highcharts/indicators/zigzag\");\nIndicatorZigZag(Highcharts);\nconst borderRadius = require('highcharts-border-radius');\nborderRadius(Highcharts);\nMore(Highcharts);\nDrilldown(Highcharts);\n// // Initialize exporting module.\nExporting(Highcharts);\ncustomEvents(Highcharts);\n//import { ShortnumberPipe } from 'src/app/support/shared/custom-pipes/shortnumber.pipe'\nconst $ = require('jquery');\nexport let HistoryChartOptionsService = /*#__PURE__*/(() => {\n  class HistoryChartOptionsService {\n    constructor(translateService, dateUtils, router, healthService, issueService) {\n      this.translateService = translateService;\n      this.dateUtils = dateUtils;\n      this.router = router;\n      this.healthService = healthService;\n      this.issueService = issueService;\n      this.subTitleObj = {\n        alarm: {\n          'byday': '',\n          'severity': '',\n          'region': '',\n          'location': '',\n          'system': ''\n        },\n        event: {\n          'region': '',\n          'location': '',\n          'system': ''\n        }\n      };\n      this.colors = {\n        \"critical\": \"#C70000\",\n        \"major\": \"#FC7235\",\n        \"minor\": \"#F3B426\",\n        \"warning\": \"#f7e9c1\",\n        \"info\": \"#7cb5ec\"\n      };\n      this.fadecolors = {\n        \"critical\": \"#ff8585\",\n        \"major\": \"#fdb89b\",\n        \"minor\": \"#f9d88b\",\n        \"warning\": \"#faf2db\",\n        \"info\": \"#b8d7f5\"\n      };\n      this.filters = ['region', 'location', 'system', 'fsan_serialnumber', 'severity', 'category', 'customCategory', 'alarmEventName', 'cco_ack', 'cco_shelv'];\n      this.filtersObj = {\n        'region': 'Region',\n        'location': 'Location',\n        'system': 'System',\n        'severity': 'Severity',\n        'category': 'Category',\n        'customCategory': 'Alarm Group',\n        'alarmEventName': window.location.pathname.indexOf('/history-reports') !== -1 ? 'Alarm/Event Name' : 'Alarm Name',\n        'fsan_serialnumber': 'FSAN',\n        'cco_ack': 'Acknowledged Alarms',\n        'cco_shelv': 'Shelved Alarms'\n      };\n      this.pieChartColurs = ['#0027FF', '#5ACFEA', '#B926F0', '#FF8238'];\n      this.stackedColumnColors = ['#5ACFEA', '#0027FF'];\n      this.stackedWfhColors = ['#0027FF', '#5ACFEA'];\n      this.stackedAqiteColors = ['#84BBF8', '#FC6784', '#FD9E4C', '#A3A5ED', '#CBC75F'];\n      this.stackedSubsColors = ['#5ACFEA', '#349885', '#0027FF'];\n      this.stackedSubsbarColors = ['#F3B426', '#FC7235', '#C70000'];\n      this.stackedSubsbarnewColors = ['#C70000', '#FC7235', '#F3B426'];\n      this.commonHighChartOptions = {\n        exporting: {\n          enabled: false\n        },\n        credits: {\n          enabled: false\n        },\n        title: {\n          text: ''\n        },\n        responsive: {\n          rules: [{\n            condition: {},\n            chartOptions: {\n              chart: {\n                styledMode: true\n              },\n              // subtitle: {\n              //   text: null\n              // },\n              navigator: {\n                enabled: false\n              }\n            }\n          }]\n        }\n      };\n      this.regions = {};\n      this.locations = {};\n      this.systems = {};\n      this.userFilters = {\n        alarm: {\n          'byday': {},\n          'severity': {},\n          'region': {},\n          'location': {},\n          'system': {}\n        },\n        event: {\n          'region': {},\n          'location': {},\n          'system': {}\n        }\n      };\n      this.language = this.translateService.defualtLanguage;\n      this.translateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n    }\n    alarmBarChart() {\n      let object = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        colors: this.stackedSubsbarColors,\n        chart: {\n          type: 'column',\n          inverted: false // default\n        },\n        credits: {\n          enabled: false\n        },\n        legend: {},\n        yAxis: {\n          min: 0,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: 'Duplicated Alarms (%)'\n          },\n          stackLabels: {\n            enabled: true,\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular',\n              color: '#4c4c4c'\n            },\n            formatter: function () {\n              return this.total + '%';\n            }\n          }\n        },\n        tooltip: {\n          headerFormat: '<b>{point.x}</b><br/>',\n          pointFormat: '{series.name}: {point.y}<br/>Total: {point.stackTotal}'\n        },\n        xAxis: {\n          categories: ['S-CMM-1', 'S-CMM-2', 'S-CMM-1', 'S-CMM-2', 'S-CMM-1', 'S-CMM-2', 'S-CMM-1', 'S-CMM-2', 'S-CMM-1', 'S-CMM-2', 'S-CMM-1', 'S-CMM-2'],\n          crosshair: false\n        },\n        plotOptions: {\n          series: {\n            maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: [{\n          name: 'Critical',\n          data: [2, 2, 3, 2, 1, 23, 2, 2, 3, 2, 1, 23],\n          stack: 'criticalMajor'\n        }, {\n          name: 'Major',\n          data: [3, 4, 4, 2, 5, 2, 2, 3, 2, 1, 23, 2],\n          stack: 'criticalMajor'\n        }, {\n          name: 'Minor',\n          data: [5, 3, 4, 7, 2, 2, 2, 3, 2, 1, 23, 2],\n          stack: 'Minor'\n        }]\n      });\n      return of(object);\n    }\n    ///\n    alarmBarHistoryChart() {\n      let object = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        colors: this.stackedSubsbarColors,\n        chart: {\n          type: 'column',\n          inverted: false // default\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: 'Duplicated Alarms (%)'\n          },\n          stackLabels: {\n            enabled: true,\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular',\n              color: '#4c4c4c'\n            },\n            formatter: function () {\n              return this.total + '%';\n            }\n          }\n        },\n        tooltip: {\n          headerFormat: '<b>{point.x}</b><br/>',\n          pointFormat: '{series.name}: {point.y}<br/>Total: {point.stackTotal}'\n        },\n        xAxis: {\n          categories: ['E7-AXOS', 'E7-20', 'CMS', 'E7-2', 'E7-AXOS', 'E7-20', 'CMS', 'E7-2'],\n          crosshair: false\n        },\n        plotOptions: {\n          series: {\n            maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: [{\n          name: 'E7-AXOS',\n          data: [5, 3, 4, 7, 2]\n        }, {\n          name: 'E7-20',\n          data: [2, 2, 3, 2, 1]\n        }, {\n          name: 'CMS',\n          data: [3, 4, 4, 2, 5]\n        }, {\n          name: 'E7-2',\n          data: [3, 4, 4, 2, 5]\n        }]\n      });\n      return of(object);\n    }\n    //pie\n    pieChartBlockedThreatOptions() {\n      let object = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          plotBackgroundColor: null,\n          plotBorderWidth: null,\n          plotShadow: false,\n          type: 'pie'\n        },\n        colors: this.pieChartColurs,\n        tooltip: {\n          pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'\n        },\n        accessibility: {\n          point: {\n            valueSuffix: '%'\n          }\n        },\n        plotOptions: {\n          series: {\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          pie: {\n            size: '80%',\n            allowPointSelect: true,\n            cursor: 'pointer',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: true,\n              format: '{point.name}',\n              //useHTML: true,\n              crop: false,\n              distance: 2,\n              overflow: \"visible\",\n              style: {\n                width: '100px',\n                fontSize: '10px',\n                font: 'Source Sans Pro,Regular',\n                color: '#4C4C4C'\n              }\n            }\n            // connectorColor: '#000000'\n          }\n        },\n\n        series: [{\n          name: 'Brands',\n          colorByPoint: true,\n          data: [{\n            name: 'Critical(123)',\n            y: 61.41,\n            sliced: false,\n            selected: true\n          }, {\n            name: 'Major(123)',\n            y: 11.84\n          }, {\n            name: 'Minor(90)',\n            y: 10.85\n          }]\n        }]\n      });\n      return of(object);\n    }\n    severityChartOptions(data, title, type, params = {}) {\n      let pipe = new TitleCasePipe();\n      let subTitle = this.getSubTitle(params, {}, {}, 'alarm', 'severity');\n      this.filters.forEach((element, index) => {\n        if (params[element]) {\n          if (element === 'system') {\n            if (typeof params[element] === 'object') {\n              params[element].forEach((e, i) => {\n                params[element][i] = params[element][i].replace('device=', '');\n                params[element][i] = params[element][i].replace('DEVICE=', '');\n              });\n            } else {\n              params[element] = params[element].replace('device=', '');\n              params[element] = params[element].replace('DEVICE=', '');\n            }\n          }\n        }\n      });\n      let chartData = data;\n      let seriesData = [];\n      let size = type == \"small\" ? \"70%\" : \"100%\";\n      var a = title.split(' ');\n      let name = a[1];\n      if (chartData && chartData.minor >= 0) {\n        let min = {\n          name: `${this.language.minor} (${chartData.minor})`,\n          y: chartData.minor ? chartData.minor : null,\n          color: environment['OPERATIONS_HOME_ACTIVE_ALARMS_COLORS'].minor,\n          legendIndex: 3,\n          severity: 'Minor'\n        };\n        seriesData.push(min);\n      }\n      if (chartData && chartData.major >= 0) {\n        let maj = {\n          name: `${this.language.major} (${chartData.major})`,\n          y: chartData.major ? chartData.major : null,\n          color: environment['OPERATIONS_HOME_ACTIVE_ALARMS_COLORS'].major,\n          legendIndex: 2,\n          severity: 'Major'\n        };\n        seriesData.push(maj);\n      }\n      if (chartData && chartData.critical >= 0) {\n        let critical = {\n          name: `${this.language.critical} (${chartData.critical})`,\n          y: chartData.critical ? chartData.critical : null,\n          color: environment['OPERATIONS_HOME_ACTIVE_ALARMS_COLORS'].critical,\n          legendIndex: 1,\n          severity: 'Critical'\n        };\n        seriesData.push(critical);\n      }\n      if (chartData && chartData.warning >= 0) {\n        let warning = {\n          name: `${this.language.Warning} (${chartData.warning})`,\n          y: chartData.warning ? chartData.warning : null,\n          color: environment['OPERATIONS_HOME_ACTIVE_ALARMS_COLORS'].warning,\n          legendIndex: 4,\n          severity: 'Warning'\n        };\n        seriesData.push(warning);\n      }\n      if (chartData && chartData.info >= 0) {\n        let info = {\n          name: `${this.language.Info} (${chartData.info})`,\n          y: chartData.info ? chartData.info : null,\n          color: environment['OPERATIONS_HOME_ACTIVE_ALARMS_COLORS'].info,\n          legendIndex: 5,\n          severity: 'Info'\n        };\n        seriesData.push(info);\n      }\n      // if (chartData2.minor > 0) {\n      //   let min = {\n      //     name: this.language.minor,\n      //     y: chartData2.minor,\n      //     color: '#F3B426'\n      //   }\n      //   seriesData2.push(min)\n      // }\n      // if (chartData2.major > 0) {\n      //   let maj = {\n      //     name: this.language.major,\n      //     y: chartData2.major,\n      //     color: '#FC7235'\n      //   }\n      //   seriesData2.push(maj)\n      // }\n      // if (chartData2.critical > 0) {\n      //   let critical = {\n      //     name: this.language.critical,\n      //     y: chartData2.critical,\n      //     color: '#C70000'\n      //   }\n      //   seriesData2.push(critical)\n      // }\n      // seriesData = [{\n      //   type: 'pie',\n      //   name: 'Raised',\n      //   data: seriesData1,\n      //   center: [type == \"full\" ? 200 : 200, type == \"full\" ? 180 : 120],\n      //   size: type == \"full\" ? 350 : 250,\n      //   showInLegend: false,\n      // }, {\n      //   type: 'pie',\n      //   name: 'Cleared',\n      //   data: seriesData2,\n      //   center: [type == \"full\" ? 650 : 600, type == \"full\" ? 180 : 120],\n      //   size: type == \"full\" ? 350 : 250,\n      //   showInLegend: false,\n      // }]\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          plotBackgroundColor: null,\n          plotBorderWidth: null,\n          plotShadow: false,\n          type: 'pie'\n        },\n        title: {\n          text: type == \"active\" ? \"\" : this.language[title] || title\n        },\n        subtitle: {\n          text: subTitle\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            var index = this.key.indexOf('(');\n            var name = this.key.substr(0, index);\n            var percentage = Highcharts.numberFormat(Math.abs(this.percentage), 2);\n            s = `<b> ${name} : ${this.y} </b><br/>\n          <p>${this.series.name}<span>: <b>${percentage}%</b><br/></span></p>`;\n            return s;\n          }\n        },\n        accessibility: {\n          point: {\n            valueSuffix: '%'\n          }\n        },\n        lang: {\n          noData: !(data === null || data === void 0 ? void 0 : data.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            cursor: 'pointer',\n            point: {\n              events: {}\n            },\n            colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          // pie: {\n          //   size: size,\n          //   allowPointSelect: true,\n          //   cursor: 'pointer',\n          //   borderWidth: 0,\n          //   showInLegend: false,\n          //   dataLabels: {\n          //     enabled: true,\n          //     format: '{point.name}',\n          //     crop: false,\n          //     distance: 2,\n          //     overflow: \"visible\",\n          //     style: {\n          //       width: '10px',\n          //       fontSize: '10px',\n          //       font: 'Source Sans Pro,Regular',\n          //       color: '#4C4C4C'\n          //     },\n          //   },\n          // }\n          pie: {\n            size: size,\n            allowPointSelect: true,\n            cursor: 'pointer',\n            dataLabels: {\n              enabled: false\n            },\n            showInLegend: true\n          }\n        },\n        // legend: {\n        //   align: 'right',\n        //   verticalAlign: 'middle',\n        //   layout: 'vertical',\n        //   x: -150,\n        //   y: 120\n        // },\n        series: []\n      });\n      let showData = false;\n      if (chartData && Object.keys(chartData).length) {\n        let keys = Object.keys(chartData);\n        keys.forEach(element => {\n          if (chartData[element] > 0) {\n            showData = true;\n            return true;\n          }\n        });\n      }\n      if (seriesData.length > 0 && showData) {\n        options.series = [{\n          data: seriesData,\n          name: this.language[name] || name\n        }];\n      }\n      return options;\n    }\n    BIPErrorRateChart(data) {\n      let maxvalue = 0;\n      const self = this;\n      let category, categoryid, subTitle;\n      var seriesName = [];\n      var seriesData = [];\n      var xAxisCategories = [];\n      var seriesData1 = [];\n      var groupby = \"region\";\n      if (data.length) {\n        let count = 0;\n        let duplicate = []; //|| element.deleted == true\n        data = this.healthService.duplicateDataHandle(data, groupby, 'regionId');\n        data.forEach(element => {\n          xAxisCategories.push(element[groupby]);\n          seriesData1.push({\n            y: element.count ? element.count : 0,\n            color: this.healthService.chart_color(element, \"count\")\n          });\n        });\n        maxvalue = xAxisCategories.length > 20 ? 21 : xAxisCategories.length;\n      }\n      let options = {\n        credits: {\n          enabled: false\n        },\n        chart: {\n          type: 'column'\n        },\n        scrollbar: {\n          enabled: false\n        },\n        legend: {\n          enabled: true\n        },\n        exporting: {\n          enabled: false\n        },\n        title: {\n          //text: type,\n          style: {\n            display: 'none'\n          }\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: xAxisCategories,\n          min: 0,\n          max: maxvalue - 1,\n          scrollbar: {\n            barBackgroundColor: '#CCCCCC',\n            barBorderColor: '#ccc',\n            rifleColor: 'transparent',\n            barBorderRadius: 3,\n            trackBorderRadius: 3,\n            buttonArrowColor: 'transparent',\n            trackBackgroundColor: '#EBEAEF',\n            height: 6,\n            enabled: maxvalue == 21 ? true : false\n          }\n        },\n        yAxis: {\n          min: 0,\n          softMax: 1,\n          allowDecimals: false,\n          title: {\n            text: this.language['PON Interface Count']\n          },\n          gridLineWidth: 1,\n          style: {\n            stacking: 'normal'\n          }\n        },\n        tooltip: {\n          useHTML: true,\n          borderColor: environment.OPERATIONS.HEALTH['HEALTH_BAR_CHART_COLORS'].first,\n          formatter: function () {\n            var s = \"\",\n              h = \"\",\n              f = \"\",\n              info = \" \";\n            f = \"</table>\";\n            this.points.forEach(point => {\n              if (point.color == environment.OPERATIONS.HEALTH['HEALTH_DELETED_BAR_CHART_COLORS'].first || point.color == environment.OPERATIONS.HEALTH['DELETED_TRANSPARENT'].first) {\n                info = \" (Deleted)\";\n              }\n              h = `<span style = \"font-size:10px\"> ${point.key} ${info}  </span><table>`;\n              s += `<tr><td style='color:${self.healthService.toolip_color(point.color)};padding:0'> ${point.series.name} : </td>\n            <td style='padding:0;margin-left:10px'>&nbsp ${point.y} </b></td></tr>`;\n            });\n            let g = s + f;\n            return h + g;\n          },\n          shared: true\n        },\n        lang: {\n          noData: !(data === null || data === void 0 ? void 0 : data.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            //cursor: 'pointer',\n            minPointLength: 3,\n            point: {\n              events: {}\n            }\n            //maxPointWidth: 16,\n          },\n\n          column: {\n            // stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: [\n        // {\n        //   name: this.language[\"DownStream\"],\n        //   data: (seriesData || []),\n        //   color: '#0027FF'\n        // },\n        // {\n        //   name: this.language[\"UpStream\"],\n        //   data: (seriesData1 || []),\n        //   color: '#82BF00'\n        // }\n        {\n          name: this.language['BIP Error Interfaces'],\n          data: seriesData1 || [],\n          color: '#0027FF'\n        }]\n      };\n      return options;\n    }\n    systemChartOptions(data, activeReports = false, params, locations = {}, systems) {\n      let subTitle = '';\n      if (systems && Object.keys(systems).length) {\n        subTitle = this.getSubTitle(params, locations, systems, 'alarm', 'system');\n      } else {\n        subTitle = this.getSubTitle(params, locations, {}, 'alarm', 'system');\n      }\n      let series = [];\n      let columnTypes = [];\n      let categories = [];\n      if (data) {\n        let clearedtypes = [];\n        let raisedtypes = [];\n        data.forEach(element => {\n          if (systems && Object.keys(systems).length) {\n            let pointName = systems[element.system] ? systems[element.system].name : element.system;\n            element.displayName = pointName;\n          } else {\n            let pointName = this.systems[element.system] ? this.systems[element.system].name : element.system;\n            element.displayName = pointName;\n          }\n        });\n        data = data === null || data === void 0 ? void 0 : data.sort((a, b) => {\n          var _a;\n          return (_a = a === null || a === void 0 ? void 0 : a.displayName) === null || _a === void 0 ? void 0 : _a.localeCompare(b === null || b === void 0 ? void 0 : b.displayName);\n        });\n        data.forEach(element => {\n          if (element['system']) {\n            categories.push(element.displayName);\n            element['original_system'] = element['system'];\n            element['system'] = element['system'].replace('device=', '');\n            element['system'] = element['system'].replace('DEVICE=', '');\n            let ndata = element['alarm'] ? element['alarm'] : element;\n            if (ndata && ndata['cleared']) {\n              clearedtypes = [...clearedtypes, ...Object.keys(ndata['cleared'])];\n            }\n            if (ndata && ndata['raised']) {\n              raisedtypes = [...raisedtypes, ...Object.keys(ndata['raised'])];\n            }\n          }\n        });\n        clearedtypes = clearedtypes.filter((x, i, a) => a.indexOf(x) === i);\n        raisedtypes = raisedtypes.filter((x, i, a) => a.indexOf(x) === i);\n        if (raisedtypes.length > clearedtypes.length) {\n          columnTypes = raisedtypes;\n        } else {\n          columnTypes = clearedtypes;\n        }\n        //console.log(columnTypes);\n        let iSeries = {};\n        let stackTypes = ['raised'];\n        if (!activeReports) {\n          stackTypes.push('cleared');\n        }\n        let color = '';\n        if (columnTypes) {\n          columnTypes.forEach(type => {\n            stackTypes.forEach(stack => {\n              iSeries = {};\n              iSeries['name'] = this.language[type];\n              iSeries['data'] = [];\n              iSeries['color'] = this.colors[type];\n              iSeries['stack'] = stack;\n              if (stack === 'cleared') {\n                iSeries['linkedTo'] = ':previous';\n              }\n              data.forEach(element => {\n                let ndata = element['alarm'] ? element['alarm'] : element;\n                //iSeries['data'].push(ndata[stack][type]);\n                if (systems && Object.keys(systems).length) {\n                  color = systems[element.system] && systems[element.system].isDeleted ? this.fadecolors[type] : this.colors[type];\n                } else {\n                  color = this.systems[element.system] && this.systems[element.system].isDeleted ? this.fadecolors[type] : this.colors[type];\n                }\n                iSeries['data'].push({\n                  y: ndata[stack][type] ? ndata[stack][type] : null,\n                  category: element['original_system'],\n                  systemId: element['original_system'],\n                  severity: type,\n                  color: color\n                });\n              });\n              series.push(iSeries);\n            });\n          });\n        }\n      }\n      let that = this;\n      let pipe = new TitleCasePipe();\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          type: 'column',\n          inverted: false,\n          zoomType: 'y'\n        },\n        subtitle: {\n          text: subTitle\n        },\n        title: {\n          text: activeReports ? \"\" : `R-${this.language['Raised']}, C-${this.language['Cleared']}`,\n          align: 'right',\n          floating: false,\n          style: {\n            fontSize: '12px',\n            fontWeight: 'normal',\n            fontFamily: 'Source Sans Pro'\n          }\n        },\n        yAxis: {\n          min: 0,\n          allowDecimals: false,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: 'Count'\n          },\n          minRange: 1,\n          stackLabels: {\n            enabled: !activeReports,\n            crop: false,\n            overflow: 'none',\n            formatter: function () {\n              let label = \"C\";\n              if (this.stack === \"raised\") {\n                label = \"R\";\n              }\n              let s = `<span style=\"font-size: 12px; font-family: Source Sans Pro;font-style: normal;font-weight: normal;\"> ${label} </span>`;\n              // if (this.total === 0) {\n              //   s = \"\";\n              // }\n              return s;\n            }\n          }\n          //type: 'logarithmic'\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            s = '<b>' + that.language[pipe.transform(this.series.userOptions.stack)] + '</b><br/>' + '<b>' + this.x + '</b><br/>' + pipe.transform(this.series.name) + ': ' + this.y + '<br/>' + that.language['Total'] + ': ' + this.point.stackTotal;\n            return s;\n          }\n        },\n        xAxis: {\n          categories: categories\n        },\n        lang: {\n          noData: !(series === null || series === void 0 ? void 0 : series.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            cursor: 'pointer',\n            point: {\n              events: {}\n            },\n            //maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            minPointLength: 2.5,\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: []\n      });\n      if (series.length > 0) {\n        options.series = series;\n      }\n      return options;\n    }\n    locationChartOptions(data, activeReports = false, params = {}, locations) {\n      let subTitle = '';\n      if (locations && Object.keys(locations).length) {\n        subTitle = this.getSubTitle(params, locations, {}, 'alarm', 'location');\n      } else {\n        subTitle = this.getSubTitle(params, {}, {}, 'alarm', 'location');\n      }\n      let series = [];\n      let columnTypes = [];\n      let categories = [];\n      if (data) {\n        let clearedtypes = [];\n        let raisedtypes = [];\n        data.forEach(element => {\n          if (locations && Object.keys(locations).length) {\n            let pointName = locations[element.location] ? locations[element.location].name : element.location;\n            element.displayName = pointName;\n          } else {\n            let pointName = this.locations[element.location] ? this.locations[element.location].name : element.location;\n            element.displayName = pointName;\n          }\n        });\n        data = data === null || data === void 0 ? void 0 : data.sort((a, b) => {\n          var _a;\n          return (_a = a === null || a === void 0 ? void 0 : a.displayName) === null || _a === void 0 ? void 0 : _a.localeCompare(b === null || b === void 0 ? void 0 : b.displayName);\n        });\n        data.forEach(element => {\n          categories.push(element.displayName);\n          let ndata = element['alarm'] ? element['alarm'] : element;\n          if (ndata && ndata['cleared']) {\n            clearedtypes = [...clearedtypes, ...Object.keys(ndata['cleared'])];\n          }\n          if (ndata && ndata['raised']) {\n            raisedtypes = [...raisedtypes, ...Object.keys(ndata['raised'])];\n          }\n        });\n        clearedtypes = clearedtypes.filter((x, i, a) => a.indexOf(x) === i);\n        raisedtypes = raisedtypes.filter((x, i, a) => a.indexOf(x) === i);\n        if (raisedtypes.length > clearedtypes.length) {\n          columnTypes = raisedtypes;\n        } else {\n          columnTypes = clearedtypes;\n        }\n        let iSeries = {};\n        let stackTypes = ['raised'];\n        if (!activeReports) {\n          stackTypes.push('cleared');\n        }\n        let color = '';\n        if (columnTypes) {\n          columnTypes.forEach(type => {\n            stackTypes.forEach(stack => {\n              iSeries = {};\n              iSeries['name'] = this.language[type];\n              iSeries['data'] = [];\n              iSeries['color'] = this.colors[type];\n              iSeries['stack'] = stack;\n              if (stack === 'cleared') {\n                iSeries['linkedTo'] = ':previous';\n              }\n              data.forEach(element => {\n                let ndata = element['alarm'] ? element['alarm'] : element;\n                if (locations && Object.keys(locations).length) {\n                  color = locations[element.location] && locations[element.location].isDeleted ? this.fadecolors[type] : this.colors[type];\n                } else {\n                  color = this.locations[element.location] && this.locations[element.location].isDeleted ? this.fadecolors[type] : this.colors[type];\n                }\n                iSeries['data'].push({\n                  y: ndata[stack][type] ? ndata[stack][type] : null,\n                  locationId: element.location,\n                  severity: type,\n                  color: color\n                });\n              });\n              series.push(iSeries);\n            });\n          });\n        }\n      }\n      let that = this;\n      let pipe = new TitleCasePipe();\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          type: 'column',\n          inverted: false,\n          zoomType: 'y'\n        },\n        subtitle: {\n          text: subTitle\n        },\n        title: {\n          text: activeReports ? \"\" : `R-${this.language['Raised']}, C-${this.language['Cleared']}`,\n          align: 'right',\n          floating: false,\n          style: {\n            fontSize: '12px',\n            fontWeight: 'normal',\n            fontFamily: 'Source Sans Pro'\n          }\n        },\n        yAxis: {\n          min: 0,\n          allowDecimals: false,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: this.language.Count\n          },\n          minRange: 1,\n          stackLabels: {\n            enabled: !activeReports,\n            crop: false,\n            overflow: 'none',\n            formatter: function () {\n              let label = \"C\";\n              if (this.stack === \"raised\") {\n                label = \"R\";\n              }\n              let s = `<span style=\"font-size: 12px; font-family: Source Sans Pro;font-style: normal;font-weight: normal;\"> ${label} </span>`;\n              // if (this.total === 0) {\n              //   s = \"\";\n              // }\n              return s;\n            }\n          }\n          //type: 'logarithmic'\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            s = '<b>' + that.language[pipe.transform(this.series.userOptions.stack)] + '</b><br/>' + '<b>' + this.x + '</b><br/>' + pipe.transform(this.series.name) + ': ' + this.y + '<br/>' + that.language['Total'] + ': ' + this.point.stackTotal;\n            return s;\n          }\n        },\n        xAxis: {\n          categories: categories\n        },\n        lang: {\n          noData: !(series === null || series === void 0 ? void 0 : series.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            //maxPointWidth: 16,\n            cursor: 'pointer',\n            point: {\n              events: {}\n            },\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            minPointLength: 2.5,\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: []\n      });\n      if (series.length > 0) {\n        options.series = series;\n      }\n      return options;\n    }\n    regionChartOptions(data, activeReports = false, params = {}) {\n      let subTitle = this.getSubTitle(params, {}, {}, 'alarm', 'region');\n      let series = [];\n      let columnTypes = [];\n      let categories = [];\n      if (typeof data === \"object\") {\n        let clearedtypes = [];\n        let raisedtypes = [];\n        data.forEach(element => {\n          let pointName = this.regions[element.region] ? this.regions[element.region].name : element.region;\n          element.displayName = pointName;\n        });\n        data = data === null || data === void 0 ? void 0 : data.sort((a, b) => {\n          var _a;\n          return (_a = a === null || a === void 0 ? void 0 : a.displayName) === null || _a === void 0 ? void 0 : _a.localeCompare(b === null || b === void 0 ? void 0 : b.displayName);\n        });\n        data.forEach(element => {\n          categories.push(element.displayName);\n          let ndata = element['alarm'] ? element['alarm'] : element;\n          if (ndata && ndata['cleared']) {\n            clearedtypes = [...clearedtypes, ...Object.keys(ndata['cleared'])];\n          }\n          if (ndata && ndata['raised']) {\n            raisedtypes = [...raisedtypes, ...Object.keys(ndata['raised'])];\n          }\n        });\n        clearedtypes = clearedtypes.filter((x, i, a) => a.indexOf(x) === i);\n        raisedtypes = raisedtypes.filter((x, i, a) => a.indexOf(x) === i);\n        if (raisedtypes.length > clearedtypes.length) {\n          columnTypes = raisedtypes;\n        } else {\n          columnTypes = clearedtypes;\n        }\n        //console.log(columnTypes);\n        let iSeries = {};\n        let stackTypes = ['raised'];\n        if (!activeReports) {\n          stackTypes.push('cleared');\n        }\n        iSeries['stack'] = '';\n        if (columnTypes) {\n          columnTypes.forEach(type => {\n            stackTypes.forEach(stack => {\n              iSeries = {};\n              iSeries['name'] = this.language[type];\n              iSeries['data'] = [];\n              iSeries['color'] = this.colors[type];\n              iSeries['stack'] = stack;\n              if (stack === 'cleared') {\n                iSeries['linkedTo'] = ':previous';\n              }\n              data.forEach(element => {\n                let ndata = element['alarm'] ? element['alarm'] : element;\n                //iSeries['data'].push(ndata[stack][type]);\n                iSeries['data'].push({\n                  y: ndata[stack][type] ? ndata[stack][type] : null,\n                  regionId: element.region,\n                  severity: type,\n                  color: this.regions[element.region] && this.regions[element.region].isDeleted ? this.fadecolors[type] : this.colors[type]\n                });\n              });\n              series.push(iSeries);\n            });\n          });\n        }\n      }\n      let pipe = new TitleCasePipe();\n      let that = this;\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          type: 'column',\n          inverted: false,\n          zoomType: 'y'\n        },\n        title: {\n          text: activeReports ? \"\" : `R-${this.language['Raised']}, C-${this.language['Cleared']}`,\n          align: 'right',\n          floating: false,\n          style: {\n            fontSize: '12px',\n            fontWeight: 'normal',\n            fontFamily: 'Source Sans Pro'\n          }\n        },\n        subtitle: {\n          text: subTitle\n        },\n        yAxis: {\n          min: 0,\n          allowDecimals: false,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: `${this.language.Count}`\n          },\n          minRange: 1,\n          stackLabels: {\n            enabled: !activeReports,\n            crop: false,\n            overflow: 'none',\n            formatter: function () {\n              let label = \"C\";\n              if (this.stack === \"raised\") {\n                label = \"R\";\n              }\n              let s = `<span style=\"font-size: 12px; font-family: Source Sans Pro;font-style: normal;font-weight: normal;\"> ${label} </span>`;\n              // if (this.total === 0) {\n              //   s = \"\";\n              // }\n              return s;\n            }\n          }\n          //type: 'logarithmic'\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            s = s = '<b>' + that.language[pipe.transform(this.series.userOptions.stack)] + '</b><br/>' + '<b>' + this.x + '</b><br/>' + pipe.transform(this.series.name) + ': ' + this.y + '<br/>' + that.language['Total'] + ': ' + this.point.stackTotal;\n            return s;\n          }\n        },\n        xAxis: {\n          categories: categories\n        },\n        lang: {\n          noData: !(series === null || series === void 0 ? void 0 : series.length) ? this.language[\"No Data Available\"] : \" \"\n        },\n        plotOptions: {\n          series: {\n            cursor: 'pointer',\n            point: {\n              events: {}\n            },\n            //maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            stacking: 'normal',\n            minPointLength: 2.5,\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: series\n      });\n      // if (seriesData.length > 0) {\n      //   options.series = seriesData;\n      // }\n      return options;\n    }\n    severityEventChartOptions(data, title, type) {\n      let chartData = data;\n      let seriesData = [];\n      let size = type == \"small\" ? \"70%\" : \"100%\";\n      var a = title.split(' ');\n      let name = a[1];\n      if (chartData.minor > 0) {\n        let min = {\n          name: this.language.minor,\n          y: chartData.minor,\n          color: '#F3B426'\n        };\n        seriesData.push(min);\n      }\n      if (chartData.major > 0) {\n        let maj = {\n          name: this.language.major,\n          y: chartData.major,\n          color: '#FC7235'\n        };\n        seriesData.push(maj);\n      }\n      if (chartData.critical > 0) {\n        let critical = {\n          name: this.language.critical,\n          y: chartData.critical,\n          color: '#C70000'\n        };\n        seriesData.push(critical);\n      }\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          plotBackgroundColor: null,\n          plotBorderWidth: null,\n          plotShadow: false,\n          type: 'pie'\n        },\n        title: {\n          text: title\n        },\n        // colors: this.pieChartColurs,\n        tooltip: {\n          formatter: function () {\n            var s;\n            var percentage = Highcharts.numberFormat(Math.abs(this.percentage), 2);\n            s = `<b> ${this.key} : ${this.y} </b><br/>\n          <p>${this.series.name}<span>: <b>${percentage} %</b><br/></span></p>`;\n            return s;\n          }\n        },\n        accessibility: {\n          point: {\n            valueSuffix: '%'\n          }\n        },\n        lang: {\n          noData: !(seriesData === null || seriesData === void 0 ? void 0 : seriesData.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            cursor: 'pointer',\n            point: {\n              events: {}\n            },\n            colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          pie: {\n            size: size,\n            allowPointSelect: true,\n            cursor: 'pointer',\n            borderWidth: 0,\n            showInLegend: false,\n            dataLabels: {\n              enabled: true,\n              format: '{point.name}',\n              crop: false,\n              distance: 2,\n              overflow: \"visible\",\n              style: {\n                width: '100px',\n                fontSize: '10px',\n                font: 'Source Sans Pro,Regular',\n                color: '#4C4C4C'\n              }\n            }\n          }\n        },\n        series: []\n      });\n      if (seriesData.length > 0) {\n        options.series = [{\n          data: seriesData,\n          name: name\n        }];\n      }\n      return options;\n    }\n    systemEventChartOptions(data) {\n      let seriesData = [];\n      let categories = [];\n      let minor = [];\n      let critical = [];\n      let major = [];\n      let minorcleared = [];\n      let criticalcleared = [];\n      let majorcleared = [];\n      if (data) {\n        data.forEach(element => {\n          categories.push(element.system);\n          if (element.raised) {\n            minor.push(element.raised.minor ? element.raised.minor : 0);\n            critical.push(element.raised.critical ? element.raised.critical : 0);\n            major.push(element.raised.major ? element.raised.major : 0);\n          }\n          if (element.cleared) {\n            minorcleared.push(element.cleared.minor ? element.cleared.minor : 0);\n            criticalcleared.push(element.cleared.critical ? element.cleared.critical : 0);\n            majorcleared.push(element.cleared.major ? element.cleared.major : 0);\n          }\n        });\n      }\n      if (minor.length > 0) {\n        let obj = {\n          name: this.language.minor,\n          data: minor,\n          stack: 'raised',\n          color: '#F3B426'\n        };\n        seriesData.push(obj);\n      }\n      if (minorcleared.length > 0) {\n        let obj = {\n          name: this.language.minor + ' (Cleared)',\n          data: minorcleared,\n          stack: 'cleared',\n          color: '#F3B426',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      if (major.length > 0) {\n        let obj = {\n          name: this.language.major,\n          data: major,\n          stack: 'raised',\n          color: '#FC7235'\n        };\n        seriesData.push(obj);\n      }\n      if (majorcleared.length > 0) {\n        let obj = {\n          showInLegend: false,\n          name: this.language.major + ' (Cleared)',\n          data: majorcleared,\n          stack: 'cleared',\n          color: '#FC7235',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      if (critical.length > 0) {\n        let obj = {\n          name: this.language.critical,\n          data: critical,\n          stack: 'raised',\n          color: '#C70000'\n        };\n        seriesData.push(obj);\n      }\n      if (criticalcleared.length > 0) {\n        let obj = {\n          showInLegend: false,\n          name: this.language.critical + ' (Cleared)',\n          data: criticalcleared,\n          stack: 'cleared',\n          color: '#C70000',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          type: 'column',\n          inverted: false // default\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: 'Count'\n          },\n          minRange: 1\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            if (!this.series.name.includes(\"(Cleared)\")) {\n              if (this.series.name.includes(\"(Raised)\")) {\n                return s = '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + this.y + '<br/>' + 'Total: ' + this.point.stackTotal;\n              } else {\n                this.series.name = this.series.name + ' (Raised)';\n              }\n            }\n            s = s = '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + this.y + '<br/>' + 'Total: ' + this.point.stackTotal;\n            return s;\n          }\n          // formatter: function () {\n          //   return '<b>' + this.x + '</b><br/>' +\n          //     this.series.name + ': ' + this.y + '<br/>' +\n          //     'Total: ' + this.point.stackTotal;\n          // }\n        },\n        xAxis: {\n          categories: categories\n        },\n        lang: {\n          noData: !(seriesData === null || seriesData === void 0 ? void 0 : seriesData.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            //maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: []\n      });\n      if (seriesData.length > 0) {\n        options.series = seriesData;\n      }\n      return options;\n    }\n    locationEventChartOptions(data) {\n      let seriesData = [];\n      let categories = [];\n      let minor = [];\n      let critical = [];\n      let major = [];\n      let minorcleared = [];\n      let criticalcleared = [];\n      let majorcleared = [];\n      if (data) {\n        data.forEach(element => {\n          categories.push(element.location);\n          if (element.raised) {\n            minor.push(element.raised.minor ? element.raised.minor : 0);\n            critical.push(element.raised.critical ? element.raised.critical : 0);\n            major.push(element.raised.major ? element.raised.major : 0);\n          }\n          if (element.cleared) {\n            minorcleared.push(element.cleared.minor ? element.cleared.minor : 0);\n            criticalcleared.push(element.cleared.critical ? element.cleared.critical : 0);\n            majorcleared.push(element.cleared.major ? element.cleared.major : 0);\n          }\n        });\n      }\n      if (minor.length > 0) {\n        let obj = {\n          name: this.language.minor,\n          data: minor,\n          stack: 'raised',\n          color: '#F3B426'\n        };\n        seriesData.push(obj);\n      }\n      if (minorcleared.length > 0) {\n        let obj = {\n          name: this.language.minor + ' (Cleared)',\n          data: minorcleared,\n          stack: 'cleared',\n          color: '#F3B426',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      if (major.length > 0) {\n        let obj = {\n          name: this.language.major,\n          data: major,\n          stack: 'raised',\n          color: '#FC7235'\n        };\n        seriesData.push(obj);\n      }\n      if (majorcleared.length > 0) {\n        let obj = {\n          showInLegend: false,\n          name: this.language.major + ' (Cleared)',\n          data: majorcleared,\n          stack: 'cleared',\n          color: '#FC7235',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      if (critical.length > 0) {\n        let obj = {\n          name: this.language.critical,\n          data: critical,\n          stack: 'raised',\n          color: '#C70000'\n        };\n        seriesData.push(obj);\n      }\n      if (criticalcleared.length > 0) {\n        let obj = {\n          showInLegend: false,\n          name: this.language.critical + ' (Cleared)',\n          data: criticalcleared,\n          stack: 'cleared',\n          color: '#C70000',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          type: 'column',\n          inverted: false // default\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: 'Count'\n          },\n          minRange: 1\n        },\n        lang: {\n          noData: !(seriesData === null || seriesData === void 0 ? void 0 : seriesData.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            if (!this.series.name.includes(\"(Cleared)\")) {\n              if (this.series.name.includes(\"(Raised)\")) {\n                return s = '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + this.y + '<br/>' + 'Total: ' + this.point.stackTotal;\n              } else {\n                this.series.name = this.series.name + ' (Raised)';\n              }\n            }\n            s = s = '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + this.y + '<br/>' + 'Total: ' + this.point.stackTotal;\n            return s;\n          }\n          // formatter: function () {\n          //   return '<b>' + this.x + '</b><br/>' +\n          //     this.series.name + ': ' + this.y + '<br/>' +\n          //     'Total: ' + this.point.stackTotal;\n          // }\n        },\n        xAxis: {\n          categories: categories\n        },\n        plotOptions: {\n          series: {\n            point: {\n              events: {}\n            },\n            //maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: []\n      });\n      if (seriesData.length > 0) {\n        options.series = seriesData;\n      }\n      return options;\n    }\n    regionEventChartOptions(data) {\n      let seriesData = [];\n      let categories = [];\n      let minor = [];\n      let critical = [];\n      let major = [];\n      let minorcleared = [];\n      let criticalcleared = [];\n      let majorcleared = [];\n      if (data) {\n        data.forEach(element => {\n          categories.push(element.region);\n          if (element.raised) {\n            minor.push(element.raised.minor ? element.raised.minor : 0);\n            critical.push(element.raised.critical ? element.raised.critical : 0);\n            major.push(element.raised.major ? element.raised.major : 0);\n          }\n          if (element.cleared) {\n            minorcleared.push(element.cleared.minor ? element.cleared.minor : 0);\n            criticalcleared.push(element.cleared.critical ? element.cleared.critical : 0);\n            majorcleared.push(element.cleared.major ? element.cleared.major : 0);\n          }\n        });\n      }\n      if (minor.length > 0) {\n        let obj = {\n          name: this.language.minor,\n          data: minor,\n          stack: 'raised',\n          color: '#F3B426'\n        };\n        seriesData.push(obj);\n      }\n      if (minorcleared.length > 0) {\n        let obj = {\n          name: this.language.minor + ' (Cleared)',\n          data: minorcleared,\n          stack: 'cleared',\n          color: '#F3B426',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      if (major.length > 0) {\n        let obj = {\n          name: this.language.major,\n          data: major,\n          stack: 'raised',\n          color: '#FC7235'\n        };\n        seriesData.push(obj);\n      }\n      if (majorcleared.length > 0) {\n        let obj = {\n          showInLegend: false,\n          name: this.language.major + ' (Cleared)',\n          data: majorcleared,\n          stack: 'cleared',\n          color: '#FC7235',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      if (critical.length > 0) {\n        let obj = {\n          name: this.language.critical,\n          data: critical,\n          stack: 'raised',\n          color: '#C70000'\n        };\n        seriesData.push(obj);\n      }\n      if (criticalcleared.length > 0) {\n        let obj = {\n          showInLegend: false,\n          name: this.language.critical + ' (Cleared)',\n          data: criticalcleared,\n          stack: 'cleared',\n          color: '#C70000',\n          linkedTo: ':previous'\n        };\n        seriesData.push(obj);\n      }\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        chart: {\n          type: 'column',\n          inverted: false // default\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            style: {\n              fontSize: '10px',\n              font: 'Source Sans Pro,Regular'\n            },\n            text: 'Count'\n          },\n          minRange: 1\n        },\n        tooltip: {\n          formatter: function () {\n            var s;\n            if (!this.series.name.includes(\"(Cleared)\")) {\n              if (this.series.name.includes(\"(Raised)\")) {\n                return s = '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + this.y + '<br/>' + 'Total: ' + this.point.stackTotal;\n              } else {\n                this.series.name = this.series.name + ' (Raised)';\n              }\n            }\n            s = s = '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + this.y + '<br/>' + 'Total: ' + this.point.stackTotal;\n            return s;\n          }\n          // formatter: function () {\n          //   return '<b>' + this.x + '</b><br/>' +\n          //     this.series.name + ': ' + this.y + '<br/>' +\n          //     'Total: ' + this.point.stackTotal;\n          // }\n        },\n        xAxis: {\n          categories: categories\n        },\n        lang: {\n          noData: !(seriesData === null || seriesData === void 0 ? void 0 : seriesData.length) ? this.language[\"No Data Available\"] : \"\"\n        },\n        plotOptions: {\n          series: {\n            point: {\n              events: {}\n            },\n            //maxPointWidth: 16,\n            states: {\n              inactive: {\n                enabled: false\n              }\n            }\n          },\n          column: {\n            stacking: 'normal',\n            borderWidth: 0,\n            dataLabels: {\n              enabled: false\n            }\n          }\n        },\n        series: []\n      });\n      if (seriesData.length > 0) {\n        options.series = seriesData;\n      }\n      return options;\n    }\n    getEventOptions(data, type, params = {}, locations, systems, fullScreen) {\n      // if (params['customCategory']) {\n      //   delete params['customCategory'];\n      // }\n      let subTitle = '';\n      if (systems && Object.keys(systems).length) {\n        subTitle = this.getSubTitle(params, locations, systems, 'event', type);\n      } else if (locations && Object.keys(locations).length) {\n        subTitle = this.getSubTitle(params, locations, {}, 'event', type);\n      } else {\n        subTitle = this.getSubTitle(params, {}, {}, 'event', type);\n      }\n      let categories = [];\n      let series = [];\n      let sdata = [];\n      if (data && data.length) {\n        data.forEach(element => {\n          if (element[type]) {\n            if (type === 'region') {\n              let pointName = this.regions[element[type]] ? this.regions[element[type]].name : element[type];\n              element.displayName = pointName;\n            } else if (type === 'location') {\n              if (locations && Object.keys(locations).length) {\n                let pointName = locations[element[type]] ? locations[element[type]].name : element[type];\n                element.displayName = pointName;\n              } else {\n                let pointName = this.locations[element[type]] ? this.locations[element[type]].name : element[type];\n                element.displayName = pointName;\n              }\n            } else if (type === 'system') {\n              if (systems && Object.keys(systems).length) {\n                let pointName = systems[element[type]] ? systems[element[type]].name : element[type];\n                element.displayName = pointName;\n              } else {\n                let pointName = this.systems[element[type]] ? this.systems[element[type]].name : element[type];\n                element.displayName = pointName;\n              }\n            }\n          }\n        });\n        data = data === null || data === void 0 ? void 0 : data.sort((a, b) => {\n          var _a;\n          return (_a = a === null || a === void 0 ? void 0 : a.displayName) === null || _a === void 0 ? void 0 : _a.localeCompare(b === null || b === void 0 ? void 0 : b.displayName);\n        });\n        data.forEach(element => {\n          if (element[type]) {\n            element[type] = element[type].replace('device=', '');\n            element[type] = element[type].replace('DEVICE=', '');\n            categories.push(element.displayName);\n            if (element['event'] && typeof element['event']['count'] != undefined) {\n              sdata.push({\n                y: element['event']['count'] ? element['event']['count'] : null,\n                uuid: element[type]\n              });\n            }\n          }\n        });\n        if (sdata && sdata.length) {\n          series.push({\n            name: 'Events',\n            data: sdata\n          });\n        }\n      }\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: 'y'\n        },\n        title: {\n          text: ''\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories,\n          crosshair: true\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: 'Count'\n          }\n        },\n        tooltip: {\n          shared: true,\n          useHTML: true,\n          formatter: function () {\n            var s = '<b>' + this.x + '</b>';\n            this.points.forEach(point => {\n              s += '<br/><span style=\"color:' + point.color + '\">\\u25CF</span> ' + 'Events' + ': ' + point.y;\n            });\n            return s;\n          }\n        },\n        plotOptions: {\n          series: {\n            minPointLength: 2.5,\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          },\n          column: {\n            pointPadding: 0.2,\n            borderWidth: 0\n          }\n        },\n        series: series,\n        credits: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        lang: {\n          noData: !(sdata === null || sdata === void 0 ? void 0 : sdata.length) ? this.language[\"No Data Available\"] : \"\"\n        }\n      };\n      return options;\n    }\n    getLineChartOptions(cData, hideClearedAlarms = false, params = {}) {\n      let titlepipe = new TitleCasePipe();\n      let subTitle = this.getSubTitle(params, {}, {}, 'alarm', 'byday');\n      let diffDays = this.getDateDiff(params);\n      let format = 'M/d/yy';\n      if (diffDays <= 3) {\n        format = 'M/d/yy HH:mm';\n      }\n      let categories = [],\n        data = [],\n        raisedData = [],\n        clearedData = [];\n      if (cData && typeof cData === 'object') {\n        cData.forEach(element => {\n          categories.push(this.dateUtils.getChartDateByFormat(element.time, format));\n          if (!hideClearedAlarms && element['alarm'] && element['alarm']['cleared']) {\n            let keys = Object.keys(element['alarm']['cleared']);\n            let count = 0;\n            keys.forEach(key => {\n              count += element['alarm']['cleared'][key];\n            });\n            clearedData.push(count);\n          }\n          if (element['alarm'] && element['alarm']['raised']) {\n            let keys = Object.keys(element['alarm']['raised']);\n            let count = 0;\n            keys.forEach(key => {\n              count += element['alarm']['raised'][key];\n            });\n            raisedData.push(count);\n          }\n        });\n        data.push({\n          name: `${this.language.Raised}`,\n          data: raisedData\n        });\n        if (!hideClearedAlarms) {\n          data.push({\n            name: `Cleared`,\n            data: clearedData\n          });\n        }\n      }\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        title: {\n          text: ''\n        },\n        subtitle: {\n          text: subTitle\n        },\n        credits: {\n          enabled: false\n        },\n        chart: {\n          type: 'line',\n          style: {\n            fontFamily: 'Source Sans Pro,Regular',\n            fontSize: '12px',\n            color: '#4c4c4c'\n          },\n          plotBorderWidth: 1\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        xAxis: [{\n          min: 0,\n          gridLineWidth: 1,\n          categories: categories\n          //tickInterval: 5,\n          //crosshair: true,\n        }],\n        yAxis: [{\n          min: 0,\n          allowDecimals: false,\n          title: {\n            text: `${this.language.Count}`,\n            style: {\n              color: '#727272'\n            }\n          },\n          style: {\n            fontFamily: 'Source Sans Pro,Regular',\n            fontSize: '13px',\n            color: '#4c4c4c'\n          }\n        }],\n        legend: {\n          symbol: 'square',\n          enabled: true\n        },\n        tooltip: {\n          shared: true,\n          crosshairs: true\n        },\n        series: data,\n        plotOptions: {\n          series: {\n            cursor: 'pointer',\n            marker: {\n              enabled: false\n            },\n            pointPlacement: 'on',\n            point: {\n              events: {}\n            }\n          },\n          states: {\n            inactive: {\n              enabled: false\n            }\n          }\n        },\n        responsive: {\n          rules: [{\n            condition: {}\n          }]\n        }\n      });\n      return options;\n    }\n    getPieChartOptionsForFS(cData, type, chartType, datatype) {\n      let titlepipe = new TitleCasePipe();\n      let data = [];\n      let subTitle = '';\n      let that = this;\n      if (chartType && datatype) {\n        subTitle = this.getSubTitleForFullScreen(chartType.toLowerCase(), datatype.toLowerCase());\n      }\n      if (cData && typeof cData === 'object') {\n        cData.forEach(element => {\n          if (element['alarm'] && element['alarm'][type]) {\n            let keys = Object.keys(element['alarm'][type]);\n            let count = 0;\n            keys.forEach(key => {\n              count += element['alarm'][type][key];\n            });\n            if (count) {\n              data.push({\n                name: element['alarmEventName'],\n                y: count,\n                extraData: element['alarm'][type]\n              });\n            }\n          }\n        });\n      }\n      let count = this.getCountForAlarmNameData(cData, type);\n      let options = Object.assign(Object.assign({}, this.commonHighChartOptions), {\n        credits: {\n          enabled: false\n        },\n        chart: {\n          plotBackgroundColor: null,\n          plotBorderWidth: null,\n          plotShadow: false,\n          type: 'pie'\n        },\n        title: {\n          text: `${this.language['Alarms']} ${this.language[titlepipe.transform(type)] || titlepipe.transform(type)}`\n        },\n        subtitle: {\n          text: subTitle\n        },\n        // tooltip: {\n        //   formatter: function () {\n        //     var s;\n        //     var percentage = Highcharts.numberFormat(Math.abs(this.percentage), 2);\n        //     s = `<b> ${this.key} : ${this.y} </b><br/>\n        //     <p>${this.series.name}<span>: <b>${percentage} %</b><br/></span></p>`\n        //     return s;\n        //   }\n        // },\n        tooltip: {\n          //pointFormat: '<b>{point.y}</b>'\n          formatter: function () {\n            if (this.point['extraData']['critical']) {\n              return `<b> ${this.key}</b><br> ${that.language['Total']} : ${this.y} <br>\n            ${that.language['critical']}: ${this.point['extraData']['critical']} <br/>`;\n            }\n            if (this.point['extraData']['major']) {\n              return `<b> ${this.key}</b><br> ${that.language['Total']} : ${this.y} <br>\n            ${that.language['major']}: ${this.point['extraData']['major']} <br/>`;\n            }\n            if (this.point['extraData']['minor']) {\n              return `<b> ${this.key}</b><br> ${that.language['Total']} : ${this.y} <br>\n            ${that.language['minor']}: ${this.point['extraData']['minor']} <br/>`;\n            }\n            if (this.point['extraData']['warning']) {\n              return `<b> ${this.key}</b><br> ${that.language['Total']} : ${this.y} <br>\n            ${that.language['warning']}: ${this.point['extraData']['warning']} <br/>`;\n            }\n            if (this.point['extraData']['info']) {\n              return `<b> ${this.key}</b><br> ${that.language['Total']} : ${this.y} <br>\n            ${that.language['info']}: ${this.point['extraData']['info']} <br/>`;\n            }\n            /* return `<b> ${this.key}</b><br> ${that.language['Total']} : ${this.y} <br>\r\n            ${that.language['critical']}: ${this.point['extraData']['critical']} <br/>\r\n            ${that.language['major']}: ${this.point['extraData']['major']} <br/>\r\n            ${that.language['minor']}: ${this.point['extraData']['minor']} <br/>\r\n            ${that.language['warning']}: ${this.point['extraData']['warning']} <br/>\r\n            ${that.language['info']}: ${this.point['extraData']['info']} <br/>\r\n            `;\r\n            }*/\n          }\n        },\n\n        accessibility: {\n          point: {\n            valueSuffix: '%'\n          }\n        },\n        plotOptions: {\n          pie: {\n            allowPointSelect: true,\n            cursor: 'pointer'\n            // dataLabels: {\n            //   enabled: true,\n            //   format: '<b>{point.name}</b>: {point.percentage:.1f} %'\n            // }\n          },\n\n          scrollbar: {\n            enabled: true\n          },\n          series: {\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        lang: {\n          noData: !(cData === null || cData === void 0 ? void 0 : cData.length) || !count ? this.language[\"No Data Available\"] : \"\"\n        },\n        series: [{\n          name: 'Brands',\n          colorByPoint: true,\n          data: data\n        }]\n      });\n      return options;\n    }\n    getCountForAlarmNameData(cData, type) {\n      let count = 0;\n      if (cData && typeof cData === 'object' && type) {\n        cData.forEach(element => {\n          if (element['alarm'] && element['alarm'][type]) {\n            let keys = Object.keys(element['alarm'][type]);\n            keys.forEach(key => {\n              count += element['alarm'][type][key];\n            });\n          }\n        });\n      } else {\n        if (cData && typeof cData === 'object') {\n          cData.forEach(element => {\n            let types = ['raised', 'cleared'];\n            types.forEach(type => {\n              if (element['alarm'] && element['alarm'][type]) {\n                let keys = Object.keys(element['alarm'][type]);\n                keys.forEach(key => {\n                  count += element['alarm'][type][key];\n                });\n              }\n            });\n          });\n        }\n      }\n      return count;\n    }\n    getCountForEventNameData(cData, type) {\n      let count = 0;\n      if (cData && typeof cData === 'object') {\n        cData.forEach(element => {\n          if (element['event'] && element['event']['count']) {\n            count += element['event']['count'];\n          }\n        });\n      }\n      return count;\n    }\n    /**\r\n     *\r\n     * @param params | Object\r\n     * return days | number\r\n     */\n    getDateDiff(params = {}) {\n      let diffDays = 0;\n      if (Object.keys(params).length && params['date']) {\n        let dates = params['date'].split(',');\n        dates[0] = Number(dates[0]);\n        dates[1] = Number(dates[1]);\n        let end = new Date(dates[1]);\n        let start = new Date(dates[0]);\n        const diffTime = Math.abs(end - start);\n        diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n      }\n      return diffDays;\n    }\n    getEndDate(params = {}) {\n      if (Object.keys(params).length && params['date']) {\n        let dates = params['date'].split(',');\n        dates[0] = Number(dates[0]);\n        dates[1] = Number(dates[1]);\n        return dates[1];\n      }\n      return 0;\n    }\n    getLineChartOptionsNew(cData, hideClearedAlarms = false, params = {}, fields = {}) {\n      let obj = {};\n      let subTitle = this.getSubTitle(params, {}, {}, 'alarm', 'byday');\n      let data = [],\n        raisedData = [],\n        clearedData = [];\n      if (cData && cData.length) {\n        if (typeof cData === \"object\") {\n          cData.forEach(element => {\n            obj[element.time] = element;\n          });\n        }\n        let diffDays = 10;\n        if (fields['date']) {\n          diffDays = this.getDateDiff(params);\n        }\n        let timestamps = [];\n        if (fields['date']) {\n          if (diffDays > 5) {\n            timestamps = this.dateUtils.getUtcHoursTimeArrByDate(fields['date'][0], fields['date'][1]);\n          } else {\n            timestamps = this.dateUtils.getUtcMinsTimeArrByDate(fields['date'][0], fields['date'][1]);\n          }\n        } else {\n          if (cData && typeof cData === 'object' && cData[0] && typeof cData[0] === 'object') {\n            cData === null || cData === void 0 ? void 0 : cData.sort((a, b) => a.time - b.time);\n            if (diffDays > 5) {\n              timestamps = this.dateUtils.getUtcHoursTimeArrFromTimeToCurrentTime(cData[0].time);\n            } else {\n              timestamps = this.dateUtils.getUtcMinsTimeArrFromTimeToCurrentTime(cData[0].time);\n            }\n          }\n        }\n        let newDataObj = {};\n        timestamps.forEach(element => {\n          if (obj[element]) {\n            newDataObj[element] = obj[element];\n          } else {\n            newDataObj[element] = {\n              \"time\": element,\n              \"alarm\": {\n                \"cleared\": {\n                  \"critical\": 0,\n                  \"major\": 0,\n                  \"minor\": 0,\n                  \"warning\": 0,\n                  \"info\": 0\n                },\n                \"raised\": {\n                  \"critical\": 0,\n                  \"major\": 0,\n                  \"minor\": 0,\n                  \"warning\": 0,\n                  \"info\": 0\n                }\n              },\n              \"event\": {\n                \"count\": 0\n              }\n            };\n          }\n        });\n        let newdata = [];\n        for (let key in newDataObj) {\n          newdata.push(newDataObj[key]);\n        }\n        cData = newdata;\n        if (cData && typeof cData === 'object') {\n          cData.forEach(element => {\n            if (!hideClearedAlarms && element['alarm'] && element['alarm']['cleared']) {\n              let keys = Object.keys(element['alarm']['cleared']);\n              let count = 0;\n              keys.forEach(key => {\n                count += element['alarm']['cleared'][key];\n              });\n              clearedData.push([element.time, count]);\n            }\n            if (element['alarm'] && element['alarm']['raised']) {\n              let keys = Object.keys(element['alarm']['raised']);\n              let count = 0;\n              keys.forEach(key => {\n                count += element['alarm']['raised'][key];\n              });\n              raisedData.push([element.time, count]);\n            }\n          });\n          data.push({\n            name: this.language['issue_raised'],\n            data: raisedData,\n            tooltip: {\n              valueDecimals: 0\n            }\n          });\n          if (!hideClearedAlarms) {\n            data.push({\n              name: this.language['Cleared'],\n              data: clearedData,\n              tooltip: {\n                valueDecimals: 0\n              }\n            });\n          }\n        }\n      }\n      let options = {\n        chart: {\n          height: 300,\n          zoomType: 'xy',\n          type: 'line'\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: ''\n        },\n        subtitle: {\n          text: subTitle\n        },\n        credits: {\n          enabled: false\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        xAxis: {\n          type: 'datetime'\n        },\n        yAxis: [{\n          opposite: false,\n          min: 0,\n          allowDecimals: false,\n          title: {\n            text: this.language['Count'],\n            style: {\n              color: '#727272'\n            }\n          },\n          style: {\n            fontFamily: 'Source Sans Pro,Regular',\n            fontSize: '13px',\n            color: '#4c4c4c'\n          }\n        }],\n        legend: {\n          enabled: true,\n          symbolRadius: 6,\n          symbolWidth: 12\n        },\n        tooltip: {\n          shared: true,\n          crosshairs: true\n        },\n        rangeSelector: {},\n        navigator: {\n          //margin: 60,\n          enabled: false\n        },\n        scrollbar: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        plotOptions: {\n          series: {\n            //compare: 'value',\n            dataGrouping: {\n              enabled: false\n            }\n          }\n        },\n        lang: {\n          noData: !(cData === null || cData === void 0 ? void 0 : cData.length) ? this.language[\"No Data Available\"] : ''\n        },\n        series: data\n      };\n      if (cData && cData.length) {\n        options['rangeSelector'] = {\n          buttons: [{\n            type: 'hour',\n            count: 1,\n            text: '1h'\n          }, {\n            type: 'day',\n            count: 1,\n            text: '1d'\n          }, {\n            type: 'week',\n            count: 1,\n            text: '1w'\n          }, {\n            type: 'all',\n            text: 'All'\n          }],\n          selected: 3,\n          inputEnabled: false,\n          enabled: true\n          // floating: false,\n          // y: -65,\n          // verticalAlign: 'bottom'\n        };\n      }\n\n      return options;\n    }\n    getLineChartOptionForActiveReports(cData, hideClearedAlarms = false, params = {}, fields = {}, last24hours = false) {\n      var _a, _b;\n      let obj = {};\n      let data = [],\n        raisedData = [],\n        dataObj = {};\n      let subTitle = this.getSubTitle(params, {}, {}, 'alarm', 'byday');\n      if (cData && cData.length) {\n        if (typeof cData === \"object\") {\n          cData.forEach(element => {\n            obj[element.time] = element;\n          });\n        }\n        let diffDays = 10;\n        if (fields['date']) {\n          diffDays = this.getDateDiff(params);\n        }\n        let timestamps = [];\n        if (fields['date']) {\n          if (last24hours) {\n            const startDate = (_a = params['date']) === null || _a === void 0 ? void 0 : _a.split(',')[0];\n            const endDate = (_b = params['date']) === null || _b === void 0 ? void 0 : _b.split(',')[1];\n            if (startDate && endDate) {\n              timestamps = this.dateUtils.getUtcMinsTimeArrByDateMillis(Number(startDate), Number(endDate));\n            } else {\n              timestamps = this.dateUtils.getUtcMinsTimeArrByDate(fields['date'][0], fields['date'][1]);\n            }\n          } else if (diffDays > 5) {\n            timestamps = this.dateUtils.getUtcHoursTimeArrByDate(fields['date'][0], fields['date'][1]);\n          } else {\n            timestamps = this.dateUtils.getUtcMinsTimeArrByDate(fields['date'][0], fields['date'][1]);\n          }\n        } else {\n          if (cData && typeof cData === 'object' && cData[0] && typeof cData[0] === 'object') {\n            cData === null || cData === void 0 ? void 0 : cData.sort((a, b) => a.time - b.time);\n            if (diffDays > 5) {\n              timestamps = this.dateUtils.getUtcHoursTimeArrFromTimeToCurrentTime(cData[0].time);\n            } else {\n              timestamps = this.dateUtils.getUtcMinsTimeArrFromTimeToCurrentTime(cData[0].time);\n            }\n          }\n        }\n        let newDataObj = {};\n        timestamps.forEach(element => {\n          if (obj[element]) {\n            newDataObj[element] = obj[element];\n          } else {\n            newDataObj[element] = {\n              \"time\": element,\n              \"alarm\": {\n                \"cleared\": {\n                  \"critical\": 0,\n                  \"major\": 0,\n                  \"minor\": 0,\n                  \"warning\": 0,\n                  \"info\": 0\n                },\n                \"raised\": {\n                  \"critical\": 0,\n                  \"major\": 0,\n                  \"minor\": 0,\n                  \"warning\": 0,\n                  \"info\": 0\n                }\n              },\n              \"event\": {\n                \"count\": 0\n              }\n            };\n          }\n        });\n        let newdata = [];\n        for (let key in newDataObj) {\n          newdata.push(newDataObj[key]);\n        }\n        cData = newdata;\n        if (cData && typeof cData === 'object') {\n          cData.forEach(element => {\n            if (element['alarm'] && element['alarm']['raised']) {\n              // let keys = Object.keys(element['alarm']['raised']);\n              // let count = 0;\n              // keys.forEach(key => {\n              //   count += element['alarm']['raised'][key];\n              // });\n              // raisedData.push([element.time, count]);\n              let keys = Object.keys(element['alarm']['raised']);\n              keys.forEach(key => {\n                if (typeof dataObj[key] === 'object') {\n                  dataObj[key].push([element.time, element['alarm']['raised'][key]]);\n                } else {\n                  dataObj[key] = [];\n                  dataObj[key].push([element.time, element['alarm']['raised'][key]]);\n                }\n              });\n            }\n          });\n          let keys = Object.keys(dataObj);\n          if (keys.length) {\n            keys.forEach(key => {\n              let sdata = [];\n              if (!params['severity']) {\n                sdata = dataObj[key];\n              } else if (params['severity'] && params['severity'] === key) {\n                sdata = dataObj[key];\n              }\n              data.push({\n                name: this.language[key],\n                data: sdata,\n                tooltip: {\n                  valueDecimals: 0\n                },\n                color: this.colors[key]\n              });\n            });\n          }\n        }\n      }\n      let options = {\n        chart: {\n          height: 300,\n          zoomType: 'xy',\n          type: 'line'\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: ''\n        },\n        subtitle: {\n          text: subTitle\n        },\n        credits: {\n          enabled: false\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        xAxis: {\n          type: 'datetime'\n        },\n        yAxis: [{\n          opposite: false,\n          min: 0,\n          allowDecimals: false,\n          title: {\n            text: this.language['Count'],\n            style: {\n              color: '#727272'\n            }\n          },\n          style: {\n            fontFamily: 'Source Sans Pro,Regular',\n            fontSize: '13px',\n            color: '#4c4c4c'\n          }\n        }],\n        legend: {\n          enabled: true,\n          symbolRadius: 6,\n          symbolWidth: 12\n        },\n        tooltip: {\n          shared: true,\n          crosshairs: true,\n          split: true,\n          distance: 30,\n          padding: 5\n        },\n        rangeSelector: {},\n        navigator: {\n          //margin: 60,\n          enabled: false\n        },\n        scrollbar: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        plotOptions: {\n          series: {\n            //compare: 'value',\n            dataGrouping: {\n              enabled: false\n            }\n          }\n        },\n        lang: {\n          noData: !(cData === null || cData === void 0 ? void 0 : cData.length) ? this.language[\"No Data Available\"] : ''\n        },\n        series: data\n      };\n      if (cData && cData.length) {\n        options['rangeSelector'] = {\n          buttons: [{\n            type: 'hour',\n            count: 1,\n            text: '1h'\n          }, {\n            type: 'day',\n            count: 1,\n            text: '1d'\n          }, {\n            type: 'week',\n            count: 1,\n            text: '1w'\n          }, {\n            type: 'all',\n            text: 'All'\n          }],\n          selected: 3,\n          inputEnabled: false,\n          enabled: true\n        };\n      }\n      return options;\n    }\n    getSubTitle(params, locations = {}, systems = {}, chartType, datatype) {\n      var _a, _b;\n      let userParams = {};\n      let titlepipe = new TitleCasePipe();\n      let datepipe = new DatePipe('en-US');\n      let subTitle = '';\n      let excelTitile = '';\n      let ackAttr = ['cco_ack', 'cco_shelv'];\n      let ackAttrObj = {\n        'cco_ack': {\n          'true': 'Show Acknowledged Alarms',\n          'false': 'Hide Acknowledged Alarms'\n        },\n        'cco_shelv': {\n          'true': 'Show Shelved Alarms',\n          'false': 'Hide Shelved Alarms'\n        }\n      };\n      // if (params['cco_ack'] == 'all') {\n      //   delete params['cco_ack'];';.\n      // }\n      // if (params['cco_shelv'] == 'all') {\n      //   delete params['cco_shelv'];\n      // }\n      if (params['date']) {\n        let startDate = (_a = params['date']) === null || _a === void 0 ? void 0 : _a.split(',')[0];\n        let endDate = (_b = params['date']) === null || _b === void 0 ? void 0 : _b.split(',')[1];\n        excelTitile += `${this.language['Start_Date']}: ${datepipe.transform(startDate, 'MM/dd/yyyy h:mm a')}  \\r\\n${this.language['enddate']}: ${datepipe.transform(endDate, 'MM/dd/yyyy h:mm a')}  \\r\\n`;\n      }\n      this.filters.forEach((element, index) => {\n        var _a;\n        if (chartType === 'event' && (element === 'severity' || element === 'customCategory')) {\n          return;\n        }\n        if (params[element]) {\n          let name = [];\n          if (element === 'region') {\n            if (typeof params[element] === 'object') {\n              params[element].forEach((e, i) => {\n                let pointName = this.regions[params[element][i]] ? this.regions[params[element][i]].name : params[element][i];\n                name.push(pointName);\n              });\n            } else {\n              let pointName = this.regions[params[element]] ? this.regions[params[element]].name : params[element];\n              name.push(pointName);\n            }\n          } else if (element === 'location') {\n            if (locations && Object.keys(locations).length) {\n              if (typeof params[element] === 'object') {\n                params[element].forEach((e, i) => {\n                  let pointName = locations[params[element][i]] ? locations[params[element][i]].name : params[element][i];\n                  name.push(pointName);\n                });\n              } else {\n                let pointName = locations[params[element]] ? locations[params[element]].name : params[element];\n                name.push(pointName);\n              }\n            } else {\n              if (typeof params[element] === 'object') {\n                params[element].forEach((e, i) => {\n                  let pointName = this.locations[params[element][i]] ? this.locations[params[element][i]].name : params[element][i];\n                  name.push(pointName);\n                });\n              } else {\n                let pointName = this.locations[params[element]] ? this.locations[params[element]].name : params[element];\n                name.push(pointName);\n              }\n            }\n          } else if (element === 'system') {\n            if (systems && Object.keys(systems).length) {\n              if (typeof params[element] === 'object') {\n                params[element].forEach((e, i) => {\n                  let pointName = systems[params[element][i]] ? systems[params[element][i]].name : params[element][i];\n                  name.push(pointName);\n                });\n              } else {\n                let pointName = systems[params[element]] ? systems[params[element]].name : params[element];\n                name.push(pointName);\n              }\n            } else {\n              if (typeof params[element] === 'object') {\n                params[element].forEach((e, i) => {\n                  let pointName = this.systems[params[element][i]] ? this.systems[params[element][i]].name : params[element][i];\n                  name.push(pointName);\n                });\n              } else {\n                let pointName = this.systems[params[element]] ? this.systems[params[element]].name : params[element];\n                name.push(pointName);\n              }\n            }\n          } else if (ackAttr.indexOf(element) !== -1) {\n            if (((_a = params[element]) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'all') {\n              return;\n            }\n            name = ackAttrObj[element][params[element]];\n          } else {\n            name = params[element];\n          }\n          let skipAttribites = ['fsan_serialnumber', 'region', 'location', 'system', 'customCategory', 'alarmEventName', 'category', 'cco_ack', 'cco_shelv'];\n          if (typeof name === 'object' && skipAttribites.indexOf(element) === -1) {\n            name = name.map(x => titlepipe.transform(x));\n          } else {\n            if (skipAttribites.indexOf(element) === -1) {\n              name = titlepipe.transform(name);\n            } else if (element === 'fsan_serialnumber') {\n              name = name.toUpperCase();\n            }\n            name = [name];\n          }\n          if (subTitle) {\n            subTitle += ', ';\n          }\n          userParams[this.filtersObj[element]] = name.join(', ');\n          subTitle += `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language[this.filtersObj[element]] || this.filtersObj[element]}: ${name.join(', ')}</span>`;\n          excelTitile += `${this.language[`${this.filtersObj[element]}`]}:${name.join('&')} \\r\\n`;\n        }\n      });\n      this.userFilters[chartType][datatype] = userParams;\n      this.subTitleObj[chartType][datatype] = `${excelTitile}`;\n      return subTitle;\n    }\n    setRegionsInfo(regions) {\n      this.regions = {};\n      let regObj = {};\n      if (regions) {\n        regions.forEach(element => {\n          regObj[element.id] = {\n            name: element.name,\n            isDeleted: element.isDeleted\n          };\n        });\n      }\n      this.regions = regObj;\n    }\n    getRegionsObj() {\n      return this.regions;\n    }\n    setLocationsInfo(locations) {\n      this.locations = {};\n      let locObj = {};\n      if (locations) {\n        locations.forEach(element => {\n          locObj[element.id] = {\n            name: element.name,\n            isDeleted: element.isDeleted\n          };\n        });\n      }\n      this.locations = locObj;\n    }\n    getLocationsObj() {\n      return this.locations;\n    }\n    setSystemsInfo(systems) {\n      this.systems = {};\n      let sysObj = {};\n      if (systems) {\n        systems.forEach(element => {\n          sysObj[element.uuid] = {\n            name: element.name,\n            isDeleted: element.isDeleted\n          };\n          ;\n        });\n      }\n      this.systems = sysObj;\n    }\n    getSystemsObj() {\n      return this.systems;\n    }\n    setFiltersObj() {\n      this.filtersObj = {\n        'region': 'Region',\n        'location': 'Location',\n        'system': 'System',\n        'severity': 'Severity',\n        'category': 'Category',\n        'customCategory': 'Alarm Group',\n        'alarmEventName': this.issueService.getAlertType() === 'EVENTS' ? 'Event Name' : 'Alarm Name',\n        'fsan_serialnumber': 'FSAN',\n        'cco_ack': 'Acknowledged Alarms',\n        'cco_shelv': 'Shelved Alarms'\n      };\n    }\n    prepareAlarmCSVDataforSeverity(chartData, reportType = 'histoy', params = {}) {\n      let titlepipe = new TitleCasePipe();\n      let data = [];\n      if (Object.keys(chartData).length) {\n        let keys = Object.keys(chartData);\n        keys.forEach(key => {\n          if (reportType === 'active' && key === 'cleared') {\n            return;\n          }\n          if (!chartData[key]) {\n            return;\n          }\n          let inrKeys = Object.keys(chartData[key]);\n          let temp = {};\n          temp['Type'] = titlepipe.transform(key);\n          if (Object.keys(params).length && params['severity']) {\n            temp[titlepipe.transform(params['severity'])] = chartData[key][params['severity']];\n          } else {\n            inrKeys.forEach(inrKey => {\n              temp[titlepipe.transform(inrKey)] = chartData[key][inrKey];\n            });\n          }\n          data.push(Object.assign(temp));\n        });\n      }\n      return data;\n    }\n    prepareAlarmCSVDataforRegion(regiondata, reportType = 'histoy', params = {}) {\n      let titlepipe = new TitleCasePipe();\n      let data = [];\n      regiondata.forEach(element => {\n        let chartData = element.alarm;\n        if (chartData && Object.keys(chartData).length) {\n          let keys = Object.keys(chartData);\n          keys.forEach(key => {\n            if (reportType === 'active' && key === 'cleared') {\n              return;\n            }\n            let temp = {};\n            let inrKeys = Object.keys(chartData[key]);\n            temp['Type'] = titlepipe.transform(key);\n            temp['Region'] = this.regions[element.region] ? this.regions[element.region].name : element.region;\n            if (Object.keys(params).length && params['severity']) {\n              temp[titlepipe.transform(params['severity'])] = chartData[key][params['severity']];\n            } else {\n              inrKeys.forEach(inrKey => {\n                temp[titlepipe.transform(inrKey)] = chartData[key][inrKey];\n              });\n            }\n            data.push(Object.assign(temp));\n          });\n        }\n      });\n      return data;\n    }\n    prepareAlarmCSVDataforLocation(locationdata, locations, reportType = 'histoy', params = {}) {\n      let titlepipe = new TitleCasePipe();\n      let data = [];\n      locationdata === null || locationdata === void 0 ? void 0 : locationdata.forEach(element => {\n        let chartData = element.alarm;\n        if (chartData && Object.keys(chartData).length) {\n          let keys = Object.keys(chartData);\n          keys.forEach(key => {\n            if (reportType === 'active' && key === 'cleared') {\n              return;\n            }\n            let temp = {};\n            let inrKeys = Object.keys(chartData[key]);\n            temp['Type'] = titlepipe.transform(key);\n            if (locations && Object.keys(locations).length) {\n              temp['Location'] = locations[element.location] ? locations[element.location].name : element.location;\n            } else {\n              temp['Location'] = this.locations[element.location] ? this.locations[element.location].name : element.location;\n            }\n            if (Object.keys(params).length && params['severity']) {\n              temp[titlepipe.transform(params['severity'])] = chartData[key][params['severity']];\n            } else {\n              inrKeys.forEach(inrKey => {\n                temp[titlepipe.transform(inrKey)] = chartData[key][inrKey];\n              });\n            }\n            data.push(Object.assign(temp));\n          });\n        }\n      });\n      return data;\n    }\n    prepareAlarmCSVDataforSystem(systemdata, systems, reportType = 'histoy', params = {}) {\n      let titlepipe = new TitleCasePipe();\n      let data = [];\n      systemdata === null || systemdata === void 0 ? void 0 : systemdata.forEach(element => {\n        let chartData = element.alarm;\n        if (chartData && Object.keys(chartData).length) {\n          let keys = Object.keys(chartData);\n          keys.forEach(key => {\n            if (reportType === 'active' && key === 'cleared') {\n              return;\n            }\n            let temp = {};\n            let inrKeys = Object.keys(chartData[key]);\n            temp['Type'] = titlepipe.transform(key);\n            if (systems && Object.keys(systems).length) {\n              temp['System'] = systems[element.system] ? systems[element.system].name : element.system;\n            } else {\n              temp['System'] = this.systems[element.system] ? this.systems[element.system].name : element.system;\n            }\n            if (Object.keys(params).length && params['severity']) {\n              temp[titlepipe.transform(params['severity'])] = chartData[key][params['severity']];\n            } else {\n              inrKeys.forEach(inrKey => {\n                temp[titlepipe.transform(inrKey)] = chartData[key][inrKey];\n              });\n            }\n            data.push(Object.assign(temp));\n          });\n        }\n      });\n      return data;\n    }\n    prepareAlarmCSVDataforDay(dayData, reportType = 'histoy', params = {}) {\n      let data = [];\n      let titlepipe = new TitleCasePipe();\n      let pipe = new DatePipe('en-US');\n      dayData === null || dayData === void 0 ? void 0 : dayData.forEach(element => {\n        let chartData = element.alarm;\n        if (chartData && Object.keys(chartData).length) {\n          let keys = Object.keys(chartData);\n          keys.forEach(key => {\n            if (reportType === 'active' && key === 'cleared') {\n              return;\n            }\n            let temp = {};\n            let inrKeys = Object.keys(chartData[key]);\n            temp['Type'] = titlepipe.transform(key);\n            temp['Date Time'] = pipe.transform(new Date(element.time), 'short');\n            if (Object.keys(params).length && params['severity']) {\n              temp[titlepipe.transform(params['severity'])] = chartData[key][params['severity']];\n            } else {\n              inrKeys.forEach(inrKey => {\n                temp[titlepipe.transform(inrKey)] = chartData[key][inrKey];\n              });\n            }\n            data.push(Object.assign(temp));\n          });\n        }\n      });\n      return data;\n    }\n    prepareEventCSVDataforRegion(regiondata) {\n      let data = [];\n      if (regiondata && regiondata.length) {\n        regiondata.forEach(element => {\n          let temp = {};\n          temp['Region'] = this.regions[element.region] ? this.regions[element.region].name : element.region;\n          data.push(Object.assign(temp, {\n            'Count': element.event ? element.event['count'] : 0\n          }));\n        });\n      }\n      return data;\n    }\n    prepareEventCSVDataforLocation(locationdata, locations) {\n      let data = [];\n      if (locationdata && locationdata.length) {\n        locationdata.forEach(element => {\n          let temp = {};\n          if (locations && Object.keys(locations).length) {\n            temp['Location'] = locations[element.location] ? locations[element.location].name : element.location;\n          } else {\n            temp['Location'] = this.locations[element.location] ? this.locations[element.location].name : element.location;\n          }\n          data.push(Object.assign(temp, {\n            'Count': element.event ? element.event['count'] : 0\n          }));\n        });\n      }\n      return data;\n    }\n    prepareEventCSVDataforSystem(systemdata, systems) {\n      let data = [];\n      if (systemdata && systemdata.length) {\n        systemdata.forEach(element => {\n          let temp = {};\n          if (systems && Object.keys(systems).length) {\n            temp['System'] = systems[element.system] ? systems[element.system].name : element.system;\n          } else {\n            temp['System'] = this.systems[element.system] ? this.systems[element.system].name : element.system;\n          }\n          data.push(Object.assign(temp, {\n            'Count': element.event ? element.event['count'] : 0\n          }));\n        });\n      }\n      return data;\n    }\n    getSubTitleStr(chartType, datatype) {\n      return this.subTitleObj[chartType][datatype];\n    }\n    getUserFilters(chartType, datatype) {\n      return this.userFilters[chartType][datatype];\n    }\n    setUserFilters(chartType, datatype, params) {\n      return this.userFilters[chartType][datatype] = params;\n    }\n    getSubTitleForFullScreen(chartType, datatype) {\n      let params = this.getUserFilters(chartType, datatype);\n      let subTitle = '';\n      let keys = Object.keys(params);\n      if (keys.length > 0) {\n        keys.forEach(key => {\n          if (subTitle) {\n            subTitle += ', ';\n          }\n          subTitle += `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language[key] ? this.language[key] : key}: ${this.language[params[key]] || params[key]}</span>`;\n        });\n      }\n      return subTitle;\n    }\n    prepareAlarmCSVData(data, type = 'alarm') {\n      let titlepipe = new TitleCasePipe();\n      let pipe = new DatePipe('en-US');\n      let exportData = [];\n      // data.forEach((element: any) => {\n      //   let temp = {};\n      //   if (element && Object.keys(element).length) {\n      //     let keys = Object.keys(element);\n      //     keys.forEach(key => {\n      //       if (element[key] && typeof element[key] === 'object' && Object.keys(element[key]).length) {\n      //         let levelOneKeys = Object.keys(element[key]);\n      //         levelOneKeys.forEach(levelOne => {\n      //           if (element[key][levelOne] && typeof element[key][levelOne] === 'object' && Object.keys(element[key][levelOne]).length) {\n      //             let levelTwoKeys = Object.keys(element[key][levelOne]);\n      //             levelTwoKeys.forEach(levelTwo => {\n      //               temp[levelTwo] = typeof element[key][levelOne][levelTwo] === 'object' ? element[key][levelOne][levelTwo]['value'] : element[key][levelOne][levelTwo];\n      //             });\n      //           } else {\n      //             temp[levelOne] = element[key][levelOne];\n      //           }\n      //         });\n      //       } else {\n      //         temp[key] = element[key];\n      //       }\n      //     });\n      //   }\n      //   exportData.push(temp);\n      // });\n      data.forEach(fullData => {\n        let temp = {};\n        temp = {\n          'Reported Time': fullData['subject'] && fullData['subject']['timeRaised'] ? pipe.transform(new Date(Number(fullData['subject']['timeRaised'])), 'short') : '',\n          'Synced Time': fullData['time'] ? pipe.transform(new Date(Number(fullData['time'])), 'short') : ''\n        };\n        if (type === 'alarm') {\n          temp['Alarm Name'] = fullData['subject'] ? fullData['subject'].alarmEventName : '';\n          temp['Alarm Category'] = fullData['subject'] ? fullData['subject'].category : '';\n          if (fullData['subject'] && fullData['subject']['transformedAlarms']) {\n            temp['Resource'] = `${fullData['subject'] && fullData['subject']['region'] ? fullData['subject']['region'] : ''}${fullData['subject'] && fullData['subject']['location'] ? `/${fullData['subject']['location']}` : ''}${fullData['subject'] && fullData['subject']['deviceName'] ? `/${fullData['subject']['deviceName']}` : ''}, ${fullData['subject'] && fullData['subject']['transformedAlarms'] ? fullData['subject']['transformedAlarms'] : ''} `;\n            temp['Type'] = fullData['type'];\n          } else {\n            temp['Resource'] = `${fullData['subject'] && fullData['subject']['region'] ? fullData['subject']['region'] : ''}${fullData['subject'] && fullData['subject']['location'] ? `/${fullData['subject']['location']}` : ''}${fullData['subject'] && fullData['subject']['deviceName'] ? `/${fullData['subject']['deviceName']}` : ''}, ${fullData['subject'] && fullData['subject']['source'] ? fullData['subject']['source'] : ''} `;\n            temp['Type'] = fullData && fullData['subject'] ? fullData['subject'].alarmType : '';\n          }\n          temp['Severity'] = fullData['subject'] ? fullData['subject'].perceivedSeverity : '';\n        } else {\n          temp['Event Name'] = fullData['subject'] ? fullData['subject'].alarmEventName : '';\n          temp['Category'] = fullData['subject'] ? fullData['subject'].category : '';\n        }\n        temp['Decription'] = fullData && fullData['subject'] ? fullData['subject'].description : '';\n        temp['Details'] = fullData && fullData['subject'] ? fullData['subject'].details : '';\n        temp['Manual Acknowledged'] = fullData && fullData['subject'] && fullData['subject'].manualAcknowledged ? 'Yes' : 'No';\n        temp['Manual Shelved'] = fullData && fullData['subject'] && fullData['subject'].manualShelved ? 'Yes' : 'No';\n        temp['Repair Action'] = fullData && fullData['subject'] ? fullData['subject'].repairAction : '';\n        temp['Service Affecting'] = fullData && fullData['subject'] && fullData['subject'].serviceAffecting ? 'Yes' : 'No';\n        temp['Service Impacting'] = fullData && fullData['subject'] && fullData['subject'].serviceImpacting ? 'Yes' : 'No';\n        if (fullData && fullData['subject'] && fullData['subject']['transformedAlarms']) {\n          temp['Source'] = fullData['subject']['transformedAlarms'];\n        } else {\n          temp['Source'] = fullData['subject']['source'];\n        }\n        temp['Notes'] = fullData && fullData['subject'] ? fullData['subject'].notes : '';\n        if (fullData && fullData['subject'] && typeof fullData['subject']['additionalAttributes'] === \"object\" && fullData['subject']['additionalAttributes']) {\n          let keys = Object.keys(fullData['subject']['additionalAttributes']);\n          keys.forEach(element => {\n            temp[titlepipe.transform(element)] = typeof fullData['subject']['additionalAttributes'][element] === 'object' ? fullData['subject']['additionalAttributes'][element].value : fullData['subject']['additionalAttributes'][element];\n          });\n        }\n        temp['Source'] = `\\t${temp['Source']}`;\n        if (temp['Repair Action']) {\n          temp['Repair Action'] = temp['Repair Action'].replace(/,/g, '');\n          temp['Repair Action'] = temp['Repair Action'].replace(/'/g, '');\n        }\n        if (temp['Notes']) {\n          temp['Notes'] = temp['Notes'].replace(/,/g, '');\n          temp['Notes'] = temp['Notes'].replace(/'/g, '');\n        }\n        // if (temp['Notes']) {\n        //   temp['Notes'] = temp['Notes'].replace(/,/g, '\\,');\n        //   temp['Notes'] = temp['Notes'].replace(/'/g, '\\'');\n        //   temp['Notes'] = temp['Notes'].replace(/\"/g, '\"\"');\n        // }\n        exportData.push(temp);\n      });\n      return exportData;\n    }\n  }\n  HistoryChartOptionsService.ɵfac = function HistoryChartOptionsService_Factory(t) {\n    return new (t || HistoryChartOptionsService)(i0.ɵɵinject(i1.TranslateService), i0.ɵɵinject(i2.DateUtilsService), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.HealthService), i0.ɵɵinject(i5.IssueService));\n  };\n  HistoryChartOptionsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: HistoryChartOptionsService,\n    factory: HistoryChartOptionsService.ɵfac,\n    providedIn: 'root'\n  });\n  return HistoryChartOptionsService;\n})();","map":null,"metadata":{},"sourceType":"module"}