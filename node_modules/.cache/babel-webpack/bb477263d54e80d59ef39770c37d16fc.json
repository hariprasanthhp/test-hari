{"ast":null,"code":"import { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove, clear as svgClear } from 'tiny-svg';\nimport { isObject } from 'min-dash';\nimport { getElementLineIntersection, getMid } from '../../layout/LayoutUtil';\nvar MARKER_CONNECTION_PREVIEW = 'djs-connection-preview';\n\n/**\n * Draws connection preview. Optionally, this can use layouter and connection docking to draw\n * better looking previews.\n *\n * @param {didi.Injector} injector\n * @param {Canvas} canvas\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementFactory} elementFactory\n */\nexport default function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {\n  this._canvas = canvas;\n  this._graphicsFactory = graphicsFactory;\n  this._elementFactory = elementFactory;\n\n  // optional components\n  this._connectionDocking = injector.get('connectionDocking', false);\n  this._layouter = injector.get('layouter', false);\n}\nConnectionPreview.$inject = ['injector', 'canvas', 'graphicsFactory', 'elementFactory'];\n\n/**\n * Draw connection preview.\n *\n * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.\n * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.\n *\n * @param {Object} context\n * @param {Object|boolean} canConnect\n * @param {Object} hints\n * @param {djs.model.shape} [hints.source] source element\n * @param {djs.model.shape} [hints.target] target element\n * @param {Point} [hints.connectionStart] connection preview start\n * @param {Point} [hints.connectionEnd] connection preview end\n * @param {Array<Point>} [hints.waypoints] provided waypoints for preview\n * @param {boolean} [hints.noLayout] true if preview should not be laid out\n * @param {boolean} [hints.noCropping] true if preview should not be cropped\n * @param {boolean} [hints.noNoop] true if simple connection should not be drawn\n */\nConnectionPreview.prototype.drawPreview = function (context, canConnect, hints) {\n  hints = hints || {};\n  var connectionPreviewGfx = context.connectionPreviewGfx,\n    getConnection = context.getConnection,\n    source = hints.source,\n    target = hints.target,\n    waypoints = hints.waypoints,\n    connectionStart = hints.connectionStart,\n    connectionEnd = hints.connectionEnd,\n    noLayout = hints.noLayout,\n    noCropping = hints.noCropping,\n    noNoop = hints.noNoop,\n    connection;\n  var self = this;\n  if (!connectionPreviewGfx) {\n    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();\n  }\n  svgClear(connectionPreviewGfx);\n  if (!getConnection) {\n    getConnection = context.getConnection = cacheReturnValues(function (canConnect, source, target) {\n      return self.getConnection(canConnect, source, target);\n    });\n  }\n  if (canConnect) {\n    connection = getConnection(canConnect, source, target);\n  }\n  if (!connection) {\n    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);\n    return;\n  }\n  connection.waypoints = waypoints || [];\n\n  // optional layout\n  if (this._layouter && !noLayout) {\n    connection.waypoints = this._layouter.layoutConnection(connection, {\n      source: source,\n      target: target,\n      connectionStart: connectionStart,\n      connectionEnd: connectionEnd,\n      waypoints: hints.waypoints || connection.waypoints\n    });\n  }\n\n  // fallback if no waypoints were provided nor created with layouter\n  if (!connection.waypoints || !connection.waypoints.length) {\n    connection.waypoints = [source ? getMid(source) : connectionStart, target ? getMid(target) : connectionEnd];\n  }\n\n  // optional cropping\n  if (this._connectionDocking && (source || target) && !noCropping) {\n    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);\n  }\n  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);\n};\n\n/**\n * Draw simple connection between source and target or provided points.\n *\n * @param {SVGElement} connectionPreviewGfx container for the connection\n * @param {Object} hints\n * @param {djs.model.shape} [hints.source] source element\n * @param {djs.model.shape} [hints.target] target element\n * @param {Point} [hints.connectionStart] required if source is not provided\n * @param {Point} [hints.connectionEnd] required if target is not provided\n */\nConnectionPreview.prototype.drawNoopPreview = function (connectionPreviewGfx, hints) {\n  var source = hints.source,\n    target = hints.target,\n    start = hints.connectionStart || getMid(source),\n    end = hints.connectionEnd || getMid(target);\n  var waypoints = this.cropWaypoints(start, end, source, target);\n  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);\n  svgAppend(connectionPreviewGfx, connection);\n};\n\n/**\n * Return cropped waypoints.\n *\n * @param {Point} start\n * @param {Point} end\n * @param {djs.model.shape} source\n * @param {djs.model.shape} target\n *\n * @returns {Array}\n */\nConnectionPreview.prototype.cropWaypoints = function (start, end, source, target) {\n  var graphicsFactory = this._graphicsFactory,\n    sourcePath = source && graphicsFactory.getShapePath(source),\n    targetPath = target && graphicsFactory.getShapePath(target),\n    connectionPath = graphicsFactory.getConnectionPath({\n      waypoints: [start, end]\n    });\n  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;\n  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;\n  return [start, end];\n};\n\n/**\n * Remove connection preview container if it exists.\n *\n * @param {Object} [context]\n * @param {SVGElement} [context.connectionPreviewGfx] preview container\n */\nConnectionPreview.prototype.cleanUp = function (context) {\n  if (context && context.connectionPreviewGfx) {\n    svgRemove(context.connectionPreviewGfx);\n  }\n};\n\n/**\n * Get connection that connects source and target.\n *\n * @param {Object|boolean} canConnect\n *\n * @returns {djs.model.connection}\n */\nConnectionPreview.prototype.getConnection = function (canConnect) {\n  var attrs = ensureConnectionAttrs(canConnect);\n  return this._elementFactory.createConnection(attrs);\n};\n\n/**\n * Add and return preview graphics.\n *\n * @returns {SVGElement}\n */\nConnectionPreview.prototype.createConnectionPreviewGfx = function () {\n  var gfx = svgCreate('g');\n  svgAttr(gfx, {\n    pointerEvents: 'none'\n  });\n  svgClasses(gfx).add(MARKER_CONNECTION_PREVIEW);\n  svgAppend(this._canvas.getDefaultLayer(), gfx);\n  return gfx;\n};\n\n/**\n * Create and return simple connection.\n *\n * @param {Point} start\n * @param {Point} end\n *\n * @returns {SVGElement}\n */\nConnectionPreview.prototype.createNoopConnection = function (start, end) {\n  var connection = svgCreate('polyline');\n  svgAttr(connection, {\n    'stroke': '#333',\n    'strokeDasharray': [1],\n    'strokeWidth': 2,\n    'pointer-events': 'none'\n  });\n  svgAttr(connection, {\n    'points': [start.x, start.y, end.x, end.y]\n  });\n  return connection;\n};\n\n// helpers //////////\n\n/**\n * Returns function that returns cached return values referenced by stringified first argument.\n *\n * @param {Function} fn\n *\n * @return {Function}\n */\nfunction cacheReturnValues(fn) {\n  var returnValues = {};\n\n  /**\n   * Return cached return value referenced by stringified first argument.\n   *\n   * @returns {*}\n   */\n  return function (firstArgument) {\n    var key = JSON.stringify(firstArgument);\n    var returnValue = returnValues[key];\n    if (!returnValue) {\n      returnValue = returnValues[key] = fn.apply(null, arguments);\n    }\n    return returnValue;\n  };\n}\n\n/**\n * Ensure connection attributes is object.\n *\n * @param {Object|boolean} canConnect\n *\n * @returns {Object}\n */\nfunction ensureConnectionAttrs(canConnect) {\n  if (isObject(canConnect)) {\n    return canConnect;\n  } else {\n    return {};\n  }\n}","map":null,"metadata":{},"sourceType":"module"}