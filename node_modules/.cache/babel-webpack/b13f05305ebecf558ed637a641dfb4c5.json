{"ast":null,"code":"import inherits from 'inherits';\nimport OrderingProvider from 'diagram-js/lib/features/ordering/OrderingProvider';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { findIndex, find } from 'min-dash';\n\n/**\n * a simple ordering provider that makes sure:\n *\n * (0) labels and groups are rendered always on top\n * (1) elements are ordered by a {level} property\n */\nexport default function BpmnOrderingProvider(eventBus, canvas, translate) {\n  OrderingProvider.call(this, eventBus);\n  var orders = [{\n    type: 'bpmn:SubProcess',\n    order: {\n      level: 6\n    }\n  }, {\n    type: 'bpmn:SequenceFlow',\n    order: {\n      level: 3,\n      containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer']\n    }\n  },\n  // handle DataAssociation(s) like message flows and render them always on top\n  {\n    type: 'bpmn:DataAssociation',\n    order: {\n      level: 9,\n      containers: ['bpmn:Collaboration', 'bpmn:Process']\n    }\n  }, {\n    type: 'bpmn:MessageFlow',\n    order: {\n      level: 9,\n      containers: ['bpmn:Collaboration']\n    }\n  }, {\n    type: 'bpmn:Association',\n    order: {\n      level: 6,\n      containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer', 'bpmn:Collaboration']\n    }\n  }, {\n    type: 'bpmn:BoundaryEvent',\n    order: {\n      level: 8\n    }\n  }, {\n    type: 'bpmn:Group',\n    order: {\n      level: 10,\n      containers: ['bpmn:Collaboration', 'bpmn:Process']\n    }\n  }, {\n    type: 'bpmn:FlowElement',\n    order: {\n      level: 5\n    }\n  }, {\n    type: 'bpmn:Participant',\n    order: {\n      level: -2\n    }\n  }, {\n    type: 'bpmn:Lane',\n    order: {\n      level: -1\n    }\n  }];\n  function computeOrder(element) {\n    if (element.labelTarget) {\n      return {\n        level: 10\n      };\n    }\n    var entry = find(orders, function (o) {\n      return isAny(element, [o.type]);\n    });\n    return entry && entry.order || {\n      level: 1\n    };\n  }\n  function getOrder(element) {\n    var order = element.order;\n    if (!order) {\n      element.order = order = computeOrder(element);\n    }\n    return order;\n  }\n  function findActualParent(element, newParent, containers) {\n    var actualParent = newParent;\n    while (actualParent) {\n      if (isAny(actualParent, containers)) {\n        break;\n      }\n      actualParent = actualParent.parent;\n    }\n    if (!actualParent) {\n      throw new Error(translate('no parent for {element} in {parent}', {\n        element: element.id,\n        parent: newParent.id\n      }));\n    }\n    return actualParent;\n  }\n  this.getOrdering = function (element, newParent) {\n    // render labels always on top\n    if (element.labelTarget) {\n      return {\n        parent: canvas.getRootElement(),\n        index: -1\n      };\n    }\n    var elementOrder = getOrder(element);\n    if (elementOrder.containers) {\n      newParent = findActualParent(element, newParent, elementOrder.containers);\n    }\n    var currentIndex = newParent.children.indexOf(element);\n    var insertIndex = findIndex(newParent.children, function (child) {\n      // do not compare with labels, they are created\n      // in the wrong order (right after elements) during import and\n      // mess up the positioning.\n      if (!element.labelTarget && child.labelTarget) {\n        return false;\n      }\n      return elementOrder.level < getOrder(child).level;\n    });\n\n    // if the element is already in the child list at\n    // a smaller index, we need to adjust the insert index.\n    // this takes into account that the element is being removed\n    // before being re-inserted\n    if (insertIndex !== -1) {\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\n        insertIndex -= 1;\n      }\n    }\n    return {\n      index: insertIndex,\n      parent: newParent\n    };\n  };\n}\nBpmnOrderingProvider.$inject = ['eventBus', 'canvas', 'translate'];\ninherits(BpmnOrderingProvider, OrderingProvider);","map":null,"metadata":{},"sourceType":"module"}