{"ast":null,"code":"import { add as collectionAdd, indexOf as collectionIdx } from '../../../util/Collections';\nimport { saveClear } from '../../../util/Removal';\n\n/**\n * A handler that implements reversible deletion of shapes.\n *\n */\nexport default function DeleteShapeHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\nDeleteShapeHandler.$inject = ['canvas', 'modeling'];\n\n/**\n * - Remove connections\n * - Remove all direct children\n */\nDeleteShapeHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var shape = context.shape;\n\n  // remove connections\n  saveClear(shape.incoming, function (connection) {\n    // To make sure that the connection isn't removed twice\n    // For example if a container is removed\n    modeling.removeConnection(connection, {\n      nested: true\n    });\n  });\n  saveClear(shape.outgoing, function (connection) {\n    modeling.removeConnection(connection, {\n      nested: true\n    });\n  });\n\n  // remove child shapes and connections\n  saveClear(shape.children, function (child) {\n    if (isConnection(child)) {\n      modeling.removeConnection(child, {\n        nested: true\n      });\n    } else {\n      modeling.removeShape(child, {\n        nested: true\n      });\n    }\n  });\n};\n\n/**\n * Remove shape and remember the parent\n */\nDeleteShapeHandler.prototype.execute = function (context) {\n  var canvas = this._canvas;\n  var shape = context.shape,\n    oldParent = shape.parent;\n  context.oldParent = oldParent;\n\n  // remove containment\n  context.oldParentIndex = collectionIdx(oldParent.children, shape);\n\n  // remove shape\n  canvas.removeShape(shape);\n  return shape;\n};\n\n/**\n * Command revert implementation\n */\nDeleteShapeHandler.prototype.revert = function (context) {\n  var canvas = this._canvas;\n  var shape = context.shape,\n    oldParent = context.oldParent,\n    oldParentIndex = context.oldParentIndex;\n\n  // restore containment\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n  canvas.addShape(shape, oldParent);\n  return shape;\n};\nfunction isConnection(element) {\n  return element.waypoints;\n}","map":null,"metadata":{},"sourceType":"module"}