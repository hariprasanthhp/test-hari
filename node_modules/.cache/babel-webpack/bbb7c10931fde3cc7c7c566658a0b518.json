{"ast":null,"code":"/*\n Highmaps JS v9.3.3 (2022-02-01)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (b) {\n  \"object\" === typeof module && module.exports ? (b[\"default\"] = b, module.exports = b) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/heatmap\", [\"highcharts\"], function (x) {\n    b(x);\n    b.Highcharts = x;\n    return b;\n  }) : b(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (b) {\n  function x(b, h, z, n) {\n    b.hasOwnProperty(h) || (b[h] = n.apply(null, z));\n  }\n  b = b ? b._modules : {};\n  x(b, \"Core/Axis/Color/ColorAxisComposition.js\", [b[\"Core/Color/Color.js\"], b[\"Core/Utilities.js\"]], function (b, h) {\n    var r = b.parse,\n      n = h.addEvent,\n      y = h.extend,\n      t = h.merge,\n      A = h.pick,\n      C = h.splat,\n      m;\n    (function (f) {\n      function b() {\n        var c = this,\n          a = this.options;\n        this.colorAxis = [];\n        a.colorAxis && (a.colorAxis = C(a.colorAxis), a.colorAxis.forEach(function (a, d) {\n          a.index = d;\n          new k(c, a);\n        }));\n      }\n      function h(a) {\n        var c = this,\n          d = function (d) {\n            d = a.allItems.indexOf(d);\n            -1 !== d && (c.destroyItem(a.allItems[d]), a.allItems.splice(d, 1));\n          },\n          e = [],\n          p,\n          k;\n        (this.chart.colorAxis || []).forEach(function (a) {\n          (p = a.options) && p.showInLegend && (p.dataClasses && p.visible ? e = e.concat(a.getDataClassLegendSymbols()) : p.visible && e.push(a), a.series.forEach(function (a) {\n            if (!a.options.showInLegend || p.dataClasses) \"point\" === a.options.legendType ? a.points.forEach(function (a) {\n              d(a);\n            }) : d(a);\n          }));\n        });\n        for (k = e.length; k--;) a.allItems.unshift(e[k]);\n      }\n      function m(a) {\n        a.visible && a.item.legendColor && a.item.legendSymbol.attr({\n          fill: a.item.legendColor\n        });\n      }\n      function u() {\n        var a = this.chart.colorAxis;\n        a && a.forEach(function (a, c, d) {\n          a.update({}, d);\n        });\n      }\n      function w() {\n        (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();\n      }\n      function q() {\n        var a = this.axisTypes;\n        a ? -1 === a.indexOf(\"colorAxis\") && a.push(\"colorAxis\") : this.axisTypes = [\"colorAxis\"];\n      }\n      function E(a) {\n        var c = this,\n          d = a ? \"show\" : \"hide\";\n        c.visible = c.options.visible = !!a;\n        [\"graphic\", \"dataLabel\"].forEach(function (a) {\n          if (c[a]) c[a][d]();\n        });\n        this.series.buildKDTree();\n      }\n      function g() {\n        var a = this,\n          c = this.options.nullColor,\n          d = this.colorAxis,\n          e = this.colorKey;\n        (this.data.length ? this.data : this.points).forEach(function (k) {\n          var l = k.getNestedProperty(e);\n          (l = k.options.color || (k.isNull || null === k.value ? c : d && \"undefined\" !== typeof l ? d.toColor(l, k) : k.color || a.color)) && k.color !== l && (k.color = l, \"point\" === a.options.legendType && k.legendItem && a.chart.legend.colorizeItem(k, k.visible));\n        });\n      }\n      function e(a) {\n        var c = a.prototype.createAxis;\n        a.prototype.createAxis = function (a, d) {\n          if (\"colorAxis\" !== a) return c.apply(this, arguments);\n          var e = new k(this, t(d.axis, {\n            index: this[a].length,\n            isX: !1\n          }));\n          this.isDirtyLegend = !0;\n          this.axes.forEach(function (a) {\n            a.series = [];\n          });\n          this.series.forEach(function (a) {\n            a.bindAxes();\n            a.isDirtyData = !0;\n          });\n          A(d.redraw, !0) && this.redraw(d.animation);\n          return e;\n        };\n      }\n      function d() {\n        this.elem.attr(\"fill\", r(this.start).tweenTo(r(this.end), this.pos), void 0, !0);\n      }\n      function c() {\n        this.elem.attr(\"stroke\", r(this.start).tweenTo(r(this.end), this.pos), void 0, !0);\n      }\n      var a = [],\n        k;\n      f.compose = function (p, l, B, f, v) {\n        k || (k = p);\n        -1 === a.indexOf(l) && (a.push(l), p = l.prototype, p.collectionsWithUpdate.push(\"colorAxis\"), p.collectionsWithInit.colorAxis = [p.addColorAxis], n(l, \"afterGetAxes\", b), e(l));\n        -1 === a.indexOf(B) && (a.push(B), l = B.prototype, l.fillSetter = d, l.strokeSetter = c);\n        -1 === a.indexOf(f) && (a.push(f), n(f, \"afterGetAllItems\", h), n(f, \"afterColorizeItem\", m), n(f, \"afterUpdate\", u));\n        -1 === a.indexOf(v) && (a.push(v), y(v.prototype, {\n          optionalAxis: \"colorAxis\",\n          translateColors: g\n        }), y(v.prototype.pointClass.prototype, {\n          setVisible: E\n        }), n(v, \"afterTranslate\", w), n(v, \"bindAxes\", q));\n      };\n      f.pointSetVisible = E;\n    })(m || (m = {}));\n    return m;\n  });\n  x(b, \"Core/Axis/Color/ColorAxisDefaults.js\", [], function () {\n    return {\n      lineWidth: 0,\n      minPadding: 0,\n      maxPadding: 0,\n      gridLineWidth: 1,\n      tickPixelInterval: 72,\n      startOnTick: !0,\n      endOnTick: !0,\n      offset: 0,\n      marker: {\n        animation: {\n          duration: 50\n        },\n        width: .01,\n        color: \"#999999\"\n      },\n      labels: {\n        overflow: \"justify\",\n        rotation: 0\n      },\n      minColor: \"#e6ebf5\",\n      maxColor: \"#003399\",\n      tickLength: 5,\n      showInLegend: !0\n    };\n  });\n  x(b, \"Core/Axis/Color/ColorAxis.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Color/Color.js\"], b[\"Core/Axis/Color/ColorAxisComposition.js\"], b[\"Core/Axis/Color/ColorAxisDefaults.js\"], b[\"Core/Globals.js\"], b[\"Core/Legend/LegendSymbol.js\"], b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Utilities.js\"]], function (b, h, z, n, y, t, A, C) {\n    var m = this && this.__extends || function () {\n        var f = function (g, e) {\n          f = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (d, c) {\n            d.__proto__ = c;\n          } || function (d, c) {\n            for (var a in c) c.hasOwnProperty(a) && (d[a] = c[a]);\n          };\n          return f(g, e);\n        };\n        return function (g, e) {\n          function d() {\n            this.constructor = g;\n          }\n          f(g, e);\n          g.prototype = null === e ? Object.create(e) : (d.prototype = e.prototype, new d());\n        };\n      }(),\n      f = h.parse,\n      v = y.noop,\n      r = A.series,\n      D = C.extend,\n      u = C.isNumber,\n      w = C.merge,\n      q = C.pick;\n    h = function (b) {\n      function g(e, d) {\n        var c = b.call(this, e, d) || this;\n        c.beforePadding = !1;\n        c.chart = void 0;\n        c.coll = \"colorAxis\";\n        c.dataClasses = void 0;\n        c.legendItem = void 0;\n        c.legendItems = void 0;\n        c.name = \"\";\n        c.options = void 0;\n        c.stops = void 0;\n        c.visible = !0;\n        c.init(e, d);\n        return c;\n      }\n      m(g, b);\n      g.compose = function (e, d, c, a) {\n        z.compose(g, e, d, c, a);\n      };\n      g.prototype.init = function (e, d) {\n        var c = e.options.legend || {},\n          a = d.layout ? \"vertical\" !== d.layout : \"vertical\" !== c.layout,\n          k = d.visible;\n        c = w(g.defaultColorAxisOptions, d, {\n          showEmpty: !1,\n          title: null,\n          visible: c.enabled && !1 !== k\n        });\n        this.coll = \"colorAxis\";\n        this.side = d.side || a ? 2 : 1;\n        this.reversed = d.reversed || !a;\n        this.opposite = !a;\n        b.prototype.init.call(this, e, c);\n        this.userOptions.visible = k;\n        d.dataClasses && this.initDataClasses(d);\n        this.initStops();\n        this.horiz = a;\n        this.zoomEnabled = !1;\n      };\n      g.prototype.initDataClasses = function (e) {\n        var d = this.chart,\n          c = this.options,\n          a = e.dataClasses.length,\n          k,\n          b = 0,\n          l = d.options.chart.colorCount;\n        this.dataClasses = k = [];\n        this.legendItems = [];\n        (e.dataClasses || []).forEach(function (e, g) {\n          e = w(e);\n          k.push(e);\n          if (d.styledMode || !e.color) \"category\" === c.dataClassColor ? (d.styledMode || (g = d.options.colors, l = g.length, e.color = g[b]), e.colorIndex = b, b++, b === l && (b = 0)) : e.color = f(c.minColor).tweenTo(f(c.maxColor), 2 > a ? .5 : g / (a - 1));\n        });\n      };\n      g.prototype.hasData = function () {\n        return !!(this.tickPositions || []).length;\n      };\n      g.prototype.setTickPositions = function () {\n        if (!this.dataClasses) return b.prototype.setTickPositions.call(this);\n      };\n      g.prototype.initStops = function () {\n        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];\n        this.stops.forEach(function (e) {\n          e.color = f(e[1]);\n        });\n      };\n      g.prototype.setOptions = function (e) {\n        b.prototype.setOptions.call(this, e);\n        this.options.crosshair = this.options.marker;\n      };\n      g.prototype.setAxisSize = function () {\n        var e = this.legendSymbol,\n          d = this.chart,\n          c = d.options.legend || {},\n          a,\n          k;\n        e ? (this.left = c = e.attr(\"x\"), this.top = a = e.attr(\"y\"), this.width = k = e.attr(\"width\"), this.height = e = e.attr(\"height\"), this.right = d.chartWidth - c - k, this.bottom = d.chartHeight - a - e, this.len = this.horiz ? k : e, this.pos = this.horiz ? c : a) : this.len = (this.horiz ? c.symbolWidth : c.symbolHeight) || g.defaultLegendLength;\n      };\n      g.prototype.normalizedValue = function (e) {\n        this.logarithmic && (e = this.logarithmic.log2lin(e));\n        return 1 - (this.max - e) / (this.max - this.min || 1);\n      };\n      g.prototype.toColor = function (e, d) {\n        var c = this.dataClasses,\n          a = this.stops,\n          k;\n        if (c) for (k = c.length; k--;) {\n          var b = c[k];\n          var l = b.from;\n          a = b.to;\n          if ((\"undefined\" === typeof l || e >= l) && (\"undefined\" === typeof a || e <= a)) {\n            var g = b.color;\n            d && (d.dataClass = k, d.colorIndex = b.colorIndex);\n            break;\n          }\n        } else {\n          e = this.normalizedValue(e);\n          for (k = a.length; k-- && !(e > a[k][0]););\n          l = a[k] || a[k + 1];\n          a = a[k + 1] || l;\n          e = 1 - (a[0] - e) / (a[0] - l[0] || 1);\n          g = l.color.tweenTo(a.color, e);\n        }\n        return g;\n      };\n      g.prototype.getOffset = function () {\n        var e = this.legendGroup,\n          d = this.chart.axisOffset[this.side];\n        e && (this.axisParent = e, b.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = d);\n      };\n      g.prototype.setLegendColor = function () {\n        var e = this.reversed,\n          d = e ? 1 : 0;\n        e = e ? 0 : 1;\n        d = this.horiz ? [d, 0, e, 0] : [0, e, 0, d];\n        this.legendColor = {\n          linearGradient: {\n            x1: d[0],\n            y1: d[1],\n            x2: d[2],\n            y2: d[3]\n          },\n          stops: this.stops\n        };\n      };\n      g.prototype.drawLegendSymbol = function (e, d) {\n        var c = e.padding,\n          a = e.options,\n          k = this.horiz,\n          b = q(a.symbolWidth, k ? g.defaultLegendLength : 12),\n          l = q(a.symbolHeight, k ? 12 : g.defaultLegendLength),\n          f = q(a.labelPadding, k ? 16 : 30);\n        a = q(a.itemDistance, 10);\n        this.setLegendColor();\n        d.legendSymbol = this.chart.renderer.rect(0, e.baseline - 11, b, l).attr({\n          zIndex: 1\n        }).add(d.legendGroup);\n        this.legendItemWidth = b + c + (k ? a : f);\n        this.legendItemHeight = l + c + (k ? f : 0);\n      };\n      g.prototype.setState = function (e) {\n        this.series.forEach(function (d) {\n          d.setState(e);\n        });\n      };\n      g.prototype.setVisible = function () {};\n      g.prototype.getSeriesExtremes = function () {\n        var e = this.series,\n          d = e.length,\n          c;\n        this.dataMin = Infinity;\n        for (this.dataMax = -Infinity; d--;) {\n          var a = e[d];\n          var k = a.colorKey = q(a.options.colorKey, a.colorKey, a.pointValKey, a.zoneAxis, \"y\");\n          var b = a.pointArrayMap;\n          var l = a[k + \"Min\"] && a[k + \"Max\"];\n          if (a[k + \"Data\"]) var g = a[k + \"Data\"];else if (b) {\n            g = [];\n            b = b.indexOf(k);\n            var f = a.yData;\n            if (0 <= b && f) for (c = 0; c < f.length; c++) g.push(q(f[c][b], f[c]));\n          } else g = a.yData;\n          l ? (a.minColorValue = a[k + \"Min\"], a.maxColorValue = a[k + \"Max\"]) : (g = r.prototype.getExtremes.call(a, g), a.minColorValue = g.dataMin, a.maxColorValue = g.dataMax);\n          \"undefined\" !== typeof a.minColorValue && (this.dataMin = Math.min(this.dataMin, a.minColorValue), this.dataMax = Math.max(this.dataMax, a.maxColorValue));\n          l || r.prototype.applyExtremes.call(a);\n        }\n      };\n      g.prototype.drawCrosshair = function (e, d) {\n        var c = d && d.plotX,\n          a = d && d.plotY,\n          k = this.pos,\n          g = this.len;\n        if (d) {\n          var f = this.toPixels(d.getNestedProperty(d.series.colorKey));\n          f < k ? f = k - 2 : f > k + g && (f = k + g + 2);\n          d.plotX = f;\n          d.plotY = this.len - f;\n          b.prototype.drawCrosshair.call(this, e, d);\n          d.plotX = c;\n          d.plotY = a;\n          this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass(\"highcharts-coloraxis-marker\").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || \"object\" !== typeof this.crosshair || this.cross.attr({\n            fill: this.crosshair.color\n          }));\n        }\n      };\n      g.prototype.getPlotLinePath = function (e) {\n        var d = this.left,\n          c = e.translatedValue,\n          a = this.top;\n        return u(c) ? this.horiz ? [[\"M\", c - 4, a - 6], [\"L\", c + 4, a - 6], [\"L\", c, a], [\"Z\"]] : [[\"M\", d, c], [\"L\", d - 6, c + 6], [\"L\", d - 6, c - 6], [\"Z\"]] : b.prototype.getPlotLinePath.call(this, e);\n      };\n      g.prototype.update = function (e, d) {\n        var c = this.chart.legend;\n        this.series.forEach(function (a) {\n          a.isDirtyData = !0;\n        });\n        (e.dataClasses && c.allItems || this.dataClasses) && this.destroyItems();\n        b.prototype.update.call(this, e, d);\n        this.legendItem && (this.setLegendColor(), c.colorizeItem(this, !0));\n      };\n      g.prototype.destroyItems = function () {\n        var e = this.chart;\n        this.legendItem ? e.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (d) {\n          e.legend.destroyItem(d);\n        });\n        e.isDirtyLegend = !0;\n      };\n      g.prototype.destroy = function () {\n        this.chart.isDirtyLegend = !0;\n        this.destroyItems();\n        b.prototype.destroy.apply(this, [].slice.call(arguments));\n      };\n      g.prototype.remove = function (e) {\n        this.destroyItems();\n        b.prototype.remove.call(this, e);\n      };\n      g.prototype.getDataClassLegendSymbols = function () {\n        var e = this,\n          d = e.chart,\n          c = e.legendItems,\n          a = d.options.legend,\n          k = a.valueDecimals,\n          b = a.valueSuffix || \"\",\n          f;\n        c.length || e.dataClasses.forEach(function (a, g) {\n          var l = a.from,\n            B = a.to,\n            h = d.numberFormatter,\n            p = !0;\n          f = \"\";\n          \"undefined\" === typeof l ? f = \"< \" : \"undefined\" === typeof B && (f = \"> \");\n          \"undefined\" !== typeof l && (f += h(l, k) + b);\n          \"undefined\" !== typeof l && \"undefined\" !== typeof B && (f += \" - \");\n          \"undefined\" !== typeof B && (f += h(B, k) + b);\n          c.push(D({\n            chart: d,\n            name: f,\n            options: {},\n            drawLegendSymbol: t.drawRectangle,\n            visible: !0,\n            setState: v,\n            isDataClass: !0,\n            setVisible: function () {\n              p = e.visible = !p;\n              e.series.forEach(function (a) {\n                a.points.forEach(function (a) {\n                  a.dataClass === g && a.setVisible(p);\n                });\n              });\n              d.legend.colorizeItem(this, p);\n            }\n          }, a));\n        });\n        return c;\n      };\n      g.defaultColorAxisOptions = n;\n      g.defaultLegendLength = 200;\n      g.keepProps = [\"legendGroup\", \"legendItemHeight\", \"legendItemWidth\", \"legendItem\", \"legendSymbol\"];\n      return g;\n    }(b);\n    Array.prototype.push.apply(b.keepProps, h.keepProps);\n    \"\";\n    return h;\n  });\n  x(b, \"Series/ColorMapMixin.js\", [b[\"Core/Globals.js\"], b[\"Core/Series/Point.js\"], b[\"Core/Utilities.js\"]], function (b, h, z) {\n    var r = b.noop;\n    b = b.seriesTypes;\n    var y = z.defined;\n    z = z.addEvent;\n    z(h, \"afterSetState\", function (b) {\n      this.moveToTopOnHover && this.graphic && this.graphic.attr({\n        zIndex: b && \"hover\" === b.state ? 1 : 0\n      });\n    });\n    return {\n      PointMixin: {\n        dataLabelOnNull: !0,\n        moveToTopOnHover: !0,\n        isValid: function () {\n          return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n        }\n      },\n      SeriesMixin: {\n        pointArrayMap: [\"value\"],\n        axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n        trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n        getSymbol: r,\n        parallelArrays: [\"x\", \"y\", \"value\"],\n        colorKey: \"value\",\n        pointAttribs: b.column.prototype.pointAttribs,\n        colorAttribs: function (b) {\n          var h = {};\n          !y(b.color) || b.state && \"normal\" !== b.state || (h[this.colorProp || \"fill\"] = b.color);\n          return h;\n        }\n      }\n    };\n  });\n  x(b, \"Series/Heatmap/HeatmapPoint.js\", [b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Utilities.js\"]], function (b, h) {\n    var r = this && this.__extends || function () {\n        var b = function (h, f) {\n          b = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (b, f) {\n            b.__proto__ = f;\n          } || function (b, f) {\n            for (var h in f) f.hasOwnProperty(h) && (b[h] = f[h]);\n          };\n          return b(h, f);\n        };\n        return function (h, f) {\n          function v() {\n            this.constructor = h;\n          }\n          b(h, f);\n          h.prototype = null === f ? Object.create(f) : (v.prototype = f.prototype, new v());\n        };\n      }(),\n      n = h.clamp,\n      y = h.defined,\n      t = h.extend,\n      A = h.pick;\n    b = function (b) {\n      function h() {\n        var f = null !== b && b.apply(this, arguments) || this;\n        f.options = void 0;\n        f.series = void 0;\n        f.value = void 0;\n        f.x = void 0;\n        f.y = void 0;\n        return f;\n      }\n      r(h, b);\n      h.prototype.applyOptions = function (f, h) {\n        f = b.prototype.applyOptions.call(this, f, h);\n        f.formatPrefix = f.isNull || null === f.value ? \"null\" : \"point\";\n        return f;\n      };\n      h.prototype.getCellAttributes = function () {\n        var b = this.series,\n          h = b.options,\n          r = (h.colsize || 1) / 2,\n          m = (h.rowsize || 1) / 2,\n          u = b.xAxis,\n          w = b.yAxis,\n          q = this.options.marker || b.options.marker;\n        b = b.pointPlacementToXValue();\n        var t = A(this.pointPadding, h.pointPadding, 0),\n          g = {\n            x1: n(Math.round(u.len - (u.translate(this.x - r, !1, !0, !1, !0, -b) || 0)), -u.len, 2 * u.len),\n            x2: n(Math.round(u.len - (u.translate(this.x + r, !1, !0, !1, !0, -b) || 0)), -u.len, 2 * u.len),\n            y1: n(Math.round(w.translate(this.y - m, !1, !0, !1, !0) || 0), -w.len, 2 * w.len),\n            y2: n(Math.round(w.translate(this.y + m, !1, !0, !1, !0) || 0), -w.len, 2 * w.len)\n          };\n        [[\"width\", \"x\"], [\"height\", \"y\"]].forEach(function (b) {\n          var d = b[0];\n          b = b[1];\n          var c = b + \"1\",\n            a = b + \"2\",\n            e = Math.abs(g[c] - g[a]),\n            f = q && q.lineWidth || 0,\n            h = Math.abs(g[c] + g[a]) / 2;\n          d = q && q[d];\n          y(d) && d < e && (d = d / 2 + f / 2, g[c] = h - d, g[a] = h + d);\n          t && (\"y\" === b && (c = a, a = b + \"1\"), g[c] += t, g[a] -= t);\n        });\n        return g;\n      };\n      h.prototype.haloPath = function (b) {\n        if (!b) return [];\n        var f = this.shapeArgs;\n        return [\"M\", f.x - b, f.y - b, \"L\", f.x - b, f.y + f.height + b, f.x + f.width + b, f.y + f.height + b, f.x + f.width + b, f.y - b, \"Z\"];\n      };\n      h.prototype.isValid = function () {\n        return Infinity !== this.value && -Infinity !== this.value;\n      };\n      return h;\n    }(b.seriesTypes.scatter.prototype.pointClass);\n    t(b.prototype, {\n      dataLabelOnNull: !0,\n      moveToTopOnHover: !0,\n      ttBelow: !1\n    });\n    return b;\n  });\n  x(b, \"Series/Heatmap/HeatmapSeries.js\", [b[\"Core/Color/Color.js\"], b[\"Series/ColorMapMixin.js\"], b[\"Series/Heatmap/HeatmapPoint.js\"], b[\"Core/Legend/LegendSymbol.js\"], b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Renderer/SVG/SVGRenderer.js\"], b[\"Core/Utilities.js\"]], function (b, h, x, n, y, t, A) {\n    var r = this && this.__extends || function () {\n        var b = function (d, c) {\n          b = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, c) {\n            a.__proto__ = c;\n          } || function (a, c) {\n            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n          };\n          return b(d, c);\n        };\n        return function (d, c) {\n          function a() {\n            this.constructor = d;\n          }\n          b(d, c);\n          d.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());\n        };\n      }(),\n      m = y.series,\n      f = y.seriesTypes,\n      v = f.column,\n      z = f.scatter,\n      D = t.prototype.symbols,\n      u = A.extend,\n      w = A.fireEvent,\n      q = A.isNumber,\n      E = A.merge,\n      g = A.pick;\n    t = function (e) {\n      function d() {\n        var c = null !== e && e.apply(this, arguments) || this;\n        c.colorAxis = void 0;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        c.valueMax = NaN;\n        c.valueMin = NaN;\n        return c;\n      }\n      r(d, e);\n      d.prototype.drawPoints = function () {\n        var c = this;\n        if ((this.options.marker || {}).enabled || this._hasPointMarkers) m.prototype.drawPoints.call(this), this.points.forEach(function (a) {\n          a.graphic && (a.graphic[c.chart.styledMode ? \"css\" : \"animate\"](c.colorAttribs(a)), c.options.borderRadius && a.graphic.attr({\n            r: c.options.borderRadius\n          }), (a.shapeArgs || {}).r = c.options.borderRadius, (a.shapeArgs || {}).d = a.graphic.pathArray, null === a.value && a.graphic.addClass(\"highcharts-null-point\"));\n        });\n      };\n      d.prototype.getExtremes = function () {\n        var c = m.prototype.getExtremes.call(this, this.valueData),\n          a = c.dataMin;\n        c = c.dataMax;\n        q(a) && (this.valueMin = a);\n        q(c) && (this.valueMax = c);\n        return m.prototype.getExtremes.call(this);\n      };\n      d.prototype.getValidPoints = function (c, a) {\n        return m.prototype.getValidPoints.call(this, c, a, !0);\n      };\n      d.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n      d.prototype.init = function () {\n        m.prototype.init.apply(this, arguments);\n        var c = this.options;\n        c.pointRange = g(c.pointRange, c.colsize || 1);\n        this.yAxis.axisPointRange = c.rowsize || 1;\n        D.ellipse = D.circle;\n      };\n      d.prototype.markerAttribs = function (c, a) {\n        var b = c.marker || {},\n          d = this.options.marker || {},\n          e = c.shapeArgs || {},\n          f = {};\n        if (c.hasImage) return {\n          x: c.plotX,\n          y: c.plotY\n        };\n        if (a) {\n          var g = d.states[a] || {};\n          var h = b.states && b.states[a] || {};\n          [[\"width\", \"x\"], [\"height\", \"y\"]].forEach(function (a) {\n            f[a[0]] = (h[a[0]] || g[a[0]] || e[a[0]]) + (h[a[0] + \"Plus\"] || g[a[0] + \"Plus\"] || 0);\n            f[a[1]] = e[a[1]] + (e[a[0]] - f[a[0]]) / 2;\n          });\n        }\n        return a ? f : e;\n      };\n      d.prototype.pointAttribs = function (c, a) {\n        var d = m.prototype.pointAttribs.call(this, c, a),\n          e = this.options || {},\n          f = this.chart.options.plotOptions || {},\n          g = f.series || {},\n          h = f.heatmap || {};\n        f = c && c.options.borderColor || e.borderColor || h.borderColor || g.borderColor;\n        g = c && c.options.borderWidth || e.borderWidth || h.borderWidth || g.borderWidth || d[\"stroke-width\"];\n        d.stroke = c && c.marker && c.marker.lineColor || e.marker && e.marker.lineColor || f || this.color;\n        d[\"stroke-width\"] = g;\n        a && (c = E(e.states[a], e.marker && e.marker.states[a], c && c.options.states && c.options.states[a] || {}), a = c.brightness, d.fill = c.color || b.parse(d.fill).brighten(a || 0).get(), d.stroke = c.lineColor);\n        return d;\n      };\n      d.prototype.setClip = function (b) {\n        var a = this.chart;\n        m.prototype.setClip.apply(this, arguments);\n        (!1 !== this.options.clip || b) && this.markerGroup.clip((b || this.clipBox) && this.sharedClipKey ? a.sharedClips[this.sharedClipKey] : a.clipRect);\n      };\n      d.prototype.translate = function () {\n        var b = this.options,\n          a = b.marker && b.marker.symbol || \"rect\",\n          d = D[a] ? a : \"rect\",\n          e = -1 !== [\"circle\", \"square\"].indexOf(d);\n        this.generatePoints();\n        this.points.forEach(function (b) {\n          var c = b.getCellAttributes(),\n            f = {};\n          f.x = Math.min(c.x1, c.x2);\n          f.y = Math.min(c.y1, c.y2);\n          f.width = Math.max(Math.abs(c.x2 - c.x1), 0);\n          f.height = Math.max(Math.abs(c.y2 - c.y1), 0);\n          var g = b.hasImage = 0 === (b.marker && b.marker.symbol || a || \"\").indexOf(\"url\");\n          if (e) {\n            var h = Math.abs(f.width - f.height);\n            f.x = Math.min(c.x1, c.x2) + (f.width < f.height ? 0 : h / 2);\n            f.y = Math.min(c.y1, c.y2) + (f.width < f.height ? h / 2 : 0);\n            f.width = f.height = Math.min(f.width, f.height);\n          }\n          h = {\n            plotX: (c.x1 + c.x2) / 2,\n            plotY: (c.y1 + c.y2) / 2,\n            clientX: (c.x1 + c.x2) / 2,\n            shapeType: \"path\",\n            shapeArgs: E(!0, f, {\n              d: D[d](f.x, f.y, f.width, f.height)\n            })\n          };\n          g && (b.marker = {\n            width: f.width,\n            height: f.height\n          });\n          u(b, h);\n        });\n        w(this, \"afterTranslate\");\n      };\n      d.defaultOptions = E(z.defaultOptions, {\n        animation: !1,\n        borderRadius: 0,\n        borderWidth: 0,\n        nullColor: \"#f7f7f7\",\n        dataLabels: {\n          formatter: function () {\n            var b = this.series.chart.numberFormatter,\n              a = this.point.value;\n            return q(a) ? b(a, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\",\n          crop: !1,\n          overflow: !1,\n          padding: 0\n        },\n        marker: {\n          symbol: \"rect\",\n          radius: 0,\n          lineColor: void 0,\n          states: {\n            hover: {\n              lineWidthPlus: 0\n            },\n            select: {}\n          }\n        },\n        clip: !0,\n        pointRange: null,\n        tooltip: {\n          pointFormat: \"{point.x}, {point.y}: {point.value}<br/>\"\n        },\n        states: {\n          hover: {\n            halo: !1,\n            brightness: .2\n          }\n        }\n      });\n      return d;\n    }(z);\n    u(t.prototype, {\n      alignDataLabel: v.prototype.alignDataLabel,\n      axisTypes: h.SeriesMixin.axisTypes,\n      colorAttribs: h.SeriesMixin.colorAttribs,\n      colorKey: h.SeriesMixin.colorKey,\n      directTouch: !0,\n      drawLegendSymbol: n.drawRectangle,\n      getExtremesFromAll: !0,\n      getSymbol: m.prototype.getSymbol,\n      parallelArrays: h.SeriesMixin.parallelArrays,\n      pointArrayMap: [\"y\", \"value\"],\n      pointClass: x,\n      trackerGroups: h.SeriesMixin.trackerGroups\n    });\n    y.registerSeriesType(\"heatmap\", t);\n    \"\";\n    \"\";\n    return t;\n  });\n  x(b, \"masters/modules/heatmap.src.js\", [b[\"Core/Globals.js\"], b[\"Core/Axis/Color/ColorAxis.js\"]], function (b, h) {\n    b.ColorAxis = h;\n    h.compose(b.Chart, b.Fx, b.Legend, b.Series);\n  });\n});\n//# sourceMappingURL=heatmap.js.map","map":null,"metadata":{},"sourceType":"script"}