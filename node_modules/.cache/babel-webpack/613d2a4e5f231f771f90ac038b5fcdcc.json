{"ast":null,"code":"import { every, find, forEach, some } from 'min-dash';\nimport inherits from 'inherits';\nimport { is, getBusinessObject } from '../../util/ModelUtil';\nimport { getParent, isAny } from '../modeling/util/ModelingUtil';\nimport { isLabel } from '../../util/LabelUtil';\nimport { isExpanded, isEventSubProcess, isInterrupting, hasErrorEventDefinition, hasEscalationEventDefinition, hasCompensateEventDefinition } from '../../util/DiUtil';\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\nimport { getBoundaryAttachment as isBoundaryAttachment } from '../snapping/BpmnSnappingUtil';\n\n/**\n * BPMN specific modeling rule\n */\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\ninherits(BpmnRules, RuleProvider);\nBpmnRules.$inject = ['eventBus'];\nBpmnRules.prototype.init = function () {\n  this.addRule('connection.start', function (context) {\n    var source = context.source;\n    return canStartConnection(source);\n  });\n  this.addRule('connection.create', function (context) {\n    var source = context.source,\n      target = context.target,\n      hints = context.hints || {},\n      targetParent = hints.targetParent,\n      targetAttach = hints.targetAttach;\n\n    // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n    if (targetAttach) {\n      return false;\n    }\n\n    // temporarily set target parent for scoping\n    // checks to work\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n    try {\n      return canConnect(source, target);\n    } finally {\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n  this.addRule('connection.reconnect', function (context) {\n    var connection = context.connection,\n      source = context.source,\n      target = context.target;\n    return canConnect(source, target, connection);\n  });\n  this.addRule('connection.updateWaypoints', function (context) {\n    return {\n      type: context.connection.type\n    };\n  });\n  this.addRule('shape.resize', function (context) {\n    var shape = context.shape,\n      newBounds = context.newBounds;\n    return canResize(shape, newBounds);\n  });\n  this.addRule('elements.create', function (context) {\n    var elements = context.elements,\n      position = context.position,\n      target = context.target;\n    return every(elements, function (element) {\n      if (isConnection(element)) {\n        return canConnect(element.source, element.target, element);\n      }\n      if (element.host) {\n        return canAttach(element, element.host, null, position);\n      }\n      return canCreate(element, target, null, position);\n    });\n  });\n  this.addRule('elements.move', function (context) {\n    var target = context.target,\n      shapes = context.shapes,\n      position = context.position;\n    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);\n  });\n  this.addRule('shape.create', function (context) {\n    return canCreate(context.shape, context.target, context.source, context.position);\n  });\n  this.addRule('shape.attach', function (context) {\n    return canAttach(context.shape, context.target, null, context.position);\n  });\n  this.addRule('element.copy', function (context) {\n    var element = context.element,\n      elements = context.elements;\n    return canCopy(elements, element);\n  });\n};\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\nBpmnRules.prototype.canMove = canMove;\nBpmnRules.prototype.canAttach = canAttach;\nBpmnRules.prototype.canReplace = canReplace;\nBpmnRules.prototype.canDrop = canDrop;\nBpmnRules.prototype.canInsert = canInsert;\nBpmnRules.prototype.canCreate = canCreate;\nBpmnRules.prototype.canConnect = canConnect;\nBpmnRules.prototype.canResize = canResize;\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {boolean}\n */\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n  return isAny(element, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference', 'bpmn:Group']);\n}\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\nfunction isSame(a, b) {\n  return a === b;\n}\nfunction getOrganizationalParent(element) {\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n    if (is(element, 'bpmn:Participant')) {\n      return getBusinessObject(element).processRef || getBusinessObject(element);\n    }\n  } while (element = element.parent);\n}\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\nfunction isGroup(element) {\n  return is(element, 'bpmn:Group') && !element.labelTarget;\n}\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') && hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n    parentB = getOrganizationalParent(b);\n  return parentA === parentB;\n}\nfunction isMessageFlowSource(element) {\n  return is(element, 'bpmn:InteractionNode') && !is(element, 'bpmn:BoundaryEvent') && (!is(element, 'bpmn:Event') || is(element, 'bpmn:ThrowEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));\n}\nfunction isMessageFlowTarget(element) {\n  return is(element, 'bpmn:InteractionNode') && !isForCompensation(element) && (!is(element, 'bpmn:Event') || is(element, 'bpmn:CatchEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')) && !(is(element, 'bpmn:BoundaryEvent') && !hasEventDefinition(element, 'bpmn:MessageEventDefinition'));\n}\nfunction getScopeParent(element) {\n  var parent = element;\n  while (parent = parent.parent) {\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n  return null;\n}\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n    scopeParentB = getScopeParent(b);\n  return scopeParentA === scopeParentB;\n}\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n  return !!find(bo.eventDefinitions || [], function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n  return (bo.eventDefinitions || []).every(function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\nfunction isSequenceFlowSource(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:EndEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateThrowEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isCompensationBoundary(element) && !isForCompensation(element);\n}\nfunction isSequenceFlowTarget(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:StartEvent') && !is(element, 'bpmn:BoundaryEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateCatchEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isForCompensation(element);\n}\nfunction isEventBasedTarget(element) {\n  return is(element, 'bpmn:ReceiveTask') || is(element, 'bpmn:IntermediateCatchEvent') && (hasEventDefinition(element, 'bpmn:MessageEventDefinition') || hasEventDefinition(element, 'bpmn:TimerEventDefinition') || hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') || hasEventDefinition(element, 'bpmn:SignalEventDefinition'));\n}\nfunction isConnection(element) {\n  return element.waypoints;\n}\nfunction getParents(element) {\n  var parents = [];\n  while (element) {\n    element = element.parent;\n    if (element) {\n      parents.push(element);\n    }\n  }\n  return parents;\n}\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\nfunction canConnect(source, target, connection) {\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n  if (!is(connection, 'bpmn:DataAssociation')) {\n    if (canConnectMessageFlow(source, target)) {\n      return {\n        type: 'bpmn:MessageFlow'\n      };\n    }\n    if (canConnectSequenceFlow(source, target)) {\n      return {\n        type: 'bpmn:SequenceFlow'\n      };\n    }\n  }\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n  if (canConnectAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element\n *\n * @return {boolean}\n */\nfunction canDrop(element, target, position) {\n  // can move labels and groups everywhere\n  if (isLabel(element) || isGroup(element)) {\n    return true;\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow moving DataInput / DataOutput within its original container only\n  if (isAny(element, ['bpmn:DataInput', 'bpmn:DataOutput'])) {\n    if (element.parent) {\n      return target === element.parent;\n    }\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  // disallow dropping boundary events which cannot replace with intermediate event\n  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n    return isAny(target, ['bpmn:Participant', 'bpmn:Lane']);\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, ['bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference'])) {\n    return isAny(target, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']);\n  }\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration') || element.source.parent == target || element.target.parent == target;\n  }\n  return false;\n}\nfunction isDroppableBoundaryEvent(event) {\n  return getBusinessObject(event).cancelActivity && (hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event));\n}\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\nfunction isBoundaryCandidate(element) {\n  if (isBoundaryEvent(element)) {\n    return true;\n  }\n  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {\n    return true;\n  }\n  return is(element, 'bpmn:IntermediateCatchEvent') && hasCommonBoundaryIntermediateEventDefinition(element);\n}\nfunction hasNoEventDefinition(element) {\n  var bo = getBusinessObject(element);\n  return bo && !(bo.eventDefinitions && bo.eventDefinitions.length);\n}\nfunction hasCommonBoundaryIntermediateEventDefinition(element) {\n  return hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']);\n}\nfunction hasOneOfEventDefinitions(element, eventDefinitions) {\n  return eventDefinitions.some(function (definition) {\n    return hasEventDefinition(element, definition);\n  });\n}\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return is(element, 'bpmn:ReceiveTask') && find(element.incoming, function (incoming) {\n    return is(incoming.source, 'bpmn:EventBasedGateway');\n  });\n}\nfunction canAttach(elements, target, source, position) {\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  // do not attach on receive tasks after event based gateways\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n  return 'attach';\n}\n\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\nfunction canReplace(elements, target, position) {\n  if (!target) {\n    return false;\n  }\n  var canExecute = {\n    replacements: []\n  };\n  forEach(elements, function (element) {\n    if (!isEventSubProcess(target)) {\n      if (is(element, 'bpmn:StartEvent') && element.type !== 'label' && canDrop(element, target)) {\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compensate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace a typed start event by a blank interrupting start event\n        // when the target is a sub process but not an event sub process\n        if (hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']) && is(target, 'bpmn:SubProcess')) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') && element.type !== 'label') {\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n  return canExecute.replacements.length ? canExecute : false;\n}\nfunction canMove(elements, target) {\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n  return elements.every(function (element) {\n    return canDrop(element, target);\n  });\n}\nfunction canCreate(shape, target, source, position) {\n  if (!target) {\n    return false;\n  }\n  if (isLabel(shape) || isGroup(shape)) {\n    return true;\n  }\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);\n  }\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || newBounds.width >= 130 && newBounds.height >= 60;\n  }\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || newBounds.width >= 250 && newBounds.height >= 50;\n  }\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n  if (isGroup(shape)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check, whether one side of the relationship\n * is a text annotation.\n */\nfunction isOneTextAnnotation(source, target) {\n  var sourceTextAnnotation = isTextAnnotation(source),\n    targetTextAnnotation = isTextAnnotation(target);\n  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;\n}\nfunction canConnectAssociation(source, target) {\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  }\n\n  // compensation boundary events are exception\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  }\n\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  if (isOneTextAnnotation(source, target)) {\n    return true;\n  }\n\n  // can connect associations where we can connect\n  // data associations, too (!)\n  return !!canConnectDataAssociation(source, target);\n}\nfunction canConnectMessageFlow(source, target) {\n  // during connect user might move mouse out of canvas\n  // https://github.com/bpmn-io/bpmn-js/issues/1033\n  if (getRootElement(source) && !getRootElement(target)) {\n    return false;\n  }\n  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);\n}\nfunction canConnectSequenceFlow(source, target) {\n  if (isEventBasedTarget(target) && target.incoming.length > 0 && areOutgoingEventBasedGatewayConnections(target.incoming) && !is(source, 'bpmn:EventBasedGateway')) {\n    return false;\n  }\n  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\nfunction canConnectDataAssociation(source, target) {\n  if (isAny(source, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(target, ['bpmn:Activity', 'bpmn:ThrowEvent'])) {\n    return {\n      type: 'bpmn:DataInputAssociation'\n    };\n  }\n  if (isAny(target, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(source, ['bpmn:Activity', 'bpmn:CatchEvent'])) {\n    return {\n      type: 'bpmn:DataOutputAssociation'\n    };\n  }\n  return false;\n}\nfunction canInsert(shape, flow, position) {\n  if (!flow) {\n    return false;\n  }\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n    shape = shape[0];\n  }\n  if (flow.source === shape || flow.target === shape) {\n    return false;\n  }\n\n  // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n  return isAny(flow, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) && !isLabel(flow) && is(shape, 'bpmn:FlowNode') && !is(shape, 'bpmn:BoundaryEvent') && canDrop(shape, flow.parent, position);\n}\nfunction includes(elements, element) {\n  return elements && element && elements.indexOf(element) !== -1;\n}\nfunction canCopy(elements, element) {\n  if (isLabel(element)) {\n    return true;\n  }\n  if (is(element, 'bpmn:Lane') && !includes(elements, element.parent)) {\n    return false;\n  }\n  return true;\n}\nfunction isOutgoingEventBasedGatewayConnection(connection) {\n  if (connection && connection.source) {\n    return is(connection.source, 'bpmn:EventBasedGateway');\n  }\n}\nfunction areOutgoingEventBasedGatewayConnections(connections) {\n  connections = connections || [];\n  return connections.some(isOutgoingEventBasedGatewayConnection);\n}\nfunction getRootElement(element) {\n  return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');\n}","map":null,"metadata":{},"sourceType":"module"}