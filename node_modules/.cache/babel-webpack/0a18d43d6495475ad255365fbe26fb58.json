{"ast":null,"code":"import { convertIpAddressToNumber } from '../service/utility.class';\n// custom validator to check that two fields match\nexport function ValidatorsDirective(controlName, matchingControlName, validateCondition) {\n  return formGroup => {\n    const control = formGroup.controls[controlName];\n    const matchingControl = formGroup.controls[matchingControlName];\n    // return null if controls haven't initialised yet\n    if (!control || !matchingControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (matchingControl.errors && !matchingControl.errors.mustMatch) {\n      return null;\n    }\n    //for port forwarding\n    if (validateCondition && (!control.value || !matchingControl.value)) {\n      return null;\n    }\n    // set error on matchingControl if validation fails\n    if (control.value > matchingControl.value) {\n      matchingControl.setErrors({\n        mustMatch: true\n      });\n    } else {\n      matchingControl.setErrors(null);\n    }\n  };\n}\n// custom validator to check that Beginning IP Address should be less than Ending IP Address\nexport function validateIpIsBefore(ipBeforeName, ipAfterName) {\n  return formGroup => {\n    const beforeControl = formGroup.controls[ipBeforeName];\n    const afterControl = formGroup.controls[ipAfterName];\n    // return null if controls haven't initialised yet\n    if (!beforeControl || !afterControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (afterControl.errors && !afterControl.errors.ipBeforeValidate || beforeControl.errors && !beforeControl.errors.ipBeforeValidate) {\n      return null;\n    }\n    var ipBeforeval = null;\n    var ipAfterval = null;\n    if (beforeControl.value && afterControl.value) {\n      ipBeforeval = convertIpAddressToNumber(beforeControl.value);\n      ipAfterval = convertIpAddressToNumber(afterControl.value);\n    }\n    // set error on matchingControl if validation fails\n    if (ipBeforeval <= ipAfterval) {\n      beforeControl.setErrors(null);\n      afterControl.setErrors(null);\n    } else {\n      beforeControl.setErrors({\n        ipBeforeValidate: true\n      });\n      afterControl.setErrors({\n        ipBeforeValidate: true\n      });\n    }\n  };\n}\n// custom validator to check that  Device IP Address should not be the same as Subnet ID or Broadcast Address\nexport function validateIpNetwork(ipName, maskName) {\n  return formGroup => {\n    const ipControl = formGroup.controls[ipName];\n    const maskControl = formGroup.controls[maskName];\n    // return null if controls haven't initialised yet\n    if (!ipControl || !maskControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (ipControl.errors && !ipControl.errors.IpNetworkBroadcast || maskControl.errors && !maskControl.errors.IpNetworkBroadcast) {\n      return null;\n    }\n    var ipval = null;\n    var maskval = null;\n    var networkNum = null;\n    var broadcastNum = null;\n    if (ipControl.value && maskControl.value) {\n      ipval = convertIpAddressToNumber(ipControl.value);\n      maskval = convertIpAddressToNumber(maskControl.value);\n      networkNum = (ipval >>> 0 & maskval >>> 0) >>> 0;\n      broadcastNum = (networkNum | ~maskval) >>> 0;\n    }\n    // set error on matchingControl if validation fails\n    if (ipval <= networkNum || ipval >= broadcastNum) {\n      ipControl.setErrors({\n        IpNetworkBroadcast: true\n      });\n      maskControl.setErrors({\n        IpNetworkBroadcast: true\n      });\n    } else {\n      ipControl.setErrors(null);\n      maskControl.setErrors(null);\n    }\n  };\n}\n// custom validator to check that Device IP Address should be outside \n// the range of Beginning IP Address and Ending IP Address\nexport function validateIpIsOutside(ipName, ipBeforeName, ipAfterName) {\n  return formGroup => {\n    const beforeControl = formGroup.controls[ipBeforeName];\n    const afterControl = formGroup.controls[ipAfterName];\n    const IpControl = formGroup.controls[ipName];\n    // return null if controls haven't initialised yet\n    if (!beforeControl || !afterControl || !IpControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (IpControl.errors && !IpControl.errors.ipIsOutside || afterControl.errors && !afterControl.errors.ipIsOutside || beforeControl.errors && !beforeControl.errors.ipIsOutside) {\n      return null;\n    }\n    var startVal = null;\n    var endVal = null;\n    var ipVal = null;\n    if (beforeControl.value && afterControl.value && IpControl.value) {\n      startVal = convertIpAddressToNumber(beforeControl.value);\n      endVal = convertIpAddressToNumber(afterControl.value);\n      ipVal = convertIpAddressToNumber(IpControl.value);\n    }\n    // set error on matchingControl if validation fails\n    if (ipVal < startVal || ipVal > endVal) {\n      beforeControl.setErrors(null);\n      afterControl.setErrors(null);\n      IpControl.setErrors(null);\n    } else {\n      beforeControl.setErrors({\n        ipIsOutside: true\n      });\n      afterControl.setErrors({\n        ipIsOutside: true\n      });\n      IpControl.setErrors({\n        ipIsOutside: true\n      });\n    }\n  };\n}\n// custom validator to check that Device IP Address, Beginning IP Address, \n// and Ending IP Address are not in the same network\nexport function validateIpIsSameNetwork(IpName, startName, endName, maskName) {\n  return formGroup => {\n    const startControl = formGroup.controls[startName];\n    const endControl = formGroup.controls[endName];\n    const ipControl = formGroup.controls[IpName];\n    const maskControl = formGroup.controls[maskName];\n    // return null if controls haven't initialised yet\n    if (!startControl || !endControl || !ipControl || !maskControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (ipControl.errors && !ipControl.errors.sameIpNetwork || startControl.errors && !startControl.errors.sameIpNetwork || endControl.errors && !endControl.errors.sameIpNetwork || maskControl.errors && !maskControl.errors.sameIpNetwork) {\n      return null;\n    }\n    //fetching the values\n    var startval = null;\n    var endval = null;\n    var ipVal = null;\n    var maskVal = null;\n    var networkNum = null;\n    if (startControl.value && endControl.value && ipControl.value && maskControl.value) {\n      startval = convertIpAddressToNumber(startControl.value);\n      endval = convertIpAddressToNumber(endControl.value);\n      ipVal = convertIpAddressToNumber(ipControl.value);\n      maskVal = convertIpAddressToNumber(maskControl.value);\n      networkNum = maskVal & ipVal;\n    }\n    if (networkNum != (maskVal & startval) || networkNum != (maskVal & endval)) {\n      ipControl.setErrors({\n        sameIpNetwork: true\n      });\n      endControl.setErrors({\n        sameIpNetwork: true\n      });\n      startControl.setErrors({\n        sameIpNetwork: true\n      });\n      maskControl.setErrors({\n        sameIpNetwork: true\n      });\n    } else {\n      ipControl.setErrors(null);\n      endControl.setErrors(null);\n      startControl.setErrors(null);\n      maskControl.setErrors(null);\n    }\n  };\n}\n// custom validator to check thatEnding IP Address should not be the same as Subnet ID or Broadcast Address\nexport function validateIpIsMaxNetwork(ipName, endName, maskName) {\n  return formGroup => {\n    const ipControl = formGroup.controls[ipName];\n    const maskControl = formGroup.controls[maskName];\n    const endControl = formGroup.controls[endName];\n    // return null if controls haven't initialised yet\n    if (!ipControl || !maskControl || !endControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (ipControl.errors && !ipControl.errors.maxNetworkBroadcast || maskControl.errors && !maskControl.errors.maxNetworkBroadcast || endControl.errors && !endControl.errors.maxNetworkBroadcast) {\n      return null;\n    }\n    var ipval = null;\n    var maskval = null;\n    var endVal = null;\n    var networkNum = null;\n    var broadcastNum = null;\n    if (ipControl.value, maskControl.value, endControl.value) {\n      ipval = convertIpAddressToNumber(ipControl.value);\n      maskval = convertIpAddressToNumber(maskControl.value);\n      endVal = convertIpAddressToNumber(endControl.value);\n      networkNum = (ipval >>> 0 & maskval >>> 0) >>> 0;\n      broadcastNum = (networkNum | ~maskval) >>> 0;\n    }\n    if (endVal <= networkNum || endVal >= broadcastNum) {\n      ipControl.setErrors({\n        maxNetworkBroadcast: true\n      });\n      maskControl.setErrors({\n        maxNetworkBroadcast: true\n      });\n      endControl.setErrors({\n        maxNetworkBroadcast: true\n      });\n    } else {\n      ipControl.setErrors(null);\n      maskControl.setErrors(null);\n      endControl.setErrors(null);\n    }\n  };\n}\n// custom validator to check that Beginning IP Address should not be the same as Subnet ID or Broadcast Address\nexport function validateIpIsMinNetwork(IpName, startName, maskName) {\n  return formGroup => {\n    const ipControl = formGroup.controls[IpName];\n    const maskControl = formGroup.controls[startName];\n    const startControl = formGroup.controls[maskName];\n    // return null if controls haven't initialised yet\n    if (!ipControl || !maskControl || !startControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (ipControl.errors && !ipControl.errors.minNetworkBroadcast || maskControl.errors && !maskControl.errors.minNetworkBroadcast || startControl.errors && !startControl.errors.minNetworkBroadcast) {\n      return null;\n    }\n    var ipval = null;\n    var maskval = null;\n    var startVal = null;\n    var networkNum = null;\n    var broadcastNum = null;\n    if (ipControl.value && maskControl.value && startControl.value) {\n      ipval = convertIpAddressToNumber(ipControl.value);\n      maskval = convertIpAddressToNumber(maskControl.value);\n      startVal = convertIpAddressToNumber(startControl.value);\n      networkNum = (ipval >>> 0 & maskval >>> 0) >>> 0;\n      broadcastNum = (networkNum | ~maskval) >>> 0;\n    }\n    if (startVal <= networkNum || startVal >= broadcastNum) {\n      ipControl.setErrors({\n        minNetworkBroadcast: true\n      });\n      maskControl.setErrors({\n        minNetworkBroadcast: true\n      });\n      startControl.setErrors({\n        minNetworkBroadcast: true\n      });\n    } else {\n      ipControl.setErrors(null);\n      maskControl.setErrors(null);\n      startControl.setErrors(null);\n    }\n  };\n}\n// custom validator to check that Beginning IP Address should not be the same as Subnet ID or Broadcast Address\nexport function validateDigitCheck(smallDigitName, longDigitName) {\n  return formGroup => {\n    const smallDigitControl = formGroup.controls[smallDigitName];\n    const logDigitControl = formGroup.controls[longDigitName];\n    // return null if controls haven't initialised yet\n    if (!smallDigitControl || !logDigitControl) {\n      return null;\n    }\n    // return null if another validator has already found an error on the matchingControl\n    if (logDigitControl.errors && !logDigitControl.errors.longDigitTimer) {\n      return null;\n    }\n    if (smallDigitControl.value && logDigitControl.value) {\n      if (smallDigitControl.value > logDigitControl.value || smallDigitControl.value == logDigitControl.value) {\n        logDigitControl.setErrors({\n          longDigitTimer: true\n        });\n      } else {\n        logDigitControl.setErrors(null);\n      }\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}