{"ast":null,"code":"'use strict';\n\nvar domClasses = require('min-dom').classes,\n  domify = require('min-dom').domify,\n  domQuery = require('min-dom').query;\nvar assign = require('min-dash').assign,\n  find = require('min-dash').find,\n  forEach = require('min-dash').forEach,\n  debounce = require('min-dash').debounce;\nvar escapeHTML = require('../Utils').escapeHTML;\nvar entryFieldDescription = require('./EntryFieldDescription');\nvar CLASS_ACTIVE = 'active';\nvar FOCUS_LEAVE_DELAY = '150';\nvar TEXT_NODE_NAME = '#text';\nvar SUGGESTION_LIST_BOX_THRESHOLD = 15;\nvar noop = function () {};\nvar autoSuggestTextBox = function (translate, options, defaultParameters) {\n  var resource = defaultParameters,\n    label = options.label || resource.id,\n    canBeShown = !!options.show && typeof options.show === 'function',\n    description = options.description;\n  resource.html = domify('<label ' + 'for=\"camunda-' + escapeHTML(resource.id) + '\" ' + (canBeShown ? 'data-show=\"isShown\"' : '') + '>' + label + '</label>' + '<div class=\"bpp-field-wrapper\" ' + (canBeShown ? 'data-show=\"isShown\"' : '') + '>' + '<div ' + 'contenteditable=\"true\"' + 'id=\"camunda-' + escapeHTML(resource.id) + '\" ' + 'name=\"' + escapeHTML(options.modelProperty) + '\" ' + 'data-auto-suggest=\"suggestItems\"' + 'data-blur=\"handleFocusLeave\"' + '></div>' + '<div class=\"bpp-autosuggest-list\"></div>' + '</div>');\n  if (description) {\n    domQuery('.bpp-field-wrapper', resource.html).appendChild(entryFieldDescription(translate, description));\n  }\n  if (canBeShown) {\n    resource.isShown = function () {\n      return options.show.apply(resource, arguments);\n    };\n  }\n\n  /**\n   * Ensure selected item got recognized before list got hidden\n   */\n  resource.handleFocusLeave = debounce(function (element, entryNode) {\n    clearSuggestionList(entryNode);\n    hideSuggestionList(entryNode);\n  }, FOCUS_LEAVE_DELAY);\n\n  /**\n   * Fill the suggestion list relative to the current word under the cursor.\n   *\n   * @param {djs.model.Base} element\n   * @param {HTMLElement} entryNode\n   * @param {Event} event\n   */\n  resource.suggestItems = function (element, entryNode, event) {\n    var editorNode = event.delegateTarget,\n      range = getSelectionRange(),\n      focusNode = range.focusNode,\n      caretPosition = getCaretPosition(range.range),\n      canSuggest = options.canSuggest || noop,\n      getItems = options.getItems;\n    function updateSuggestionList(items) {\n      var listNode = domQuery('.bpp-autosuggest-list', entryNode);\n\n      // (1) clear list before\n      clearSuggestionList(entryNode);\n\n      // (2) keep list invisible if no items\n      if (!items.length) {\n        return;\n      }\n      domClasses(listNode).add(CLASS_ACTIVE);\n\n      // (3) create new items\n      forEach(items, function (item) {\n        createSuggestionItem(listNode, item);\n      });\n\n      // (4) place list relative to cursor\n      var position = getSuggestionListPosition(listNode, document.body).position;\n      setPosition(listNode, position.x, position.y);\n    }\n    function createSuggestionItem(parentNode, value) {\n      var itemNode = domify('<div class=\"bpp-autosuggest-item\"></div>');\n      itemNode.innerText = escapeHTML(value);\n      parentNode.appendChild(itemNode);\n      itemNode.addEventListener('click', handleItemClick);\n    }\n    function handleItemClick(event) {\n      var value = event.target.innerText,\n        wordIndex = currentWord.index,\n        start = wordIndex,\n        end = wordIndex + currentWord[0].length;\n      selectRange(focusNode, start, end);\n      document.execCommand('insertText', false, value);\n      clearSuggestionList(entryNode);\n      hideSuggestionList(entryNode);\n    }\n    hideSuggestionList(entryNode);\n    var currentWord = getWordUnderCursor(focusNode, caretPosition) || [];\n    if (currentWord && canSuggest(currentWord, editorNode, focusNode)) {\n      var items = getItems(element, entryNode),\n        results = [],\n        value = currentWord[0];\n\n      // sort matches by\n      // (1) item starts with value (case insensitive)\n      // (2) value is inside suggested item (case insensitive)\n      forEach(items, function (item) {\n        var itemLowerCase = item.toLowerCase(),\n          valueLowerCase = value && value.toLowerCase();\n        if (itemLowerCase.indexOf(valueLowerCase) === 0) {\n          results.push(item);\n        }\n      });\n      forEach(items, function (item) {\n        var itemLowerCase = item.toLowerCase(item),\n          valueLowerCase = value && value.toLowerCase();\n        if (itemLowerCase.indexOf(valueLowerCase) >= 1) {\n          results.push(item);\n        }\n      });\n      updateSuggestionList(results);\n    }\n  };\n\n  /**\n  * Calculates the position coordinates of the suggestion list,\n  * dependant on position of cursor\n  *\n  * @return {Object} coordinates\n  */\n  function getSuggestionListPosition(listNode, container) {\n    var range = getSelectionRange().range,\n      cursorBounds = range.getBoundingClientRect(),\n      clientBounds = container.getBoundingClientRect(),\n      listBounds = listNode.getBoundingClientRect();\n    var coordinates = {\n      'top-left': {\n        x: cursorBounds.right - listBounds.width,\n        y: cursorBounds.top - listBounds.height\n      },\n      'top-right': {\n        x: cursorBounds.right,\n        y: cursorBounds.top - listBounds.height\n      },\n      'bottom-left': {\n        x: cursorBounds.right - listBounds.width,\n        y: cursorBounds.top + SUGGESTION_LIST_BOX_THRESHOLD\n      },\n      'bottom-right': {\n        x: cursorBounds.right,\n        y: cursorBounds.top + SUGGESTION_LIST_BOX_THRESHOLD\n      }\n    };\n    var orientation = '';\n    if (cursorBounds.top + SUGGESTION_LIST_BOX_THRESHOLD + listBounds.height > clientBounds.height + clientBounds.top) {\n      orientation = 'top-';\n    } else {\n      orientation = 'bottom-';\n    }\n    if (cursorBounds.right + listBounds.width > clientBounds.width + clientBounds.left) {\n      orientation += 'left';\n    } else {\n      orientation += 'right';\n    }\n    return {\n      orientation: orientation,\n      position: coordinates[orientation]\n    };\n  }\n  resource.getSuggestionListPosition = getSuggestionListPosition;\n  resource.cssClasses = ['bpp-autosuggest-textbox'];\n  return resource;\n};\nmodule.exports = autoSuggestTextBox;\n\n// helpers /////////////////////////////\n\nfunction getSelectionRange() {\n  var selection = document.getSelection();\n  return {\n    range: selection.getRangeAt(0),\n    focusNode: selection.focusNode\n  };\n}\nfunction getCaretPosition(range) {\n  return range.startOffset;\n}\nfunction selectRange(focusNode, start, end) {\n  var range = document.createRange(),\n    selection = window.getSelection();\n  range.setStart(focusNode, start);\n  range.setEnd(focusNode, end);\n  selection.removeAllRanges();\n  selection.addRange(range);\n}\nfunction hideSuggestionList(entryNode) {\n  var listNode = domQuery('.bpp-autosuggest-list', entryNode);\n  domClasses(listNode).remove(CLASS_ACTIVE);\n}\nfunction clearSuggestionList(entryNode) {\n  var listNode = domQuery('.bpp-autosuggest-list', entryNode);\n  while (listNode.firstChild) {\n    listNode.removeChild(listNode.firstChild);\n  }\n}\nfunction getWordUnderCursor(node, currentCursorPositon) {\n  var value = node.nodeName === TEXT_NODE_NAME ? node.wholeText : node.innerText,\n    allWords = findWords(value);\n  return find(allWords, function (word) {\n    var matchValue = word[0],\n      wordStart = word.index,\n      wordEnd = wordStart + matchValue.length - 1;\n    return wordStart <= currentCursorPositon - 1 && wordEnd >= currentCursorPositon - 1;\n  });\n}\n\n/**\n * Retrieves all words inside a text (also inside clauses and after operators)\n *\n * @param {string} value\n *\n * @return {Array<Object>}\n */\nfunction findWords(value) {\n  // eslint-disable-next-line no-useless-escape\n  return matchAll(value, /[^\\s\\r\\(\\)\\,\\+\\-\\*\\/\\{\\}]+/g);\n}\nfunction matchAll(value, regex) {\n  var regexp = RegExp(regex),\n    match,\n    matches = [];\n  while ((match = regexp.exec(value)) !== null) {\n    matches.push(match);\n  }\n  return matches;\n}\nfunction setPosition(el, x, y) {\n  assign(el.style, {\n    left: x + 'px',\n    top: y + 'px'\n  });\n}","map":null,"metadata":{},"sourceType":"script"}