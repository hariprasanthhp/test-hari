{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IPMask = exports.IPSubnetwork = exports.IPRange = exports.partsToIP = exports.getIP = exports.IPv6 = exports.IPv4 = exports.IPMatch = exports.getMatch = void 0;\nconst IP4_REGEX = /^(\\d{1,3}\\.|\\*\\.){3}(\\d{1,3}|\\*)$/;\n// https://regexr.com/5e5i7\nconst IP6_REGEX = /^((([a-f\\d]{1,4}|\\*)::?)+([a-f\\d]{1,4}|\\*)|:(:[a-f\\d]{1,4}|:\\*)+|([a-f\\d]{1,4}:|\\*:)+:|::)$/i;\nconst IP6_MIXED_REGEX = /(.*):((?:\\d{1,3}\\.|\\*\\.){3}(\\d{1,3}|\\*))$/;\nfunction wildcardToNumber(max, radix = 10) {\n  return input => {\n    if (input === '*') return -1;\n    const n = parseInt(input, radix);\n    if (n < 0 || n > max) {\n      throw new Error(`Value has to be in the range of 0-${max}`);\n    }\n    return n;\n  };\n}\n/** `toBits(0b0010110101, 10)` would give `[0, 0, 1, 0, 1, 1, 0, 1, 0, 1]` */\nfunction toBits(value, bits) {\n  const result = [];\n  while (bits--) {\n    result[bits] = value >> bits & 1;\n  }\n  return result.reverse();\n}\n/** `fromBits([0, 0, 1, 0, 1, 1, 0, 1, 0, 1])` would give `0b0010110101` */\nfunction fromBits(bits) {\n  return bits.reduce((prev, bit) => {\n    if (bit !== 0 && bit !== 1) throw new Error(`Expected 0 or 1 as bit but got '${bit}' instead`);\n    return prev << 1 | bit;\n  });\n}\n/**\n * Converts a string to an IPMatch object. This correspondends either to\n * an IPv4, IPv4, IPRange or IPSubnetwork object, all extending the IPMatch class.\n * For ease-of-use, if the given input is an IPMatch object, that object itself is returned.\n * @param input - The input string to convert, or IPMatch object to return.\n * @returns Returns an IPMatch for the given string (or returns the given IPMatch itself)\n */\nfunction getMatch(input) {\n  if (input instanceof IPMatch) return input;\n  let ip = getIP(`${input}`);\n  if (ip) return ip;\n  // Check if it's a range, aka `IP1-IP2` with IP1 and IP2 being both a IPv4 or both a IPv6.\n  let split = input.split('-');\n  if (split.length !== 1) {\n    if (split.length !== 2) throw new Error('A range looks like \\'IP-IP\\'');\n    const l = getIP(split[0]);\n    if (!l || !l.exact()) throw new Error('Left side of the IP range isn\\'t a valid (exact) IP');\n    const r = getIP(split[1]);\n    if (!r || !r.exact()) throw new Error('Right side of the IP range isn\\'t a valid (exact) IP');\n    if (l.type !== r.type) throw new Error('Expected same type of IP on both sides of range');\n    return new IPRange(l, r);\n  }\n  // Check if it's a subnetwork, aka 'IP/mask' with IP being an IPv4/IPv6 and mask being a number.\n  // The IPSubnetwork constructor will check if the mask is within range (1-32 for IPv4, 1-128 for IPv6)\n  split = input.split('/');\n  if (split.length !== 1) {\n    ip = getIP(split[0]);\n    if (!ip || !ip.exact()) throw new Error('Expected a valid (exact) IP for a subnetwork');\n    const bits = Number(split[1]);\n    if (Number.isInteger(bits)) return new IPSubnetwork(ip, bits);\n    const mask = getIP(split[1]);\n    if (mask) return new IPMask(ip, mask);\n    throw new Error('A subnetwork or mask looks like \\'IP/bits\\' or \\'IP/mask\\' e.g. \\'::1/64\\' or \\'::1/aa::\\'');\n  }\n  throw new Error('Invalid IP (range/subnetwork)');\n}\nexports.getMatch = getMatch;\n/** @internal Utility function to create cached functions */\nfunction createCached(symbol, func) {\n  return value => {\n    if (symbol in value) return value[symbol];\n    return value[symbol] = func(value);\n  };\n}\n/** @internal Symbol to cache `convertToMasks` calls */\nconst SYM_CTMasks = Symbol('convertToMasks');\n/** @internal Creates a wrapper around the given converter function to cache results */\nfunction createCachedConvertToMasks(converter) {\n  const cached = createCached(SYM_CTMasks, converter);\n  // Doing it this way so that even though the underlying array is only calculated once, we\n  // return a copy of it every invocation, so the user can freely modify the resulting array\n  return obj => [...cached(obj)];\n}\n/** @internal Symbol to cache `convertToSubnet` calls */\nconst SYM_CTSubnet = Symbol('convertToSubnet');\n/** @internal Symbol to cache `convertToSubnets` calls */\nconst SYM_CTSubnets = Symbol('convertToSubnets');\n/**\n * Superclass of the IPv4, IPv6, IPRange and IPSubnetwork classes.\n * Only specifies a generic .matches() function and .type field.\n *\n * **Check the specific classes for more specialized methods/docs**\n * e.g. IPRange comes with `convertToSubnets`, IPv6 with `toLongString`, ...\n */\nclass IPMatch {\n  /**\n   * This used to be the generic way of converting a string to an IPRange/IPv4/... without assuming a type.\n   * This class is now made abstract with a protected constructor, in favor of the new `getMatch(input)` function.\n   * The abstract/deprecated/protected flag are to warn users about switching over to the new function.\n   * With the way TypeScript compiles them to JavaScript, this constructor still works (thus compatible with old code)\n   * @deprecated Use `getMatch(input: string)` instead.\n   */\n  constructor(input) {\n    if (input == null) return this;\n    return getMatch(input);\n  }\n}\nexports.IPMatch = IPMatch;\n/** Represents an IPv4 address, optionall with wildcards */\nclass IPv4 extends IPMatch {\n  constructor(input) {\n    super(null);\n    this.type = 'IPv4';\n    /** Field present on both IPv4 and IPv6 addresses indicating how many bits an address of that type has */\n    this.bits = IPv4.bits;\n    this.input = input.trim();\n    const ip = input.match(IP4_REGEX);\n    if (!ip) throw new Error('Invalid input for IPv4');\n    this.parts = input.split('.').map(wildcardToNumber(255));\n  }\n  /**\n   * Checks whether the given IP (or string to be first converted to an IP) matches this IPv4 object.\n   * - If the given string represents an IPv6 address, this method returns false.\n   * - In other cases, for an IPv4, we check if all 4 octets match.\n   * - Octets that are wildcards in this object are always assumed to match.\n   * - Octets that are wildcards in the input are **NOT** seen as a wildcard, e.g.\n   *    `10.0.0.*` matches `10.0.0.3`, but the inverse would give false.\n   */\n  matches(ip) {\n    let real;\n    if (!(ip instanceof IPv4 || ip instanceof IPv6)) {\n      real = getIP(ip);\n    } else {\n      real = ip;\n    }\n    if (!real) throw new Error('The given value is not a valid IP');\n    if (!(real instanceof IPv4)) return false;\n    for (let i = 0; i < 4; i += 1) {\n      const given = real.parts[i];\n      const wanted = this.parts[i];\n      if (wanted !== -1 && given !== wanted) return false;\n    }\n    return true;\n  }\n  equals(match) {\n    return match instanceof IPv4 && match.parts.every((v, i) => this.parts[i] === v);\n  }\n  /** Returns whether this IPv4 is exact (aka contains no wildcards) */\n  exact() {\n    return !this.parts.includes(-1);\n  }\n  /**\n   * Returns this IPv4 in dot-decimal/quat-dotted notation. Wildcards are represented as stars.\n   * For example: `\"10.*.0.*\"`\n   */\n  toString() {\n    return this.parts.map(v => v === -1 ? '*' : v).join('.');\n  }\n  convertToMasks() {\n    return IPv4.convertToMasks(this);\n  }\n  getAmount() {\n    return this.parts.reduce((t, p) => p === -1 ? t * 256 : t, 1);\n  }\n  /**\n   * Returns the previous address, or undefined for `0.0.0.0`.\n   * In case of a non-exact IP, the wildcard parts are ignored.\n   * E.g. getPrevious for `10.0.*.0` returns `9.255.*.255`\n   */\n  getPrevious() {\n    const newParts = [...this.parts];\n    for (let i = newParts.length - 1; i >= 0; i--) {\n      if (newParts[i] === 0) {\n        newParts[i] = 255;\n      } else if (newParts[i] !== -1) {\n        newParts[i]--;\n        return partsToIP(newParts);\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Returns the next address, or undefined for `255.255.255.255`.\n   * In case of a non-exact IP, the wildcard parts are ignored.\n   * E.g. getNext for `10.0.*.255` returns `10.1.*.0`\n   */\n  getNext() {\n    const newParts = [...this.parts];\n    for (let i = newParts.length - 1; i >= 0; i--) {\n      if (newParts[i] === 255) {\n        newParts[i] = 0;\n      } else if (newParts[i] !== -1) {\n        newParts[i]++;\n        return partsToIP(newParts);\n      }\n    }\n    return undefined;\n  }\n  /** Converts this IP to an array of bits, e.g. `[1, 1, 0, 0, 0, ...]` for `192.0.0.0`. */\n  toBits() {\n    return this.parts.reduce((bits, part) => [...bits, ...toBits(part, 8)], []);\n  }\n  /** Converts an array of 32 bits to an IPv4, e.g. `192.0.0.0` for `[1, 1, 0, 0, 0, ...]` */\n  static fromBits(bits) {\n    if (bits.length !== 32) throw new Error('Expected 32 bits for IPv4.fromBits');\n    return partsToIP([fromBits(bits.slice(0, 8)), fromBits(bits.slice(8, 16)), fromBits(bits.slice(16, 24)), fromBits(bits.slice(24, 32))]);\n  }\n}\nexports.IPv4 = IPv4;\n/** @internal */\nIPv4.convertToMasks = createCachedConvertToMasks(ip => {\n  if (ip.exact()) return [new IPMask(ip, partsToIP(ip.parts.map(() => 255)))];\n  const lower = partsToIP(ip.parts.map(v => v === -1 ? 0 : v));\n  return [new IPMask(lower, partsToIP(ip.parts.map(v => v === -1 ? 0 : 255)))];\n});\n/** Field present on both IPv4 and IPv6 indicating how many bits an address of that type has */\nIPv4.bits = 32;\nconst IP6_WTN = wildcardToNumber(0xFFFF, 16);\nfunction shortenIPv6(address) {\n  if (typeof address === 'string') address = new IPv6(address);\n  if (address instanceof IPv6) address = address.toHextets();\n  const score = [0, 0, 0, 0, 0, 0, 0, 0];\n  const {\n    length\n  } = address;\n  for (let i = 0; i < length; i += 1) {\n    for (let j = i; j < length; j += 1) {\n      if (address[j] === '0') score[i] += 1;else break;\n    }\n  }\n  const best = score.reduce((prev, s, key) => s > score[prev] ? key : prev, 0);\n  if (score[best]) {\n    address.splice(best, score[best] - 1);\n    address[best] = '';\n  }\n  // '::' results in address being ['']\n  if (address.length === 1 && !address[0]) return '::';\n  return address.join(':').replace(/(^:|:$)/, '::');\n}\n/** Lazy wait-until-all-classes-are-available loading the ranges for mixed IPv6 formats, e.g. '::ffff:10.0.0.1' */\nlet MIXED_ADDRESS_RANGES = () => (MIXED_ADDRESS_RANGES = () => [getMatch('::ffff:*:*'), getMatch('::ffff:0:*:*') // https://tools.ietf.org/html/draft-ietf-behave-translator-addressing-00#section-3.2.2\n// Also ::*:* but got deprecated, and would also conflict with e.g. ::1\n])();\n/** Represents an IPv6 address, optionall with wildcards */\nclass IPv6 extends IPMatch {\n  constructor(input) {\n    super(null);\n    this.type = 'IPv6';\n    /** Field present on both IPv4 and IPv6 addresses indicating how many bits an address of that type has */\n    this.bits = IPv6.bits;\n    this.input = input = input.trim();\n    const mixed = input.match(IP6_MIXED_REGEX);\n    if (mixed) {\n      if (mixed[2].includes('*')) throw new Error('Mixed IPv6 address cannot contain wildcards in IPv4 part');\n      const {\n        parts: ipv4\n      } = new IPv4(mixed[2]);\n      this.parts = [...new IPv6(`${mixed[1]}:0:0`).parts.slice(0, 6), (ipv4[0] << 8) + ipv4[1], (ipv4[2] << 8) + ipv4[3]];\n      return;\n    }\n    if (!IP6_REGEX.test(input) && !IP6_MIXED_REGEX.test(input)) throw new Error('Invalid input for IPv6');\n    const sides = input.split('::');\n    if (sides.length > 2) throw new Error('IPv6 addresses can only contain :: once');\n    if (sides.length === 1) {\n      this.parts = sides[0].split(':').map(IP6_WTN);\n    } else {\n      const l = sides[0] ? sides[0].split(':') : [];\n      const r = sides[1] ? sides[1].split(':') : [];\n      const t = 8 - l.length - r.length;\n      if (t === 0) throw new Error('This IPv6 address doesn\\'t need a ::');\n      if (t < 1) throw new Error('Invalid amount of :');\n      for (let i = 0; i < t; i += 1) l.push('0');\n      this.parts = l.concat(r).map(IP6_WTN);\n    }\n  }\n  /**\n   * Checks whether the given IP (or string to be first converted to an IP) matches this IPv6 object.\n   * - If the given string represents an IPv4 address, this method returns false.\n   * - In other cases, for an IPv6, we check if all 8 hextets/hexadectets match.\n   * - Octets that are wildcards in this object are always assumed to match.\n   * - Octets that are wildcards in the input are **NOT** seen as a wildcard, e.g.\n   *    `2001::abcd:*` matches `2001::abcd:1`, but the inverse would give false.\n   */\n  matches(ip) {\n    let real;\n    if (!(ip instanceof IPv4 || ip instanceof IPv6)) {\n      real = getIP(ip);\n    } else {\n      real = ip;\n    }\n    if (!real) throw new Error('The given value is not a valid IP');\n    if (!(real instanceof IPv6)) return false;\n    for (let i = 0; i < 8; i += 1) {\n      const given = real.parts[i];\n      const wanted = this.parts[i];\n      if (wanted !== -1 && given !== wanted) return false;\n    }\n    return true;\n  }\n  equals(match) {\n    return match instanceof IPv6 && match.parts.every((v, i) => this.parts[i] === v);\n  }\n  /** Returns whether this IPv4 is exact (aka contains no wildcards) */\n  exact() {\n    return !this.parts.includes(-1);\n  }\n  /** Returns an array with the 8 hextets of this address, or `\"*\"` for wildcard hextets */\n  toHextets() {\n    return this.parts.map(v => v === -1 ? '*' : v.toString(16));\n  }\n  /**\n   * Returns the address in the full format, but with leading zeroes of hextets omitted.\n   * Hextets representing wildcards will be shown as `\"*\"` instead.\n   * Example result: `\"2001:0:0:0:0:0:abc:1\"`\n   */\n  toLongString() {\n    return this.toHextets().join(':');\n  }\n  /**\n   * Returns the address in the full format, but without omitting leading zeroes or hextets.\n   * Hextets representing wildcards will be shown as `\"*\"` instead.\n   * Example result: `\"2001:0000:0000:0000:0000:0000:0abc:0001\"`\n   */\n  toFullString() {\n    return this.toHextets().map(v => v !== '*' && v.length < 4 ? `${'0'.repeat(4 - v.length)}${v}` : v).join(':');\n  }\n  /** Returns a mixed address (32 last bits representing an IPv4 address) in a mixed format e.g. \"::ffff:c000:0280\" as \"::ffff:192.0.2.128\" */\n  toMixedString() {\n    const {\n      parts\n    } = this;\n    // Prepare the first part\n    const hextets = parts.slice(0, 6).map(v => v === -1 ? '*' : v.toString(16));\n    let shorten = shortenIPv6(hextets);\n    if (shorten.endsWith('::')) shorten = shorten.substring(0, shorten.length - 1);\n    // Prepare the second part\n    const ipv4 = [parts[6] >> 8, parts[6] & 0xFF, parts[7] >> 8, parts[7] & 0xFF];\n    if (parts[6] === -1) ipv4[0] = ipv4[1] = '*';\n    if (parts[7] === -1) ipv4[2] = ipv4[3] = '*';\n    // And slap them together\n    return `${shorten}:${ipv4.join('.')}`;\n  }\n  /**\n   * Returns the address in the shortest possible format, according to RFC 5952:\n   * - All hexadecimal digits are lowercase (if applicable), as is the case with .toLongString(), toFullString(), ...\n   * - Leading zeroes of each hextet are suppressed, apart from the all-zero field which is rendered as a single zero\n   * - The (leftmost) longest sequence of multiple consecutive all-zero hextets is replaced with \"::\"\n   * - If this address is known to be IPv4 mapped, it is displayed as such, which currently are for e.g. 127.0.0.1:\n   *    - `\"::ffff:127.0.0.1\"`\n   *    - `\"::ffff:0:127.0.0.1\"`\n   */\n  toString() {\n    if (MIXED_ADDRESS_RANGES().some(m => m.matches(this))) return this.toMixedString();\n    return shortenIPv6(this.toHextets());\n  }\n  convertToMasks() {\n    return IPv6.convertToMasks(this);\n  }\n  getAmount() {\n    return this.parts.reduce((t, p) => p === -1 ? t * 0x10000 : t, 1);\n  }\n  /**\n   * Returns the previous address, or undefined for `::`.\n   * In case of a non-exact IP, the wildcard parts are ignored.\n   * E.g. getPrevious for `::5:*:0` returns `::4:*:ffff`\n   */\n  getPrevious() {\n    const newParts = [...this.parts];\n    for (let i = newParts.length - 1; i >= 0; i--) {\n      if (newParts[i] === 0) {\n        newParts[i] = 0xFFFF;\n      } else if (newParts[i] !== -1) {\n        newParts[i]--;\n        return partsToIP(newParts);\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Returns the next address, or undefined for `ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`.\n   * In case of a non-exact IP, the wildcard parts are ignored.\n   * E.g. getNext for `::0:*:ffff` returns `::1:*:0`\n   */\n  getNext() {\n    const newParts = [...this.parts];\n    for (let i = newParts.length - 1; i >= 0; i--) {\n      if (newParts[i] === 0xFFFF) {\n        newParts[i] = 0;\n      } else if (newParts[i] !== -1) {\n        newParts[i]++;\n        return partsToIP(newParts);\n      }\n    }\n    return undefined;\n  }\n  /** Converts this IP to an array of bits, e.g. `[1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, ...]` for `f8::`. */\n  toBits() {\n    return this.parts.reduce((bits, part) => [...bits, ...toBits(part, 16)], []);\n  }\n  /** Converts an array of 128 bits to an IPv6, e.g. `f8::` for `[1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, ...]` */\n  static fromBits(bits) {\n    if (bits.length !== 128) throw new Error('Expected 128 bits for IPv6.fromBits');\n    const parts = [];\n    for (let i = 0; i < 8; i++) parts[i] = fromBits(bits.slice(i * 16, (i + 1) * 16));\n    return partsToIP(parts);\n  }\n}\nexports.IPv6 = IPv6;\n/** @internal */\nIPv6.convertToMasks = createCachedConvertToMasks(ip => {\n  if (ip.exact()) return [new IPMask(ip, partsToIP(ip.parts.map(() => 0xffff)))];\n  const lower = partsToIP(ip.parts.map(v => v === -1 ? 0 : v));\n  return [new IPMask(lower, partsToIP(ip.parts.map(v => v === -1 ? 0 : 0xffff)))];\n});\n/** Field present on both IPv4 and IPv6 indicating how many bits an address of that type has */\nIPv6.bits = 128;\n/**\n * Tries to convert the given input string to an IP, aka an IPv4 or IPv6 object.\n * For ease-of-use, if the input is already an IPv4 or IPv6, it is returned.\n * @throws Errors if the given input format matches an IPv4/IPv6 address well enough, but is still invalid.\n */\nfunction getIP(input) {\n  if (input instanceof IPv4 || input instanceof IPv6) return input;\n  input = input.trim();\n  if (IP4_REGEX.test(input)) return new IPv4(input);\n  if (IP6_REGEX.test(input) || IP6_MIXED_REGEX.test(input)) return new IPv6(input);\n  return null;\n}\nexports.getIP = getIP;\n/** @internal */\nfunction partsToIP(parts) {\n  if (parts.length !== 4 && parts.length !== 8) throw new Error(`Expected 4 or 8 parts, got ${parts.length} instead`);\n  const ip = parts.length === 4 ? new IPv4('0.0.0.0') : new IPv6('::');\n  Object.assign(ip, {\n    parts\n  });\n  ip.input = ip.toString();\n  return ip;\n}\nexports.partsToIP = partsToIP;\n/** Represents a range of IP addresses, according to their numerical value */\nclass IPRange extends IPMatch {\n  /** Both values should be the same type (IPv4 or IPv6) and `left` should be lower in numeric value than `right` */\n  constructor(left, right) {\n    super(null);\n    this.left = left;\n    this.right = right;\n    this.type = 'IPRange';\n    if (left.type !== right.type) throw new Error('Expected same type of IP on both sides of range');\n    if (!this.isLowerOrEqual(left, right)) throw new Error('Left side of range should be lower than right side');\n    this.input = left + '-' + right;\n  }\n  /** Checks whether the given IP lies in the range defined by the two bounds (inclusive) */\n  matches(ip) {\n    let real;\n    if (!(ip instanceof IPv4 || ip instanceof IPv6)) {\n      real = getIP(ip);\n    } else {\n      real = ip;\n    }\n    if (!real) throw new Error('The given value is not a valid IP');\n    // While we originally threw an error here, this seems counter-intuitive and is unlike all other implementations\n    if (real.type !== this.left.type) return false;\n    return this.isLowerOrEqual(this.left, real) && this.isLowerOrEqual(real, this.right);\n  }\n  equals(match) {\n    return match instanceof IPRange && match.left.equals(this.left) && match.right.equals(this.right);\n  }\n  /** Converts this IPRange to a string, by joining the two bounds with a dash, e.g. \"IP1-IP2\" */\n  toString() {\n    return this.input;\n  }\n  /** Converts this IPRange to an optimized list of (CIDR) IPSubnetworks */\n  convertToSubnets() {\n    return [...IPRange.convertToSubnets(this)];\n  }\n  convertToMasks() {\n    return IPRange.convertToMasks(this);\n  }\n  getAmount() {\n    const lParts = this.left.parts;\n    const rParts = [...this.right.parts];\n    const maxPart = 2 ** (this.left.bits / lParts.length);\n    for (let i = 0; i < rParts.length; i++) {\n      let v = rParts[i] - lParts[i];\n      if (v < 0) {\n        v += maxPart;\n        rParts[i - 1] -= 1;\n      }\n      rParts[i] = v;\n    }\n    return rParts.reduce((t, s) => t * maxPart + s, 0) + 1;\n  }\n  /** Returns the first IP address in this range */\n  getFirst() {\n    return this.left;\n  }\n  /** Returns the last IP address in this range */\n  getLast() {\n    return this.right;\n  }\n  isLowerOrEqual(left, right) {\n    const l = left.parts;\n    const r = right.parts;\n    for (let i = 0; i < l.length; i += 1) {\n      const L = l[i];\n      const R = r[i];\n      if (L === R) continue;\n      if (L < R) return true;\n      if (L > R) return false;\n    }\n    return true;\n  }\n}\nexports.IPRange = IPRange;\n/** @internal */\nIPRange.convertToSubnets = createCached(SYM_CTSubnets, range => {\n  const result = [];\n  const {\n    left,\n    right\n  } = range;\n  const maxBits = left.bits;\n  const rBits = right.toBits();\n  let current = left;\n  while (current && range.isLowerOrEqual(current, right)) {\n    const cBits = current.toBits();\n    let hostBits = 0;\n    for (let i = cBits.length - 1; i >= 0; i--) if (cBits[i]) break;else hostBits++;\n    let maxHostBits = 0;\n    for (let i = 0; i < cBits.length; i++) {\n      if (cBits[i] === rBits[i]) maxHostBits++;else break;\n    }\n    maxHostBits = maxBits - maxHostBits;\n    let trailingOnes = 0;\n    for (let i = rBits.length - 1; i >= 0; i--) if (rBits[i]) trailingOnes++;else break;\n    if (trailingOnes < maxHostBits) maxHostBits--;\n    const prefixLength = maxBits - Math.min(hostBits, maxHostBits);\n    const subnet = new IPSubnetwork(current, prefixLength);\n    result.push(subnet);\n    current = subnet.getLast().getNext();\n  }\n  return result;\n});\n/** @internal */\nIPRange.convertToMasks = createCachedConvertToMasks(range => range.convertToSubnets().reduce((r, subnet) => [...r, ...subnet.convertToMasks()], []));\nfunction getLowerPart(part, bits, max) {\n  if (bits > max) bits = max;\n  return part & Math.pow(2, max) - Math.pow(2, max - bits);\n}\nfunction getUpperPart(part, bits, max) {\n  if (bits > max) bits = max;\n  return part | Math.pow(2, max - bits) - 1;\n}\n/** Represents a subnetwork. The combination of an IP and a (simple) mask. A simplified version of IPMask. */\nclass IPSubnetwork extends IPMatch {\n  /** Bits has to be in the range 0-32 for IPv4 and 0-128 for IPv6 */\n  constructor(ip, bits) {\n    super(null);\n    this.bits = bits;\n    this.type = 'IPSubnetwork';\n    if (bits < 0 || bits > ip.bits) {\n      throw new Error(`A ${ip.type} subnetwork's bits should be in the range of 1-${ip.bits}, got ${bits} instead`);\n    }\n    let lower = new ip.constructor(ip.input);\n    let upper = new ip.constructor(ip.input);\n    const bitsPerPart = ip.bits / ip.parts.length;\n    for (let i = 0; i < ip.parts.length; i += 1) {\n      lower.parts[i] = getLowerPart(ip.parts[i], bits, bitsPerPart);\n      upper.parts[i] = getUpperPart(lower.parts[i], bits, bitsPerPart);\n      bits = bits <= bitsPerPart ? 0 : bits - bitsPerPart;\n    }\n    lower = new ip.constructor(lower.toString());\n    upper = new ip.constructor(upper.toString());\n    this.range = new IPRange(lower, upper);\n    this.input = `${lower}/${this.bits}`;\n  }\n  /** Checks whether the given IP lies in this subnetwork */\n  matches(ip) {\n    return this.range.matches(ip);\n  }\n  equals(match) {\n    return match instanceof IPSubnetwork && match.range.equals(this.range);\n  }\n  /** Converts this IPSubnetwork to a string in CIDR representation, e.g. \"IP/mask\" */\n  toString() {\n    return this.input;\n  }\n  convertToMasks() {\n    return IPSubnetwork.convertToMasks(this);\n  }\n  getAmount() {\n    return 2 ** (this.range.left.bits - this.bits);\n  }\n  /** Returns the first IP address in this range */\n  getFirst() {\n    return this.range.left;\n  }\n  /** Returns the last IP address in this range */\n  getLast() {\n    return this.range.right;\n  }\n}\nexports.IPSubnetwork = IPSubnetwork;\n/** @internal */\nIPSubnetwork.convertToMasks = createCachedConvertToMasks(subnet => {\n  const {\n    left\n  } = subnet.range;\n  const parts = [];\n  const bitsPerPart = left.bits / left.parts.length;\n  const max_part = 2 ** bitsPerPart - 1;\n  let {\n    bits\n  } = subnet;\n  while (bits > 0) {\n    const adding = bits > bitsPerPart ? bitsPerPart : bits;\n    const neg = bitsPerPart - adding;\n    parts.push(max_part >> neg << neg);\n    bits = bits - adding;\n  }\n  for (let i = parts.length, max = left.parts.length; i < max; i++) parts[i] = 0;\n  return [new IPMask(subnet.range.left, partsToIP(parts))];\n});\n/** Represents an IP mask. The combination of an IP and a mask. A more complex version of IPSubnetwork. */\nclass IPMask extends IPMatch {\n  constructor(ip, mask) {\n    super(null);\n    this.ip = ip;\n    this.mask = mask;\n    this.type = 'IPMask';\n    if (!ip.exact()) throw new Error(`Base IP of the IPMask isn't a valid (exact) IP`);\n    if (!mask.exact()) throw new Error(`Mask IP of the IPMask isn't a valid (exact) IP`);\n    if (ip.type !== mask.type) throw new Error('Expected same type of IP as base IP and mask IP to construct the mask');\n    const lower = new ip.constructor(ip.input);\n    const maskParts = mask.parts;\n    lower.parts.forEach((p, i) => lower.parts[i] = p & maskParts[i]);\n    this.ip = lower;\n    this.input = `${lower}/${mask}`;\n  }\n  /** Checks whether the given IP matches this mask */\n  matches(ip) {\n    const real = getIP(ip);\n    if (!real) throw new Error('The given value is not a valid IP');\n    if (real.type !== this.ip.type) return false;\n    const {\n      ip: {\n        parts: ipParts\n      },\n      mask: {\n        parts: maskParts\n      }\n    } = this;\n    return real.parts.every((p, i) => (p & maskParts[i]) === ipParts[i]);\n  }\n  equals(match) {\n    return match instanceof IPMask && match.ip.equals(this.ip) && match.mask.equals(this.mask);\n  }\n  /**\n   * Converts this IPMask to a string, by joining the IP and mask with a slash, e.g. \"IP/mask\".\n   * Does simplify the IP and mask in their IP form, but does not simplify e.g. `10.0.0.0/255.0.0.0` to `10.0.0.0/8`.\n   */\n  toString() {\n    return this.input;\n  }\n  /**\n   * Tries to convert this IPMask to an IPSubnetwork. This only works if this mask is a \"proper\" subnet mask.\n   * In other words, the bits have to be sequential. `255.255.128.0` is valid, `255.255.63.0` is not.\n   * When this is not the case, `undefined` is returned instead.\n   */\n  convertToSubnet() {\n    return IPMask.convertToSubnet(this);\n  }\n  convertToMasks() {\n    return [this];\n  }\n  getAmount() {\n    return this.mask.toBits().reduce((p, b) => b ? p : p + p, 1);\n  }\n  /**\n   * Returns whether this mask is a subset of the given mask. In other words, all IP addresses matched\n   * by this mask should also be matched by the given mask, although the given mask can match others too.\n   * @throws Throws an error if the IP address types mismatch (e.g. this mask is for IPv4 but the given is IPv6)\n   */\n  isSubsetOf(mask) {\n    if (this.ip.type !== mask.ip.type) throw new Error('Expected same type of masks (e.g. all IPv4 or all IPv6)');\n    if (this.equals(mask)) return true;\n    if (this.getAmount() > mask.getAmount()) return false;\n    const iBitsA = this.ip.toBits();\n    const mBitsA = this.mask.toBits();\n    const iBitsB = mask.ip.toBits();\n    const mBitsB = mask.mask.toBits();\n    for (let i = 0; i < iBitsA.length; i++) {\n      if (!mBitsB[i]) continue; // mask B matches every bit\n      if (!mBitsA[i]) return false; // mask A matches every bit, mask B doesn't\n      if (iBitsA[i] !== iBitsB[i]) return false; // both masks expect different bits\n    }\n\n    return true;\n  }\n}\nexports.IPMask = IPMask;\n/** @internal */\nIPMask.convertToSubnet = createCached(SYM_CTSubnet, ({\n  ip,\n  mask\n}) => {\n  const bitsPerPart = ip.bits / ip.parts.length;\n  const maxPart = 2 ** bitsPerPart - 1;\n  let prefix = 0;\n  let partial = false;\n  for (const part of mask.parts) {\n    if (partial && part) {\n      return undefined;\n    } else if (part === maxPart) {\n      prefix += bitsPerPart;\n    } else if (part) {\n      for (let i = bitsPerPart - 1; i >= 0; i--) {\n        const b = part >> i & 1;\n        if (partial && b) {\n          return undefined;\n        } else if (b) {\n          prefix++;\n        } else {\n          partial = true;\n        }\n      }\n    } else {\n      partial = true;\n    }\n  }\n  return new IPSubnetwork(ip, prefix);\n});\n//# sourceMappingURL=ip.js.map","map":null,"metadata":{},"sourceType":"script"}