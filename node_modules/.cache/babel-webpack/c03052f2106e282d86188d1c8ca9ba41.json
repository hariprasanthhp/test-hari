{"ast":null,"code":"import { pick, assign } from 'min-dash';\nimport { resizeBounds, ensureConstraints, computeChildrenBBox, getMinResizeBounds } from './ResizeUtil';\nimport { asTRBL, getMid, roundBounds } from '../../layout/LayoutUtil';\nvar DEFAULT_MIN_WIDTH = 10;\n\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n */\nexport default function Resize(eventBus, rules, modeling, dragging) {\n  this._dragging = dragging;\n  this._rules = rules;\n  var self = this;\n\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n  function handleMove(context, delta) {\n    var shape = context.shape,\n      direction = context.direction,\n      resizeConstraints = context.resizeConstraints,\n      newBounds;\n    context.delta = delta;\n    newBounds = resizeBounds(shape, direction, delta);\n\n    // ensure constraints during resize\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints);\n\n    // update + cache executable state\n    context.canExecute = self.canResize(context);\n  }\n\n  /**\n   * Handle resize start.\n   *\n   * @param  {Object} context\n   */\n  function handleStart(context) {\n    var resizeConstraints = context.resizeConstraints,\n      // evaluate minBounds for backwards compatibility\n      minBounds = context.minBounds;\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n\n  /**\n   * Handle resize end.\n   *\n   * @param  {Object} context\n   */\n  function handleEnd(context) {\n    var shape = context.shape,\n      canExecute = context.canExecute,\n      newBounds = context.newBounds;\n    if (canExecute) {\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n      if (!boundsChanged(shape, newBounds)) {\n        // no resize necessary\n        return;\n      }\n\n      // perform the actual resize\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n  eventBus.on('resize.start', function (event) {\n    handleStart(event.context);\n  });\n  eventBus.on('resize.move', function (event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n    handleMove(event.context, delta);\n  });\n  eventBus.on('resize.end', function (event) {\n    handleEnd(event.context);\n  });\n}\nResize.prototype.canResize = function (context) {\n  var rules = this._rules;\n  var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);\n  return rules.allowed('shape.resize', ctx);\n};\n\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent} event\n * @param {djs.model.Shape} shape\n * @param {Object|string} contextOrDirection\n */\nResize.prototype.activate = function (event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n    context,\n    direction;\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n  context = assign({\n    shape: shape\n  }, contextOrDirection);\n  direction = context.direction;\n  if (!direction) {\n    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');\n  }\n  dragging.init(event, getReferencePoint(shape, direction), 'resize', {\n    autoActivate: true,\n    cursor: getCursor(direction),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\nResize.prototype.computeMinResizeBox = function (context) {\n  var shape = context.shape,\n    direction = context.direction,\n    minDimensions,\n    childrenBounds;\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  };\n\n  // get children bounds\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);\n\n  // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\nResize.$inject = ['eventBus', 'rules', 'modeling', 'dragging'];\n\n// helpers //////////\n\nfunction boundsChanged(shape, newBounds) {\n  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;\n}\nexport function getReferencePoint(shape, direction) {\n  var mid = getMid(shape),\n    trbl = asTRBL(shape);\n  var referencePoint = {\n    x: mid.x,\n    y: mid.y\n  };\n  if (direction.indexOf('n') !== -1) {\n    referencePoint.y = trbl.top;\n  } else if (direction.indexOf('s') !== -1) {\n    referencePoint.y = trbl.bottom;\n  }\n  if (direction.indexOf('e') !== -1) {\n    referencePoint.x = trbl.right;\n  } else if (direction.indexOf('w') !== -1) {\n    referencePoint.x = trbl.left;\n  }\n  return referencePoint;\n}\nfunction getCursor(direction) {\n  var prefix = 'resize-';\n  if (direction === 'n' || direction === 's') {\n    return prefix + 'ns';\n  } else if (direction === 'e' || direction === 'w') {\n    return prefix + 'ew';\n  } else if (direction === 'nw' || direction === 'se') {\n    return prefix + 'nwse';\n  } else {\n    return prefix + 'nesw';\n  }\n}","map":null,"metadata":{},"sourceType":"module"}