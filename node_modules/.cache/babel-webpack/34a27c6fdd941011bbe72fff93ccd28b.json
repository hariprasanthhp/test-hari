{"ast":null,"code":"import * as Highcharts from 'highcharts';\nimport { DatePipe } from '@angular/common';\nimport * as moment from 'moment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app-services/translate.service\";\nimport * as i2 from \"../../data.service\";\nimport * as i3 from \"../service/device.service\";\nimport * as i4 from \"src/app/shared/services/sso-auth.service\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"@ng-select/ng-select\";\nimport * as i7 from \"@angular/forms\";\nimport * as i8 from \"primeng/calendar\";\nimport * as i9 from \"@angular-slider/ngx-slider\";\nfunction EfficiencyComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵelementStart(1, \"span\", 16);\n    i0.ɵɵelement(2, \"img\", 17);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 18);\n    i0.ɵɵlistener(\"click\", function EfficiencyComponent_div_1_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.isDateAreEqual = false;\n    });\n    i0.ɵɵelement(5, \"span\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.language[\"Both Start Time And End Time areSame\"], \"\");\n  }\n}\nfunction EfficiencyComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 19);\n    i0.ɵɵelementStart(1, \"label\", 20);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"ng-select\", 21);\n    i0.ɵɵlistener(\"change\", function EfficiencyComponent_div_3_Template_ng_select_change_3_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.dropDownchange();\n    })(\"ngModelChange\", function EfficiencyComponent_div_3_Template_ng_select_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.TimeFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.language.TTimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"clearable\", false)(\"searchable\", false)(\"items\", ctx_r1.Frame)(\"ngModel\", ctx_r1.TimeFrame);\n  }\n}\nfunction EfficiencyComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 22);\n    i0.ɵɵelementStart(1, \"label\", 20);\n    i0.ɵɵtext(2, \"Day(s)\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"ng-select\", 21);\n    i0.ɵɵlistener(\"change\", function EfficiencyComponent_div_4_Template_ng_select_change_3_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.dropDownchange();\n    })(\"ngModelChange\", function EfficiencyComponent_div_4_Template_ng_select_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.WeekFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"clearable\", false)(\"searchable\", false)(\"items\", ctx_r2.WeekFramedata)(\"ngModel\", ctx_r2.WeekFrame);\n  }\n}\nconst _c0 = function () {\n  return {\n    width: \"100%\",\n    height: \"38px\"\n  };\n};\nconst _c1 = function () {\n  return {\n    height: \"36px\"\n  };\n};\nconst _c2 = function () {\n  return {\n    standalone: true\n  };\n};\nfunction EfficiencyComponent_div_5_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 30);\n    i0.ɵɵelementStart(1, \"label\");\n    i0.ɵɵtext(2, \"Date\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p-calendar\", 31);\n    i0.ɵɵlistener(\"ngModelChange\", function EfficiencyComponent_div_5_div_5_Template_p_calendar_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return ctx_r17.weekDate = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(7, _c0));\n    i0.ɵɵproperty(\"inputStyle\", i0.ɵɵpureFunction0(8, _c1))(\"autoZIndex\", true)(\"ngModel\", ctx_r14.weekDate)(\"showIcon\", true)(\"ngModelOptions\", i0.ɵɵpureFunction0(9, _c2));\n  }\n}\nfunction EfficiencyComponent_div_5_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 32);\n    i0.ɵɵelementStart(1, \"label\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p-calendar\", 33);\n    i0.ɵɵlistener(\"ngModelChange\", function EfficiencyComponent_div_5_div_6_Template_p_calendar_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.startDate = $event;\n    })(\"onSelect\", function EfficiencyComponent_div_5_div_6_Template_p_calendar_onSelect_3_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return ctx_r21.startTimeUpdate();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r15.language[\"Start Time\"], \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(11, _c0));\n    i0.ɵɵproperty(\"ngModel\", ctx_r15.startDate)(\"stepMinute\", ctx_r15.stepMinuteVal)(\"inputStyle\", i0.ɵɵpureFunction0(12, _c1))(\"autoZIndex\", true)(\"showIcon\", true)(\"ngModelOptions\", i0.ɵɵpureFunction0(13, _c2))(\"timeOnly\", ctx_r15.showHrs)(\"panelStyleClass\", !ctx_r15.isLastDay15minSelected ? \"hideMin\" : \"\");\n  }\n}\nfunction EfficiencyComponent_div_5_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 32);\n    i0.ɵɵelementStart(1, \"label\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p-calendar\", 34);\n    i0.ɵɵlistener(\"ngModelChange\", function EfficiencyComponent_div_5_div_7_Template_p_calendar_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.endDate = $event;\n    })(\"onSelect\", function EfficiencyComponent_div_5_div_7_Template_p_calendar_onSelect_3_listener() {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.endTimeUpdate();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r16.language[\"End Time\"], \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(12, _c0));\n    i0.ɵɵproperty(\"stepMinute\", ctx_r16.stepMinuteVal)(\"inputStyle\", i0.ɵɵpureFunction0(13, _c1))(\"autoZIndex\", true)(\"ngModel\", ctx_r16.endDate)(\"showIcon\", true)(\"ngModelOptions\", i0.ɵɵpureFunction0(14, _c2))(\"timeOnly\", ctx_r16.showHrs)(\"disabled\", ctx_r16.isEndDateDisabled)(\"panelStyleClass\", !ctx_r16.isLastDay15minSelected ? \"hideMin\" : \"\");\n  }\n}\nfunction EfficiencyComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 6);\n    i0.ɵɵelementStart(1, \"div\", 23);\n    i0.ɵɵelementStart(2, \"label\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"ng-select\", 24);\n    i0.ɵɵlistener(\"ngModelChange\", function EfficiencyComponent_div_5_Template_ng_select_ngModelChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.onTimeFrameChange($event);\n    })(\"ngModelChange\", function EfficiencyComponent_div_5_Template_ng_select_ngModelChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return ctx_r27.TimeFrame = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, EfficiencyComponent_div_5_div_5_Template, 4, 10, \"div\", 25);\n    i0.ɵɵtemplate(6, EfficiencyComponent_div_5_div_6_Template, 4, 14, \"div\", 26);\n    i0.ɵɵtemplate(7, EfficiencyComponent_div_5_div_7_Template, 4, 15, \"div\", 26);\n    i0.ɵɵelementStart(8, \"div\", 27);\n    i0.ɵɵelementStart(9, \"div\", 28);\n    i0.ɵɵelementStart(10, \"button\", 29);\n    i0.ɵɵlistener(\"click\", function EfficiencyComponent_div_5_Template_button_click_10_listener() {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return ctx_r28.loadChart();\n    });\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r3.language.TTimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"items\", ctx_r3.Frame)(\"ngModel\", ctx_r3.TimeFrame);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.start && !ctx_r3.isLastDay15minSelected);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.start);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.start);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.language.apply, \" \");\n  }\n}\nfunction EfficiencyComponent_section_6_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 37);\n    i0.ɵɵelementStart(1, \"div\", 38);\n    i0.ɵɵelementStart(2, \"div\", 39);\n    i0.ɵɵelementStart(3, \"div\", 40);\n    i0.ɵɵelementStart(4, \"span\", 41);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r29.language.Loading);\n  }\n}\nfunction EfficiencyComponent_section_6_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 42);\n    i0.ɵɵelementStart(1, \"ngx-slider\", 43);\n    i0.ɵɵlistener(\"valueChange\", function EfficiencyComponent_section_6_div_2_Template_ngx_slider_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.selectedInterval = $event;\n    })(\"userChangeEnd\", function EfficiencyComponent_section_6_div_2_Template_ngx_slider_userChangeEnd_1_listener() {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.sliderEvent();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\", 44);\n    i0.ɵɵelementStart(3, \"label\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\", 45);\n    i0.ɵɵelementStart(6, \"label\");\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r30 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", ctx_r30.selectedInterval)(\"options\", ctx_r30.timeIntervalOptions);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r30.leftSliderTime, \"\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r30.rightSliderTime);\n  }\n}\nfunction EfficiencyComponent_section_6_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 6);\n    i0.ɵɵelementStart(1, \"div\", 46);\n    i0.ɵɵelementStart(2, \"div\", 28);\n    i0.ɵɵelementStart(3, \"button\", 29);\n    i0.ɵɵlistener(\"click\", function EfficiencyComponent_section_6_div_3_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      return ctx_r35.loadChart();\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r31.language.apply, \" \");\n  }\n}\nfunction EfficiencyComponent_section_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"section\", 35);\n    i0.ɵɵtemplate(1, EfficiencyComponent_section_6_div_1_Template, 6, 1, \"div\", 10);\n    i0.ɵɵtemplate(2, EfficiencyComponent_section_6_div_2_Template, 8, 4, \"div\", 36);\n    i0.ɵɵtemplate(3, EfficiencyComponent_section_6_div_3_Template, 5, 1, \"div\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.loader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.showIntervalSlider);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", false);\n  }\n}\nfunction EfficiencyComponent_div_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 37);\n    i0.ɵɵelementStart(1, \"div\", 38);\n    i0.ɵɵelementStart(2, \"div\", 39);\n    i0.ɵɵelementStart(3, \"div\", 40);\n    i0.ɵɵelementStart(4, \"span\", 41);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r5.language.Loading);\n  }\n}\nconst _c3 = function (a0) {\n  return {\n    \"opac\": a0\n  };\n};\nexport let EfficiencyComponent = /*#__PURE__*/(() => {\n  class EfficiencyComponent {\n    constructor(translateService, dataChartService, deviceService, ssoService) {\n      var _a, _b, _c, _e, _f;\n      this.translateService = translateService;\n      this.dataChartService = dataChartService;\n      this.deviceService = deviceService;\n      this.ssoService = ssoService;\n      this.deviceInfo = [];\n      this.globalObj = {};\n      this.pipe = new DatePipe('en-US');\n      this.homeRes = {};\n      this.station_mac_addr = (_a = history === null || history === void 0 ? void 0 : history.state) === null || _a === void 0 ? void 0 : _a.stationMac;\n      this.WeekFrame = 7;\n      this.lastSeventhDay = moment().subtract(144, 'hours').format('dddd');\n      this.lastSixthDay = moment().subtract(120, 'hours').format('dddd');\n      this.lastfifthDay = moment().subtract(96, 'hours').format('dddd');\n      this.lastFourthDay = moment().subtract(72, 'hours').format('dddd');\n      this.lastThirdDay = moment().subtract(48, 'hours').format('dddd');\n      this.yesterDay = moment().subtract(24, 'hours').format('dddd');\n      this.toDay = moment().format('dddd');\n      this.WeekFramedata = [];\n      this.TimeFrame = 2;\n      this.TimeInterval = 1;\n      this.FrameSV = [\n      // { id: 1, name: 'Last 7 days' },\n      {\n        id: 2,\n        name: 'Last 24 hours'\n      }, {\n        id: 3,\n        name: 'Last 3 hours'\n      }, {\n        id: 5,\n        name: ' Last 15 minutes'\n      }, {\n        id: 6,\n        name: ' Any 15 minutes within last day'\n      }\n      // { id: 4, name: ' Any hours within last week' },\n      ];\n\n      this.Frame = [{\n        id: 1,\n        name: 'Last 7 days'\n      }, {\n        id: 2,\n        name: 'Last_hours'\n      }, {\n        id: 3,\n        name: 'Last 3 hours'\n      }, {\n        id: 5,\n        name: 'Last 15 minutes'\n      }, {\n        id: 6,\n        name: 'Any 15 minutes within last day'\n      },\n      // { id: 4, name: ' Any hours within last week' },\n      {\n        id: 4,\n        name: 'Any 3 Hours within last week'\n      }, {\n        id: 7,\n        name: 'Any day within last week'\n      }];\n      this.maxDate = new Date();\n      this.minDate = new Date();\n      this.formDate = new Date(this.minDate.setDate(this.minDate.getDate() - 6));\n      this.stepMinuteVal = 0;\n      this.showHrs = true;\n      this.isLastDay15minSelected = false;\n      this.isEndDateDisabled = true;\n      this.effDash = true;\n      this.userClickTimeout = setTimeout(() => {}, 0);\n      this.timeIntervalOptions = {\n        hideLimitLabels: true,\n        onlyBindHandles: true,\n        stepsArray: []\n      };\n      this.showIntervalSlider = false;\n      this.timeIntervals = [];\n      this.TimeFrame = ((_b = history === null || history === void 0 ? void 0 : history.state) === null || _b === void 0 ? void 0 : _b.period) || this.TimeFrame;\n      this.endDate = ((_c = history === null || history === void 0 ? void 0 : history.state) === null || _c === void 0 ? void 0 : _c.endTime) || this.endDate;\n      this.startDate = ((_e = history === null || history === void 0 ? void 0 : history.state) === null || _e === void 0 ? void 0 : _e.startTime) || this.startDate;\n      this.WeekFrame = ((_f = history === null || history === void 0 ? void 0 : history.state) === null || _f === void 0 ? void 0 : _f.WeekFrame) || this.WeekFrame;\n      this.lastdays15MinOfValues();\n    }\n    inClick(e) {\n      //Slider bar Prev, Next click events\n      e.stopPropagation();\n      history.state.endTime = false;\n      this.inputs = undefined;\n      let id = e.target.id ? e.target.id : '';\n      if (id == 'slider-click-next' || id == 'slider-click-prev') {\n        let clsList = e.target.className ? e.target.className.split(' ')[0] : '';\n        let tag = e.target.localName;\n        let totalPoints = this.timeIntervals.length - 1;\n        // console.log(this.selectedInterval)\n        if (id == 'slider-click-next') {\n          history.state.endTime = false;\n          this.inputs = undefined;\n          let point = parseInt(clsList.split('-')[1]);\n          if (point + 1 <= totalPoints) {\n            this.selectedInterval = point + 1;\n          }\n        }\n        if (id == 'slider-click-prev') {\n          history.state.endTime = false;\n          this.inputs = undefined;\n          let point = parseInt(clsList.split('-')[1]);\n          if (point - 1 >= 0) {\n            this.selectedInterval = point - 1;\n          }\n        }\n        // console.log(`${this.selectedInterval} selected from range of 0 to ${totalPoints}`)\n        this.handleUserTime();\n      }\n      history.state.endTime = false;\n      this.inputs = undefined;\n    }\n    startTimeUpdate() {\n      // if (this.isEndDateDisabled) return\n      this.endDate = moment(this.startDate).add(this.stepMinuteVal, \"m\").toDate();\n      this.isEndDateDisabled = this.isLastDay15minSelected;\n      this.isDateAreEqual = this.start && moment(this.startDate).isSame(this.endDate);\n      // this.isDateAreEqual = moment(this.startDate).isSame(this.endDate)\n    }\n\n    endTimeUpdate() {\n      this.isDateAreEqual = this.start && moment(this.startDate).isSame(this.endDate);\n    }\n    onTimeFrameChange(event) {\n      // console.log(event);\n      this.isEndDateDisabled = true;\n      this.isLastDay15minSelected = event == 6;\n      if (event == 6) {\n        this.start = true;\n        // this.endDate = moment(this.startDate).add(this.stepMinuteVal, \"m\").toDate()\n        this.stepMinuteVal = 15;\n        var coeff = 1000 * 60 * 5;\n        var date = new Date();\n        date.setMinutes(0); //or use any other date\n        this.startDate = this.endDate = new Date(Math.round(date.getTime() / coeff) * coeff);\n        this.startDate = moment(this.endDate).add(-15, \"m\").toDate();\n        this.showHrs = true;\n      } else if (event == 4) {\n        this.startDate = this.endDate = '';\n        this.isEndDateDisabled = false;\n        this.start = true;\n        this.stepMinuteVal = 60;\n        var coeff = 1000 * 60 * 5;\n        var date = new Date();\n        date.setMinutes(0); //or use any other date\n        this.startDate = this.endDate = new Date(Math.round(date.getTime() / coeff) * coeff);\n        this.startDate = moment(this.endDate).add(-60, \"m\").toDate();\n        this.showHrs = true;\n      } else {\n        this.start = false;\n      }\n      //this.loadChart();\n    }\n\n    ngOnInit() {\n      var _a, _b, _c, _e;\n      this.weekDate = this.maxDate = new Date();\n      var coeff = 1000 * 60 * 5;\n      var date = new Date(); //or use any other date\n      this.startDate = this.endDate = new Date(Math.round(date.getTime() / coeff) * coeff);\n      this.language = this.translateService.defualtLanguage;\n      this.languageSubject = this.translateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n        this.Frame = [{\n          id: 1,\n          name: this.language['Last 7 days']\n        }, {\n          id: 2,\n          name: this.language['Last_hours']\n        }, {\n          id: 3,\n          name: this.language['Last 3 hours']\n        }, {\n          id: 5,\n          name: this.language['Last 15 minutes']\n        }, {\n          id: 6,\n          name: this.language['Any 15 minutes within last day']\n        },\n        // { id: 4, name: ' Any hours within last week' },\n        {\n          id: 4,\n          name: this.language['Any 3 Hours within last week']\n        }, {\n          id: 7,\n          name: this.language['Any day within last week']\n        }];\n        this.loadChart();\n      });\n      this.orgId = this.ssoService.getOrgId();\n      this.deviceInfo = JSON.parse(sessionStorage.getItem(`${this.ssoService.getTabId()}calix.deviceData`));\n      let deviceInfo = (_a = this.deviceInfo) === null || _a === void 0 ? void 0 : _a.filter(el => el.opMode && el.opMode.indexOf('RG') > -1);\n      // if (deviceInfo) {\n      //   this.serialNumberSelected = this.deviceInfo[0].serialNumber;\n      // }\n      // if (deviceInfo) {\n      //   this.softwareVersion = this.deviceInfo[0]?.softwareVersion?.substring(0, 4)\n      // } else {\n      //   this.softwareVersion = 0;\n      // };\n      if ((deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.length) > 0) {\n        deviceInfo = deviceInfo.filter(x => x.opMode == 'RG');\n        if (deviceInfo.length || this.ssoService.acceptGSModel(((_b = deviceInfo[0]) === null || _b === void 0 ? void 0 : _b.modelName) || '')) {\n          this.softwareVersion = (_c = deviceInfo[0].softwareVersion) === null || _c === void 0 ? void 0 : _c.substring(0, 4);\n          this.serialNumberSelected = deviceInfo[0].serialNumber;\n          // this.mac = deviceInfo[0].macAddress;\n        } else return;\n      } else return;\n      // if (deviceInfo?.length) {\n      //   this.serialNumberSelected = this.deviceInfo ? this.deviceInfo[0].serialNumber : '';\n      // } else {\n      //   this.serialNumberSelected = this.deviceInfo ? this.deviceInfo[0].serialNumber : '';\n      // }\n      if ((_e = history === null || history === void 0 ? void 0 : history.state) === null || _e === void 0 ? void 0 : _e.endTime) {\n        this.calcOf15minVal();\n      }\n      this.zyxelModel();\n      this.loadChart();\n    }\n    ngAfterViewInit() {\n      this.Frame = [{\n        id: 1,\n        name: this.language['Last 7 days']\n      }, {\n        id: 2,\n        name: this.language['Last_hours']\n      }, {\n        id: 3,\n        name: this.language['Last 3 hours']\n      }, {\n        id: 5,\n        name: this.language['Last 15 minutes']\n      }, {\n        id: 6,\n        name: this.language['Any 15 minutes within last day']\n      },\n      // { id: 4, name: ' Any hours within last week' },\n      {\n        id: 4,\n        name: this.language['Any 3 Hours within last week']\n      }, {\n        id: 7,\n        name: this.language['Any day within last week']\n      }];\n    }\n    sliderEvent() {\n      history.state.endTime = false;\n      this.inputs = undefined;\n      setTimeout(() => {\n        if (this.TimeFrame == 6 || this.TimeFrame == 4 || this.TimeFrame == 7) {\n          this.showIntervalSlider = true;\n        }\n        this.loadChart();\n      }, 500);\n    }\n    dropDownChaneWeekFrame() {\n      history.state.endTime = false;\n      this.inputs = undefined;\n      // this.dropDownchangeweek()\n    }\n\n    dropDownchange() {\n      history.state.endTime = false;\n      history.state.stationMac = false;\n      history.state.period = false;\n      this.lastdays15MinOfValues();\n      // if (this.TimeFrame == 4) {\n      //   this.dropDownchangeweek()\n      // }\n      // this.dropDownchangeweek();\n      if (this.TimeFrame == 6 || this.TimeFrame == 4 || this.TimeFrame == 7) {\n        this.showIntervalSlider = false;\n      }\n      this.sliderEvent();\n    }\n    handleUserTime() {\n      clearTimeout(this.userClickTimeout);\n      this.userClickTimeout = setTimeout(() => {\n        this.loadChart();\n      }, 2000);\n    }\n    // sliderEvent() {\n    //   setTimeout(() => {\n    //     this.loadChart();\n    //   }, 500);\n    // }\n    loadChart() {\n      var _a, _b, _c, _e, _f, _g, _h, _j;\n      if ((_a = history === null || history === void 0 ? void 0 : history.state) === null || _a === void 0 ? void 0 : _a.endTime) {\n        let [start, end] = this.timeForFilter(new Date(), new Date());\n        // let endTime\n        // let startTime\n        // if (this.TimeFrame == 7) {\n        //   endTime = history?.state?.endTime[3];\n        //   startTime = history?.state?.endTime[2];\n        // } else {\n        //   endTime = history?.state?.endTime[1];\n        //   startTime = history?.state?.endTime[0];\n        // }\n        let endTime = (_b = history === null || history === void 0 ? void 0 : history.state) === null || _b === void 0 ? void 0 : _b.endTime[1];\n        let startTime = (_c = history === null || history === void 0 ? void 0 : history.state) === null || _c === void 0 ? void 0 : _c.endTime[0];\n        // format('MM/DD/YYYY HH:mm')\n        [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n        const routerMac = (_e = JSON.parse(this.ssoService.getSerialNo() || [])) === null || _e === void 0 ? void 0 : _e.filter(obj => obj.opMode == 'RG').map(obj => obj.macAddress).join('');\n        let params;\n        if (this.TimeFrame == 1) {\n          params = {\n            sn: this.serialNumberSelected,\n            orgId: this.orgId,\n            routerMac: routerMac,\n            stationMac: this.station_mac_addr,\n            period: this.TimeFrame,\n            start: start,\n            end: end,\n            tz: 0\n          };\n        } else {\n          params = {\n            sn: this.serialNumberSelected,\n            orgId: this.orgId,\n            routerMac: routerMac,\n            stationMac: this.station_mac_addr,\n            period: this.TimeFrame,\n            start: start,\n            end: end,\n            tz: -(new Date().getTimezoneOffset() / 60)\n          };\n        }\n        this.loader = true;\n        this.deviceService.getClientScore(params).subscribe(res => {\n          this.loader = false;\n          this.homeRes = res;\n          Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(res || []));\n        }, err => {\n          this.homeRes = {};\n          let res = [];\n          Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(res || []));\n          this.loader = false;\n        });\n      } else {\n        this.globalObj.latencyCreateTime = '';\n        let [start, end] = this.timeForFilter(new Date(), new Date());\n        if (this.TimeFrame == 6) {\n          // const last15End = new Date();\n          let endTime = this.timeIntervals[this.selectedInterval].date;\n          let startTime = moment(endTime).subtract(15, \"minutes\");\n          endTime = moment(endTime).add(1, \"minutes\");\n          [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n        }\n        if (this.TimeFrame == 4) {\n          let startTime;\n          let endTime;\n          let endTime1;\n          if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n            endTime1 = this.timeIntervals[this.selectedInterval].date;\n            endTime = moment(endTime1).subtract(15, \"minutes\");\n            startTime = moment(endTime1).subtract(180, \"minutes\");\n          } else {\n            endTime1 = this.timeIntervals[this.selectedInterval].date;\n            endTime = moment(endTime1).subtract(15, \"minutes\");\n            // startTime = moment(endTime1).subtract(60, \"minutes\");\n            startTime = this.timeIntervals[this.selectedInterval - 1].date;\n          }\n          // let endTime = this.timeIntervals[this.selectedInterval].date;\n          // let startTime = moment(endTime).subtract(180, \"minutes\");\n          [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n          //  this.timeForDeviceEfficiency = endTime;\n        }\n\n        if (this.TimeFrame == 7) {\n          let startTime;\n          let endTime;\n          let endTime1;\n          if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 12 == 0) {\n            endTime1 = this.timeIntervals[this.selectedInterval].date;\n            endTime = moment(endTime1);\n            startTime = moment(endTime1).subtract(24, \"hours\");\n          } else {\n            endTime = moment(this.timeIntervals[this.selectedInterval].date);\n            startTime = moment(this.timeIntervals[this.selectedInterval - 1].date);\n          }\n          [start, end] = [this.getISOString(startTime), this.getISOString(endTime)];\n        }\n        if (this.inputs != undefined) {\n          let startTime;\n          let endTime;\n          this.calcOf15minVal1();\n          this.TimeFrame = this.inputs.period;\n          startTime = moment(this.timeIntervals[this.selectedInterval - 1].date);\n          endTime = moment(this.timeIntervals[this.selectedInterval].date);\n          end = endTime.toISOString().substr(0, 16) + ':00';\n          start = startTime.toISOString().substr(0, 16) + ':00';\n        }\n        let getserial = this.ssoService.getSerialNo();\n        const routerMac = getserial ? JSON.parse(getserial || []).filter(obj => obj.opMode == 'RG').map(obj => obj.macAddress).join('') : '';\n        let params;\n        if (this.TimeFrame == 1) {\n          params = {\n            sn: this.serialNumberSelected,\n            orgId: this.orgId,\n            routerMac: routerMac,\n            stationMac: ((_f = this.index) === null || _f === void 0 ? void 0 : _f.MACAddress) ? (_g = this.index) === null || _g === void 0 ? void 0 : _g.MACAddress : this.station_mac_addr,\n            period: this.TimeFrame,\n            start: start,\n            end: end,\n            tz: 0\n          };\n        } else {\n          params = {\n            sn: this.serialNumberSelected,\n            orgId: this.orgId,\n            routerMac: routerMac,\n            stationMac: ((_h = this.index) === null || _h === void 0 ? void 0 : _h.MACAddress) ? (_j = this.index) === null || _j === void 0 ? void 0 : _j.MACAddress : this.station_mac_addr,\n            period: this.TimeFrame,\n            start: start,\n            end: end,\n            tz: -(new Date().getTimezoneOffset() / 60)\n          };\n        }\n        this.loader = true;\n        this.deviceService.getClientScore(params).subscribe(res => {\n          this.loader = false;\n          this.homeRes = res;\n          Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(res || []));\n        }, err => {\n          this.homeRes = {};\n          let res = [];\n          Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(res || []));\n          this.loader = false;\n        });\n      }\n    }\n    zyxelModel() {\n      let model = JSON.parse(sessionStorage.getItem('calix.deviceData'));\n      model.forEach(element => {\n        if (element.manufacturer == \"ZYXEL\") {\n          this.dropdownModel = true;\n        } else if (element.manufacturer == \"Calix\" && parseFloat(element.softwareVersion) >= 22.1) {\n          this.dropdownModel = true;\n        } else this.dropdownModel = false;\n      });\n    }\n    timeForFilter(start, end) {\n      // let [start, end] = [new Date(), new Date()];\n      switch (this.TimeFrame) {\n        case 1:\n          // start.setDate(start.getDate() - 5);\n          // start.setHours(0, 0, 0, 0)\n          start.setDate(start.getDate() - 6);\n          start.setHours(5, 30, 0, 0);\n          end.setMinutes(end.getMinutes());\n          return [start.toISOString().substring(0, 11) + '00' + ':00' + ':00', end.toISOString().substring(0, 19)];\n          // [start, end] = this.minuteAligner(start, end);\n          break;\n        case 2:\n          start.setHours(start.getHours() - 24);\n          [start, end] = this.minuteAligner(start, end);\n          break;\n        case 3:\n          start.setHours(start.getHours() - 3);\n          [start, end] = this.minuteAligner(start, end);\n          break;\n        case 4:\n          // [start, end] = [this.startDate, this.endDate];\n          // start.setDate(this.weekDate.getDate());\n          // start.setMonth(this.weekDate.getMonth());\n          // start.setFullYear(this.weekDate.getFullYear());\n          // end.setDate(this.weekDate.getDate());\n          // end.setMonth(this.weekDate.getMonth());\n          // end.setFullYear(this.weekDate.getFullYear());\n          // [start, end] = this.minuteAligner(start, end);\n          //if (start.getDate() > end.getDate()) end.setDate(end.getDate() + 2);\n          break;\n        case 5:\n          start.setMinutes(start.getMinutes() - 16);\n          end.setMinutes(end.getMinutes() + 1);\n          // start.setMinutes(start.getMinutes() - 15);\n          break;\n        case 6:\n        // [start, end] = [this.startDate, this.endDate];\n        // [start, end] = this.minuteAligner(start, end);\n        // break;\n        default:\n          break;\n      }\n      return [start.toISOString().substring(0, 16) + ':00', end.toISOString().substring(0, 16) + ':00'];\n    }\n    minuteAligner(start, end) {\n      let [s, e] = [start.getMinutes(), end.getMinutes()];\n      const limit = [45, 30, 15, 0];\n      for (let i = 0; i < limit.length; i++) {\n        //const ind = (i > 0 ? (i - 1) : 0);\n        if (!limit.includes(s) && s > limit[i]) {\n          start.setMinutes(limit[i]);\n          s = limit[i];\n        }\n        if (!limit.includes(e) && e > limit[i]) {\n          end.setMinutes(limit[i]);\n          e = limit[i];\n        }\n      }\n      return [start, end];\n    }\n    roundOffDate(start, end) {\n      if (start && end && start > end) {\n        let endSplit = end.split('T');\n        let endDate = endSplit[0].split('-');\n        endDate[2] = (endDate[2] < 9 ? '0' : '') + (parseInt(endDate[2]) + 1);\n        end = endDate.join('-') + 'T' + endSplit[1];\n        return this.roundOffDate(start, end);\n      } else {\n        return [start, end];\n      }\n    }\n    wholeHomeEfficiencyOption(data) {\n      let thisComponent = this;\n      const mappingObject = {\n        time: \"time\",\n        homeefficiency: \"homeefficiency\"\n      };\n      let [categories, homeefficiency] = this.mapWholeHomeEfficencyChartData(data);\n      // let average = data?.avg_eff_score ? data?.avg_eff_score : 0;\n      let frame = this.TimeFrame;\n      let self = this;\n      return {\n        title: {\n          text: ''\n          // style: {\n          //   fontSize: '14px',\n          // },\n          // align: 'left'\n        },\n\n        credits: {\n          enabled: false\n        },\n        // chart: {\n        //   type: 'column'\n        // },\n        tooltip: {\n          // headerFormat: '',\n          pointFormat: `${this.language['Efficiency Score']} : <b>{point.y}%</b>`\n        },\n        xAxis: {\n          categories: categories || [],\n          overflow: false,\n          labels: {\n            rotation: -45\n          },\n          tickInterval: function () {\n            let sLength = categories.length ? categories.length : 0;\n            let f = 1;\n            if (frame === 2 || frame === 7) {\n              if (sLength > 90) {\n                f = 4;\n              } else if (sLength > 70) {\n                f = 3;\n              } else if (sLength > 30) {\n                f = 2;\n              }\n            }\n            return f;\n          }()\n        },\n        yAxis: {\n          min: 0,\n          max: 100,\n          tickInterval: 20,\n          lineColor: '#ddd',\n          title: {\n            text: `${this.language['Client Efficiency']} (%)`,\n            style: {\n              fontSize: '15px'\n            }\n          }\n          // plotLines: [{\n          //   color: '#5ACFEA',\n          //   value: average, // Insert your average here\n          //   width: '2',\n          //   zIndex: 4, // To not get stuck below the regular plot lines or series\n          //   label: {\n          //     text: ('Avg: ' + average.toFixed(2)),\n          //     align: 'right'\n          //   },\n          // }],\n        },\n\n        plotOptions: {\n          series: {\n            maxPointWidth: 20,\n            borderRadius: 0,\n            cursor: 'pointer',\n            marker: {\n              enabled: false,\n              states: {\n                hover: {\n                  enabled: true\n                  //radius: 3\n                }\n              }\n            },\n\n            point: {\n              events: {\n                click: function () {\n                  if (frame === 2) {\n                    self.inputs = {\n                      period: 6,\n                      startTime: this.category\n                    };\n                    self.loadChart();\n                    // console.log(this.inputs)\n                    // this.subject.next(this.inputs)\n                  }\n                  //alert('Category: ' + this.category + ', value: ' + this.y);\n                  // thisComponent.showClientEfficencyChart();\n                  //thisComponent.modalRef = thisComponent.dialogService.open(thisComponent.showProbeStatusModal);\n                  //alert(2);\n                }\n              }\n            }\n          }\n        },\n\n        // plotOptions: {\n        //   series: {\n        //     maxPointWidth: 20,\n        //     borderRadius: 0\n        //   },\n        // },\n        series: [{\n          type: 'line',\n          name: '',\n          data: homeefficiency || [],\n          color: '#0a77fb',\n          showInLegend: false\n        }]\n      };\n    }\n    mapWholeHomeEfficencyChartData(data) {\n      let categories = [],\n        download = [],\n        upload = [],\n        homeefficiency = [];\n      const mapKey = this.TimeFrame == 1 ? 'dailyAverageScore' : 'rawData';\n      (data[mapKey] || []).forEach(obj => {\n        const date = obj.date;\n        let y = date.substring(0, 4),\n          m = date.substring(6, 4),\n          d = date.substring(6);\n        let dateWithSlash = m + '/' + d + '/' + y;\n        const time = obj.time;\n        // const dt = moment((time.substr(0, 2) + ':' + time.substr(2, 4)), [\"HH:mm\"]).format(\"hh:mm A\");\n        //let fullDate = (dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substr(0, 2) + ':' + time.substr(2, 4)));\n        // categories.push(dt);\n        let fullDateTime;\n        let year = date.substring(2, 4);\n        let dateWithSlashyear = m + '/' + d + '/' + year;\n        let fullDate = dateWithSlash + ' ' + (this.TimeFrame == 1 ? '' : time.substring(0, 2) + ':' + time.substring(2, 4));\n        if (this.TimeFrame == 1) {\n          //daily data\n          fullDate = dateWithSlash;\n          categories.push(fullDate);\n        } else if (this.TimeFrame == 4) {\n          fullDateTime = dateWithSlashyear + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          categories.push(fullDateTime);\n          // this.category.push(fullDateTime)\n        } else if (this.TimeFrame == 2) {\n          const dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDateTime = dateWithSlashyear + ' ' + moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = dt;\n          categories.push(fullDateTime);\n        } else {\n          const dt = moment(time.substring(0, 2) + ':' + time.substring(2, 4), [\"HH:mm\"]).format(\"hh:mm A\");\n          fullDate = dt;\n          categories.push(dt);\n        }\n        // Math.round(obj.eff_score); \n        const roundedScore = parseInt(obj.eff_score.toString().substring(0, 5));\n        homeefficiency.push(roundedScore);\n      });\n      return [categories, homeefficiency];\n    }\n    filterContent() {\n      this.effDash = !this.effDash;\n      Highcharts.chart('wholeHomeEfficiencyChart', this.wholeHomeEfficiencyOption(this.effDash ? this.homeRes : {\n        rawData: []\n      }));\n    }\n    lastdays15MinOfValues() {\n      var _a;\n      if ((_a = history === null || history === void 0 ? void 0 : history.state) === null || _a === void 0 ? void 0 : _a.endTime) {\n        if (this.TimeFrame == 7) {\n          let date = new Date();\n          let coeff = 1000 * 60;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n          // let startTime = moment(lastTime).subtract(168, \"hours\");\n          // let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).startOf('day')\n          // lastTime.add(1, 'day');\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          startTime1 = moment(startTime1).add(1, 'day');\n          this.timeIntervals = [];\n          // lastTime1 = moment(lastTime).subtract(1, 'day');\n          let current = moment(startTime1);\n          let i = 0;\n          while (current <= lastTime) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(1, 'day');\n            // let lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()));\n            // if (current['_d'].getDate() >= lastTime[\"_d\"].getDate()) {\n            //   current.add(lasttime, 'hours')\n            // }\n            if (current > lastTime) {\n              let lasttime = lastTime[\"_d\"];\n              this.timeIntervals.push({\n                value: i + 1,\n                legend: moment(lasttime).format('MM/DD/YYYY HH:mm'),\n                date: moment(lasttime).toDate()\n              });\n            }\n            i++;\n          }\n          this.calcOf15minVal();\n        } else if (this.TimeFrame == 4) {\n          var i = this.WeekFrame;\n          if (i == 1) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            var startTime1;\n            var lastTime1;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n            lastTime1 = moment(lastTime1).subtract(180, 'minutes');\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            this.calcOf15minVal();\n          } else if (i == 2) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            // let startTime1\n            // let lastTime1\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n            lastTime1 = moment(lastTime1).subtract(180, 'minutes');\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            this.calcOf15minVal();\n          } else if (i == 3) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(48, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n            lastTime1 = moment(lastTime1).subtract(180, 'minutes');\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            this.calcOf15minVal();\n          } else if (i == 4) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(72, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n            lastTime1 = moment(lastTime1).subtract(180, 'minutes');\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            this.calcOf15minVal();\n          } else if (i == 5) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(96, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n            lastTime1 = moment(lastTime1).subtract(180, 'minutes');\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            this.calcOf15minVal();\n          } else if (i == 6) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(120, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n            lastTime1 = moment(lastTime1).subtract(180, 'minutes');\n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            this.calcOf15minVal();\n          } else if (i == 7) {\n            {\n              let date = new Date();\n              let coeff = 1000 * 60;\n              let timeDuration = -24 * 60;\n              let lastUpdatedTime;\n              let that = this;\n              let len = 0;\n              let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n              let startTime = moment(lastTime).subtract(144, \"hours\");\n              startTime1 = new Date(startTime['_d'].setHours(144, 0, 0, 0));\n              // lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0))\n              let currentTimestamp = new Date().setSeconds(0, 0);\n              const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n              startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n              this.timeIntervals = [];\n              let current = moment(startTime1);\n              // console.log(this.timeIntervals);\n              let i = 0;\n              let lasttime;\n              while (current <= lastTime) {\n                this.timeIntervals.push({\n                  value: i,\n                  legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                  date: moment(current).toDate()\n                });\n                lastUpdatedTime = moment(current);\n                lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()) / 3);\n                if (lasttime > 0) {\n                  current.add(180, 'minutes');\n                } else {\n                  const minToRoundOf24hr = Math.ceil(lastTime[\"_d\"].getHours() - current['_d'].getHours()) == 2 ? 120 : 60;\n                  current.add(minToRoundOf24hr, 'minutes');\n                }\n                i++;\n              }\n              this.calcOf15minVal();\n            }\n          }\n          setTimeout(() => {\n            this.WeekFramedata = [{\n              id: 1,\n              name: this.language[this.lastSeventhDay]\n            }, {\n              id: 2,\n              name: this.language[this.lastSixthDay]\n            }, {\n              id: 3,\n              name: this.language[this.lastfifthDay]\n            }, {\n              id: 4,\n              name: this.language[this.lastFourthDay]\n            }, {\n              id: 5,\n              name: this.language[this.lastThirdDay]\n            }, {\n              id: 6,\n              name: this.language[this.yesterDay]\n            }, {\n              id: 7,\n              name: this.language[this.toDay]\n            }];\n          }, 2000);\n        } else {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(24, \"hours\");\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          // let currentTimestamp = history?.state?.endTime\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 30 : 15;\n          startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n          this.timeIntervals = [];\n          let current = moment(startTime);\n          let i = 0;\n          while (current <= lastTime) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(15, 'minutes');\n            i++;\n          }\n          this.calcOf15minVal();\n        }\n      } else {\n        if (this.TimeFrame == 4) {\n          var i = this.WeekFrame;\n          if (i == 1) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            var startTime1;\n            var lastTime1;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastSeventhDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 2) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            // let startTime1\n            // let lastTime1\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastSixthDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 3) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(48, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastfifthDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 4) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(72, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastFourthDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 5) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(96, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            //including current time\n            // let currentEnd = moment(date).seconds(0).milliseconds(0);\n            // console.log(currentEnd);\n            // if (!moment(currentEnd).isSame(lastUpdatedTime)) {\n            //   console.log('Not same');\n            //   this.timeIntervals.push({\n            //     value: i, legend: moment(currentEnd).format('MM/DD/YYYY HH:mm'),\n            //     date: moment(currentEnd).toDate()\n            //   });\n            // }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.lastThirdDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 6) {\n            let date = new Date();\n            let coeff = 1000 * 60 * 15;\n            let timeDuration = -24 * 60;\n            let lastUpdatedTime;\n            let that = this;\n            let len = 0;\n            let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n            let startTime = moment(lastTime).subtract(144, \"hours\");\n            startTime1 = new Date(startTime['_d'].setHours(120, 0, 0, 0));\n            lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0));\n            let currentTimestamp = new Date().setSeconds(0, 0);\n            // console.log('current = ' + new Date(currentTimestamp));\n            // console.log('start = ' + new Date(moment(startTime).toDate()));\n            // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n            //   / (1000 * 60 * 60));\n            const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 15 : 30;\n            startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n            this.timeIntervals = [];\n            let current = moment(startTime1);\n            // console.log(this.timeIntervals);\n            let i = 0;\n            while (current <= lastTime1) {\n              this.timeIntervals.push({\n                value: i,\n                legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                date: moment(current).toDate()\n              });\n              lastUpdatedTime = moment(current);\n              current.add(180, 'minutes');\n              i++;\n            }\n            len = this.timeIntervals.length;\n            this.selectedInterval = this.timeIntervals[len - 1].value;\n            this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n            const translate = (value, label) => {\n              let pointersTime = moment(that.timeIntervals[value]['date']);\n              let start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n              return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n            };\n            this.timeIntervalOptions.translate = translate;\n            //console.log(this.timeIntervals);\n            this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n            this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            // this.yesterDay = moment(this.timeIntervals[0].date).format('dddd');\n            setTimeout(() => {\n              this.showIntervalSlider = true;\n              setTimeout(() => {\n                $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n              }, 10);\n            }, 1000);\n          } else if (i == 7) {\n            {\n              let date = new Date();\n              let coeff = 1000 * 60;\n              let timeDuration = -24 * 60;\n              let lastUpdatedTime;\n              let that = this;\n              let len = 0;\n              let lastTime;\n              lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n              let startTime = moment(lastTime).subtract(144, \"hours\");\n              startTime1 = new Date(startTime['_d'].setHours(144, 0, 0, 0));\n              // lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0))\n              let currentTimestamp = new Date().setSeconds(0, 0);\n              // console.log('current = ' + new Date(currentTimestamp));\n              // console.log('start = ' + new Date(moment(startTime).toDate()));\n              // console.log((currentTimestamp - new Date(moment(startTime).toDate()).getTime())\n              //   / (1000 * 60 * 60));\n              const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime1).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 60 : 180;\n              // startTime1 = moment(startTime1).add(180, 'minutes'); // omitting first 0th minute \n              this.timeIntervals = [];\n              let current = moment(startTime1);\n              // console.log(this.timeIntervals);\n              let i = 0;\n              let lasttime;\n              // this.timeinterrval1 = 180;\n              let now = moment();\n              while (current <= lastTime) {\n                this.timeIntervals.push({\n                  value: i,\n                  legend: moment(current).format('MM/DD/YYYY HH:mm'),\n                  date: moment(current).toDate()\n                });\n                lastUpdatedTime = moment(current);\n                lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()) / 3);\n                if (lasttime > 0) {\n                  current.add(180, 'minutes');\n                } else {\n                  const minToRoundOf24hr = Math.ceil(lastTime[\"_d\"].getHours() - current['_d'].getHours()) == 2 ? 120 : 60;\n                  current.add(minToRoundOf24hr, 'minutes');\n                }\n                i++;\n              }\n              len = this.timeIntervals.length;\n              this.selectedInterval = this.timeIntervals[len - 1].value;\n              this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n              const translate = (value, label) => {\n                let pointersTime = moment(that.timeIntervals[value]['date']);\n                var start;\n                var end;\n                if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n                  start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n                  end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n                } else {\n                  // start = pointersTime.subtract(minToRoundOf24hr, 'minutes').format('MMM DD hh:mm A');\n                  start = moment(this.timeIntervals[len - 2].date).format('MMM DD hh:mm A');\n                  end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n                }\n                // let start = pointersTime.subtract(180, 'minutes').format('hh:mm A');\n                // let end = moment(that.timeIntervals[value]['date']).format('hh:mm A');\n                return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n              };\n              this.timeIntervalOptions.translate = translate;\n              //console.log(this.timeIntervals);\n              this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(180, 'minutes').format('MMM DD hh:mm A');\n              this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n              // this.toDay = moment(this.timeIntervals[0].date).format('dddd');\n              setTimeout(() => {\n                this.showIntervalSlider = true;\n                setTimeout(() => {\n                  $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n                }, 10);\n              }, 1000);\n            }\n          }\n          setTimeout(() => {\n            this.WeekFramedata = [{\n              id: 1,\n              name: this.language[this.lastSeventhDay]\n            }, {\n              id: 2,\n              name: this.language[this.lastSixthDay]\n            }, {\n              id: 3,\n              name: this.language[this.lastfifthDay]\n            }, {\n              id: 4,\n              name: this.language[this.lastFourthDay]\n            }, {\n              id: 5,\n              name: this.language[this.lastThirdDay]\n            }, {\n              id: 6,\n              name: this.language[this.yesterDay]\n            }, {\n              id: 7,\n              name: this.language[this.toDay]\n            }];\n          }, 2000);\n        } else if (this.TimeFrame == 7) {\n          let date = new Date();\n          let coeff = 1000 * 60;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).minutes(0).seconds(0).milliseconds(0);\n          // let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).startOf('day');\n          // startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0))\n          // lastTime1 = new Date(startTime['_d'].setHours(24, 0, 0, 0))\n          let startTime = moment(lastTime).subtract(144, \"hours\");\n          startTime1 = new Date(startTime['_d'].setHours(0, 0, 0, 0));\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 30 : 15;\n          // startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n          startTime1 = moment(startTime1).add(1, 'day');\n          this.timeIntervals = [];\n          let current = moment(startTime1);\n          let now = moment();\n          let i = 0;\n          while (current <= lastTime) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(1, 'day');\n            // let lasttime = Math.floor((lastTime[\"_d\"].getHours() - current['_d'].getHours()));\n            // if (current['_d'].getDate() >= lastTime[\"_d\"].getDate()) {\n            //   current.add(lasttime, 'hours')\n            // }\n            if (current > lastTime) {\n              let lasttime = lastTime[\"_d\"];\n              this.timeIntervals.push({\n                value: i + 1,\n                legend: moment(lasttime).format('MM/DD/YYYY HH:mm'),\n                date: moment(lasttime).toDate()\n              });\n            }\n            i++;\n          }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(1, 'day').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let start;\n            let end;\n            if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 24 == 0) {\n              start = pointersTime.subtract(1, 'day').format('MMM DD hh:mm A');\n              end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            } else {\n              // start = pointersTime.subtract(minToRoundOf24hr, 'minutes').format('MMM DD hh:mm A');\n              start = moment(this.timeIntervals[len - 2].date).format('MMM DD hh:mm A');\n              end = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n            }\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(1, 'day').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else {\n          let date = new Date();\n          let coeff = 1000 * 60 * 15;\n          let timeDuration = -24 * 60;\n          let lastUpdatedTime;\n          let that = this;\n          let len = 0;\n          let lastTime = moment(new Date(Math.floor(date.getTime() / coeff) * coeff)).seconds(0).milliseconds(0);\n          let startTime = moment(lastTime).subtract(24, \"hours\");\n          let currentTimestamp = new Date().setSeconds(0, 0);\n          const minToRoundOf24hr = Math.ceil((currentTimestamp - new Date(moment(startTime).toDate()).getTime()) / (1000 * 60 * 60)) > 24 ? 30 : 15;\n          startTime = moment(startTime).add(minToRoundOf24hr, 'minutes'); // omitting first 0th minute \n          this.timeIntervals = [];\n          let current = moment(startTime);\n          let i = 0;\n          while (current <= lastTime) {\n            this.timeIntervals.push({\n              value: i,\n              legend: moment(current).format('MM/DD/YYYY HH:mm'),\n              date: moment(current).toDate()\n            });\n            lastUpdatedTime = moment(current);\n            current.add(15, 'minutes');\n            i++;\n          }\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A');\n            let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" > </span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span > `;\n          };\n          this.timeIntervalOptions.translate = translate;\n          //console.log(this.timeIntervals);\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        }\n      }\n    }\n    calcOf15minVal() {\n      var _a, _b, _c, _e, _f, _g, _h, _j, _k;\n      if (this.TimeFrame == 7) {\n        let len = 0;\n        let timeDuration = -24 * 60;\n        let that = this;\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        let qoeEndTime = moment((_a = history === null || history === void 0 ? void 0 : history.state) === null || _a === void 0 ? void 0 : _a.endTime[1]);\n        let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n        if (index === -1) {\n          //If time not matches and when new time ranges came while user coming to this page\n          let first = moment(this.timeIntervals[0].date);\n          let last = moment(this.timeIntervals[len - 1].date);\n          this.timeIntervals[0].date;\n          let j = 0;\n          let newIntervals = [];\n          if (qoeEndTime < first) {\n            //if qoe time is lesser than first value\n            while (qoeEndTime < first) {\n              newIntervals.push({\n                value: j,\n                legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                date: moment(qoeEndTime).toDate()\n              });\n              qoeEndTime.add(24, 'hours');\n              j++;\n            }\n            let newLen = newIntervals.length;\n            this.timeIntervals.map(t => t.value = t.value + newLen);\n            this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n            index = 0;\n          } else if (qoeEndTime < last) {\n            index = len;\n          }\n        }\n        this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          var _a;\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start;\n          let end;\n          if (parseInt(((_a = this.timeIntervals[this.selectedInterval]) === null || _a === void 0 ? void 0 : _a.legend.substring(11, 13)) || \"0\") % 24 == 0) {\n            start = moment(this.timeIntervals[this.selectedInterval].date).subtract(1, 'day').format('MMM DD hh:mm A');\n            end = moment(this.timeIntervals[this.selectedInterval].date).format('MMM DD hh:mm A');\n          } else {\n            start = moment(this.timeIntervals[this.selectedInterval - 1].date).format('MMM DD hh:mm A');\n            end = moment(this.timeIntervals[this.selectedInterval].date).format('MMM DD hh:mm A');\n          }\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n        };\n        this.timeIntervalOptions.translate = translate;\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(24, 'hours').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      } else if (this.TimeFrame == 4) {\n        var wkFrm = this.WeekFrame;\n        var z = this.WeekFrame;\n        // for (var z = 1; z <= 7; z++) {\n        if (z == 1) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_b = history === null || history === void 0 ? void 0 : history.state) === null || _b === void 0 ? void 0 : _b.endTime[0]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(180, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(165, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let start = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let end = pointersTime.add(165, 'minutes').format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(180, 'minutes').format('MMM DD hh:mm A');\n          // this.lastSeventhDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (z == 2) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_c = history === null || history === void 0 ? void 0 : history.state) === null || _c === void 0 ? void 0 : _c.endTime[0]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(180, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(165, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let start = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let end = pointersTime.add(165, 'minutes').format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(180, 'minutes').format('MMM DD hh:mm A');\n          // this.lastSixthDay = moment(this.timeIntervals[0].date).subtract(120, 'hours').format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (z == 3) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_e = history === null || history === void 0 ? void 0 : history.state) === null || _e === void 0 ? void 0 : _e.endTime[0]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(180, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(165, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let start = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let end = pointersTime.add(165, 'minutes').format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(180, 'minutes').format('MMM DD hh:mm A');\n          // this.lastfifthDay = moment(this.timeIntervals[0].date).subtract(96, 'hours').format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (z == 4) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_f = history === null || history === void 0 ? void 0 : history.state) === null || _f === void 0 ? void 0 : _f.endTime[0]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(180, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(165, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let start = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let end = pointersTime.add(165, 'minutes').format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(180, 'minutes').format('MMM DD hh:mm A');\n          // this.lastFourthDay = moment(this.timeIntervals[0].date).subtract(72, 'hours').format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (z == 5) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_g = history === null || history === void 0 ? void 0 : history.state) === null || _g === void 0 ? void 0 : _g.endTime[0]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(180, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(165, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let start = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let end = pointersTime.add(165, 'minutes').format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(180, 'minutes').format('MMM DD hh:mm A');\n          // this.lastThirdDay = moment(this.timeIntervals[0].date).subtract(48, 'hours').format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (z == 6) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_h = history === null || history === void 0 ? void 0 : history.state) === null || _h === void 0 ? void 0 : _h.endTime[0]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(180, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            // let start = pointersTime.subtract(165, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n            let start = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            let end = pointersTime.add(165, 'minutes').format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).add(180, 'minutes').format('MMM DD hh:mm A');\n          //  this.yesterDay = moment(this.timeIntervals[0].date).subtract(24, 'hours').format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        } else if (z == 7) {\n          let len = 0;\n          let timeDuration = -24 * 60;\n          let that = this;\n          len = this.timeIntervals.length;\n          this.selectedInterval = this.timeIntervals[len - 1].value;\n          //  if (history?.state?.endTime) {\n          let qoeEndTime = moment((_j = history === null || history === void 0 ? void 0 : history.state) === null || _j === void 0 ? void 0 : _j.endTime[2]);\n          let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n          if (index === -1) {\n            //If time not matches and when new time ranges came while user coming to this page\n            let first = moment(this.timeIntervals[0].date);\n            let last = moment(this.timeIntervals[len - 1].date);\n            this.timeIntervals[0].date;\n            let j = 0;\n            let newIntervals = [];\n            if (qoeEndTime < first) {\n              //if qoe time is lesser than first value\n              while (qoeEndTime < first) {\n                newIntervals.push({\n                  value: j,\n                  legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                  date: moment(qoeEndTime).toDate()\n                });\n                qoeEndTime.add(15, 'minutes');\n                j++;\n              }\n              let newLen = newIntervals.length;\n              this.timeIntervals.map(t => t.value = t.value + newLen);\n              this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n              index = 0;\n            } else if (qoeEndTime < last) {\n              index = len;\n            }\n          }\n          this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n          this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n          const translate = (value, label) => {\n            let pointersTime = moment(that.timeIntervals[value]['date']);\n            if (parseInt(this.timeIntervals[this.selectedInterval].legend.substring(11, 13) || \"0\") % 3 == 0) {\n              var start;\n              var end;\n              start = pointersTime.subtract(180, 'minutes').format('MMM DD hh:mm A');\n              end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n            } else {\n              // start = pointersTime.subtract(minToRoundOf24hr, 'minutes').format('MMM DD hh:mm A');\n              start = moment(this.timeIntervals[len - 2].date).format('MMM DD hh:mm A');\n              end = moment(that.timeIntervals[value]['date']).subtract(15, 'minutes').format('MMM DD hh:mm A');\n            }\n            // let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A');\n            // let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n            return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n          };\n          this.timeIntervalOptions.translate = translate;\n          this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(15, 'minutes').format('MMM DD hh:mm A');\n          this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n          // this.toDay = moment(this.timeIntervals[0].date).format('dddd');\n          setTimeout(() => {\n            this.showIntervalSlider = true;\n            setTimeout(() => {\n              $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n            }, 10);\n          }, 1000);\n        }\n        // }\n        setTimeout(() => {\n          this.WeekFramedata = [{\n            id: 1,\n            name: this.language[this.lastSeventhDay]\n          }, {\n            id: 2,\n            name: this.language[this.lastSixthDay]\n          }, {\n            id: 3,\n            name: this.language[this.lastfifthDay]\n          }, {\n            id: 4,\n            name: this.language[this.lastFourthDay]\n          }, {\n            id: 5,\n            name: this.language[this.lastThirdDay]\n          }, {\n            id: 6,\n            name: this.language[this.yesterDay]\n          }, {\n            id: 7,\n            name: this.language[this.toDay]\n          }];\n        }, 2000);\n      } else {\n        let len = 0;\n        let timeDuration = -24 * 60;\n        let that = this;\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        //  if (history?.state?.endTime) {\n        let qoeEndTime = moment((_k = history === null || history === void 0 ? void 0 : history.state) === null || _k === void 0 ? void 0 : _k.endTime[1]);\n        let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n        if (index === -1) {\n          //If time not matches and when new time ranges came while user coming to this page\n          let first = moment(this.timeIntervals[0].date);\n          let last = moment(this.timeIntervals[len - 1].date);\n          this.timeIntervals[0].date;\n          let j = 0;\n          let newIntervals = [];\n          if (qoeEndTime < first) {\n            //if qoe time is lesser than first value\n            while (qoeEndTime < first) {\n              newIntervals.push({\n                value: j,\n                legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                date: moment(qoeEndTime).toDate()\n              });\n              qoeEndTime.add(15, 'minutes');\n              j++;\n            }\n            let newLen = newIntervals.length;\n            this.timeIntervals.map(t => t.value = t.value + newLen);\n            this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n            index = 0;\n          } else if (qoeEndTime < last) {\n            //if qoe time is lesser than last value\n            // this.timeIntervals[len - 1] = {\n            //   value: len - 1, legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n            //   date: moment(qoeEndTime).toDate()\n            // }\n            // this.timeIntervals[len] = {\n            //   value: len, legend: moment(last).format('MM/DD/YYYY HH:mm'),\n            //   date: moment(last).toDate()\n            // }\n            //let inssertIndex = \n            // for (let k = 0; k < len; k++) {\n            // }\n            index = len;\n          }\n        }\n        this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n        // console.log(index);\n        // console.log(this.selectedInterval);\n        // }\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n        };\n        this.timeIntervalOptions.translate = translate;\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(60, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      }\n    }\n    calcOf15minVal1() {\n      {\n        let len = 0;\n        let timeDuration = -24 * 60;\n        let that = this;\n        len = this.timeIntervals.length;\n        this.selectedInterval = this.timeIntervals[len - 1].value;\n        //  if (history?.state?.endTime) {\n        let qoeEndTime = moment(this.inputs.startTime);\n        let index = this.timeIntervals.findIndex(time => moment(time.date).isSame(qoeEndTime));\n        if (index === -1) {\n          //If time not matches and when new time ranges came while user coming to this page\n          let first = moment(this.timeIntervals[0].date);\n          let last = moment(this.timeIntervals[len - 1].date);\n          this.timeIntervals[0].date;\n          let j = 0;\n          let newIntervals = [];\n          if (qoeEndTime < first) {\n            //if qoe time is lesser than first value\n            while (qoeEndTime < first) {\n              newIntervals.push({\n                value: j,\n                legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n                date: moment(qoeEndTime).toDate()\n              });\n              qoeEndTime.add(15, 'minutes');\n              j++;\n            }\n            let newLen = newIntervals.length;\n            this.timeIntervals.map(t => t.value = t.value + newLen);\n            this.timeIntervals = [...newIntervals, ...this.timeIntervals];\n            index = 0;\n          } else if (qoeEndTime < last) {\n            //if qoe time is lesser than last value\n            // this.timeIntervals[len - 1] = {\n            //   value: len - 1, legend: moment(qoeEndTime).format('MM/DD/YYYY HH:mm'),\n            //   date: moment(qoeEndTime).toDate()\n            // }\n            // this.timeIntervals[len] = {\n            //   value: len, legend: moment(last).format('MM/DD/YYYY HH:mm'),\n            //   date: moment(last).toDate()\n            // }\n            //let inssertIndex = \n            // for (let k = 0; k < len; k++) {\n            // }\n            index = len;\n          }\n        }\n        this.selectedInterval = this.timeIntervals[index] ? this.timeIntervals[index + 1].value : this.timeIntervals[this.timeIntervals.length - 1].value;\n        // console.log(index);\n        // console.log(this.selectedInterval);\n        // }\n        this.timeIntervalOptions.stepsArray = [...this.timeIntervals];\n        const translate = (value, label) => {\n          let pointersTime = moment(that.timeIntervals[value]['date']);\n          let start = pointersTime.subtract(15, 'minutes').format('MMM DD hh:mm A');\n          let end = moment(that.timeIntervals[value]['date']).format('MMM DD hh:mm A');\n          return `<span id=\"slider-click-prev\" class=\"point-${value} dir-arrows\" ></span> ${start} - ${end} <span id=\"slider-click-next\" class=\"point-${value} dir-arrows\"></span>`;\n        };\n        this.timeIntervalOptions.translate = translate;\n        this.leftSliderTime = moment(this.timeIntervals[0].date).subtract(15, 'minutes').format('MMM DD hh:mm A');\n        this.rightSliderTime = moment(this.timeIntervals[len - 1].date).format('MMM DD hh:mm A');\n        setTimeout(() => {\n          this.showIntervalSlider = true;\n          setTimeout(() => {\n            $('.multi-point-slider .ngx-slider-pointer-min').attr('title', 'Drag to select Time frame');\n          }, 10);\n        }, 1000);\n      }\n    }\n    getISOString(time) {\n      return time.toISOString().substr(0, 16) + ':00';\n    }\n  }\n  EfficiencyComponent.ɵfac = function EfficiencyComponent_Factory(t) {\n    return new (t || EfficiencyComponent)(i0.ɵɵdirectiveInject(i1.TranslateService), i0.ɵɵdirectiveInject(i2.DataServiceService), i0.ɵɵdirectiveInject(i3.DeviceService), i0.ɵɵdirectiveInject(i4.SsoAuthService));\n  };\n  EfficiencyComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: EfficiencyComponent,\n    selectors: [[\"app-efficiency\"]],\n    hostBindings: function EfficiencyComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function EfficiencyComponent_click_HostBindingHandler($event) {\n          return ctx.inClick($event);\n        });\n      }\n    },\n    inputs: {\n      index: \"index\"\n    },\n    decls: 19,\n    vars: 11,\n    consts: [[\"class\", \"w-100 alert alert alert-danger fade show\", 4, \"ngIf\"], [1, \"row\", \"my-2\"], [\"class\", \"col-md-12 col-lg-3 col-xl-3\", 4, \"ngIf\"], [\"class\", \"col-md-12 col-lg-2 col-xl-2 cus-select-height-24\", 4, \"ngIf\"], [\"class\", \"row mb-3\", 4, \"ngIf\"], [\"class\", \"time-frame-section mb-3 p-0\", \"style\", \"min-height: 100px;\", 4, \"ngIf\"], [1, \"row\", \"mb-3\"], [1, \"col-md-12\"], [\"id\", \"devie-client-eff\", 1, \"ccl-Secondary-title\", \"border-bottom\", \"mb-4\"], [1, \"\"], [\"class\", \"loader-wrapper-info\", 4, \"ngIf\"], [\"id\", \"wholeHomeEfficiencyChart\", 1, \"chart-box\", 2, \"height\", \"400px\"], [1, \"row\", \"d-flex\", \"justify-content-center\"], [1, \"serviceLegend\", \"mr-1\", 2, \"background-color\", \"#0a77fb\"], [1, \"cursor-pointer\", \"mr-2\", 3, \"ngClass\", \"click\"], [1, \"w-100\", \"alert\", \"alert\", \"alert-danger\", \"fade\", \"show\"], [1, \"error-img\"], [\"src\", \"./assets/img/ic_error-36px.svg\"], [\"type\", \"button\", 1, \"close\", 3, \"click\"], [1, \"col-md-12\", \"col-lg-3\", \"col-xl-3\"], [1, \"f-s-14px\", \"mb-0\"], [\"bindLabel\", \"name\", \"bindValue\", \"id\", 3, \"clearable\", \"searchable\", \"items\", \"ngModel\", \"change\", \"ngModelChange\"], [1, \"col-md-12\", \"col-lg-2\", \"col-xl-2\", \"cus-select-height-24\"], [1, \"col-md-3\"], [\"bindLabel\", \"name\", \"bindValue\", \"id\", 3, \"items\", \"ngModel\", \"ngModelChange\"], [\"class\", \"col-md-2\", 4, \"ngIf\"], [\"class\", \"col-md-2 form-check\", 4, \"ngIf\"], [1, \"col-md-3\", \"col-lg-3\", \"text-right\", \"btns-con\", \"smy-2\", 2, \"margin-top\", \"40px\"], [1, \"d-inline-flex\", \"mr-3\"], [\"type\", \"button\", 1, \"btn-default\", \"primary\", \"px-3\", 3, \"click\"], [1, \"col-md-2\"], [\"id\", \"week_Date\", \"appendTo\", \"body\", \"placeholder\", \"weekDate\", \"value\", \"#{dateBean.date}\", 1, \"ccl-form\", 3, \"inputStyle\", \"autoZIndex\", \"ngModel\", \"showIcon\", \"ngModelOptions\", \"ngModelChange\"], [1, \"col-md-2\", \"form-check\"], [\"id\", \"start_date\", \"appendTo\", \"body\", \"placeholder\", \"Time\", \"hourFormat\", \"12\", 1, \"ccl-form\", 3, \"ngModel\", \"stepMinute\", \"inputStyle\", \"autoZIndex\", \"showIcon\", \"ngModelOptions\", \"timeOnly\", \"panelStyleClass\", \"ngModelChange\", \"onSelect\"], [\"id\", \"end_date\", \"appendTo\", \"body\", \"placeholder\", \"Time\", \"hourFormat\", \"12\", 1, \"ccl-form\", 3, \"stepMinute\", \"inputStyle\", \"autoZIndex\", \"ngModel\", \"showIcon\", \"ngModelOptions\", \"timeOnly\", \"disabled\", \"panelStyleClass\", \"ngModelChange\", \"onSelect\"], [1, \"time-frame-section\", \"mb-3\", \"p-0\", 2, \"min-height\", \"100px\"], [\"class\", \"multi-point-slider\", 4, \"ngIf\"], [1, \"loader-wrapper-info\"], [1, \"loader\"], [1, \"d-flex\", \"justify-content-center\"], [1, \"spinner-border\", \"text-primary\"], [1, \"sr-only\"], [1, \"multi-point-slider\"], [3, \"value\", \"options\", \"valueChange\", \"userChangeEnd\"], [1, \"left-most-slider-time\"], [1, \"right-most-slider-time\"], [1, \"col-md-3\", \"col-lg-3\", \"text-left\", \"btns-con\", \"smy-2\", 2, \"margin-top\", \"15px\"]],\n    template: function EfficiencyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"section\");\n        i0.ɵɵtemplate(1, EfficiencyComponent_div_1_Template, 6, 1, \"div\", 0);\n        i0.ɵɵelementStart(2, \"div\", 1);\n        i0.ɵɵtemplate(3, EfficiencyComponent_div_3_Template, 4, 5, \"div\", 2);\n        i0.ɵɵtemplate(4, EfficiencyComponent_div_4_Template, 4, 4, \"div\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, EfficiencyComponent_div_5_Template, 12, 7, \"div\", 4);\n        i0.ɵɵtemplate(6, EfficiencyComponent_section_6_Template, 4, 3, \"section\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"section\");\n        i0.ɵɵelementStart(8, \"div\", 6);\n        i0.ɵɵelementStart(9, \"div\", 7);\n        i0.ɵɵelementStart(10, \"div\", 8);\n        i0.ɵɵtext(11);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(12, \"div\", 9);\n        i0.ɵɵtemplate(13, EfficiencyComponent_div_13_Template, 6, 1, \"div\", 10);\n        i0.ɵɵelement(14, \"div\", 11);\n        i0.ɵɵelementStart(15, \"div\", 12);\n        i0.ɵɵelement(16, \"span\", 13);\n        i0.ɵɵelementStart(17, \"span\", 14);\n        i0.ɵɵlistener(\"click\", function EfficiencyComponent_Template_span_click_17_listener() {\n          return ctx.filterContent();\n        });\n        i0.ɵɵtext(18);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isDateAreEqual);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.dropdownModel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.TimeFrame == 4);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.TimeFrame == 6 || ctx.TimeFrame == 4 || ctx.TimeFrame == 7);\n        i0.ɵɵadvance(5);\n        i0.ɵɵtextInterpolate1(\" \", ctx.language[\"Client Efficiency\"], \" \");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.loader);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(9, _c3, !ctx.effDash));\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.language.Efficiency);\n      }\n    },\n    directives: [i5.NgIf, i5.NgClass, i6.NgSelectComponent, i7.NgControlStatus, i7.NgModel, i8.Calendar, i9.ɵa],\n    styles: [\".hideMin[_ngcontent-%COMP%]   .p-minute-picker[_ngcontent-%COMP%]{color:gray;cursor:not-allowed!important;text-decoration:none}.hideMin[_ngcontent-%COMP%]   .p-minute-picker[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{cursor:not-allowed!important;color:gray}.loader-wrapper[_ngcontent-%COMP%]{position:relative}.loader-wrapper-info[_ngcontent-%COMP%]{transform:translate(-50%,-50%);top:50%;left:50%;position:absolute;width:100%;z-index:100;height:100%}.legendSolid[_ngcontent-%COMP%]{width:20px;height:3px;border-top:2px solid #0a77fb;margin-top:.8rem!important}.serviceLegend[_ngcontent-%COMP%]{width:13px;height:13px;margin-top:.4rem!important;border-radius:50%}.opac[_ngcontent-%COMP%]{opacity:.5}.time-frame-section[_ngcontent-%COMP%]{padding:2px 0 1px 140px;position:relative}.time-frame-section[_ngcontent-%COMP%]   .left-label[_ngcontent-%COMP%]{position:absolute;left:0;top:25px;font-size:16px}.time-frame-section[_ngcontent-%COMP%]   .left-label[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{margin-bottom:-8px!important;display:block}.time-frame-section[_ngcontent-%COMP%]   .left-label[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#9e9e9e;font-size:12px}  .multi-point-slider .ngx-slider-bar{height:5px!important;background:#EBEAEF!important;border-radius:6px}  .multi-point-slider .ngx-slider .ngx-slider-bubble{color:#4c4c4c!important;font-size:14px!important;font-weight:600;bottom:8px!important;padding:0 15px!important}  .multi-point-slider .ngx-slider-pointer{background-color:#0279ff!important;cursor:pointer;width:32px!important;height:12px!important;top:-3px!important}  .multi-point-slider .ngx-slider-pointer:after{display:none}  .multi-point-slider{position:relative}  .multi-point-slider .left-most-slider-time,   .multi-point-slider .right-most-slider-time{position:absolute;color:#4c4c4c;font-size:12px;font-weight:normal;bottom:-16px}  .multi-point-slider .left-most-slider-time{left:0}  .multi-point-slider .right-most-slider-time{right:0}  .dir-arrows{cursor:pointer;position:absolute;top:5px;right:0;z-index:999;background-repeat:no-repeat!important;width:20px;height:15px}  #slider-click-next{background:url(ic_chevronright_blue.fd81c30020686fc07c55.svg);background-position:14px 0px!important}  #slider-click-prev{background:url(ic_chevronleft_blue.fe45f1210cc5f8e5cadf.svg);left:0}\"]\n  });\n  return EfficiencyComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}