{"ast":null,"code":"import { assign, find, forEach, isArray, isNumber, map, matchPattern, omit, sortBy } from 'min-dash';\nimport { getBBox, getParents } from '../../util/Elements';\nimport { eachElement } from '../../util/Elements';\n\n/**\n * @typedef {Function} <copyPaste.canCopyElements> listener\n *\n * @param {Object} context\n * @param {Array<djs.model.Base>} context.elements\n *\n * @returns {Array<djs.model.Base>|boolean} - Return elements to be copied or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <copyPaste.copyElement> listener\n *\n * @param {Object} context\n * @param {Object} context.descriptor\n * @param {djs.model.Base} context.element\n * @param {Array<djs.model.Base>} context.elements\n */\n\n/**\n * @typedef {Function} <copyPaste.elementsCopied> listener\n *\n * @param {Object} context\n * @param {Object} context.elements\n * @param {Object} context.tree\n */\n\n/**\n * @typedef {Function} <copyPaste.pasteElement> listener\n *\n * @param {Object} context\n * @param {Object} context.cache - Already created elements.\n * @param {Object} context.descriptor\n */\n\n/**\n * @typedef {Function} <copyPaste.pasteElements> listener\n *\n * @param {Object} context\n * @param {Object} context.hints - Add hints before pasting.\n */\n\n/**\n * Copy and paste elements.\n *\n * @param {Canvas} canvas\n * @param {Create} create\n * @param {Clipboard} clipboard\n * @param {ElementFactory} elementFactory\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Mouse} mouse\n * @param {Rules} rules\n */\nexport default function CopyPaste(canvas, create, clipboard, elementFactory, eventBus, modeling, mouse, rules) {\n  this._canvas = canvas;\n  this._create = create;\n  this._clipboard = clipboard;\n  this._elementFactory = elementFactory;\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._mouse = mouse;\n  this._rules = rules;\n  eventBus.on('copyPaste.copyElement', function (context) {\n    var descriptor = context.descriptor,\n      element = context.element,\n      elements = context.elements;\n\n    // default priority (priority = 1)\n    descriptor.priority = 1;\n    descriptor.id = element.id;\n    var parentCopied = find(elements, function (e) {\n      return e === element.parent;\n    });\n\n    // do NOT reference parent if parent wasn't copied\n    if (parentCopied) {\n      descriptor.parent = element.parent.id;\n    }\n\n    // attachers (priority = 2)\n    if (isAttacher(element)) {\n      descriptor.priority = 2;\n      descriptor.host = element.host.id;\n    }\n\n    // connections (priority = 3)\n    if (isConnection(element)) {\n      descriptor.priority = 3;\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n      descriptor.waypoints = copyWaypoints(element);\n    }\n\n    // labels (priority = 4)\n    if (isLabel(element)) {\n      descriptor.priority = 4;\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n    forEach(['x', 'y', 'width', 'height'], function (property) {\n      if (isNumber(element[property])) {\n        descriptor[property] = element[property];\n      }\n    });\n    descriptor.hidden = element.hidden;\n    descriptor.collapsed = element.collapsed;\n  });\n  eventBus.on('copyPaste.pasteElements', function (context) {\n    var hints = context.hints;\n    assign(hints, {\n      createElementsBehavior: false\n    });\n  });\n}\nCopyPaste.$inject = ['canvas', 'create', 'clipboard', 'elementFactory', 'eventBus', 'modeling', 'mouse', 'rules'];\n\n/**\n * Copy elements.\n *\n * @param {Array<djs.model.Base>} elements\n *\n * @returns {Object}\n */\nCopyPaste.prototype.copy = function (elements) {\n  var allowed, tree;\n  if (!isArray(elements)) {\n    elements = elements ? [elements] : [];\n  }\n  allowed = this._eventBus.fire('copyPaste.canCopyElements', {\n    elements: elements\n  });\n  if (allowed === false) {\n    tree = {};\n  } else {\n    tree = this.createTree(isArray(allowed) ? allowed : elements);\n  }\n\n  // we set an empty tree, selection of elements\n  // to copy was empty.\n  this._clipboard.set(tree);\n  this._eventBus.fire('copyPaste.elementsCopied', {\n    elements: elements,\n    tree: tree\n  });\n  return tree;\n};\n\n/**\n * Paste elements.\n *\n * @param {Object} [context]\n * @param {djs.model.base} [context.element] - Parent.\n * @param {Point} [context.point] - Position.\n * @param {Object} [context.hints] - Hints.\n */\nCopyPaste.prototype.paste = function (context) {\n  var tree = this._clipboard.get();\n  if (this._clipboard.isEmpty()) {\n    return;\n  }\n  var hints = context && context.hints || {};\n  this._eventBus.fire('copyPaste.pasteElements', {\n    hints: hints\n  });\n  var elements = this._createElements(tree);\n\n  // paste directly\n  if (context && context.element && context.point) {\n    return this._paste(elements, context.element, context.point, hints);\n  }\n  this._create.start(this._mouse.getLastMoveEvent(), elements, {\n    hints: hints || {}\n  });\n};\n\n/**\n * Paste elements directly.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {djs.model.base} target\n * @param {Point} position\n * @param {Object} [hints]\n */\nCopyPaste.prototype._paste = function (elements, target, position, hints) {\n  // make sure each element has x and y\n  forEach(elements, function (element) {\n    if (!isNumber(element.x)) {\n      element.x = 0;\n    }\n    if (!isNumber(element.y)) {\n      element.y = 0;\n    }\n  });\n  var bbox = getBBox(elements);\n\n  // center elements around cursor\n  forEach(elements, function (element) {\n    if (isConnection(element)) {\n      element.waypoints = map(element.waypoints, function (waypoint) {\n        return {\n          x: waypoint.x - bbox.x - bbox.width / 2,\n          y: waypoint.y - bbox.y - bbox.height / 2\n        };\n      });\n    }\n    assign(element, {\n      x: element.x - bbox.x - bbox.width / 2,\n      y: element.y - bbox.y - bbox.height / 2\n    });\n  });\n  return this._modeling.createElements(elements, position, target, assign({}, hints));\n};\n\n/**\n * Create elements from tree.\n */\nCopyPaste.prototype._createElements = function (tree) {\n  var self = this;\n  var eventBus = this._eventBus;\n  var cache = {};\n  var elements = [];\n  forEach(tree, function (branch, depth) {\n    depth = parseInt(depth, 10);\n\n    // sort by priority\n    branch = sortBy(branch, 'priority');\n    forEach(branch, function (descriptor) {\n      // remove priority\n      var attrs = assign({}, omit(descriptor, ['priority']));\n      if (cache[descriptor.parent]) {\n        attrs.parent = cache[descriptor.parent];\n      } else {\n        delete attrs.parent;\n      }\n      eventBus.fire('copyPaste.pasteElement', {\n        cache: cache,\n        descriptor: attrs\n      });\n      var element;\n      if (isConnection(attrs)) {\n        attrs.source = cache[descriptor.source];\n        attrs.target = cache[descriptor.target];\n        element = cache[descriptor.id] = self.createConnection(attrs);\n        elements.push(element);\n        return;\n      }\n      if (isLabel(attrs)) {\n        attrs.labelTarget = cache[attrs.labelTarget];\n        element = cache[descriptor.id] = self.createLabel(attrs);\n        elements.push(element);\n        return;\n      }\n      if (attrs.host) {\n        attrs.host = cache[attrs.host];\n      }\n      element = cache[descriptor.id] = self.createShape(attrs);\n      elements.push(element);\n    });\n  });\n  return elements;\n};\nCopyPaste.prototype.createConnection = function (attrs) {\n  var connection = this._elementFactory.createConnection(omit(attrs, ['id']));\n  return connection;\n};\nCopyPaste.prototype.createLabel = function (attrs) {\n  var label = this._elementFactory.createLabel(omit(attrs, ['id']));\n  return label;\n};\nCopyPaste.prototype.createShape = function (attrs) {\n  var shape = this._elementFactory.createShape(omit(attrs, ['id']));\n  return shape;\n};\n\n/**\n * Check wether element has relations to other elements e.g. attachers, labels and connections.\n *\n * @param  {Object} element\n * @param  {Array<djs.model.Base>} elements\n *\n * @returns {boolean}\n */\nCopyPaste.prototype.hasRelations = function (element, elements) {\n  var labelTarget, source, target;\n  if (isConnection(element)) {\n    source = find(elements, matchPattern({\n      id: element.source.id\n    }));\n    target = find(elements, matchPattern({\n      id: element.target.id\n    }));\n    if (!source || !target) {\n      return false;\n    }\n  }\n  if (isLabel(element)) {\n    labelTarget = find(elements, matchPattern({\n      id: element.labelTarget.id\n    }));\n    if (!labelTarget) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Create a tree-like structure from elements.\n *\n * @example\n * tree: {\n  *  0: [\n  *    { id: 'Shape_1', priority: 1, ... },\n  *    { id: 'Shape_2', priority: 1, ... },\n  *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },\n  *    ...\n  *  ],\n  *  1: [\n  *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },\n  *    ...\n  *  ]\n  * };\n  *\n  * @param  {Array<djs.model.base>} elements\n  *\n  * @return {Object}\n  */\nCopyPaste.prototype.createTree = function (elements) {\n  var rules = this._rules,\n    self = this;\n  var tree = {},\n    elementsData = [];\n  var parents = getParents(elements);\n  function canCopy(element, elements) {\n    return rules.allowed('element.copy', {\n      element: element,\n      elements: elements\n    });\n  }\n  function addElementData(element, depth) {\n    // (1) check wether element has already been added\n    var foundElementData = find(elementsData, function (elementsData) {\n      return element === elementsData.element;\n    });\n\n    // (2) add element if not already added\n    if (!foundElementData) {\n      elementsData.push({\n        element: element,\n        depth: depth\n      });\n      return;\n    }\n\n    // (3) update depth\n    if (foundElementData.depth < depth) {\n      elementsData = removeElementData(foundElementData, elementsData);\n      elementsData.push({\n        element: foundElementData.element,\n        depth: depth\n      });\n    }\n  }\n  function removeElementData(elementData, elementsData) {\n    var index = elementsData.indexOf(elementData);\n    if (index !== -1) {\n      elementsData.splice(index, 1);\n    }\n    return elementsData;\n  }\n\n  // (1) add elements\n  eachElement(parents, function (element, _index, depth) {\n    // do NOT add external labels directly\n    if (isLabel(element)) {\n      return;\n    }\n\n    // always copy external labels\n    forEach(element.labels, function (label) {\n      addElementData(label, depth);\n    });\n    function addRelatedElements(elements) {\n      elements && elements.length && forEach(elements, function (element) {\n        // add external labels\n        forEach(element.labels, function (label) {\n          addElementData(label, depth);\n        });\n        addElementData(element, depth);\n      });\n    }\n    forEach([element.attachers, element.incoming, element.outgoing], addRelatedElements);\n    addElementData(element, depth);\n    return element.children;\n  });\n  elements = map(elementsData, function (elementData) {\n    return elementData.element;\n  });\n\n  // (2) copy elements\n  elementsData = map(elementsData, function (elementData) {\n    elementData.descriptor = {};\n    self._eventBus.fire('copyPaste.copyElement', {\n      descriptor: elementData.descriptor,\n      element: elementData.element,\n      elements: elements\n    });\n    return elementData;\n  });\n\n  // (3) sort elements by priority\n  elementsData = sortBy(elementsData, function (elementData) {\n    return elementData.descriptor.priority;\n  });\n  elements = map(elementsData, function (elementData) {\n    return elementData.element;\n  });\n\n  // (4) create tree\n  forEach(elementsData, function (elementData) {\n    var depth = elementData.depth;\n    if (!self.hasRelations(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n      return;\n    }\n    if (!canCopy(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n      return;\n    }\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n    tree[depth].push(elementData.descriptor);\n  });\n  return tree;\n};\n\n// helpers //////////\n\nfunction isAttacher(element) {\n  return !!element.host;\n}\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}\nfunction copyWaypoints(element) {\n  return map(element.waypoints, function (waypoint) {\n    waypoint = copyWaypoint(waypoint);\n    if (waypoint.original) {\n      waypoint.original = copyWaypoint(waypoint.original);\n    }\n    return waypoint;\n  });\n}\nfunction copyWaypoint(waypoint) {\n  return assign({}, waypoint);\n}\nfunction removeElement(element, elements) {\n  var index = elements.indexOf(element);\n  if (index === -1) {\n    return elements;\n  }\n  return elements.splice(index, 1);\n}","map":null,"metadata":{},"sourceType":"module"}