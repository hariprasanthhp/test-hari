{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let IPv6AddressService = /*#__PURE__*/(() => {\n  class IPv6AddressService {\n    constructor() {}\n    /*\r\n     * is a valid IPv6 CIDR, e.g., \"2017::1/64\"\r\n     */\n    isIpv6CIDR(subnet) {\n      // is standard CIDR or compressed CIDR\n      return /^([0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}\\/([1-9]|[1-9][0-9]|[1][0-1][0-9]|[1][2][0-8])\\,*)+$/.test(subnet) || /^((([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})?)::(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})?)\\/([1-9]|[1-9][0-9]|[1][0-1][0-9]|[1][2][0-8])\\,*)+$/.test(subnet);\n    }\n    /*\r\n     * is a valid IPv6 address, e.g., \"2017::1\"\r\n     */\n    isIpv6Address(ipAddress) {\n      // is standard address or compressed address\n      return /^[0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}$/.test(ipAddress) || /^(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})?)::(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})?)$/.test(ipAddress);\n    }\n    /*\r\n     * padding a section of IPv6 address, which is seperated by \":\"\r\n     */\n    padSection(section, len) {\n      var padding = \"0\".repeat(len);\n      if (section.length < padding.length) {\n        section = padding.substring(0, padding.length - section.length) + section;\n      }\n      return section;\n    }\n    bin2HexOfSection(binStr) {\n      return parseInt(binStr, 2).toString(16);\n    }\n    hex2BinOfSection(hexStr) {\n      return parseInt(hexStr, 16).toString(2);\n    }\n    bin2HexOfAddress(binStr) {\n      var addr = [];\n      for (var i = 0; i < 128; i += 16) {\n        var binPart = binStr.substring(i, i + 16);\n        var hexSection = this.padSection(this.bin2HexOfSection(binPart), 4);\n        addr.push(hexSection);\n      }\n      return addr.join(':');\n    }\n    hex2BinOfAddress(hexStr) {\n      var nAddr = this.normalize(hexStr);\n      var sections = nAddr.split(\":\");\n      var binAddr = '';\n      for (var i = 0; i < sections.length; i++) {\n        binAddr += this.padSection(this.hex2BinOfSection(sections[i]), 16);\n      }\n      return binAddr;\n    }\n    /**\r\n     * compress the given ip address to shortest form\r\n     * @param ip\r\n     * @returns {string}\r\n     */\n    abbreviate(ip) {\n      if (!this.isIpv6Address(ip)) {\n        //throw new Error('Invalid address: ' + a);\n      }\n      // convert std format, e.g., 1:2:3:4:5:0:0:8\n      var stdAddr = \"\";\n      var nAddr = this.normalize(ip);\n      var sections = nAddr.split(\":\");\n      for (var i = 0; i < sections.length; i++) {\n        stdAddr += this.bin2HexOfSection(this.hex2BinOfSection(sections[i]));\n        if (i < sections.length - 1) {\n          stdAddr += \":\";\n        }\n      }\n      // to compress\n      var p = new RegExp(\"(:0){2,7}\", \"g\");\n      var oneMatch = p.exec(stdAddr);\n      var longestIndex = -1;\n      var len = -1;\n      if (oneMatch != null) {\n        longestIndex = oneMatch[\"index\"];\n        len = oneMatch[\"0\"].length;\n      }\n      while (oneMatch != null) {\n        oneMatch = p.exec(stdAddr);\n        if (oneMatch != null) {\n          if (oneMatch[\"0\"].length >= longestIndex) {\n            longestIndex = oneMatch[\"index\"];\n            len = oneMatch[\"0\"].length;\n          }\n        }\n      }\n      if (len > 2) {\n        if (longestIndex == 0) {\n          stdAddr = \"::\" + stdAddr.substring(len);\n        } else if (longestIndex + len >= stdAddr.length) {\n          stdAddr = stdAddr.substring(0, longestIndex) + \"::\";\n        } else {\n          stdAddr = stdAddr.substring(0, longestIndex) + \"::\" + stdAddr.substring(longestIndex + len + 1);\n          if (stdAddr.indexOf(\"0::\") == 0) {\n            stdAddr = stdAddr.substring(1);\n          }\n        }\n      }\n      return stdAddr;\n    }\n    /*\r\n     * normalize an IPv6 address, e.g., give \"cdc::123\", return \"0cdc:0000:0000:0000:0000:0000:0000:0123\"\r\n     */\n    normalize(a) {\n      if (!this.isIpv6Address(a)) {\n        throw new Error('Invalid address: ' + a);\n      }\n      var nh = a.split(/\\:\\:/g);\n      // if (nh.length > 2) {\n      //     throw new Error('Invalid address: ' + a);\n      // }\n      var sections = [];\n      if (nh.length == 1) {\n        // full mode\n        sections = a.split(/\\:/g);\n        if (sections.length !== 8) {\n          throw new Error('Invalid address: ' + a);\n        }\n      } else if (nh.length == 2) {\n        // compact mode\n        var n = nh[0];\n        var h = nh[1];\n        var ns = n.split(/\\:/g);\n        var hs = h.split(/\\:/g);\n        for (var i in ns) {\n          sections[i] = ns[i];\n        }\n        for (let i = hs.length; i > 0; --i) {\n          sections[7 - (hs.length - i)] = hs[i - 1];\n        }\n      }\n      for (let i = 0; i < 8; ++i) {\n        if (sections[i] === undefined) {\n          sections[i] = '0000';\n        }\n        sections[i] = this.padSection(sections[i], 4);\n      }\n      return sections.join(':');\n    }\n    /*\r\n     * Given an IPv6 address and its prefixe, return the range of this CIDR. e.g.,\r\n     * Given: ip=cdc::123, prefixe=64\r\n     * Return:\r\n     *  {\r\n     *    \"ipLowStr\":\"0cdc:0000:0000:0000:0000:0000:0000:0000\",\"ipHighStr\":\"0cdc:0000:0000:0000:ffff:ffff:ffff:ffff\"\r\n     *  }\r\n     */\n    range(ip, prefix) {\n      if (!this.isIpv6Address(ip)) {\n        throw new Error('Invalid address: ' + ip);\n      }\n      // parse HEX address to bin\n      var normalizedIp = this.normalize(ip);\n      var sections = normalizedIp.split(\":\");\n      var binAddr = \"\";\n      for (var i = 0; i < sections.length; i++) {\n        // parse HEX section[i] to binary and then left padding with \"0\"\n        binAddr += this.padSection(this.hex2BinOfSection(sections[i]), 16);\n      }\n      var mask1 = 128;\n      var binNet = binAddr.substring(0, prefix);\n      var binStart = binNet + \"0\".repeat(mask1 - prefix);\n      var binEnd = binNet + \"1\".repeat(mask1 - prefix);\n      return {\n        ipLowStr: this.bin2HexOfAddress(binStart),\n        ipHighStr: this.bin2HexOfAddress(binEnd)\n      };\n    }\n    /*\r\n     * Given an IPv6 address range, return the CIDR. e.g.,\r\n     * Given: \"ipLowStr\":\"0cdc:0000:0000:0000:0000:0000:0000:0000\",\"ipHighStr\":\"0cdc:0000:0000:0000:ffff:ffff:ffff:ffff\"\r\n     * Return:\r\n     *  {\r\n     *    {\"ipLowStr\":\"0cdc::\",\"prefixSize\":64}\r\n     *  }\r\n     */\n    cidr(ipLowStr, ipHighStr) {\n      if (!this.isIpv6Address(ipLowStr) || !this.isIpv6Address(ipHighStr)) {\n        throw new Error('Invalid address: ' + ipLowStr + \", \" + ipHighStr);\n      }\n      // to determine the prefix\n      var binLow = this.hex2BinOfAddress(ipLowStr);\n      var binHigh = this.hex2BinOfAddress(ipHighStr);\n      var prefix = 0;\n      for (var i = 0; i < binLow.length; i++) {\n        if (binLow[i] == binHigh[i]) {\n          prefix = i + 1;\n          continue;\n        }\n        break;\n      }\n      return {\n        ipLowStr: this.abbreviate(ipLowStr),\n        prefixSize: prefix\n      };\n    }\n  }\n  IPv6AddressService.ɵfac = function IPv6AddressService_Factory(t) {\n    return new (t || IPv6AddressService)();\n  };\n  IPv6AddressService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: IPv6AddressService,\n    factory: IPv6AddressService.ɵfac,\n    providedIn: 'root'\n  });\n  return IPv6AddressService;\n})();","map":null,"metadata":{},"sourceType":"module"}