{"ast":null,"code":"import { pick, assign, filter, forEach, isArray, isUndefined, has } from 'min-dash';\nimport { is, getBusinessObject } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { isExpanded, isEventSubProcess } from '../../util/DiUtil';\nimport { getPropertyNames } from '../copy-paste/ModdleCopy';\nfunction copyProperties(source, target, properties) {\n  if (!isArray(properties)) {\n    properties = [properties];\n  }\n  forEach(properties, function (property) {\n    if (!isUndefined(source[property])) {\n      target[property] = source[property];\n    }\n  });\n}\nvar CUSTOM_PROPERTIES = ['cancelActivity', 'instantiate', 'eventGatewayType', 'triggeredByEvent', 'isInterrupting'];\nfunction toggeling(element, target) {\n  var oldCollapsed = element && has(element, 'collapsed') ? element.collapsed : !isExpanded(element);\n  var targetCollapsed;\n  if (target && (has(target, 'collapsed') || has(target, 'isExpanded'))) {\n    // property is explicitly set so use it\n    targetCollapsed = has(target, 'collapsed') ? target.collapsed : !target.isExpanded;\n  } else {\n    // keep old state\n    targetCollapsed = oldCollapsed;\n  }\n  if (oldCollapsed !== targetCollapsed) {\n    element.collapsed = oldCollapsed;\n    return true;\n  }\n  return false;\n}\n\n/**\n * This module takes care of replacing BPMN elements\n */\nexport default function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules, selection) {\n  /**\n   * Prepares a new business object for the replacement element\n   * and triggers the replace operation.\n   *\n   * @param  {djs.model.Base} element\n   * @param  {Object} target\n   * @param  {Object} [hints]\n   *\n   * @return {djs.model.Base} the newly created element\n   */\n  function replaceElement(element, target, hints) {\n    hints = hints || {};\n    var type = target.type,\n      oldBusinessObject = element.businessObject;\n    if (isSubProcess(oldBusinessObject)) {\n      if (type === 'bpmn:SubProcess') {\n        if (toggeling(element, target)) {\n          // expanding or collapsing process\n          modeling.toggleCollapse(element);\n          return element;\n        }\n      }\n    }\n    var newBusinessObject = bpmnFactory.create(type);\n    var newElement = {\n      type: type,\n      businessObject: newBusinessObject\n    };\n    var elementProps = getPropertyNames(oldBusinessObject.$descriptor),\n      newElementProps = getPropertyNames(newBusinessObject.$descriptor, true),\n      copyProps = intersection(elementProps, newElementProps);\n\n    // initialize special properties defined in target definition\n    assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));\n    var properties = filter(copyProps, function (propertyName) {\n      // copying event definitions, unless we replace\n      if (propertyName === 'eventDefinitions') {\n        return hasEventDefinition(element, target.eventDefinitionType);\n      }\n\n      // retain loop characteristics if the target element\n      // is not an event sub process\n      if (propertyName === 'loopCharacteristics') {\n        return !isEventSubProcess(newBusinessObject);\n      }\n\n      // so the applied properties from 'target' don't get lost\n      if (has(newBusinessObject, propertyName)) {\n        return false;\n      }\n      if (propertyName === 'processRef' && target.isExpanded === false) {\n        return false;\n      }\n      if (propertyName === 'triggeredByEvent') {\n        return false;\n      }\n      return true;\n    });\n    newBusinessObject = moddleCopy.copyElement(oldBusinessObject, newBusinessObject, properties);\n\n    // initialize custom BPMN extensions\n    if (target.eventDefinitionType) {\n      // only initialize with new eventDefinition\n      // if we did not set an event definition yet,\n      // i.e. because we copied it\n      if (!hasEventDefinition(newBusinessObject, target.eventDefinitionType)) {\n        newElement.eventDefinitionType = target.eventDefinitionType;\n        newElement.eventDefinitionAttrs = target.eventDefinitionAttrs;\n      }\n    }\n    if (is(oldBusinessObject, 'bpmn:Activity')) {\n      if (isSubProcess(oldBusinessObject)) {\n        // no toggeling, so keep old state\n        newElement.isExpanded = isExpanded(oldBusinessObject);\n      }\n\n      // else if property is explicitly set, use it\n      else if (target && has(target, 'isExpanded')) {\n        newElement.isExpanded = target.isExpanded;\n      }\n\n      // TODO: need also to respect min/max Size\n      // copy size, from an expanded subprocess to an expanded alternative subprocess\n      // except bpmn:Task, because Task is always expanded\n      if (isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'bpmn:Task') && newElement.isExpanded) {\n        newElement.width = element.width;\n        newElement.height = element.height;\n      }\n    }\n\n    // remove children if not expanding sub process\n    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {\n      hints.moveChildren = false;\n    }\n\n    // transform collapsed/expanded pools\n    if (is(oldBusinessObject, 'bpmn:Participant')) {\n      // create expanded pool\n      if (target.isExpanded === true) {\n        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n      } else {\n        // remove children when transforming to collapsed pool\n        hints.moveChildren = false;\n      }\n\n      // apply same width and default height\n      newElement.width = element.width;\n      newElement.height = elementFactory._getDefaultSize(newBusinessObject).height;\n    }\n    if (!rules.allowed('shape.resize', {\n      shape: newBusinessObject\n    })) {\n      newElement.height = elementFactory._getDefaultSize(newBusinessObject).height;\n      newElement.width = elementFactory._getDefaultSize(newBusinessObject).width;\n    }\n    newBusinessObject.name = oldBusinessObject.name;\n\n    // retain default flow's reference between inclusive <-> exclusive gateways and activities\n    if (isAny(oldBusinessObject, ['bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway', 'bpmn:Activity']) && isAny(newBusinessObject, ['bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway', 'bpmn:Activity'])) {\n      newBusinessObject.default = oldBusinessObject.default;\n    }\n    if (target.host && !is(oldBusinessObject, 'bpmn:BoundaryEvent') && is(newBusinessObject, 'bpmn:BoundaryEvent')) {\n      newElement.host = target.host;\n    }\n\n    // The DataStoreReference element is 14px wider than the DataObjectReference element\n    // This ensures that they stay centered on the x axis when replaced\n    if (newElement.type === 'bpmn:DataStoreReference' || newElement.type === 'bpmn:DataObjectReference') {\n      newElement.x = element.x + (element.width - newElement.width) / 2;\n    }\n    newElement.di = {};\n\n    // fill and stroke will be set to DI\n    copyProperties(oldBusinessObject.di, newElement.di, ['fill', 'stroke']);\n    newElement = replace.replaceElement(element, newElement, hints);\n    if (hints.select !== false) {\n      selection.select(newElement);\n    }\n    return newElement;\n  }\n  this.replaceElement = replaceElement;\n}\nBpmnReplace.$inject = ['bpmnFactory', 'elementFactory', 'moddleCopy', 'modeling', 'replace', 'rules', 'selection'];\nfunction isSubProcess(bo) {\n  return is(bo, 'bpmn:SubProcess');\n}\nfunction hasEventDefinition(element, type) {\n  var bo = getBusinessObject(element);\n  return type && bo.get('eventDefinitions').some(function (definition) {\n    return is(definition, type);\n  });\n}\n\n/**\n * Compute intersection between two arrays.\n */\nfunction intersection(a1, a2) {\n  return a1.filter(function (el) {\n    return a2.indexOf(el) !== -1;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}