{"ast":null,"code":"import { flatten, filter, forEach, groupBy, map, unionBy } from 'min-dash';\nimport { saveClear } from '../../util/Removal';\nimport { getNewAttachShapeDelta } from '../../util/AttachUtil';\nimport inherits from 'inherits';\nimport CommandInterceptor from '../../command/CommandInterceptor';\nvar LOW_PRIORITY = 251,\n  HIGH_PRIORITY = 1401;\nvar MARKER_ATTACH = 'attach-ok';\n\n/**\n * Adds the notion of attached elements to the modeler.\n *\n * Optionally depends on `diagram-js/lib/features/move` to render\n * the attached elements during move preview.\n *\n * Optionally depends on `diagram-js/lib/features/label-support`\n * to render attached labels during move preview.\n *\n * @param {didi.Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\nexport default function AttachSupport(injector, eventBus, canvas, rules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  var movePreview = injector.get('movePreview', false);\n\n  // remove all the attached elements from the shapes to be validated\n  // add all the attached shapes to the overall list of moved shapes\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function (e) {\n    var context = e.context,\n      shapes = context.shapes,\n      validatedShapes = context.validatedShapes;\n    context.shapes = addAttached(shapes);\n    context.validatedShapes = removeAttached(validatedShapes);\n  });\n\n  // add attachers to the visual's group\n  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function (e) {\n    var context = e.context,\n      shapes = context.shapes,\n      attachers = getAttachers(shapes);\n    forEach(attachers, function (attacher) {\n      movePreview.makeDraggable(context, attacher, true);\n      forEach(attacher.labels, function (label) {\n        movePreview.makeDraggable(context, label, true);\n      });\n    });\n  });\n\n  // add attach-ok marker to current host\n  movePreview && eventBus.on('shape.move.start', function (event) {\n    var context = event.context,\n      shapes = context.shapes;\n    if (shapes.length !== 1) {\n      return;\n    }\n    var shape = shapes[0];\n    var host = shape.host;\n    if (host) {\n      canvas.addMarker(host, MARKER_ATTACH);\n      eventBus.once(['shape.move.out', 'shape.move.cleanup'], function () {\n        canvas.removeMarker(host, MARKER_ATTACH);\n      });\n    }\n  });\n\n  // add all attachers to move closure\n  this.preExecuted('elements.move', HIGH_PRIORITY, function (e) {\n    var context = e.context,\n      closure = context.closure,\n      shapes = context.shapes,\n      attachers = getAttachers(shapes);\n    forEach(attachers, function (attacher) {\n      closure.add(attacher, closure.topLevel[attacher.host.id]);\n    });\n  });\n\n  // perform the attaching after shapes are done moving\n  this.postExecuted('elements.move', function (e) {\n    var context = e.context,\n      shapes = context.shapes,\n      newHost = context.newHost,\n      attachers;\n\n    // only single elements can be attached\n    // multiply elements can be detached\n    if (newHost && shapes.length !== 1) {\n      return;\n    }\n    if (newHost) {\n      attachers = shapes;\n    } else {\n      // find attachers moved without host\n      attachers = filter(shapes, function (shape) {\n        var host = shape.host;\n        return isAttacher(shape) && !includes(shapes, host);\n      });\n    }\n    forEach(attachers, function (attacher) {\n      modeling.updateAttachment(attacher, newHost);\n    });\n  });\n\n  // ensure invalid attachment connections are removed\n  this.postExecuted('elements.move', function (e) {\n    var shapes = e.context.shapes;\n    forEach(shapes, function (shape) {\n      forEach(shape.attachers, function (attacher) {\n        // remove invalid outgoing connections\n        forEach(attacher.outgoing.slice(), function (connection) {\n          var allowed = rules.allowed('connection.reconnect', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n\n        // remove invalid incoming connections\n        forEach(attacher.incoming.slice(), function (connection) {\n          var allowed = rules.allowed('connection.reconnect', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n      });\n    });\n  });\n  this.postExecute('shape.create', function (e) {\n    var context = e.context,\n      shape = context.shape,\n      host = context.host;\n    if (host) {\n      modeling.updateAttachment(shape, host);\n    }\n  });\n\n  // update attachments if the host is replaced\n  this.postExecute('shape.replace', function (e) {\n    var context = e.context,\n      oldShape = context.oldShape,\n      newShape = context.newShape;\n\n    // move the attachers to the new host\n    saveClear(oldShape.attachers, function (attacher) {\n      var allowed = rules.allowed('elements.move', {\n        target: newShape,\n        shapes: [attacher]\n      });\n      if (allowed === 'attach') {\n        modeling.updateAttachment(attacher, newShape);\n      } else {\n        modeling.removeShape(attacher);\n      }\n    });\n\n    // move attachers if new host has different size\n    if (newShape.attachers.length) {\n      forEach(newShape.attachers, function (attacher) {\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\n        modeling.moveShape(attacher, delta, attacher.parent);\n      });\n    }\n  });\n\n  // move shape on host resize\n  this.postExecute('shape.resize', function (event) {\n    var context = event.context,\n      shape = context.shape,\n      oldBounds = context.oldBounds,\n      newBounds = context.newBounds,\n      attachers = shape.attachers,\n      hints = context.hints || {};\n    if (hints.attachSupport === false) {\n      return;\n    }\n    forEach(attachers, function (attacher) {\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\n      modeling.moveShape(attacher, delta, attacher.parent);\n      forEach(attacher.labels, function (label) {\n        modeling.moveShape(label, delta, label.parent);\n      });\n    });\n  });\n\n  // remove attachments\n  this.preExecute('shape.delete', function (event) {\n    var shape = event.context.shape;\n    saveClear(shape.attachers, function (attacher) {\n      modeling.removeShape(attacher);\n    });\n    if (shape.host) {\n      modeling.updateAttachment(shape, null);\n    }\n  });\n}\ninherits(AttachSupport, CommandInterceptor);\nAttachSupport.$inject = ['injector', 'eventBus', 'canvas', 'rules', 'modeling'];\n\n/**\n * Return attachers of the given shapes\n *\n * @param {Array<djs.model.Base>} shapes\n * @return {Array<djs.model.Base>}\n */\nfunction getAttachers(shapes) {\n  return flatten(map(shapes, function (s) {\n    return s.attachers || [];\n  }));\n}\n\n/**\n * Return a combined list of elements and\n * attachers.\n *\n * @param {Array<djs.model.Base>} elements\n * @return {Array<djs.model.Base>} filtered\n */\nfunction addAttached(elements) {\n  var attachers = getAttachers(elements);\n  return unionBy('id', elements, attachers);\n}\n\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeAttached(elements) {\n  var ids = groupBy(elements, 'id');\n  return filter(elements, function (element) {\n    while (element) {\n      // host in selection\n      if (element.host && ids[element.host.id]) {\n        return false;\n      }\n      element = element.parent;\n    }\n    return true;\n  });\n}\nfunction isAttacher(shape) {\n  return !!shape.host;\n}\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}","map":null,"metadata":{},"sourceType":"module"}