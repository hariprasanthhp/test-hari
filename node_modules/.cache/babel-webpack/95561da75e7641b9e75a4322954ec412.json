{"ast":null,"code":"import BpmnRules from 'bpmn-js/lib/features/rules/BpmnRules';\nimport { find } from 'min-dash';\nimport { isLabel } from 'bpmn-js/lib/util/LabelUtil';\nimport { is, getBusinessObject } from 'bpmn-js/lib/util/ModelUtil';\nimport { isEventSubProcess } from 'bpmn-js/lib/util/DiUtil';\nimport { getBoundaryAttachment as isBoundaryAttachment } from 'bpmn-js/lib/features/snapping/BpmnSnappingUtil';\nconst HIGH_PRIORITY = 15000;\n\n/**\n * Zeebe rule provider that allows to create boundary events with catch events\n *\n * See {@link CustomRules} for the default implementation\n * of BPMN 2.0 modeling rules provided by bpmn-js.\n *\n * @param {EventBus} eventBus\n */\nlet CustomRules = /*#__PURE__*/(() => {\n  class CustomRules extends BpmnRules {\n    constructor(eventBus) {\n      super(eventBus);\n    }\n    init() {\n      super.init();\n      this.addRule('shape.attach', HIGH_PRIORITY, context => {\n        return this.canAttach(context.shape, context.target, null, context.position);\n      });\n    }\n    canAttach(elements, target, source, position) {\n      function isBoundaryEvent(element) {\n        return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n      }\n\n      /**\n       * In Zeebe we treat IntermediateCatchEvents as boundary events too,\n       * this must be reflected in the rules.\n       */\n      function isBoundaryCandidate(element) {\n        return isBoundaryEvent(element) || (is(element, 'bpmn:IntermediateCatchEvent') || is(element, 'bpmn:IntermediateThrowEvent')) && !element.parent;\n      }\n      function isForCompensation(e) {\n        return getBusinessObject(e).isForCompensation;\n      }\n      function isReceiveTaskAfterEventBasedGateway(element) {\n        return is(element, 'bpmn:ReceiveTask') && find(element.incoming, function (incoming) {\n          return is(incoming.source, 'bpmn:EventBasedGateway');\n        });\n      }\n      if (!Array.isArray(elements)) {\n        elements = [elements];\n      }\n\n      // disallow appending as boundary event\n      if (source) {\n        return false;\n      }\n\n      // only (re-)attach one element at a time\n      if (elements.length !== 1) {\n        return false;\n      }\n      const element = elements[0];\n\n      // do not attach labels\n      if (isLabel(element)) {\n        return false;\n      }\n\n      // only handle boundary events\n      if (!isBoundaryCandidate(element)) {\n        return false;\n      }\n\n      // allow default move operation\n      if (!target) {\n        return true;\n      }\n\n      // disallow drop on event sub processes\n      if (isEventSubProcess(target)) {\n        return false;\n      }\n\n      // only allow drop on non compensation activities\n      if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n        return false;\n      }\n\n      // only attach to subprocess border\n      if (position && !isBoundaryAttachment(position, target)) {\n        return false;\n      }\n\n      // do not attach on receive tasks after event based gateways\n      if (isReceiveTaskAfterEventBasedGateway(target)) {\n        return false;\n      }\n      return 'attach';\n    }\n  }\n  CustomRules.$inject = ['eventBus'];\n  return CustomRules;\n})();\nexport { CustomRules as default };","map":null,"metadata":{},"sourceType":"module"}