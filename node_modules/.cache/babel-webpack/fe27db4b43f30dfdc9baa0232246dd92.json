{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport * as Highcharts from 'highcharts';\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"src/app/shared/services/sso-auth.service\";\nimport * as i3 from \"@angular/router\";\nconst {\n  Manager\n} = require(\"socket.io-client\");\nexport let WebsocketService = /*#__PURE__*/(() => {\n  class WebsocketService {\n    constructor(http, sso, router) {\n      this.http = http;\n      this.sso = sso;\n      this.router = router;\n      this.delayTime$ = new Subject();\n      this.data = {\n        // graphType: 'TRF',\n        // sendTime: (new Date()).getTime(),\n        // usage: [0, 0],\n        // maxRate: [0, 0],\n        // packet: [0, 0]\n      };\n      this.rtData$ = new BehaviorSubject(this.data);\n      this.ratePacketStreamData$ = new BehaviorSubject(this.data);\n      this.multipleRatePacketStreamData$ = new BehaviorSubject(this.data);\n      this.multipleStreamData$ = new BehaviorSubject(this.data);\n      this.recordResponseData$ = new Subject();\n      this.stopRecordResponseData$ = new Subject();\n      this.recordErrorResponseData$ = new Subject();\n      this.cacheRateRTDataObj = {};\n      this.cachePacketRTDataObj = {};\n      this.lastChartDataObj = {};\n      this.cacheData$ = new Subject();\n      this.endPointSearch$ = new Subject();\n      this.endPointSearchError$ = new Subject();\n      this.connectWS$ = new BehaviorSubject(false);\n      this.showModalInfo$ = new Subject();\n      this.endPointSearchValue = \"\";\n      this.previousURL = \"\";\n      this.isUnmapped = false;\n      this.delay$ = new BehaviorSubject(false);\n      this.wsConnectionError$ = new BehaviorSubject(false);\n      this.wsNoResponse$ = new BehaviorSubject({\n        isError: false,\n        type: \"\"\n      });\n      this.endPointName = \"\";\n      this.isAggregateMember$ = new BehaviorSubject({\n        id: null\n      });\n      this.baseUrl = `${environment.API_BASE_URL}realtime/signed-url`;\n      this.timezoneDetected = 0;\n      // timezoneDetected = -75 * 1000;\n      this.shouldReflow = false;\n      this.connectErrorCount = 0;\n      this.WebSocketServer = {\n        websocketPaths: ['/SystemtryComponent', '/cco/issues/realtime/current-issues', '/cco/traffic/network/realtime', '/cco/traffic/applications/realtime', '/cco/traffic/locations/realtime', '/cco/traffic/endpoints/realtime', \"/cco/home/network-trends\"],\n        isConnected: false,\n        socket: null,\n        interval: null,\n        isdisconnected: false,\n        hasDisconnectedOnce: false,\n        callmethod(sec, cnt) {\n          let count = cnt;\n          clearInterval(interval);\n          var interval = setInterval(() => {\n            count++;\n            if (count == 3) {\n              clearInterval(interval);\n              interval = null;\n              this.callmethod(6000, 3);\n            } else if (count == 6) {\n              clearInterval(interval);\n              interval = null;\n              this.callmethod(25000, 6);\n            } else {\n              // if (this.isConnected || this.websocketPaths.includes(window.location.pathname) == false) {\n              if (this.isConnected) {\n                this.isdisconnected = false;\n                clearInterval(interval);\n                interval = null;\n                // return;\n              } else {\n                this.socket.connect();\n                this.isConnected = true;\n              }\n            }\n          }, sec);\n        },\n        close() {\n          //this.emit('eventclosed', 'closing from client side');\n          this.socket.emit('eventclosed', 'closing from client side');\n          this.socket.disconnect();\n          this.socket = undefined;\n        },\n        connect1(signedUrl) {\n          // if (this.socket)\n          //   return;\n          if (this.socket) {\n            this.socket.destroy();\n            delete this.socket;\n            this.socket = null;\n          }\n          if (this.socket) {\n            return;\n          }\n          this.socket = io(signedUrl, {\n            transports: ['websocket'],\n            path: '/calix/socket-io/',\n            autoConnect: false,\n            reconnection: false\n          });\n          if (this.isConnected == false) {\n            this.callmethod(5000, 0);\n          }\n          this.socket.on('connect', () => {\n            // console.log(\"Web Socket connected\");\n            this.isConnected = true;\n          });\n          this.socket.on('ping', () => {\n            setTimeout(() => {\n              this.socket.emit('pong');\n            }, 500);\n          });\n          this.socket.on('disconnect', err => {\n            console.log(err);\n            this.isConnected = false;\n            this.isdisconnected = true;\n            this.hasDisconnectedOnce = true;\n            // this.socket.close();\n            // this.callmethod(5000, 0);\n          });\n\n          this.socket.on(\"connect_error\", err => {\n            this.isConnected = false;\n            console.log(err.message);\n          });\n          this.socket.on('isConnected', (data, callback) => {\n            callback({\n              status: \"true\"\n            });\n          });\n          return this.socket;\n        }\n      };\n      this.recordRatePacketStreamData$ = new BehaviorSubject(this.data);\n      this.connectionTypes = {};\n      this.currentMonitorType = '';\n      this.lastData = [0, 0];\n      this.chartData = [0, 0];\n      this.searchEPval = '';\n      this.healthRtData$ = new BehaviorSubject(this.data);\n      this.healthRatePacketStreamData$ = new BehaviorSubject(this.data);\n      this.healthCacheData$ = new Subject();\n      this.cachePonportData$ = new Subject();\n      this.ponPortsStreamData$ = new BehaviorSubject(this.data);\n      this.healthWSNoResponse$ = new BehaviorSubject({\n        isError: false,\n        type: \"\"\n      });\n      this.healthCurrentMonitorType = '';\n      this.healthConnectionTypes = {};\n      this.ponPortsList = [];\n      this.filterValues = {};\n      this.customAppSearch = (searchTerm, item) => {\n        searchTerm = searchTerm.toLowerCase();\n        if (item['groupName']) {\n          return item['groupName'].toLowerCase().indexOf(searchTerm) > -1 || item['label'].toLowerCase().indexOf(searchTerm) > -1;\n        } else {\n          return item['label'].toLowerCase().indexOf(searchTerm) > -1;\n        }\n      };\n      this.customLocSearch = (searchTerm, item) => {\n        searchTerm = searchTerm.toLowerCase();\n        if (item['region']) {\n          return item['region'].toLowerCase().indexOf(searchTerm) > -1 || item['name'].toLowerCase().indexOf(searchTerm) > -1;\n        } else {\n          return item['name'].toLowerCase().indexOf(searchTerm) > -1;\n        }\n      };\n      //this.timezoneDetected = this.dateUtils.timezoneDetected();\n    }\n\n    openSocket() {\n      const manager = new Manager(`${environment.TRAFFIC_SOCKET_URL}`, {\n        transports: ['websocket'],\n        reconnectionDelayMax: 10000,\n        path: \"/calix/socket-io/\"\n      });\n      this.WebSocketServer.socket = manager.socket(\"\", {});\n    }\n    removeExistingListeners() {\n      this.WebSocketServer.socket.off();\n    }\n    // To send msg to server\n    emit(eventname, data) {\n      // if (this.connection()) {\n      if (typeof data === 'object' && !data.replay && eventname != \"STOP_RECORDING\" && eventname != \"RECORDING\") {\n        this.setCurrentMonitorInfo(data);\n      }\n      if (typeof data === 'object' && eventname != \"STOP_RECORDING\") {\n        this.setRealtimeDelay(data);\n      }\n      if (typeof data === 'object' && data['replay'] && data['replay'] == \"true\") {\n        let time = Math.abs(this.sso.getRealtimeDelay());\n        data['startTime'] = parseInt(data['startTime']) - (time ? time : 60000);\n      }\n      if (this.WebSocketServer.isdisconnected) {\n        console.log(JSON.stringify(data));\n        console.log(\"Web socket is disconnected\");\n        this.wsConnectionError$.next(true);\n        return;\n      }\n      if (data) {\n        this.WebSocketServer.socket.emit(eventname, data);\n      } else this.WebSocketServer.socket.emit(eventname);\n      //};\n    }\n\n    listen(eventname) {\n      this.WebSocketServer.socket.on(eventname, data => {\n        var _a;\n        let cdata = data;\n        if (typeof cdata === 'string') {\n          cdata = [cdata];\n        }\n        if (eventname.includes('error_traffic')) {\n          if (typeof data === 'string') {\n            this.wsNoResponse$.next({\n              isError: true,\n              type: eventname\n            });\n          }\n        }\n        if (eventname === 'REPLAY' || eventname === 'event') {\n          this.cacheRateRTDataObj = {};\n          this.cachePacketRTDataObj = {};\n          this.clearRecordRtInfo();\n          if (cdata && cdata.length) {\n            cdata = cdata.slice();\n            console.log(\"Replay data\", cdata);\n            cdata.forEach(element => {\n              let data;\n              if (this.IsJsonString(element)) {\n                //element = element.slice()\n                data = JSON.parse(element);\n              } else {\n                data = element;\n              }\n              if (data.confData && data.confData['monitorId'] == this.connectionTypes[this.currentMonitorType].monitorId) {\n                this.data = data;\n                this.cacheRTData('rate', 'Traffic');\n                this.cacheRTData('packet', 'Traffic');\n              }\n            });\n            this.cacheData$.next({\n              'rate': this.getCachedata('rate'),\n              'packet': this.getCachedata('packet')\n            });\n            let sendData = Object.assign(Object.assign({}, this.data), this.data.confData);\n            if (sendData.graphType === 'TRF') {\n              console.log(sendData);\n              this.ratePacketStreamData$.next(sendData);\n            }\n          }\n          // console.log(this.cacheRateRTDataObj);\n        } else if (cdata && cdata[0]) {\n          if (this.IsJsonString(cdata[0])) {\n            cdata[0] = cdata[0].slice();\n            cdata[0] = JSON.parse(cdata[0]);\n          }\n          if (cdata[0].confData && cdata[0].confData['monitorType'] === this.currentMonitorType && cdata[0].confData['monitorId'] == ((_a = this.connectionTypes[this.currentMonitorType]) === null || _a === void 0 ? void 0 : _a.monitorId)) {\n            let sendData = Object.assign(Object.assign({}, cdata[0]), cdata[0].confData);\n            if (sendData.graphType === 'TRF') {\n              console.log(sendData);\n              if (!this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur) {\n                this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur = new Date().getTime() - parseInt(sendData.sendTime);\n                this.delayTime$.next(this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur);\n              }\n              this.ratePacketStreamData$.next(sendData);\n            } else {\n              this.rtData$.next(sendData);\n            }\n          }\n        }\n      });\n    }\n    multipleEmit(eventname, data) {\n      if (typeof data === 'object') {\n        this.setRealtimeDelay(data);\n      }\n      if (typeof data === 'object' && data['replay'] && data['replay'] == \"true\") {\n        let time = Math.abs(this.sso.getRealtimeDelay());\n        data['startTime'] = parseInt(data['startTime']) - (time ? time : 60000);\n      }\n      if (this.WebSocketServer.isdisconnected) {\n        this.wsConnectionError$.next(true);\n        return;\n      }\n      if (data) {\n        this.WebSocketServer.socket.emit(eventname, data);\n      } else this.WebSocketServer.socket.emit(eventname);\n    }\n    listenMultiple(eventname) {\n      this.WebSocketServer.socket.on(eventname, data => {\n        let cdata = data;\n        if (typeof cdata === 'string') {\n          cdata = [cdata];\n        }\n        if (eventname === 'REPLAY' || eventname === 'event') {\n          this.multipleRatePacketStreamData$.next(cdata);\n        } else if (cdata && cdata[0]) {\n          if (this.IsJsonString(cdata[0])) {\n            cdata[0] = cdata[0].slice();\n            cdata[0] = JSON.parse(cdata[0]);\n          }\n          if (cdata[0].confData && (cdata[0].confData['monitorType'] === \"LOC\" || cdata[0].confData['monitorType'] === \"APP\")) {\n            let sendData = Object.assign(Object.assign({}, cdata[0]), cdata[0].confData);\n            if (sendData.graphType === 'TRF') {\n              // if (!this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur) {\n              //   this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur = (new Date()).getTime() - parseInt(sendData.sendTime);\n              // }\n              this.multipleStreamData$.next(sendData);\n            }\n          }\n        }\n      });\n    }\n    listenRecord(eventname) {\n      this.WebSocketServer.socket.on(eventname, data => {\n        if (eventname == \"RECORDING\") {\n          this.recordResponseData$.next(data);\n        } else if (eventname == \"STOP_RECORDING\") {\n          this.stopRecordResponseData$.next(data);\n        } else if (eventname == \"error\") {\n          this.recordErrorResponseData$.next(data);\n        }\n      });\n    }\n    getRecordData() {\n      let params = {\n        \"orgId\": this.sso.getOrgId(),\n        \"monitorType\": \"NET\",\n        \"networkId\": `${this.sso.getOrgId()}_0`,\n        \"monitorId\": `${this.sso.getOrgId()}_0`,\n        \"graphType\": \"TRF,TAPP,TLOC,TEP\",\n        outputStartTimeDiffToCur: 0\n      };\n      this.setCurrentMonitorInfo(params);\n      let cdata = [\"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1669898,1531250],\\\"maxRate\\\":[890612,816666],\\\"packet\\\":[9605,9358],\\\"sendTime\\\":1632138060000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1758492,1685044],\\\"maxRate\\\":[937862,898690],\\\"packet\\\":[9818,9722],\\\"sendTime\\\":1632138075000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1921935,1778104],\\\"maxRate\\\":[1025032,948322],\\\"packet\\\":[11664,11644],\\\"sendTime\\\":1632138090000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1741112,1603827],\\\"maxRate\\\":[928593,855374],\\\"packet\\\":[11119,11088],\\\"sendTime\\\":1632138105000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1861596,1767668],\\\"maxRate\\\":[992850,942756],\\\"packet\\\":[10993,11235],\\\"sendTime\\\":1632138120000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2353828,2173871],\\\"maxRate\\\":[1255374,1159398],\\\"packet\\\":[13430,13640],\\\"sendTime\\\":1632138135000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2064040,1913536],\\\"maxRate\\\":[1100821,1020552],\\\"packet\\\":[12333,12217],\\\"sendTime\\\":1632138150000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1934139,1784486],\\\"maxRate\\\":[1031540,951725],\\\"packet\\\":[11808,11732],\\\"sendTime\\\":1632138165000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2390974,2200786],\\\"maxRate\\\":[1275186,1173752],\\\"packet\\\":[14370,14282],\\\"sendTime\\\":1632138180000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2364978,2200961],\\\"maxRate\\\":[1261322,1173846],\\\"packet\\\":[14272,14444],\\\"sendTime\\\":1632138195000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2028658,1846579],\\\"maxRate\\\":[1081950,984842],\\\"packet\\\":[12647,12695],\\\"sendTime\\\":1632138210000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1830408,1715952],\\\"maxRate\\\":[976217,915174],\\\"packet\\\":[11394,11461],\\\"sendTime\\\":1632138225000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1813494,1662066],\\\"maxRate\\\":[967196,886434],\\\"packet\\\":[11670,11701],\\\"sendTime\\\":1632138240000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1745935,1634533],\\\"maxRate\\\":[931164,871750],\\\"packet\\\":[11462,11510],\\\"sendTime\\\":1632138255000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1462256,1350103],\\\"maxRate\\\":[779869,720054],\\\"packet\\\":[10005,9897],\\\"sendTime\\\":1632138270000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1648829,1464350],\\\"maxRate\\\":[879375,780986],\\\"packet\\\":[10184,9786],\\\"sendTime\\\":1632138285000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2010853,1876954],\\\"maxRate\\\":[1072454,1001042],\\\"packet\\\":[11517,11479],\\\"sendTime\\\":1632138300000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2089170,1983216],\\\"maxRate\\\":[1114224,1057715],\\\"packet\\\":[11624,11582],\\\"sendTime\\\":1632138315000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2177269,1989227],\\\"maxRate\\\":[1161210,1060920],\\\"packet\\\":[12384,12246],\\\"sendTime\\\":1632138330000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2238716,2091218],\\\"maxRate\\\":[1193982,1115316],\\\"packet\\\":[12421,12446],\\\"sendTime\\\":1632138345000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2330046,2134872],\\\"maxRate\\\":[1242691,1138598],\\\"packet\\\":[12754,12722],\\\"sendTime\\\":1632138360000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2304012,2146061],\\\"maxRate\\\":[1228806,1144566],\\\"packet\\\":[13040,13164],\\\"sendTime\\\":1632138375000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2163364,2028615],\\\"maxRate\\\":[1153794,1081928],\\\"packet\\\":[12212,12284],\\\"sendTime\\\":1632138390000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2426284,2290174],\\\"maxRate\\\":[1294018,1221426],\\\"packet\\\":[13614,13579],\\\"sendTime\\\":1632138405000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2494918,2386645],\\\"maxRate\\\":[1330623,1272877],\\\"packet\\\":[13872,13843],\\\"sendTime\\\":1632138420000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2414894,2261934],\\\"maxRate\\\":[1287944,1206364],\\\"packet\\\":[13178,13052],\\\"sendTime\\\":1632138435000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2394889,2218582],\\\"maxRate\\\":[1277274,1183243],\\\"packet\\\":[13625,13604],\\\"sendTime\\\":1632138450000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2418611,2260147],\\\"maxRate\\\":[1289926,1205411],\\\"packet\\\":[13722,13698],\\\"sendTime\\\":1632138465000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2546804,2381377],\\\"maxRate\\\":[1358296,1270067],\\\"packet\\\":[14398,14260],\\\"sendTime\\\":1632138480000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2153924,2005231],\\\"maxRate\\\":[1148760,1069456],\\\"packet\\\":[12462,12364],\\\"sendTime\\\":1632138495000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1933706,1834662],\\\"maxRate\\\":[1031310,978486],\\\"packet\\\":[10964,10826],\\\"sendTime\\\":1632138510000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2017426,1849974],\\\"maxRate\\\":[1075960,986652],\\\"packet\\\":[12176,11707],\\\"sendTime\\\":1632138525000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[2135234,2001997],\\\"maxRate\\\":[1138791,1067731],\\\"packet\\\":[12734,12556],\\\"sendTime\\\":1632138540000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1637154,1551267],\\\"maxRate\\\":[873148,827342],\\\"packet\\\":[9790,9718],\\\"sendTime\\\":1632138555000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1684980,1584558],\\\"maxRate\\\":[898655,845097],\\\"packet\\\":[10104,10083],\\\"sendTime\\\":1632138570000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1859924,1717283],\\\"maxRate\\\":[991959,915884],\\\"packet\\\":[11204,11320],\\\"sendTime\\\":1632138585000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1953386,1780490],\\\"maxRate\\\":[1041805,949594],\\\"packet\\\":[11784,11482],\\\"sendTime\\\":1632138600000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1657301,1526030],\\\"maxRate\\\":[883893,813882],\\\"packet\\\":[9974,9822],\\\"sendTime\\\":1632138615000}\", \"{\\\"confData\\\":{\\\"monitorType\\\":\\\"NET\\\",\\\"monitorId\\\":\\\"10001_0\\\",\\\"graphType\\\":\\\"TRF\\\"},\\\"usage\\\":[1839265,1667763],\\\"maxRate\\\":[980940,889473],\\\"packet\\\":[11200,11129],\\\"sendTime\\\":1632138630000}\"];\n      this.cacheRateRTDataObj = {};\n      this.cachePacketRTDataObj = {};\n      if (cdata && cdata.length) {\n        cdata = cdata.slice();\n        cdata.forEach(element => {\n          let data;\n          if (this.IsJsonString(element)) {\n            //element = element.slice()\n            data = JSON.parse(element);\n          } else {\n            data = element;\n          }\n          if (data.confData && data.confData['monitorId']) {\n            this.data = data;\n            this.cacheRTData('rate', 'Traffic');\n            this.cacheRTData('packet', 'Traffic');\n          }\n        });\n        this.recordRatePacketStreamData$.next({\n          'rate': this.getCachedata('rate'),\n          'packet': this.getCachedata('packet')\n        });\n      }\n    }\n    cacheRTData(type, from) {\n      if (type === 'rate') {\n        if (this.currentData) {\n          this.lastData = this.currentData;\n        } else {\n          this.chartData = [0, 0];\n        }\n        this.currentData = this.data.maxRate ? this.data.maxRate : [0, 0];\n        this.yAxixTitle = type === 'rate' ? 'bps' : 'pps';\n        let loadTime;\n        if (from === 'Traffic') {\n          loadTime = this.data.sendTime ? this.data.sendTime + this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur + this.timezoneDetected : 0;\n        } else {\n          loadTime = this.data.sendTime ? this.data.sendTime + this.healthConnectionTypes[this.healthCurrentMonitorType].outputStartTimeDiffToCur + this.timezoneDetected : 0;\n        }\n        for (let i = 1; i <= 15; i++) {\n          var time = loadTime + i * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cacheRateRTDataObj[key] = this.generateRTforCache(this.currentData, this.lastData, this.chartData, type);\n          this.removeOldKeys(this.cacheRateRTDataObj, type, from);\n        }\n      } else {\n        if (this.currentDataPacket) {\n          this.lastDataPacket = this.currentDataPacket;\n        } else {\n          this.chartDataPacket = [0, 0];\n        }\n        this.currentDataPacket = this.data.packet ? this.data.packet : [];\n        this.yAxixTitlePacket = type === 'rate' ? 'bps' : 'pps';\n        let loadTime;\n        if (from === 'Traffic') {\n          loadTime = this.data.sendTime ? this.data.sendTime + this.connectionTypes[this.currentMonitorType].outputStartTimeDiffToCur + this.timezoneDetected : 0;\n        } else {\n          loadTime = this.data.sendTime ? this.data.sendTime + this.healthConnectionTypes[this.healthCurrentMonitorType].outputStartTimeDiffToCur + this.timezoneDetected : 0;\n        }\n        let inc = 0;\n        for (let i = 1; i <= 15; i++) {\n          var time = loadTime + i * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cachePacketRTDataObj[key] = this.generateRTforCache(this.currentDataPacket, this.lastDataPacket, this.chartDataPacket, type);\n          this.removeOldKeys(this.cachePacketRTDataObj, type, from);\n        }\n      }\n    }\n    bitsToSize(bits, chartName) {\n      let bytes = parseFloat(bits);\n      let sizes = chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2) + ' ' + sizes[i];\n    }\n    removeLast3Chars(str) {\n      str = str.toString();\n      str = str.slice(0, -3);\n      str = parseInt(str);\n      return str;\n    }\n    removeOldKeys(lastChartDataObj, chartName, from) {\n      if (window.location.pathname.indexOf('/cco/record') !== -1 || window.location.pathname.indexOf('/organization-admin/flowAnalyze/record-view') !== -1 || window.location.pathname.indexOf('/systemAdministration/flowAnalyze/record-view') !== -1) {\n        return;\n      }\n      let keys = Object.keys(lastChartDataObj);\n      let len = keys.length;\n      let windowLen = (from === 'health' ? this.getHealthWindowLen() : this.getWindowLen()) * 300 + 50;\n      if (len > windowLen) {\n        let obj = lastChartDataObj;\n        let removeLen = len - windowLen;\n        for (let i = 0; i < removeLen; i++) {\n          delete obj[keys[i]];\n        }\n        if (chartName === 'rate') {\n          this.cacheRateRTDataObj = obj;\n        } else {\n          this.cachePacketRTDataObj = obj;\n        }\n      }\n    }\n    generateRTforCache(currentData, lastData, chartData, chartName) {\n      let data = this.transformData(currentData, lastData, chartData, chartName);\n      if (chartName === 'rate') {\n        this.chartData = data;\n      } else {\n        this.chartDataPacket = data;\n      }\n      if (!data[0]) {\n        data[0] = 0;\n      }\n      if (!data[1]) {\n        data[1] = 0;\n      }\n      let upRate = this.bitsToSize(data[0], chartName);\n      let downRate = this.bitsToSize(data[1], chartName);\n      let vArr1 = upRate.split(\" \");\n      let vArr2 = downRate.split(\" \");\n      let upRateUnit = vArr1[1] ? vArr1[1] : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      let downRateUnit = vArr2[1] ? vArr2[1] : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      let maxUnit = '';\n      if (data[0] || data[1]) {\n        if (data[0] > data[1]) {\n          maxUnit = vArr1[1];\n        } else {\n          maxUnit = vArr2[1];\n        }\n      } else {\n        if (chartName.toLowerCase() === 'rate') {\n          maxUnit = this.yAxixTitle ? this.yAxixTitle : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        } else {\n          maxUnit = this.yAxixTitlePacket ? this.yAxixTitlePacket : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        }\n      }\n      if (maxUnit == 'undefined') {\n        //maxUnit = this.yAxixTitle ? this.yAxixTitle : (chartName.toLowerCase() === 'rate') ? 'bps' : 'pps';\n        if (chartName.toLowerCase() === 'rate') {\n          maxUnit = this.yAxixTitle ? this.yAxixTitle : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        } else {\n          maxUnit = this.yAxixTitlePacket ? this.yAxixTitlePacket : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        }\n      }\n      if (typeof maxUnit === 'string') {\n        //this.yAxixTitle = maxUnit;\n        if (chartName.toLowerCase() === 'rate') {\n          this.yAxixTitle = maxUnit;\n        } else {\n          this.yAxixTitlePacket = maxUnit;\n        }\n      }\n      if (data) {\n        if (chartName.toLowerCase() === 'rate') {\n          return [data[0], data[1], this.yAxixTitle, upRateUnit, downRateUnit];\n        } else {\n          return [data[0], data[1], this.yAxixTitlePacket, upRateUnit, downRateUnit];\n        }\n      }\n    }\n    transformData(currentData, lastData, data, chartName) {\n      if (chartName.toLowerCase() === 'rate') {\n        // console.log(\"current api value\", currentData);\n        // console.log(\"last api value\", lastData);\n        // console.log(\"last chart value\", data);\n      }\n      if (Array.isArray(currentData)) {\n        if (currentData[0] == undefined) {\n          currentData[0] = 0;\n        }\n        if (currentData[1] == undefined) {\n          currentData[1] = 0;\n        }\n      } else {\n        currentData = [0, 0];\n      }\n      if (Array.isArray(lastData)) {\n        if (lastData[0] == undefined) {\n          lastData[0] = 0;\n        }\n        if (lastData[1] == undefined) {\n          lastData[1] = 0;\n        }\n      } else {\n        lastData = [0, 0];\n      }\n      let chartData = [];\n      for (let i = 0; i < currentData.length; i++) {\n        let delta = parseFloat(currentData[i]) - parseFloat(lastData[i]);\n        //delta = Math.abs(delta);\n        if (!parseFloat(currentData[i]) && !parseFloat(lastData[i])) {\n          data[i] = 0;\n        }\n        let deltaRate = delta / 15;\n        let value = Math.abs(parseFloat(data[i]) + deltaRate);\n        chartData.push(value);\n      }\n      if (!chartData[0] && !chartData[1] && (currentData[0] || currentData[1])) {\n        chartData = currentData;\n      }\n      return chartData;\n    }\n    //checking whether connection is established or not\n    Checkconnectornot(signedUrl) {\n      let socket;\n      if (this.WebSocketServer.isConnected == false && signedUrl) {\n        socket = this.WebSocketServer.connect1(signedUrl);\n        socket.on('connect', () => {\n          console.log(\"Web Socket connected\");\n          this.WebSocketServer.isdisconnected = false;\n          if (this.connectWS$) {\n            this.connectWS$.next(true);\n          }\n        });\n        //this.connectWS$.next(true);\n        socket.on('disconnect', err => {\n          console.log(err);\n          if (err == \"transport close\" || err == \"ping timeout\") {\n            socket.close();\n            this.reconnectWebSocket();\n            // if (Object.keys(this.connectionTypes).length === 0) {\n            //   socket.close()\n            //   this.reconnectWebSocket();\n            // }\n            // this.showModalInfo$.next(true);\n          }\n        });\n\n        socket.on('connect_error', err => {\n          console.log(\"error\", err);\n          if (this.connectErrorCount < 2) {\n            this.connectErrorCount++;\n            setTimeout(() => {\n              this.reconnectWebSocket();\n            }, 30000);\n          }\n          this.wsConnectionError$.next(true);\n        });\n      }\n    }\n    reconnectWebSocket() {\n      this.getUnSignedUrl().subscribe(res => {\n        this.Checkconnectornot(res.signedurl);\n      }, err => {\n        if (err.name == \"HttpErrorResponse\") {\n          setTimeout(() => {\n            this.reconnectWebSocket();\n          }, 5000);\n        }\n      });\n    }\n    setCurrentMonitorInfo(data) {\n      if (!data['startTime']) {\n        data['startTime'] = new Date().getTime();\n      }\n      this.connectionTypes[data.monitorType] = data;\n    }\n    getCurrentMonitorInfo(monitorType) {\n      return this.connectionTypes[monitorType];\n    }\n    setMonitorType(type) {\n      this.currentMonitorType = type;\n    }\n    getMonitorType() {\n      return this.currentMonitorType;\n    }\n    setWindowLen(windowLen) {\n      if (this.connectionTypes[this.currentMonitorType]) {\n        this.connectionTypes[this.currentMonitorType].windowLen = windowLen;\n      }\n    }\n    getWindowLen() {\n      return this.connectionTypes[this.currentMonitorType] && this.connectionTypes[this.currentMonitorType].windowLen ? this.connectionTypes[this.currentMonitorType].windowLen : 1;\n    }\n    IsJsonString(str) {\n      try {\n        JSON.parse(str);\n      } catch (e) {\n        return false;\n      }\n      return true;\n    }\n    clearReplayData() {\n      this.cachePacketRTDataObj = {};\n      this.cacheRateRTDataObj = {};\n    }\n    getCachedata(chartName) {\n      if (chartName === 'rate') {\n        return this.cacheRateRTDataObj;\n      } else {\n        return this.cachePacketRTDataObj;\n      }\n    }\n    getCurrrentUnit(chartName) {\n      if (chartName.toLowerCase() === 'rate') {\n        return this.yAxixTitle ? this.yAxixTitle : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      } else {\n        return this.yAxixTitlePacket ? this.yAxixTitlePacket : chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n      }\n    }\n    clearRtInfo() {\n      this.currentMonitorType = '';\n      this.connectionTypes = {};\n      // this.lastData = [0, 0];\n      // this.currentData = [0, 0];\n      // this.chartData = [0, 0];\n      this.clearReplayData();\n    }\n    clearRecordRtInfo() {\n      this.lastData = [0, 0];\n      this.currentData = [0, 0];\n      this.chartData = [0, 0];\n      this.lastDataPacket = [0, 0];\n      this.currentDataPacket = [0, 0];\n      this.chartDataPacket = [0, 0];\n    }\n    setEndpointSearch(value) {\n      this.endPointSearchValue = value;\n      this.endPointSearch$.next(value);\n    }\n    setEndPointSearchError(flag) {\n      this.endPointSearchError$.next(flag);\n    }\n    getEndpointValue() {\n      return this.searchEPval;\n    }\n    setEndpointValue(value) {\n      this.searchEPval = value;\n    }\n    getMinutesByMillis(millis) {\n      return millis / 60000;\n    }\n    getUnSignedUrl() {\n      return this.http.get(`${this.baseUrl}`);\n    }\n    getRealtimeDelay() {\n      // let orgId = this.sso.getOrgId();\n      let orgId = this.sso.getOrganizationID(this.router.url);\n      let url = `${environment.API_BASE_URL}fa/config/organization?org-id=${orgId}`;\n      this.http.get(`${url}`).subscribe(res => {\n        if (res && res !== null) {\n          let timeDelay = -1 * (res.realtimeLateflowDelay ? res.realtimeLateflowDelay : 0) * 1000;\n          this.sso.setRealtimeDelay(timeDelay);\n          this.timezoneDetected = timeDelay;\n        } else {\n          this.sso.setRealtimeDelay(0);\n          this.timezoneDetected = 0;\n        }\n        this.delay$.next(true);\n      }, error => {\n        this.sso.setRealtimeDelay(0);\n        this.timezoneDetected = 0;\n        this.delay$.next(true);\n      });\n    }\n    prepareAndGetRecordData(cdata, configparams) {\n      this.cacheRateRTDataObj = {};\n      this.cachePacketRTDataObj = {};\n      let data = {};\n      let streamObj = {};\n      if (cdata && cdata.length) {\n        cdata.forEach(element => {\n          if (element.confData && element.confData['graphType'] === \"TRF\") {\n            streamObj[element.sendTime] = element;\n          } else {\n            if (typeof data[element.sendTime] !== 'object') {\n              data[element.sendTime] = {};\n            }\n            data[element.sendTime][element.confData.graphType] = element;\n          }\n        });\n        let keys = Object.keys(streamObj);\n        keys.sort(function (a, b) {\n          return Number(a) - Number(b);\n        });\n        let slen = Object.keys(streamObj).length;\n        if (slen) {\n          for (let i = 0; i < slen; i++) {\n            this.data = streamObj[keys[i]];\n            this.cacheRTDataForRecord('rate');\n            this.cacheRTDataForRecord('packet');\n          }\n        }\n      }\n      return {\n        stream: {\n          'rate': this.getCachedata('rate'),\n          'packet': this.getCachedata('packet')\n        },\n        bar: data\n      };\n    }\n    cacheRTDataForRecord(type) {\n      if (type === 'rate') {\n        if (this.currentData) {\n          this.lastData = this.currentData;\n        } else {\n          this.chartData = [0, 0];\n        }\n        this.currentData = this.data.maxRate ? this.data.maxRate : [0, 0];\n        this.yAxixTitle = type === 'rate' ? 'bps' : 'pps';\n        let loadTime = this.data.sendTime ? this.data.sendTime : 0;\n        for (let i = 1; i <= 15; i++) {\n          var time = loadTime + i * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cacheRateRTDataObj[key] = this.generateRTforCache(this.currentData, this.lastData, this.chartData, type);\n          this.removeOldKeys(this.cacheRateRTDataObj, type);\n        }\n      } else {\n        if (this.currentDataPacket) {\n          this.lastDataPacket = this.currentDataPacket;\n        } else {\n          this.chartDataPacket = [0, 0];\n        }\n        this.currentDataPacket = this.data.packet ? this.data.packet : [];\n        this.yAxixTitlePacket = type === 'rate' ? 'bps' : 'pps';\n        let loadTime = this.data.sendTime ? this.data.sendTime : 0;\n        for (let i = 1; i <= 15; i++) {\n          var time = loadTime + i * 1000;\n          let key = this.removeLast3Chars(time);\n          this.cachePacketRTDataObj[key] = this.generateRTforCache(this.currentDataPacket, this.lastDataPacket, this.chartDataPacket, type);\n          this.removeOldKeys(this.cachePacketRTDataObj, type);\n        }\n      }\n    }\n    healthEmit(eventname, data) {\n      if (typeof data === 'object' && !data.replay) {\n        this.setHealthCurrentMonitorInfo(data);\n      }\n      if (typeof data === 'object') {\n        this.setRealtimeDelay(data);\n      }\n      if (typeof data === 'object' && data['replay'] && data['replay'] == \"true\") {\n        let time = Math.abs(this.sso.getRealtimeDelay());\n        data['startTime'] = parseInt(data['startTime']) - (time ? time : 60000);\n      }\n      if (this.WebSocketServer.isdisconnected) {\n        console.log(JSON.stringify(data));\n        console.log(\"Web socket is disconnected\");\n        this.wsConnectionError$.next(true);\n        return;\n      }\n      if (data) {\n        this.WebSocketServer.socket.emit(eventname, data);\n      } else this.WebSocketServer.socket.emit(eventname);\n    }\n    healthListen(eventname) {\n      this.WebSocketServer.socket.on(eventname, data => {\n        //console.log(data);\n        let cdata = data;\n        if (typeof cdata === 'string') {\n          cdata = [cdata];\n        }\n        if (eventname.includes('error_ipfix')) {\n          if (typeof data === 'string' && !data.includes('replay')) {\n            this.healthWSNoResponse$.next({\n              isError: true,\n              type: eventname\n            });\n          }\n        }\n        if (eventname === 'IPFIX_REPLAY') {\n          this.cacheRateRTDataObj = {};\n          this.cachePacketRTDataObj = {};\n          this.clearRecordRtInfo();\n          if (cdata && cdata.length) {\n            cdata = cdata.slice();\n            console.log(\"Replay data\", cdata);\n            cdata.forEach(element => {\n              if (this.IsJsonString(element)) {\n                //element = element.slice()\n                this.data = JSON.parse(element);\n              } else {\n                this.data = element;\n              }\n              this.cacheRTData('rate', 'health');\n              this.cacheRTData('packet', 'health');\n            });\n            this.healthCacheData$.next({\n              'rate': this.getCachedata('rate'),\n              'packet': this.getCachedata('packet')\n            });\n            let sendData = Object.assign(Object.assign({}, this.data), this.data.confData);\n            if (sendData.graphType === 'TRF') {\n              console.log(sendData);\n              this.healthRatePacketStreamData$.next(sendData);\n            }\n          }\n          // console.log(this.cacheRateRTDataObj);\n        } else if (cdata && cdata[0]) {\n          if (this.IsJsonString(cdata[0])) {\n            cdata[0] = cdata[0].slice();\n            cdata[0] = JSON.parse(cdata[0]);\n          }\n          if (cdata[0].confData && cdata[0].confData['monitorType'].includes(this.healthCurrentMonitorType)) {\n            let sendData = Object.assign(Object.assign({}, cdata[0]), cdata[0].confData);\n            if (sendData.graphType === 'TRF') {\n              console.log(sendData);\n              if (!this.healthConnectionTypes[this.healthCurrentMonitorType].hasOwnProperty('outputStartTimeDiffToCur')) {\n                this.healthConnectionTypes[this.healthCurrentMonitorType]['outputStartTimeDiffToCur'] = new Date().getTime() - parseInt(sendData.sendTime);\n              }\n              this.healthRatePacketStreamData$.next(sendData);\n            } else {\n              this.healthRtData$.next(sendData);\n            }\n          }\n        }\n      });\n    }\n    listenPonPorts(eventname) {\n      if (this.WebSocketServer.socket === null) {\n        return;\n      }\n      this.WebSocketServer.socket.on(eventname, data => {\n        //console.log(data);\n        let cdata = data;\n        if (typeof cdata === 'string') {\n          cdata = [cdata];\n        }\n        if (eventname.includes(\"IPFIX_REPLAY\")) {\n          this.cacheRateRTDataObj = {};\n          this.cachePacketRTDataObj = {};\n          this.clearRecordRtInfo();\n          if (cdata && cdata.length) {\n            cdata = cdata.slice();\n            cdata.forEach(element => {\n              if (this.IsJsonString(element)) {\n                //element = element.slice()\n                this.data = JSON.parse(element);\n              } else {\n                this.data = element;\n              }\n              this.cacheRTData('rate', 'health');\n              this.cacheRTData('packet', 'health');\n            });\n            this.cachePonportData$.next({\n              'monitorId': eventname,\n              'rate': this.getCachedata('rate'),\n              'packet': this.getCachedata('packet')\n            });\n            let sendData = Object.assign(Object.assign({}, this.data), this.data.confData);\n            if (sendData.graphType === 'TRF') {\n              this.ponPortsStreamData$.next(sendData);\n            }\n          }\n        } else {\n          if (cdata && cdata[0]) {\n            if (this.IsJsonString(cdata[0])) {\n              cdata[0] = cdata[0].slice();\n              cdata[0] = JSON.parse(cdata[0]);\n            }\n            if (cdata[0].confData && cdata[0].confData['monitorType'] === \"PORT\") {\n              let sendData = Object.assign(Object.assign({}, cdata[0]), cdata[0].confData);\n              // console.log(\"sendData\", sendData);\n              if (sendData.graphType === 'TRF') {\n                this.ponPortsStreamData$.next(sendData);\n              }\n            }\n          }\n        }\n      });\n    }\n    setPonportsInfo(data) {\n      this.ponPortsList.push(data);\n    }\n    getPonportsInfo() {\n      return this.ponPortsList;\n    }\n    emitPonports(eventname, data) {\n      if (this.WebSocketServer.socket === null) {\n        return;\n      }\n      if (typeof data === 'object') {\n        this.setRealtimeDelay(data);\n      }\n      if (typeof data === 'object' && data['replay'] && data['replay'] == \"true\") {\n        let time = Math.abs(this.sso.getRealtimeDelay());\n        data['startTime'] = parseInt(data['startTime']) - (time ? time : 60000);\n      }\n      if (this.WebSocketServer.isdisconnected) {\n        this.wsConnectionError$.next(true);\n        return;\n      }\n      if (data) {\n        this.WebSocketServer.socket.emit(eventname, data ? data : {});\n      } else this.WebSocketServer.socket.emit(eventname);\n    }\n    setHealthCurrentMonitorInfo(data) {\n      if (!data['startTime']) {\n        data['startTime'] = new Date().getTime();\n      }\n      this.healthConnectionTypes[data.monitorType] = data;\n    }\n    getHealthCurrentMonitorInfo(monitorType) {\n      return this.healthConnectionTypes[monitorType];\n    }\n    setHealthMonitorType(type) {\n      this.healthCurrentMonitorType = type;\n    }\n    getHealthMonitorType() {\n      return this.healthCurrentMonitorType;\n    }\n    setHealthWindowLen(windowLen) {\n      if (this.healthConnectionTypes[this.healthCurrentMonitorType]) {\n        this.healthConnectionTypes[this.healthCurrentMonitorType].windowLen = windowLen;\n      }\n    }\n    getHealthWindowLen() {\n      return this.healthConnectionTypes[this.healthCurrentMonitorType] && this.healthConnectionTypes[this.healthCurrentMonitorType].windowLen ? this.healthConnectionTypes[this.healthCurrentMonitorType].windowLen : 1;\n    }\n    setFilterValues(filtername, filterId, name, id) {\n      this.filterValues[name] = filtername;\n      this.filterValues[id] = filterId;\n    }\n    getFilterValues() {\n      return this.filterValues;\n    }\n    deleteFilterValues(filtername, filterId) {\n      delete this.filterValues[filtername];\n      delete this.filterValues[filterId];\n    }\n    clearHealthReplayData() {\n      this.cachePacketRTDataObj = {};\n      this.cacheRateRTDataObj = {};\n    }\n    clearHealthInfo() {\n      this.currentMonitorType = null;\n      this.connectionTypes = {};\n      this.filterValues = {};\n    }\n    calculatePercentage(total, data, length) {\n      if (!total || data.length === 0) {\n        return 0;\n      }\n      let filterData = data.slice(0, length);\n      let filterTotal = filterData.reduce((filterTotal, item) => filterTotal + item.value, 0);\n      let percentage = (filterTotal / total * 100).toFixed(2);\n      if (!percentage || percentage === 'NaN') {\n        return 0;\n      }\n      if (percentage && parseFloat(percentage) > 100) {\n        return 100;\n      }\n      return percentage;\n    }\n    setRealtimeDelay(data) {\n      data['delay'] = this.sso.getRealtimeDelay() ? Math.abs(this.sso.getRealtimeDelay()) / 1000 : 60;\n    }\n  }\n  WebsocketService.ɵfac = function WebsocketService_Factory(t) {\n    return new (t || WebsocketService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.SsoAuthService), i0.ɵɵinject(i3.Router));\n  };\n  WebsocketService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: WebsocketService,\n    factory: WebsocketService.ɵfac,\n    providedIn: 'root'\n  });\n  return WebsocketService;\n})();","map":null,"metadata":{},"sourceType":"module"}