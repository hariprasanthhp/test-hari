{"ast":null,"code":"import { getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\nSplitLaneHandler.$inject = ['modeling', 'translate'];\nSplitLaneHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling,\n    translate = this._translate;\n  var shape = context.shape,\n    newLanesCount = context.count;\n  var childLanes = getChildLanes(shape),\n    existingLanesCount = childLanes.length;\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', {\n      count: newLanesCount\n    }));\n  }\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\n\n  // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n  var laneY, laneHeight, laneBounds, newLaneAttrs, idx;\n  for (idx = 0; idx < newLanesCount; idx++) {\n    laneY = shape.y + idx * newLanesHeight;\n\n    // if bottom lane\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - newLanesHeight * idx;\n    } else {\n      laneHeight = newLanesHeight;\n    }\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}