{"ast":null,"code":"import { setSnapped, isSnapped } from '../snapping/SnapUtil';\nimport { isCmd } from '../keyboard/KeyboardUtil';\nimport { assign, isNumber } from 'min-dash';\nimport { SPACING, quantize } from './GridUtil';\nvar LOWER_PRIORITY = 1200;\nvar LOW_PRIORITY = 800;\n\n/**\r\n * Basic grid snapping that covers connecting, creating, moving, resizing shapes, moving bendpoints\r\n * and connection segments.\r\n */\nexport default function GridSnapping(elementRegistry, eventBus, config) {\n  var active = !config || config.active !== false;\n  this._eventBus = eventBus;\n  var self = this;\n  eventBus.on('diagram.init', LOW_PRIORITY, function () {\n    self.setActive(active);\n  });\n  eventBus.on(['create.move', 'create.end', 'bendpoint.move.move', 'bendpoint.move.end', 'connect.move', 'connect.end', 'connectionSegment.move.move', 'connectionSegment.move.end', 'resize.move', 'resize.end', 'shape.move.move', 'shape.move.end'], LOWER_PRIORITY, function (event) {\n    var originalEvent = event.originalEvent;\n    if (!self.active || originalEvent && isCmd(originalEvent)) {\n      return;\n    }\n    var context = event.context,\n      gridSnappingContext = context.gridSnappingContext;\n    if (!gridSnappingContext) {\n      gridSnappingContext = context.gridSnappingContext = {};\n    }\n    ['x', 'y'].forEach(function (axis) {\n      var options = {};\n\n      // allow snapping with offset\n      var snapOffset = getSnapOffset(event, axis, elementRegistry);\n      if (snapOffset) {\n        options.offset = snapOffset;\n      }\n\n      // allow snapping with min and max\n      var snapConstraints = getSnapConstraints(event, axis);\n      if (snapConstraints) {\n        assign(options, snapConstraints);\n      }\n      if (!isSnapped(event, axis)) {\n        self.snapEvent(event, axis, options);\n      }\n    });\n  });\n}\n\n/**\r\n * Snap an events x or y with optional min, max and offset.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\nGridSnapping.prototype.snapEvent = function (event, axis, options) {\n  var snappedValue = this.snapValue(event[axis], options);\n  setSnapped(event, axis, snappedValue);\n};\n\n/**\r\n * Expose grid spacing for third parties (i.e. extensions).\r\n *\r\n * @return {number} spacing of grid dots\r\n */\nGridSnapping.prototype.getGridSpacing = function () {\n  return SPACING;\n};\n\n/**\r\n * Snap value with optional min, max and offset.\r\n *\r\n * @param {number} value\r\n * @param {Object} options\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\nGridSnapping.prototype.snapValue = function (value, options) {\n  var offset = 0;\n  if (options && options.offset) {\n    offset = options.offset;\n  }\n  value += offset;\n  value = quantize(value, SPACING);\n  var min, max;\n  if (options && options.min) {\n    min = options.min;\n    if (isNumber(min)) {\n      min = quantize(min + offset, SPACING, 'ceil');\n      value = Math.max(value, min);\n    }\n  }\n  if (options && options.max) {\n    max = options.max;\n    if (isNumber(max)) {\n      max = quantize(max + offset, SPACING, 'floor');\n      value = Math.min(value, max);\n    }\n  }\n  value -= offset;\n  return value;\n};\nGridSnapping.prototype.isActive = function () {\n  return this.active;\n};\nGridSnapping.prototype.setActive = function (active) {\n  this.active = active;\n  this._eventBus.fire('gridSnapping.toggle', {\n    active: active\n  });\n};\nGridSnapping.prototype.toggleActive = function () {\n  this.setActive(!this.active);\n};\nGridSnapping.$inject = ['elementRegistry', 'eventBus', 'config.gridSnapping'];\n\n// helpers //////////\n\n/**\r\n * Get minimum and maximum snap constraints.\r\n * Constraints are cached.\r\n *\r\n * @param {Object} event\r\n * @param {Object} event.context\r\n * @param {string} axis\r\n *\r\n * @returns {boolean|Object}\r\n */\nfunction getSnapConstraints(event, axis) {\n  var context = event.context,\n    createConstraints = context.createConstraints,\n    resizeConstraints = context.resizeConstraints || {},\n    gridSnappingContext = context.gridSnappingContext,\n    snapConstraints = gridSnappingContext.snapConstraints;\n\n  // cache snap constraints\n  if (snapConstraints && snapConstraints[axis]) {\n    return snapConstraints[axis];\n  }\n  if (!snapConstraints) {\n    snapConstraints = gridSnappingContext.snapConstraints = {};\n  }\n  if (!snapConstraints[axis]) {\n    snapConstraints[axis] = {};\n  }\n  var direction = context.direction;\n\n  // create\n  if (createConstraints) {\n    if (isHorizontal(axis)) {\n      snapConstraints.x.min = createConstraints.left;\n      snapConstraints.x.max = createConstraints.right;\n    } else {\n      snapConstraints.y.min = createConstraints.top;\n      snapConstraints.y.max = createConstraints.bottom;\n    }\n  }\n\n  // resize\n  var minResizeConstraints = resizeConstraints.min,\n    maxResizeConstraints = resizeConstraints.max;\n  if (minResizeConstraints) {\n    if (isHorizontal(axis)) {\n      if (isWest(direction)) {\n        snapConstraints.x.max = minResizeConstraints.left;\n      } else {\n        snapConstraints.x.min = minResizeConstraints.right;\n      }\n    } else {\n      if (isNorth(direction)) {\n        snapConstraints.y.max = minResizeConstraints.top;\n      } else {\n        snapConstraints.y.min = minResizeConstraints.bottom;\n      }\n    }\n  }\n  if (maxResizeConstraints) {\n    if (isHorizontal(axis)) {\n      if (isWest(direction)) {\n        snapConstraints.x.min = maxResizeConstraints.left;\n      } else {\n        snapConstraints.x.max = maxResizeConstraints.right;\n      }\n    } else {\n      if (isNorth(direction)) {\n        snapConstraints.y.min = maxResizeConstraints.top;\n      } else {\n        snapConstraints.y.max = maxResizeConstraints.bottom;\n      }\n    }\n  }\n  return snapConstraints[axis];\n}\n\n/**\r\n * Get snap offset.\r\n * Offset is cached.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {ElementRegistry} elementRegistry\r\n *\r\n * @returns {number}\r\n */\nfunction getSnapOffset(event, axis, elementRegistry) {\n  var context = event.context,\n    shape = event.shape,\n    gridSnappingContext = context.gridSnappingContext,\n    snapLocation = gridSnappingContext.snapLocation,\n    snapOffset = gridSnappingContext.snapOffset;\n\n  // cache snap offset\n  if (snapOffset && isNumber(snapOffset[axis])) {\n    return snapOffset[axis];\n  }\n  if (!snapOffset) {\n    snapOffset = gridSnappingContext.snapOffset = {};\n  }\n  if (!isNumber(snapOffset[axis])) {\n    snapOffset[axis] = 0;\n  }\n  if (!shape) {\n    return snapOffset[axis];\n  }\n  if (!elementRegistry.get(shape.id)) {\n    if (isHorizontal(axis)) {\n      snapOffset[axis] += shape[axis] + shape.width / 2;\n    } else {\n      snapOffset[axis] += shape[axis] + shape.height / 2;\n    }\n  }\n  if (!snapLocation) {\n    return snapOffset[axis];\n  }\n  if (axis === 'x') {\n    if (/left/.test(snapLocation)) {\n      snapOffset[axis] -= shape.width / 2;\n    } else if (/right/.test(snapLocation)) {\n      snapOffset[axis] += shape.width / 2;\n    }\n  } else {\n    if (/top/.test(snapLocation)) {\n      snapOffset[axis] -= shape.height / 2;\n    } else if (/bottom/.test(snapLocation)) {\n      snapOffset[axis] += shape.height / 2;\n    }\n  }\n  return snapOffset[axis];\n}\nfunction isHorizontal(axis) {\n  return axis === 'x';\n}\nfunction isNorth(direction) {\n  return direction.indexOf('n') !== -1;\n}\nfunction isWest(direction) {\n  return direction.indexOf('w') !== -1;\n}","map":null,"metadata":{},"sourceType":"module"}