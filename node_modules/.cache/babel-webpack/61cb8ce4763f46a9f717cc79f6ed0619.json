{"ast":null,"code":"import inherits from 'inherits';\nimport { assign, filter, find, isNumber } from 'min-dash';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getApproxIntersection } from 'diagram-js/lib/util/LineIntersection';\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n      waypointsBefore,\n      waypointsAfter,\n      dockingPoint,\n      source,\n      target,\n      incomingConnection,\n      outgoingConnection,\n      oldOutgoing = shape.outgoing.slice(),\n      oldIncoming = shape.incoming.slice();\n    var mid;\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n    var intersection = getApproxIntersection(waypoints, mid);\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n    source = targetFlow.source;\n    target = targetFlow.target;\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n      incomingConnection = targetFlow;\n    }\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(shape, target, {\n          type: targetFlow.type,\n          waypoints: waypointsAfter\n        });\n      }\n    }\n    var duplicateConnections = [].concat(incomingConnection && filter(oldIncoming, function (connection) {\n      return connection.source === incomingConnection.source;\n    }) || [], outgoingConnection && filter(oldOutgoing, function (connection) {\n      return connection.target === outgoingConnection.target;\n    }) || []);\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n  this.preExecute('elements.move', function (context) {\n    var newParent = context.newParent,\n      shapes = context.shapes,\n      delta = context.delta,\n      shape = shapes[0];\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function (element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n  }, true);\n  this.postExecuted('elements.move', function (context) {\n    var shapes = context.shapes,\n      targetFlow = context.targetFlow,\n      position = context.position;\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n  }, true);\n  this.preExecute('shape.create', function (context) {\n    var parent = context.parent,\n      shape = context.shape;\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n  this.postExecuted('shape.create', function (context) {\n    var shape = context.shape,\n      targetFlow = context.targetFlow,\n      positionOrBounds = context.position;\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\ninherits(DropOnFlowBehavior, CommandInterceptor);\nDropOnFlowBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling'];\n\n// helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n    y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\nfunction copy(obj) {\n  return assign({}, obj);\n}","map":null,"metadata":{},"sourceType":"module"}