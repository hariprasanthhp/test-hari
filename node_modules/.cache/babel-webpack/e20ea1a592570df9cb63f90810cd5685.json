{"ast":null,"code":"import { isObject, sortBy } from 'min-dash';\nimport { pointDistance, pointsOnLine } from '../util/Geometry';\nimport intersectPaths from 'path-intersection';\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\nexport function roundPoint(point) {\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\nexport function getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n// orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|number} padding\n *\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nexport function getOrientation(rect, reference, padding) {\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = {\n      x: padding,\n      y: padding\n    };\n  }\n  var rectOrientation = asTRBL(rect),\n    referenceOrientation = asTRBL(reference);\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n    right = rectOrientation.left - padding.x >= referenceOrientation.right,\n    bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n    left = rectOrientation.right + padding.x <= referenceOrientation.left;\n  var vertical = top ? 'top' : bottom ? 'bottom' : null,\n    horizontal = left ? 'left' : right ? 'right' : null;\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n// intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function (i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n      distance = 100 - distance;\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n  return null;\n}\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\nexport function filterRedundantWaypoints(waypoints) {\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n  var idx = 0,\n    point,\n    previousPoint,\n    nextPoint;\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n  return waypoints;\n}","map":null,"metadata":{},"sourceType":"module"}