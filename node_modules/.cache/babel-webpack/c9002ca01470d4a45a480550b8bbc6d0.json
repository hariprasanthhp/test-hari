{"ast":null,"code":"import { assign } from 'min-dash';\nimport inherits from 'inherits';\nimport { is, getBusinessObject } from '../../../util/ModelUtil';\nimport { isLabelExternal, getExternalLabelMid, hasExternalLabel, isLabel } from '../../../util/LabelUtil';\nimport { getLabel } from '../../label-editing/LabelUtil';\nimport { getLabelAdjustment } from './util/LabelLayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getNewAttachPoint } from 'diagram-js/lib/util/AttachUtil';\nimport { getMid, roundPoint } from 'diagram-js/lib/layout/LayoutUtil';\nimport { delta } from 'diagram-js/lib/util/PositionUtil';\nimport { sortBy } from 'min-dash';\nimport { getDistancePointLine, perpendicularFoot } from './util/GeometricUtil';\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\nvar NAME_PROPERTY = 'name';\nvar TEXT_PROPERTY = 'text';\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n * @param {TextRenderer} textRenderer\n */\nexport default function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {\n  CommandInterceptor.call(this, eventBus);\n\n  // update label if name property was updated\n  this.postExecute('element.updateProperties', function (e) {\n    var context = e.context,\n      element = context.element,\n      properties = context.properties;\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n    if (TEXT_PROPERTY in properties && is(element, 'bpmn:TextAnnotation')) {\n      var newBounds = textRenderer.getTextAnnotationBounds({\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height\n      }, properties[TEXT_PROPERTY] || '');\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  });\n\n  // create label shape after shape/connection was created\n  this.postExecute(['shape.create', 'connection.create'], function (e) {\n    var context = e.context,\n      hints = context.hints || {};\n    if (hints.createElementsBehavior === false) {\n      return;\n    }\n    var element = context.shape || context.connection,\n      businessObject = element.businessObject;\n    if (isLabel(element) || !isLabelExternal(element)) {\n      return;\n    }\n\n    // only create label if attribute available\n    if (!getLabel(element)) {\n      return;\n    }\n    var labelCenter = getExternalLabelMid(element);\n\n    // we don't care about x and y\n    var labelDimensions = textRenderer.getExternalLabelBounds(DEFAULT_LABEL_DIMENSIONS, getLabel(element));\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  });\n\n  // update label after label shape was deleted\n  this.postExecute('shape.delete', function (event) {\n    var context = event.context,\n      labelTarget = context.labelTarget,\n      hints = context.hints || {};\n\n    // check if label\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, {\n        removeShape: false\n      });\n    }\n  });\n\n  // update di information on label creation\n  this.postExecute(['label.create'], function (event) {\n    var context = event.context,\n      element = context.shape,\n      businessObject,\n      di;\n\n    // we want to trigger on real labels only\n    if (!element.labelTarget) {\n      return;\n    }\n\n    // we want to trigger on BPMN elements only\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n    businessObject = element.businessObject, di = businessObject.di;\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n  function getVisibleLabelAdjustment(event) {\n    var context = event.context,\n      connection = context.connection,\n      label = connection.label,\n      hints = assign({}, context.hints),\n      newWaypoints = context.newWaypoints || connection.waypoints,\n      oldWaypoints = context.oldWaypoints;\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n  this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (event) {\n    var context = event.context,\n      hints = context.hints || {};\n    if (hints.labelBehavior === false) {\n      return;\n    }\n    var connection = context.connection,\n      label = connection.label,\n      labelAdjustment;\n\n    // handle missing label as well as the case\n    // that the label parent does not exist (yet),\n    // because it is being pasted / created via multi element create\n    //\n    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227\n    if (!label || !label.parent) {\n      return;\n    }\n    labelAdjustment = getVisibleLabelAdjustment(event);\n    modeling.moveShape(label, labelAdjustment);\n  });\n\n  // keep label position on shape replace\n  this.postExecute(['shape.replace'], function (event) {\n    var context = event.context,\n      newShape = context.newShape,\n      oldShape = context.oldShape;\n    var businessObject = getBusinessObject(newShape);\n    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n\n  // move external label after resizing\n  this.postExecute('shape.resize', function (event) {\n    var context = event.context,\n      shape = context.shape,\n      newBounds = context.newBounds,\n      oldBounds = context.oldBounds;\n    if (hasExternalLabel(shape)) {\n      var label = shape.label,\n        labelMid = getMid(label),\n        edges = asEdges(oldBounds);\n\n      // get nearest border point to label as reference point\n      var referencePoint = getReferencePoint(labelMid, edges);\n      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);\n      modeling.moveShape(label, delta);\n    }\n  });\n}\ninherits(LabelBehavior, CommandInterceptor);\nLabelBehavior.$inject = ['eventBus', 'modeling', 'bpmnFactory', 'textRenderer'];\n\n// helpers //////////////////////\n\n/**\n * Calculates a reference point delta relative to a new position\n * of a certain element's bounds\n *\n * @param {Point} point\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @return {Delta} delta\n */\nexport function getReferencePointDelta(referencePoint, oldBounds, newBounds) {\n  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);\n  return roundPoint(delta(newReferencePoint, referencePoint));\n}\n\n/**\n * Generates the nearest point (reference point) for a given point\n * onto given set of lines\n *\n * @param {Array<Point, Point>} lines\n * @param {Point} point\n *\n * @param {Point}\n */\nexport function getReferencePoint(point, lines) {\n  if (!lines.length) {\n    return;\n  }\n  var nearestLine = getNearestLine(point, lines);\n  return perpendicularFoot(point, nearestLine);\n}\n\n/**\n * Convert the given bounds to a lines array containing all edges\n *\n * @param {Bounds|Point} bounds\n *\n * @return Array<Point>\n */\nexport function asEdges(bounds) {\n  return [[\n  // top\n  {\n    x: bounds.x,\n    y: bounds.y\n  }, {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y\n  }], [\n  // right\n  {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y\n  }, {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y + (bounds.height || 0)\n  }], [\n  // bottom\n  {\n    x: bounds.x,\n    y: bounds.y + (bounds.height || 0)\n  }, {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y + (bounds.height || 0)\n  }], [\n  // left\n  {\n    x: bounds.x,\n    y: bounds.y\n  }, {\n    x: bounds.x,\n    y: bounds.y + (bounds.height || 0)\n  }]];\n}\n\n/**\n * Returns the nearest line for a given point by distance\n * @param {Point} point\n * @param Array<Point> lines\n *\n * @return Array<Point>\n */\nfunction getNearestLine(point, lines) {\n  var distances = lines.map(function (l) {\n    return {\n      line: l,\n      distance: getDistancePointLine(point, l)\n    };\n  });\n  var sorted = sortBy(distances, 'distance');\n  return sorted[0].line;\n}","map":null,"metadata":{},"sourceType":"module"}