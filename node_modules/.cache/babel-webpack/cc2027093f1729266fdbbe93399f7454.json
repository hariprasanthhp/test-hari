{"ast":null,"code":"import { domify, classes as domClasses, matches as domMatches, delegate as domDelegate, query as domQuery, queryAll as domQueryAll, event as domEvent, attr as domAttr } from 'min-dom';\nimport { filter, assign } from 'min-dash';\nimport createEmitter from 'mitt';\nvar DEFAULT_OPTIONS = {\n  scrollSymbolLeft: '‹',\n  scrollSymbolRight: '›'\n};\n\n/**\n * This component adds the functionality to scroll over a list of tabs.\n *\n * It adds scroll buttons on the left and right side of the tabs container\n * if not all tabs are visible. It also adds a mouse wheel listener on the\n * container.\n *\n * If either a button is clicked or the mouse wheel is used over the tabs,\n * a 'scroll' event is being fired. This event contains the node elements\n * of the new and old active tab, and the direction in which the tab has\n * changed relative to the old active tab.\n *\n * @example:\n * (1) provide a tabs-container:\n *\n * var $el = (\n *   <div>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-left\"></span>\n *     <ul class=\"my-tabs-container\">\n *       <li class=\"my-tab i-am-active\"></li>\n *       <li class=\"my-tab\"></li>\n *       <li class=\"my-tab ignore-me\"></li>\n *     </ul>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-right\"></span>\n *   </div>\n * );\n *\n *\n * (2) initialize scrollTabs:\n *\n *  var scroller = scrollTabs(tabBarNode, {\n *    selectors: {\n *      tabsContainer: '.my-tabs-container',\n *      tab: '.my-tab',\n *      ignore: '.ignore-me',\n *      active: '.i-am-active'\n *    }\n *  });\n *\n *\n * (3) listen to the scroll event:\n *\n * scroller.on('scroll', function(newActiveNode, oldActiveNode, direction) {\n *   // direction is any of (-1: left, 1: right)\n *   // activate the new active tab\n * });\n *\n *\n * (4) update the scroller if tabs change and or the tab container resizes:\n *\n * scroller.update();\n *\n *\n * @param  {DOMElement} el\n * @param  {Object} options\n * @param  {Object} options.selectors\n * @param  {String} options.selectors.tabsContainer the container all tabs are contained in\n * @param  {String} options.selectors.tab a single tab inside the tab container\n * @param  {String} options.selectors.ignore tabs that should be ignored during scroll left/right\n * @param  {String} options.selectors.active selector for the current active tab\n * @param  {String} [options.scrollSymbolLeft]\n * @param  {String} [options.scrollSymbolRight]\n */\nfunction ScrollTabs($el, options) {\n  // we are an event emitter\n  assign(this, createEmitter());\n  this.options = options = assign({}, DEFAULT_OPTIONS, options);\n  this.container = $el;\n  this._createScrollButtons($el, options);\n  this._bindEvents($el);\n}\n\n/**\n * Create a clickable scroll button\n *\n * @param {Object} options\n * @param {String} options.className\n * @param {String} options.label\n * @param {Number} options.direction\n *\n * @return {DOMElement} The created scroll button node\n */\nScrollTabs.prototype._createButton = function (parentNode, options) {\n  var className = options.className,\n    direction = options.direction;\n  var button = domQuery('.' + className, parentNode);\n  if (!button) {\n    button = domify('<span class=\"scroll-tabs-button ' + className + '\">' + options.label + '</span>');\n    parentNode.insertBefore(button, parentNode.childNodes[0]);\n  }\n  domAttr(button, 'data-direction', direction);\n  return button;\n};\n\n/**\n * Create both scroll buttons\n *\n * @param  {DOMElement} parentNode\n * @param  {Object} options\n * @param  {String} options.scrollSymbolLeft\n * @param  {String} options.scrollSymbolRight\n */\nScrollTabs.prototype._createScrollButtons = function (parentNode, options) {\n  // Create a button that scrolls to the tab left to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-left',\n    label: options.scrollSymbolLeft,\n    direction: -1\n  });\n\n  // Create a button that scrolls to the tab right to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-right',\n    label: options.scrollSymbolRight,\n    direction: 1\n  });\n};\n\n/**\n * Get the current active tab\n *\n * @return {DOMElement}\n */\nScrollTabs.prototype.getActiveTabNode = function () {\n  return domQuery(this.options.selectors.active, this.container);\n};\n\n/**\n * Get the container all tabs are contained in\n *\n * @return {DOMElement}\n */\nScrollTabs.prototype.getTabsContainerNode = function () {\n  return domQuery(this.options.selectors.tabsContainer, this.container);\n};\n\n/**\n * Get all tabs (visible and invisible ones)\n *\n * @return {Array<DOMElement>}\n */\nScrollTabs.prototype.getAllTabNodes = function () {\n  return domQueryAll(this.options.selectors.tab, this.container);\n};\n\n/**\n * Gets all tabs that don't have the ignore class set\n *\n * @return {Array<DOMElement>}\n */\nScrollTabs.prototype.getVisibleTabs = function () {\n  var allTabs = this.getAllTabNodes();\n  var ignore = this.options.selectors.ignore;\n  return filter(allTabs, function (tabNode) {\n    return !domMatches(tabNode, ignore);\n  });\n};\n\n/**\n * Get a tab relative to a reference tab.\n *\n * @param  {DOMElement} referenceTabNode\n * @param  {Number} n gets the nth tab next or previous to the reference tab\n *\n * @return {DOMElement}\n *\n * @example:\n * Visible tabs: [ A | B | C | D | E ]\n * Assume tab 'C' is the reference tab:\n * If direction === -1, it returns tab 'B',\n * if direction ===  2, it returns tab 'E'\n */\nScrollTabs.prototype.getAdjacentTab = function (referenceTabNode, n) {\n  var visibleTabs = this.getVisibleTabs();\n  var index = visibleTabs.indexOf(referenceTabNode);\n  return visibleTabs[index + n];\n};\nScrollTabs.prototype._bindEvents = function (node) {\n  this._bindWheelEvent(node);\n  this._bindTabClickEvents(node);\n  this._bindScrollButtonEvents(node);\n};\n\n/**\n *  Bind a click listener to a DOM node.\n *  Make sure a tab link is entirely visible after onClick.\n *\n * @param {DOMElement} node\n */\nScrollTabs.prototype._bindTabClickEvents = function (node) {\n  var selector = this.options.selectors.tab;\n  var self = this;\n  domDelegate.bind(node, selector, 'click', function onClick(event) {\n    self.scrollToTabNode(event.delegateTarget);\n  });\n};\n\n/**\n * Bind the wheel event listener to a DOM node\n *\n * @param {DOMElement} node\n */\nScrollTabs.prototype._bindWheelEvent = function (node) {\n  var self = this;\n  domEvent.bind(node, 'wheel', function (e) {\n    // scroll direction (-1: left, 1: right)\n    var direction = Math.sign(e.deltaY);\n    var oldActiveTab = self.getActiveTabNode();\n    var newActiveTab = self.getAdjacentTab(oldActiveTab, direction);\n    if (newActiveTab) {\n      self.scrollToTabNode(newActiveTab);\n      self.emit('scroll', newActiveTab, oldActiveTab, direction);\n    }\n    e.preventDefault();\n  });\n};\n\n/**\n * Bind scroll button events to a DOM node\n *\n * @param  {DOMElement} node\n */\nScrollTabs.prototype._bindScrollButtonEvents = function (node) {\n  var self = this;\n  domDelegate.bind(node, '.scroll-tabs-button', 'click', function (event) {\n    var target = event.delegateTarget;\n\n    // data-direction is either -1 or 1\n    var direction = parseInt(domAttr(target, 'data-direction'), 10);\n    var oldActiveTabNode = self.getActiveTabNode();\n    var newActiveTabNode = self.getAdjacentTab(oldActiveTabNode, direction);\n    if (newActiveTabNode) {\n      self.scrollToTabNode(newActiveTabNode);\n      self.emit('scroll', newActiveTabNode, oldActiveTabNode, direction);\n    }\n    event.preventDefault();\n  });\n};\n\n/**\n* Scroll to a tab if it is not entirely visible\n*\n* @param  {DOMElement} tabNode tab node to scroll to\n*/\nScrollTabs.prototype.scrollToTabNode = function (tabNode) {\n  if (!tabNode) {\n    return;\n  }\n  var tabsContainerNode = tabNode.parentNode;\n  var tabWidth = tabNode.offsetWidth,\n    tabOffsetLeft = tabNode.offsetLeft,\n    tabOffsetRight = tabOffsetLeft + tabWidth,\n    containerWidth = tabsContainerNode.offsetWidth,\n    containerScrollLeft = tabsContainerNode.scrollLeft;\n  if (containerScrollLeft > tabOffsetLeft) {\n    // scroll to the left, if the tab is overflowing on the left side\n    tabsContainerNode.scrollLeft = 0;\n  } else if (tabOffsetRight > containerWidth) {\n    // scroll to the right, if the tab is overflowing on the right side\n    tabsContainerNode.scrollLeft = tabOffsetRight - containerWidth;\n  }\n};\n\n/**\n * React on tab changes from outside (resize/show/hide/add/remove),\n * update scroll button visibility.\n */\nScrollTabs.prototype.update = function () {\n  var tabsContainerNode = this.getTabsContainerNode();\n\n  // check if tabs fit in container\n  var overflow = tabsContainerNode.scrollWidth > tabsContainerNode.offsetWidth;\n\n  // TODO(nikku): distinguish overflow left / overflow right?\n  var overflowClass = 'scroll-tabs-overflow';\n  domClasses(this.container).toggle(overflowClass, overflow);\n  if (overflow) {\n    // make sure the current active tab is always visible\n    this.scrollToTabNode(this.getActiveTabNode());\n  }\n};\n\n// exports ////////////////\n\n/**\n * Create a scrollTabs instance on the given element.\n *\n * @param {DOMElement} $el\n * @param {Object} options\n *\n * @return {ScrollTabs}\n */\nexport default function create($el, options) {\n  var scrollTabs = get($el);\n  if (!scrollTabs) {\n    scrollTabs = new ScrollTabs($el, options);\n    $el.__scrollTabs = scrollTabs;\n  }\n  return scrollTabs;\n}\n\n/**\n * Return the scrollTabs instance that has been previously\n * initialized on the element.\n *\n * @param {DOMElement} $el\n * @return {ScrollTabs}\n */\nfunction get($el) {\n  return $el.__scrollTabs;\n}\ncreate.get = get;","map":null,"metadata":{},"sourceType":"module"}