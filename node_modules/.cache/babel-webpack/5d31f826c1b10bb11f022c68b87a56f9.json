{"ast":null,"code":"import { assign, isNumber } from 'min-dash';\nvar DEFAULT_OPTIONS = {\n  offset: {\n    x: 150,\n    y: 75\n  },\n  tolerance: 50,\n  alignOnSave: true\n};\nvar HIGHER_PRIORITY = 1250;\n\n/**\n * Moves diagram contents to the origin + offset,\n * optionally upon diagram save.\n *\n * @param {Object} config\n * @param {didi.Injector} injector\n * @param {EventBus} eventBus\n * @param {CommandStack} commandStack\n * @param {Canvas} canvas\n * @param {Modeling} modeling\n */\nexport default function AlignToOrigin(config, injector, eventBus, commandStack, canvas, modeling) {\n  /**\n   * Return actual config with defaults applied.\n   */\n  function applyDefaults(config) {\n    var c = assign({}, DEFAULT_OPTIONS, config || {});\n    if (isNumber(c.offset)) {\n      c.offset = {\n        x: c.offset,\n        y: c.offset\n      };\n    }\n    return c;\n  }\n  config = applyDefaults(config);\n\n  /**\n   * Compute adjustment given the specified diagram origin.\n   *\n   * @param {Point} origin\n   *\n   * @return {Point} adjustment\n   */\n  function computeAdjustment(origin, config) {\n    var offset = config.offset,\n      tolerance = config.tolerance;\n    var adjustment = {};\n    ['x', 'y'].forEach(function (axis) {\n      var delta = -origin[axis] + offset[axis];\n      var gridSnapping = injector.get('gridSnapping', false);\n      if (gridSnapping) {\n        delta = quantize(delta, gridSnapping.getGridSpacing());\n      }\n      adjustment[axis] = Math.abs(delta) < tolerance ? 0 : delta;\n    });\n    return adjustment;\n  }\n\n  /**\n   * Align the diagram content to the origin.\n   *\n   * @param {Object} options\n   */\n  function align() {\n    var bounds = canvas.viewbox().inner;\n    var elements = canvas.getRootElement().children;\n    var delta = computeAdjustment(bounds, config);\n    if (delta.x === 0 && delta.y === 0) {\n      return;\n    }\n    commandStack.execute('elements.alignToOrigin', {\n      elements: elements,\n      delta: delta\n    });\n  }\n\n  /**\n   * Setup align on save functionality\n   */\n  function bindOnSave() {\n    // nested editors expose _parent to access the\n    // save responsible entity\n    var parent = injector.get('_parent', false);\n    var localEvents = eventBus;\n    var parentEvents = parent && parent._eventBus;\n    (parentEvents || localEvents).on('saveXML.start', HIGHER_PRIORITY, align);\n    if (parentEvents) {\n      // unregister for saveXML.start\n      localEvents.on('diagram.destroy', function () {\n        parentEvents.off('saveXML.start', align);\n      });\n    }\n  }\n\n  /**\n   * Create a function that compensates the element movement\n   * by moving applying the delta in the given direction.\n   */\n  function movementCompensator(direction) {\n    /**\n     * Handler to executed\n     */\n    return function (context) {\n      // adjust canvas after the commandstack got changed\n      eventBus.once('commandStack.changed', function () {\n        var delta = context.delta;\n        var scale = canvas.viewbox().scale;\n        canvas.scroll({\n          dx: direction * delta.x * scale,\n          dy: direction * delta.y * scale\n        });\n      });\n    };\n  }\n\n  // command registration\n\n  /**\n   * A command handler that compensates the element movement\n   * by applying the inverse move operation on the canvas.\n   */\n  commandStack.register('elements.alignToOrigin', {\n    preExecute: function (context) {\n      var delta = context.delta,\n        elements = context.elements;\n      modeling.moveElements(elements, delta);\n    },\n    execute: movementCompensator(-1),\n    revert: movementCompensator(1)\n  });\n\n  // setup\n\n  if (config.alignOnSave) {\n    bindOnSave();\n  }\n\n  // API\n\n  this.align = align;\n  this.computeAdjustment = computeAdjustment;\n\n  // internal debugging purposes\n  this._config = config;\n}\nAlignToOrigin.$inject = ['config.alignToOrigin', 'injector', 'eventBus', 'commandStack', 'canvas', 'modeling'];\n\n// helpers /////////////////////////\n\nfunction quantize(value, quantum, fn) {\n  if (!fn) {\n    fn = 'round';\n  }\n  return Math[fn](value / quantum) * quantum;\n}","map":null,"metadata":{},"sourceType":"module"}