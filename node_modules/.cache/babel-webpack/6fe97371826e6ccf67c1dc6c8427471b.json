{"ast":null,"code":"import { assign, forEach, isArray } from 'min-dash';\nimport { setSnapped } from '../snapping/SnapUtil';\nvar abs = Math.abs,\n  round = Math.round;\nvar TOLERANCE = 10;\nexport default function BendpointSnapping(eventBus) {\n  function snapTo(values, value) {\n    if (isArray(values)) {\n      var i = values.length;\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n    return value;\n  }\n  function mid(element) {\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  }\n\n  // connection segment snapping //////////////////////\n\n  function getConnectionSegmentSnaps(context) {\n    var snapPoints = context.snapPoints,\n      connection = context.connection,\n      waypoints = connection.waypoints,\n      segmentStart = context.segmentStart,\n      segmentStartIndex = context.segmentStartIndex,\n      segmentEnd = context.segmentEnd,\n      segmentEndIndex = context.segmentEndIndex,\n      axis = context.axis;\n    if (snapPoints) {\n      return snapPoints;\n    }\n    var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(mid(connection.source));\n    }\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(mid(connection.target));\n    }\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n    return snapPoints;\n  }\n  eventBus.on('connectionSegment.move.move', 1500, function (event) {\n    var context = event.context,\n      snapPoints = getConnectionSegmentSnaps(context),\n      x = event.x,\n      y = event.y,\n      sx,\n      sy;\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y);\n\n    // correction x/y\n    var cx = x - sx,\n      cy = y - sy;\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n\n  // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n    var snapPoints = context.snapPoints,\n      waypoints = context.connection.waypoints,\n      bendpointIndex = context.bendpointIndex;\n    if (snapPoints) {\n      return snapPoints;\n    }\n    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n    return snapPoints;\n  }\n  eventBus.on(['bendpoint.move.move', 'bendpoint.move.end'], 1500, function (event) {\n    var context = event.context,\n      snapPoints = getBendpointSnaps(context),\n      hover = context.hover,\n      hoverMid = hover && mid(hover),\n      x = event.x,\n      y = event.y,\n      sx,\n      sy;\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap to hover mid\n    sx = snapTo(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x);\n    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y);\n\n    // correction x/y\n    var cx = x - sx,\n      cy = y - sy;\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n}\nBendpointSnapping.$inject = ['eventBus'];","map":null,"metadata":{},"sourceType":"module"}