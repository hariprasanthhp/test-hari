{"ast":null,"code":"var MARKER_OK = 'drop-ok',\n  MARKER_NOT_OK = 'drop-not-ok',\n  MARKER_ATTACH = 'attach-ok',\n  MARKER_NEW_PARENT = 'new-parent';\nimport { assign, filter, find, forEach, isArray, isNumber, map } from 'min-dash';\nimport { getBBox } from '../../util/Elements';\nvar PREFIX = 'create';\nvar HIGH_PRIORITY = 2000;\n\n/**\n * Create new elements through drag and drop.\n *\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function Create(canvas, dragging, eventBus, modeling, rules) {\n  // rules //////////\n\n  /**\n   * Check wether elements can be created.\n   *\n   * @param {Array<djs.model.Base>} elements\n   * @param {djs.model.Base} target\n   * @param {Point} position\n   * @param {djs.model.Base} [source]\n   *\n   * @returns {boolean|null|Object}\n   */\n  function canCreate(elements, target, position, source, hints) {\n    if (!target) {\n      return false;\n    }\n\n    // ignore child elements and external labels\n    elements = filter(elements, function (element) {\n      var labelTarget = element.labelTarget;\n      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);\n    });\n    var shape = find(elements, function (element) {\n      return !isConnection(element);\n    });\n    var attach = false,\n      connect = false,\n      create = false;\n\n    // (1) attaching single shapes\n    if (isSingleShape(elements)) {\n      attach = rules.allowed('shape.attach', {\n        position: position,\n        shape: shape,\n        target: target\n      });\n    }\n    if (!attach) {\n      // (2) creating elements\n      if (isSingleShape(elements)) {\n        create = rules.allowed('shape.create', {\n          position: position,\n          shape: shape,\n          source: source,\n          target: target\n        });\n      } else {\n        create = rules.allowed('elements.create', {\n          elements: elements,\n          position: position,\n          target: target\n        });\n      }\n    }\n    var connectionTarget = hints.connectionTarget;\n\n    // (3) appending single shapes\n    if (create || attach) {\n      if (shape && source) {\n        connect = rules.allowed('connection.create', {\n          source: connectionTarget === source ? shape : source,\n          target: connectionTarget === source ? source : shape,\n          hints: {\n            targetParent: target,\n            targetAttach: attach\n          }\n        });\n      }\n      return {\n        attach: attach,\n        connect: connect\n      };\n    }\n\n    // ignore wether or not elements can be created\n    if (create === null || attach === null) {\n      return null;\n    }\n    return false;\n  }\n  function setMarker(element, marker) {\n    [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n  // event handling //////////\n\n  eventBus.on(['create.move', 'create.hover'], function (event) {\n    var context = event.context,\n      elements = context.elements,\n      hover = event.hover,\n      source = context.source,\n      hints = context.hints || {};\n    if (!hover) {\n      context.canExecute = false;\n      context.target = null;\n      return;\n    }\n    ensureConstraints(event);\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);\n    if (hover && canExecute !== null) {\n      context.target = hover;\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n  eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {\n    var hover = event.hover;\n    if (hover) {\n      setMarker(hover, null);\n    }\n  });\n  eventBus.on('create.end', function (event) {\n    var context = event.context,\n      source = context.source,\n      shape = context.shape,\n      elements = context.elements,\n      target = context.target,\n      canExecute = context.canExecute,\n      attach = canExecute && canExecute.attach,\n      connect = canExecute && canExecute.connect,\n      hints = context.hints || {};\n    if (canExecute === false || !target) {\n      return false;\n    }\n    ensureConstraints(event);\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n    if (connect) {\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect,\n        connectionTarget: hints.connectionTarget\n      });\n    } else {\n      elements = modeling.createElements(elements, position, target, assign({}, hints, {\n        attach: attach\n      }));\n\n      // update shape\n      shape = find(elements, function (element) {\n        return !isConnection(element);\n      });\n    }\n\n    // update elements and shape\n    assign(context, {\n      elements: elements,\n      shape: shape\n    });\n    assign(event, {\n      elements: elements,\n      shape: shape\n    });\n  });\n  function cancel() {\n    var context = dragging.context();\n    if (context && context.prefix === PREFIX) {\n      dragging.cancel();\n    }\n  }\n\n  // cancel on <elements.changed> that is not result of <drag.end>\n  eventBus.on('create.init', function () {\n    eventBus.on('elements.changed', cancel);\n    eventBus.once(['create.cancel', 'create.end'], HIGH_PRIORITY, function () {\n      eventBus.off('elements.changed', cancel);\n    });\n  });\n\n  // API //////////\n\n  this.start = function (event, elements, context) {\n    if (!isArray(elements)) {\n      elements = [elements];\n    }\n    var shape = find(elements, function (element) {\n      return !isConnection(element);\n    });\n    if (!shape) {\n      // at least one shape is required\n      return;\n    }\n    context = assign({\n      elements: elements,\n      hints: {},\n      shape: shape\n    }, context || {});\n\n    // make sure each element has x and y\n    forEach(elements, function (element) {\n      if (!isNumber(element.x)) {\n        element.x = 0;\n      }\n      if (!isNumber(element.y)) {\n        element.y = 0;\n      }\n    });\n    var bbox = getBBox(elements);\n\n    // center elements around cursor\n    forEach(elements, function (element) {\n      if (isConnection(element)) {\n        element.waypoints = map(element.waypoints, function (waypoint) {\n          return {\n            x: waypoint.x - bbox.x - bbox.width / 2,\n            y: waypoint.y - bbox.y - bbox.height / 2\n          };\n        });\n      }\n      assign(element, {\n        x: element.x - bbox.x - bbox.width / 2,\n        y: element.y - bbox.y - bbox.height / 2\n      });\n    });\n    dragging.init(event, PREFIX, {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        elements: elements,\n        context: context\n      }\n    });\n  };\n}\nCreate.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules'];\n\n// helpers //////////\n\nfunction ensureConstraints(event) {\n  var context = event.context,\n    createConstraints = context.createConstraints;\n  if (!createConstraints) {\n    return;\n  }\n  if (createConstraints.left) {\n    event.x = Math.max(event.x, createConstraints.left);\n  }\n  if (createConstraints.right) {\n    event.x = Math.min(event.x, createConstraints.right);\n  }\n  if (createConstraints.top) {\n    event.y = Math.max(event.y, createConstraints.top);\n  }\n  if (createConstraints.bottom) {\n    event.y = Math.min(event.y, createConstraints.bottom);\n  }\n}\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\nfunction isSingleShape(elements) {\n  return elements && elements.length === 1 && !isConnection(elements[0]);\n}\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}","map":null,"metadata":{},"sourceType":"module"}