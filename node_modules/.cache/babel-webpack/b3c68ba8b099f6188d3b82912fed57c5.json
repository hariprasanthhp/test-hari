{"ast":null,"code":"import { filter, forEach, sortBy } from 'min-dash';\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n\n/**\n * Sorting functions for different types of alignment\n *\n * @type {Object}\n *\n * @return {Function}\n */\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function (element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function (element) {\n    return element.y + element.height;\n  }\n};\nexport default function AlignElements(modeling) {\n  this._modeling = modeling;\n}\nAlignElements.$inject = ['modeling'];\n\n/**\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\n *\n * @param  {string} type left|right|center|top|bottom|middle\n *\n * @return {Object} { axis, dimension }\n */\nAlignElements.prototype._getOrientationDetails = function (type) {\n  var vertical = ['top', 'bottom', 'middle'],\n    axis = 'x',\n    dimension = 'width';\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\nAlignElements.prototype._isType = function (type, types) {\n  return types.indexOf(type) !== -1;\n};\n\n/**\n * Get a point on the relevant axis where elements should align to\n *\n * @param  {string} type left|right|center|top|bottom|middle\n * @param  {Array} sortedElements\n *\n * @return {Object}\n */\nAlignElements.prototype._alignmentPosition = function (type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n    axis = orientation.axis,\n    dimension = orientation.dimension,\n    alignment = {},\n    centers = {},\n    hasSharedCenters = false,\n    centeredElements,\n    firstElement,\n    lastElement;\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n  if (this._isType(type, ['left', 'top'])) {\n    alignment[type] = sortedElements[0][axis];\n  } else if (this._isType(type, ['right', 'bottom'])) {\n    lastElement = last(sortedElements);\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n  } else if (this._isType(type, ['center', 'middle'])) {\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function (element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [element],\n          center: center\n        };\n      }\n    });\n    centeredElements = sortBy(centers, function (center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n      return center.elements.length;\n    });\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n      return alignment;\n    }\n    firstElement = sortedElements[0];\n    sortedElements = sortBy(sortedElements, function (element) {\n      return element[axis] + element[dimension];\n    });\n    lastElement = last(sortedElements);\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n  return alignment;\n};\n\n/**\n * Executes the alignment of a selection of elements\n *\n * @param  {Array} elements [description]\n * @param  {string} type left|right|center|top|bottom|middle\n */\nAlignElements.prototype.trigger = function (elements, type) {\n  var modeling = this._modeling;\n  var filteredElements = filter(elements, function (element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n  if (filteredElements.length < 2) {\n    return;\n  }\n  var sortFn = ALIGNMENT_SORTING[type];\n  var sortedElements = sortBy(filteredElements, sortFn);\n  var alignment = this._alignmentPosition(type, sortedElements);\n  modeling.alignElements(sortedElements, alignment);\n};","map":null,"metadata":{},"sourceType":"module"}