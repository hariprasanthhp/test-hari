{"ast":null,"code":"import * as Highcharts from 'highcharts/highstock';\nimport more from 'highcharts/highcharts-more';\nimport StreamgraphModule from 'highcharts/modules/streamgraph';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app-services/translate.service\";\nimport * as i2 from \"src/app/shared-utils/date-utils.service\";\nimport * as i3 from \"src/app/cco/shared/services/websocket.service\";\nimport * as i4 from \"src/app/shared/services/sso-auth.service\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"highcharts-angular\";\nfunction StreamChartComponent_div_0_span_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 16);\n    i0.ɵɵelement(1, \"i\", 17);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.upRate, \" \");\n  }\n}\nfunction StreamChartComponent_div_0_span_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵelement(1, \"i\", 19);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.downRate, \"\");\n  }\n}\nfunction StreamChartComponent_div_0_highcharts_chart_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"highcharts-chart\", 20);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"Highcharts\", ctx_r3.highcharts)(\"options\", ctx_r3.streamOptions)(\"callbackFunction\", ctx_r3.chartCallback);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"background-color\": a0\n  };\n};\nfunction StreamChartComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵelementStart(1, \"div\", 2);\n    i0.ɵɵelementStart(2, \"div\", 3);\n    i0.ɵɵelementStart(3, \"div\", 4);\n    i0.ɵɵelementStart(4, \"span\", 5);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"a\", 6);\n    i0.ɵɵlistener(\"click\", function StreamChartComponent_div_0_Template_a_click_6_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.toggleUpStream();\n    });\n    i0.ɵɵelement(7, \"span\", 7);\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"a\", 8);\n    i0.ɵɵlistener(\"click\", function StreamChartComponent_div_0_Template_a_click_9_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.toggleDownStream();\n    });\n    i0.ɵɵelement(10, \"span\", 7);\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(12, \"span\", 9);\n    i0.ɵɵtext(13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"div\", 10);\n    i0.ɵɵelementStart(15, \"span\", 11);\n    i0.ɵɵtemplate(16, StreamChartComponent_div_0_span_16_Template, 3, 1, \"span\", 12);\n    i0.ɵɵtemplate(17, StreamChartComponent_div_0_span_17_Template, 3, 1, \"span\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(18, \"div\", 14);\n    i0.ɵɵtemplate(19, StreamChartComponent_div_0_highcharts_chart_19_Template, 1, 3, \"highcharts-chart\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵpropertyInterpolate(\"title\", ctx_r0.chartName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.chartName, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(10, _c0, ctx_r0.isUpStreamVisible === true ? \"#0027FF\" : \"grey\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.language.up, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(12, _c0, ctx_r0.isDownStreamVisible === true ? \"#00d0ff\" : \"grey\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.language.down, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r0.language.interval, \" 1 sec\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isUpStreamVisible);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isDownStreamVisible);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.load);\n  }\n}\nmore(Highcharts);\nStreamgraphModule(Highcharts);\nexport let StreamChartComponent = /*#__PURE__*/(() => {\n  class StreamChartComponent {\n    constructor(customTranslateService, dateUtilsService, websocketService, sso) {\n      this.customTranslateService = customTranslateService;\n      this.dateUtilsService = dateUtilsService;\n      this.websocketService = websocketService;\n      this.sso = sso;\n      this.load = true;\n      this.title = 'myHighchart';\n      this.highcharts = Highcharts;\n      this.yAxixTitle = '';\n      this.pageAvailable = false;\n      this.windowLen = 5;\n      this.selectedFilter = 1;\n      this.selectedLocation = [];\n      this.selectedApplication = [];\n      this.selectedRegion = [];\n      this.selectedSystem = [];\n      this.lastData = [0, 0];\n      this.chartData = [0, 0];\n      this.lastChartDataObj = {};\n      this.triggerReloadChart = false;\n      this.minutes = [5, 10, 15, 20, 25, 30];\n      this.msgLen = 0;\n      this.inc = 0;\n      this.isDownStreamVisible = true;\n      this.isUpStreamVisible = true;\n      this.conversions = {\n        'bps': 1,\n        'Kbps': 1000,\n        'Mbps': 1000000,\n        'Gbps': 1000000000,\n        'Tbps': 1000000000000,\n        'pps': 1,\n        'Kpps': 1000,\n        'Mpps': 1000000,\n        'Gpps': 1000000000,\n        'Tpps': 1000000000000\n      };\n      this.reloadChart = false;\n      this.sizes = {\n        'bps': 1,\n        'Kbps': 1000,\n        'Mbps': 1000000,\n        'Gbps': 1000000000,\n        'Tbps': 1000000000000,\n        'pps': 1,\n        'Kpps': 1000,\n        'Mpps': 1000000,\n        'Gpps': 1000000000,\n        'Tpps': 1000000000000\n      };\n    }\n    ngOnInit() {\n      this.language = this.customTranslateService.defualtLanguage;\n      if (this.language) {\n        this.pageAvailable = true;\n      }\n      this.customTranslateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n        Highcharts.setOptions({\n          lang: {\n            resetZoom: this.language.resetButton\n          }\n        });\n      });\n    }\n    ngOnChanges(changes) {\n      let v1, v2;\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (changes.data && changes.data.currentValue && this.data) {\n        this.msgLen++;\n        this.yAxixTitle = this.getYAxisTitle(changes.data.currentValue);\n        this.originalData = changes.data.currentValue;\n        let upRate = this.bitsToSize(this.data[0]);\n        let downRate = this.bitsToSize(this.data[1]);\n        // console.log(this.data);\n        if (this.chartName.toLowerCase() === 'rate') {\n          // console.log('Up Rate - ', upRate);\n          // console.log('Down Rate - ', downRate);\n        } else {\n          // console.log('Up Packet Rate - ', upRate);\n          // console.log('Down Packer Rate - ', downRate);\n        }\n        if (this.currentData) {\n          this.lastData = this.currentData;\n          this.chartData = this.currentData;\n        } else {\n          this.lastData = [0, 0];\n          this.chartData = [0, 0];\n        }\n        this.currentData = this.data;\n      }\n      if (changes.monitorId && changes.monitorId.currentValue) {\n        this.lastChartDataObj = {};\n        this.lastData = [0, 0];\n        this.currentData = [0, 0];\n        //this.buildChart();\n        this.buildNewChart();\n      }\n      if (changes.selectedFilter && changes.selectedFilter.currentValue) {\n        this.selectedFilter = changes.selectedFilter.currentValue;\n        if (window.location.pathname != '/cco/health/pon-utilization/realtime/realtime-basic') {\n          this.websocketService.setWindowLen(this.selectedFilter);\n        }\n        //this.buildChart();\n        this.buildNewChart();\n      }\n      if (changes.selectedLocation && changes.selectedLocation.currentValue) {\n        this.selectedLocation = changes.selectedLocation.currentValue;\n        // this.buildChart();\n        this.buildNewChart();\n      }\n      if (changes.selectedApplication && changes.selectedApplication.currentValue) {\n        this.selectedApplication = changes.selectedApplication.currentValue;\n        //this.buildChart();\n        this.buildNewChart();\n      }\n      if (changes.selectedRegion && changes.selectedRegion.currentValue) {\n        this.selectedRegion = changes.selectedRegion.currentValue;\n        //this.buildChart();\n        this.buildNewChart();\n      }\n      if (changes.selectedSystem && changes.selectedSystem.currentValue) {\n        this.selectedSystem = changes.selectedSystem.currentValue;\n        //this.buildChart();\n        this.buildNewChart();\n      }\n      if (changes.windowLen && changes.windowLen.currentValue && this.data) {\n        this.time = this.dateUtilsService.getCurrentUtcTime() * 1000;\n        this.triggerReloadChart = false;\n        this.load = true;\n        this.yAxixTitle = this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        this.lastChartDataObj = this.history ? this.history : {};\n        if (Object.keys(this.lastChartDataObj).length) {\n          this.lastData = this.data;\n          this.chartData = this.data;\n          this.rebuildData();\n        } else {\n          // console.log('intial call for load chart');\n          this.buildNewChart();\n        }\n        //console.log('history', this.history);\n      }\n\n      if (changes.history && changes.history.currentValue) {\n        this.lastChartDataObj = this.history ? this.history : {};\n        // console.log(\"receive history from component\");\n        if (Object.keys(this.lastChartDataObj).length) {\n          this.lastData = this.data;\n          this.chartData = this.data;\n          this.rebuildData();\n        } else {\n          // console.log('intial call for load chart');\n          this.buildNewChart();\n        }\n        //console.log('history', this.history);\n      }\n    }\n\n    chartCallback(chart) {}\n    toggleDownStream() {\n      if (this.streamOptions.series[1].visible) {\n        this.streamOptions.series[1].visible = false;\n        this.isDownStreamVisible = false;\n      } else {\n        this.streamOptions.series[1].visible = true;\n        this.isDownStreamVisible = true;\n      }\n      this.rebuildData();\n    }\n    toggleUpStream() {\n      if (this.streamOptions.series[0].visible) {\n        this.streamOptions.series[0].visible = false;\n        this.isUpStreamVisible = false;\n      } else {\n        this.streamOptions.series[0].visible = true;\n        this.isUpStreamVisible = true;\n      }\n      this.rebuildData();\n    }\n    ngOnDestroy() {\n      this.streamOptions = {};\n      clearInterval(this.interval);\n      clearInterval(this.interval2);\n      this.interval = null;\n      this.interval2 = null;\n    }\n    transformData(currentData, lastData, data) {\n      if (this.chartName.toLowerCase() === 'rate') {\n        // console.log(\"last chart value\", data);\n      }\n      if (!lastData || !lastData.length) {\n        lastData = [0, 0];\n      }\n      let chartData = [];\n      for (let i = 0; i < currentData.length; i++) {\n        let delta = parseFloat(currentData[i]) - parseFloat(lastData[i]);\n        if (!parseFloat(currentData[i]) && !parseFloat(lastData[i])) {\n          data[i] = 0;\n        }\n        let deltaRate = delta / 15;\n        let value = parseFloat(data[i]) + deltaRate;\n        chartData.push(value);\n      }\n      if (!chartData[0] && !chartData[1] && (currentData[0] || currentData[1]) && this.msgLen > 2) {\n        chartData = currentData;\n      }\n      return chartData;\n    }\n    bitsToSize(bits) {\n      let bytes = parseFloat(bits);\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && this.chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && this.chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2) + ' ' + sizes[i];\n    }\n    removeLast3Chars(str) {\n      str = str.toString();\n      str = str.slice(0, -3);\n      str = parseInt(str);\n      return str;\n    }\n    removeOldKeys() {\n      let keys = Object.keys(this.lastChartDataObj);\n      let len = keys.length;\n      if (len > 300 * 6) {\n        let obj = this.lastChartDataObj;\n        let removeLen = len - 300 * 6;\n        for (let i = 0; i < removeLen; i++) {\n          delete obj[keys[i]];\n        }\n        this.lastChartDataObj = obj;\n        // console.log(\"removal of old chart length\", Object.keys(this.lastChartDataObj).length);\n      }\n    }\n\n    getPacketRate(bits) {\n      let bytes = bits;\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && this.chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && this.chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1024));\n      return Math.round(bytes / Math.pow(1000, i)) + ' ' + sizes[i];\n    }\n    timezoneDetected() {\n      var dtDate = new Date('1/1/' + new Date().getUTCFullYear());\n      var intOffset = 10000;\n      var intMonth;\n      for (intMonth = 0; intMonth < 12; intMonth++) {\n        dtDate.setUTCMonth(dtDate.getUTCMonth() + 1);\n        if (intOffset > dtDate.getTimezoneOffset() * -1) {\n          intOffset = dtDate.getTimezoneOffset() * -1;\n        }\n      }\n      //return intOffset * 60 * 1000;\n      // return 0;\n      // return -75 * 1000;\n      return parseInt(this.sso.getRealtimeDelay());\n    }\n    rebuildData() {\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      let keys = Object.keys(this.lastChartDataObj);\n      let length = keys.length;\n      if (length) {\n        let time = new Date().getTime() + this.timezoneDetected(),\n          i;\n        for (i = -299; i <= 0; i += 1) {\n          let timeKey = time + i * 1000;\n          let key = this.removeLast3Chars(timeKey);\n          if (typeof this.lastChartDataObj[key] == 'undefined' && typeof this.lastChartDataObj[key - 1] !== 'undefined') {\n            this.lastChartDataObj[key] = this.lastChartDataObj[key - 1];\n          } else if (typeof this.lastChartDataObj[key] == 'undefined' && typeof this.lastChartDataObj[key - 2] !== 'undefined') {\n            this.lastChartDataObj[key] = this.lastChartDataObj[key - 2];\n          }\n        }\n        //console.log(this.lastChartDataObj);\n        this.reloadChart = true;\n        this.buildNewChart();\n      }\n    }\n    buildNewChart() {\n      var _a, _b;\n      this.time = this.dateUtilsService.getCurrentUtcTime() * 1000;\n      this.streamOptions = {};\n      let timezoneDetected = this.timezoneDetected();\n      //let timezoneDetected = 0;\n      let loadTime = new Date().getTime();\n      //var tickintervalMinutes = this.minutes[this.selectedFilter - 1] * 60 * 1000;\n      var chartxaxis = {\n        type: 'datetime',\n        tickPixelInterval: 120\n        //categoreis: ['00:05', '00:10', '00:15', '00:20', '00:25', '00:30',]\n      };\n\n      var charcredits = {\n        enabled: false\n      };\n      var chartyaxis = {\n        gridLineDashStyle: 'longdash',\n        opposite: false,\n        startOnTick: false,\n        endOnTick: false,\n        // reversed: false,\n        // events: {\n        //   setExtremes: function (e) {\n        //     var c = this;\n        //     c.chart.yAxis[0].setExtremes(0, e.max);\n        //   }\n        // },\n        title: {\n          text: this.yAxixTitle,\n          margin: 40\n          // style: {\n          //   fontWeight: 'bold',\n          //   textAlign: 'left'\n          // }\n        },\n\n        labels: {\n          align: 'left',\n          x: -35,\n          formatter: function () {\n            return Math.abs(this.value);\n            // var temp = that.bitsConversion(this.value);\n            // return Math.abs(temp);\n          }\n        }\n      };\n\n      let that = this;\n      this.streamOptions = {\n        chart: {\n          type: 'areaspline',\n          zoomType: 'x',\n          //marginLeft: 100,\n          height: 200,\n          events: {\n            load: function () {\n              let sizes = that.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n              var series = this.series;\n              that.interval = setInterval(function () {\n                that.inc++;\n                let data = that.transformData(that.currentData, that.lastData, that.chartData);\n                that.chartData = data;\n                if (!data[0]) {\n                  data[0] = 0;\n                }\n                if (!data[1]) {\n                  data[1] = 0;\n                }\n                let upRate = that.bitsToSize(data[0]);\n                let downRate = that.bitsToSize(data[1]);\n                let vArr1 = upRate.split(\" \");\n                let vArr2 = downRate.split(\" \");\n                let upRateValue = vArr1[0];\n                let downRateValue = vArr2[0];\n                let upRateUnit = vArr1[1] ? vArr1[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let downRateUnit = vArr2[1] ? vArr2[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let maxUnit = '';\n                upRateUnit = upRateUnit == 'undefined' ? that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps' : upRateUnit;\n                downRateUnit = downRateUnit == 'undefined' ? that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps' : downRateUnit;\n                if (data[0] || data[1]) {\n                  if (data[0] > data[1]) {\n                    maxUnit = vArr1[1];\n                  } else {\n                    maxUnit = vArr2[1];\n                  }\n                } else {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit == 'undefined') {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit != undefined && that.yAxixTitle != maxUnit && (data[0] || data[1])) {\n                  // console.log(`scale changed from ${that.yAxixTitle} to ${maxUnit}`);\n                  that.yAxixTitle = maxUnit;\n                  that.streamOptions.yAxis.title.text = that.yAxixTitle;\n                  // var time = (new Date()).getTime() + timezoneDetected;\n                  // let key = that.removeLast3Chars(time);\n                  //that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.rebuildData();\n                  return;\n                }\n                if (typeof maxUnit === 'string') {\n                  that.yAxixTitle = maxUnit;\n                }\n                let v1 = parseFloat(vArr1[0]);\n                let v2 = parseFloat(vArr2[0]);\n                if ((data[0] || data[1]) && data[0] < data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV2 - indexV1;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v1 = v1 / 1000;\n                    }\n                  }\n                }\n                if ((data[0] || data[1]) && data[0] > data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV1 - indexV2;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v2 = v2 / 1000;\n                    }\n                  }\n                }\n                if (data) {\n                  var time = new Date().getTime() + timezoneDetected;\n                  let num = parseFloat(Highcharts.numberFormat(Math.abs(v1), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.upRate = `${upRateValue} ${upRateUnit ? upRateUnit : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps'}`;\n                  num = parseFloat(Highcharts.numberFormat(Math.abs(v2), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.removeOldKeys();\n                  that.downRate = `${downRateValue} ${downRateUnit ? downRateUnit : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps'}`;\n                  var x = time,\n                    y = v1;\n                  series[0].addPoint([x, y], true, true);\n                  var sx = time,\n                    sy = -v2;\n                  series[1].addPoint([sx, sy], true, true);\n                  let key = that.removeLast3Chars(time);\n                  that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.lastChartDataObj[key + 1] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  if (series[0].chart.resetZoomButton && series[0].xData.length) {\n                    let range = series[0].chart.xAxis[0].getExtremes();\n                    series[0].chart.xAxis[0].setExtremes(range.min + 1200, range.max + 1200);\n                  }\n                  if (that.websocketService.shouldReflow) {\n                    series[0].chart.reflow();\n                  }\n                }\n              }, 1000);\n            }\n          }\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: ''\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        //colors: ['#FF8238', '#836EE8'],\n        xAxis: chartxaxis,\n        yAxis: chartyaxis,\n        credits: charcredits,\n        plotOptions: {\n          areaspline: {\n            lineWidth: 1,\n            marker: {\n              enabled: false\n            },\n            fillOpacity: 0.75\n          },\n          spline: {\n            animation: false,\n            marker: {\n              enabled: false,\n              radius: 0.9,\n              lineWidth: 0.7\n            }\n          },\n          series: {\n            turboThreshold: 1000000\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            let dateValue = this.point.x;\n            var dateStr = that.dateUtilsService.getLocalRealtimeDateFormat(dateValue);\n            let datakey = that.removeLast3Chars(this.point.x);\n            let unit = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][2] : '';\n            // return `<b> ${dateStr}  </b><br/>\n            //        ${this.series.name}stream: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle ? that.yAxixTitle : unit}`;\n            if (this.series.name == 'up') {\n              return `<b> ${dateStr}  </b><br/>\n            ${that.language.Upstream}: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle}`;\n            }\n            if (this.series.name == 'down') {\n              return `<b> ${dateStr}  </b><br/>\n            ${that.language.Downstream}: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle}`;\n            }\n          }\n        },\n        legend: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        series: [{\n          name: ((_a = that === null || that === void 0 ? void 0 : that.language) === null || _a === void 0 ? void 0 : _a.upStream) ? that.language.upStream : 'up',\n          data: function () {\n            var data = [],\n              time = new Date().getTime() + timezoneDetected,\n              i;\n            for (i = -299 * that.selectedFilter; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][0] : that.lastChartDataObj[key - 1] && that.lastChartDataObj[key - 1][0] ? that.lastChartDataObj[key - 1][0] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][0] : that.lastChartDataObj[key - 2] && that.lastChartDataObj[key - 2][0] ? that.lastChartDataObj[key - 2][0] : 0;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            return data;\n          }()\n        }, {\n          name: ((_b = that === null || that === void 0 ? void 0 : that.language) === null || _b === void 0 ? void 0 : _b.downStream) ? that.language.downStream : 'down',\n          data: function () {\n            // generate an array of random data\n            var data = [],\n              time = new Date().getTime() + timezoneDetected,\n              i;\n            //console.log(\" series\", that.lastChartDataObj)\n            for (i = -299 * that.selectedFilter; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              // let value = that.lastChartDataObj[key] ? that.lastChartDataObj[key][1] : 0;\n              // if (that.reloadChart && !value) {\n              //   value = that.lastChartDataObj[key - 1] ? that.lastChartDataObj[key - 1][0] : 0;\n              // }\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][1] : that.lastChartDataObj[key - 1] && that.lastChartDataObj[key - 1][1] ? that.lastChartDataObj[key - 1][1] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][1] : that.lastChartDataObj[key - 2] && that.lastChartDataObj[key - 2][1] ? that.lastChartDataObj[key - 2][1] : 0;\n              }\n              if (that.lastChartDataObj[key]) {\n                that.lastChartDataObj[key][1] = value;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              value = value * -1;\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            return data;\n          }()\n        }]\n      };\n      this.streamOptions.series[0].visible = this.isUpStreamVisible;\n      this.streamOptions.series[1].visible = this.isDownStreamVisible;\n      this.streamOptions = Object.assign({}, this.streamOptions);\n    }\n    bitsConversion(bits) {\n      let down = false;\n      if (bits < 0) {\n        bits = -bits;\n        down = true;\n      }\n      let bytes = parseFloat(bits);\n      if (bytes == 0) return 0;\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      var val = parseInt(Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2));\n      return down ? -1 * val : val;\n    }\n    getYAxisTitle(bits) {\n      let bytes = bits;\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps', 'pbps', 'ebps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps', 'ppps', 'epps'];\n      var i = Math.floor(Math.log(bytes) / Math.log(1024));\n      return sizes[i];\n    }\n    removePrevious() {\n      this.lastChartDataObj = Object.keys(this.lastChartDataObj).reduce((acc, key) => {\n        acc[key] = [0, 0, \"bps\", \"bps\", \"bps\"];\n        return acc;\n      }, {});\n      this.lastData = [0, 0];\n      this.currentData = [0, 0];\n      this.rebuildData();\n    }\n  }\n  StreamChartComponent.ɵfac = function StreamChartComponent_Factory(t) {\n    return new (t || StreamChartComponent)(i0.ɵɵdirectiveInject(i1.TranslateService), i0.ɵɵdirectiveInject(i2.DateUtilsService), i0.ɵɵdirectiveInject(i3.WebsocketService), i0.ɵɵdirectiveInject(i4.SsoAuthService));\n  };\n  StreamChartComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: StreamChartComponent,\n    selectors: [[\"app-stream-chart\"]],\n    inputs: {\n      chartName: \"chartName\",\n      yAxixTitle: \"yAxixTitle\",\n      xAxix: \"xAxix\",\n      data: \"data\",\n      windowLen: \"windowLen\",\n      selectedFilter: \"selectedFilter\",\n      selectedLocation: \"selectedLocation\",\n      selectedApplication: \"selectedApplication\",\n      selectedRegion: \"selectedRegion\",\n      selectedSystem: \"selectedSystem\",\n      monitorId: \"monitorId\",\n      time: \"time\",\n      history: \"history\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"analytic-widget\", 4, \"ngIf\"], [1, \"analytic-widget\"], [1, \"analytic-widget-header\"], [1, \"d-flex\", \"justify-content-between\"], [1, \"mx-2\"], [1, \"widget-title\", 3, \"title\"], [1, \"legend-label\", \"toggle-up\", 3, \"click\"], [1, \"legend-glyph\", 3, \"ngStyle\"], [1, \"legend-label\", \"toggle-down\", 3, \"click\"], [1, \"interval\"], [1, \"mr-2\", 2, \"text-align\", \"right\"], [1, \"traffic-volume\", \"monitor-status-normal\"], [\"style\", \"color: #0027FF;\", 4, \"ngIf\"], [\"style\", \"color: #5ACFEA;\", 4, \"ngIf\"], [1, \"analytic-widget-body\"], [\"id\", \"custom-mirrot-chart\", \"style\", \"width: 100%; display: block;\", 3, \"Highcharts\", \"options\", \"callbackFunction\", 4, \"ngIf\"], [2, \"color\", \"#0027FF\"], [\"aria-hidden\", \"true\", 1, \"fa\", \"fa-arrow-up\"], [2, \"color\", \"#5ACFEA\"], [\"aria-hidden\", \"true\", 1, \"fa\", \"fa-arrow-down\"], [\"id\", \"custom-mirrot-chart\", 2, \"width\", \"100%\", \"display\", \"block\", 3, \"Highcharts\", \"options\", \"callbackFunction\"]],\n    template: function StreamChartComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, StreamChartComponent_div_0_Template, 20, 14, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.pageAvailable);\n      }\n    },\n    directives: [i5.NgIf, i5.NgStyle, i6.HighchartsChartComponent],\n    styles: [\".highcharts-data-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{min-width:320px;max-width:800px;margin:1em auto}.highcharts-data-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{font-family:Verdana,sans-serif;border-collapse:collapse;border:1px solid #EBEBEB;margin:10px auto;text-align:center;width:100%;max-width:500px}.highcharts-data-table[_ngcontent-%COMP%]   caption[_ngcontent-%COMP%]{padding:1em 0;font-size:1.2em;color:#555}.highcharts-data-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{font-weight:600;padding:.5em}.highcharts-data-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   caption[_ngcontent-%COMP%]{padding:.5em}.highcharts-data-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:nth-child(even){background:#f8f8f8}.highcharts-data-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{background:#f1f7ff}.analytic-widget[_ngcontent-%COMP%]   .analytic-widget-header[_ngcontent-%COMP%]{display:block}.analytic-widget[_ngcontent-%COMP%]   .analytic-widget-header-cell[_ngcontent-%COMP%]{display:block;padding:5px 5px 5px 10px;position:relative}.analytic-widget[_ngcontent-%COMP%]   .legend-glyph[_ngcontent-%COMP%]{display:inline-block;margin-left:4px;margin-right:4px;width:10px;height:10px;border-radius:6px}.analytic-widget[_ngcontent-%COMP%]   .legend-label[_ngcontent-%COMP%]{display:inline-block;font-size:12px;padding-right:8px;margin-right:4px;border-color:#e1dfec;background-color:#eae8f3;border-width:1px;text-decoration:none;cursor:pointer}.analytic-widget[_ngcontent-%COMP%]   .interval[_ngcontent-%COMP%]{background:#efefef;padding:2px 6px;font-size:11px;border-radius:2px;color:#666;margin-right:15px}.analytic-widget[_ngcontent-%COMP%]   .traffic-volume.monitor-status-normal[_ngcontent-%COMP%]{margin-top:0;background-color:#eae8f3;border-color:#e1dfec;border-width:1px;font-size:12px}\"]\n  });\n  return StreamChartComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}