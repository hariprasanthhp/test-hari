{"ast":null,"code":"import { DatePipe } from '@angular/common';\nimport * as moment from 'moment';\nimport * as Highcharts from 'highcharts';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"src/app/support/support-traffic-reports/service/fa-utils.service\";\nimport * as i3 from \"src/app/shared-utils/date-utils.service\";\nimport * as i4 from \"src/app/shared/services/export-excel.service\";\nimport * as i5 from \"src/app/shared/services/custom-translate.service\";\nimport * as i6 from \"src/app/shared/services/sso-auth.service\";\nconst noData = require('highcharts/modules/no-data-to-display');\nnoData(Highcharts);\nexport let TrafficeRealtimeOptionsManagerService = /*#__PURE__*/(() => {\n  class TrafficeRealtimeOptionsManagerService {\n    constructor(router, utils, dateUtils, excel, customTranslateService, sso) {\n      this.router = router;\n      this.utils = utils;\n      this.dateUtils = dateUtils;\n      this.excel = excel;\n      this.customTranslateService = customTranslateService;\n      this.sso = sso;\n      /***begin-aswin-06-05-2021-localstorage-realtime-graphdata */\n      this.defaultData = {\n        downData: [],\n        downPercentage: \"\",\n        downTotal: \"\",\n        graphType: \"\",\n        sendTime: new Date().getTime(),\n        upData: [],\n        upPercentage: \"\",\n        upTotal: \"\"\n      };\n      /***end-aswin-06-05-2021-localstorage-realtime-graphdata */\n      /***begin-aswin-24-05-2021-localstorage-realtime-graphdata-replay-integration */\n      this.restoreChartObj = {};\n      this.language = this.customTranslateService.defualtLanguage;\n      this.customTranslateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n    }\n    makeOptionsForTraffic(data, type, params) {\n      var that = this;\n      let pipe = new DatePipe('en-US');\n      let upUsage,\n        upUsageTotal = 0;\n      let downUsage,\n        downUsageTotal = 0;\n      //let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let timezoneName = 'UTC';\n      let diff = moment(params.endDate).diff(moment(params.startDate), \"hour\");\n      let subTitle = '';\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      for (let i = 0; i < data.length; i++) {\n        let period = this.dateUtils.getChartFormatDate(data[i].startPeriodSec);\n        categories.push(period);\n        seriesData1.push(data[i].usOctets);\n        seriesData2.push(data[i].dsOctets);\n        upUsageTotal += data[i].usOctets ? data[i].usOctets : 0;\n        downUsageTotal += data[i].dsOctets ? data[i].dsOctets : 0;\n      }\n      let upUsageUnit = this.getStackedUnit(upUsageTotal);\n      let downUsageUnit = this.getStackedUnit(downUsageTotal);\n      upUsage = (upUsageTotal / upUsageUnit[0]).toFixed(2) + ' ' + upUsageUnit[1];\n      downUsage = (downUsageTotal / downUsageUnit[0]).toFixed(2) + ' ' + downUsageUnit[1];\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: this.language['subscriberUsage']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          opposite: false,\n          tickLength: 2\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: false\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            //color: '#E87B00',\n            colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        exporting: {\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  extraData = `Subscriber Usage\\r\\nSubscriber:\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\n${that.language['upUsageTitle']}: ${upUsage}    ${that.language['downUsageTitle']}: ${downUsage}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.dateUtils.getChartFormatDate(data[i].startPeriodSec),\n                      'Up Usage(Byte)': data[i].usOctets ? data[i].usOctets : 0,\n                      'Down Usage(Byte)': data[i].dsOctets ? data[i].dsOctets : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('SubscriberUsageReport', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var name = this.x || this.point.name;\n            var unit = that.getStackedUnit(m);\n            return '<p><strong>' + name + '</strong><br/><span> ' + this.series.name + ': <strong>' + (this.y / unit[0]).toFixed(2) + ' ' + unit[1] + '</strong><br/></span></p>';\n          }\n        }\n      };\n      options.series = [{\n        name: this.language['upUsageTitle'],\n        data: seriesData1,\n        color: \"#E87B00\"\n      }, {\n        name: this.language['downUsageTitle'],\n        data: seriesData2,\n        color: \"#44367D\"\n      }];\n      options.xAxis['categories'] = categories;\n      subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span><br/>\n    <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['upUsageTitle']}: ${upUsage}    ${this.language['downUsageTitle']}: ${downUsage}</span>`;\n      options.subtitle.text = subTitle;\n      return options;\n    }\n    dataFormingForRTBC(data, dataType) {\n      let categories = [];\n      let seriesData1 = [];\n      if (dataType === 'upData') {\n        data.upData = data.upData.slice(0, 5);\n        for (let i = 0; i < data.upData.length; i++) {\n          categories.push(data.upData[i].name);\n          seriesData1.push({\n            y: data.upData[i].value,\n            id: data.upData[i].id,\n            name: data.upData[i].name\n          });\n        }\n      } else {\n        data.downData = data.downData.slice(0, 5);\n        for (let i = 0; i < data.downData.length; i++) {\n          categories.push(data.downData[i].name);\n          seriesData1.push({\n            y: data.downData[i].value,\n            id: data.downData[i].id,\n            name: data.downData[i].name\n          });\n        }\n      }\n      let series = [{\n        name: dataType,\n        data: seriesData1\n      }];\n    }\n    makeOptionsForRTBC(data, type, dataType, sliceNum, fsView) {\n      let that = this;\n      sliceNum = sliceNum ? sliceNum : 5;\n      let categories = [];\n      let seriesData1 = [];\n      let tickAmount = fsView ? 6 : 3;\n      let options = {\n        chart: {\n          type: 'bar',\n          zoomType: \"xy\",\n          height: 180,\n          renderTo: 'container'\n        },\n        title: {\n          text: ''\n        },\n        credits: {\n          enabled: false\n        },\n        xAxis: {\n          categories: categories,\n          startOnTick: false,\n          endOnTick: false,\n          labels: {\n            style: {\n              color: '#007bff'\n            },\n            formatter: function () {\n              return `<span  class=\"text-primary axis_label\" title=\"${this.value[0]}\" style=\"cursor:pointer\">${this.value[0]}</span>`;\n            },\n            events: {}\n          }\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          opposite: true,\n          tickLength: 2,\n          tickAmount: tickAmount,\n          startOnTick: false,\n          endOnTick: false,\n          labels: {\n            formatter: function () {\n              let ret = `${that.bitsToSize(this.value, false)}`;\n              return ret;\n            },\n            events: {},\n            rotation: 0\n          }\n        },\n        legend: {\n          enabled: false\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            color: '#0027FF',\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        tooltip: {\n          formatter: function () {\n            let ret = `${this.x[0]} <br/> ${that.utils.bitsToSize(this.y, false)}`;\n            return ret;\n          }\n        },\n        lang: {\n          noData: this.language[\"No Data Available\"]\n        }\n      };\n      let xData = [],\n        ids = [];\n      if (type === 'bar') {\n        if (dataType === 'upData') {\n          data.upData = data.upData.slice(0, sliceNum);\n          for (let i = 0; i < data.upData.length; i++) {\n            let catData = [];\n            catData.push(data.upData[i].name, data.upData[i].id);\n            categories.push(catData);\n            // categories.push(data.upData[i].name);\n            seriesData1.push(data.upData[i].value);\n            xData.push(data.upData[i].name);\n            ids.push(data.upData[i].id);\n          }\n        } else {\n          data.downData = data.downData.slice(0, sliceNum);\n          for (let i = 0; i < data.downData.length; i++) {\n            let catData = [];\n            catData.push(data.downData[i].name, data.downData[i].id);\n            categories.push(catData);\n            // categories.push(data.downData[i].name);\n            seriesData1.push(data.downData[i].value);\n            xData.push(data.downData[i].name);\n            ids.push(data.downData[i].id);\n          }\n        }\n        options.series = [{\n          data: seriesData1\n          // xData: xData,\n          // id: ids\n        }];\n      }\n\n      options.xAxis['categories'] = categories;\n      return options;\n    }\n    makeOptionsForAreaChart(data, dType, params) {\n      let categories = [];\n      let seriesData = [];\n      let options = {\n        chart: {\n          type: 'area',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: ''\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          }\n        },\n        legend: {\n          reversed: true\n        },\n        plotOptions: {\n          area: {\n            stacking: 'normal',\n            lineColor: '#666666',\n            lineWidth: 1,\n            marker: {\n              lineWidth: 1,\n              lineColor: '#666666'\n            }\n          }\n        },\n        series: []\n      };\n      let cData = [];\n      for (let i = 0; i < data.length; i++) {\n        if (dType == 'up') {\n          cData.push({\n            name: data[i].name,\n            data: [data[i].usOctets]\n          });\n        } else {\n          cData.push({\n            name: data[i].name,\n            data: [data[i].dsOctets]\n          });\n        }\n      }\n      options.xAxis.categories = [params.startDate];\n      options.series = cData;\n      return options;\n    }\n    makeOptionsForLineChart(data, dType, params) {\n      let up = this.language['max_up_rate'];\n      let down = this.language['max_down_rate'];\n      let that = this;\n      let categories = [];\n      let upData = [];\n      let downData = [];\n      let subsId = `${this.sso.getReportChartSubscriberInfo()}`;\n      if (params['rateSelected'] == 'Average') {\n        up = this.language['avg_up_rate'];\n        down = this.language['avg_down_rate'];\n      }\n      let pipe = new DatePipe('en-US');\n      //let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let timezoneName = 'UTC';\n      let diff = moment(params.endDate).diff(moment(params.startDate), \"hour\");\n      let subTitle = `<span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">Rate: ${this.language[params['rateSelected']]}</span><span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} to ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]</span>`;\n      let options = {\n        chart: {\n          type: 'line'\n        },\n        time: {\n          useUTC: false\n        },\n        title: {\n          text: this.language['subscriberRate']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: []\n        },\n        yAxis: {\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              return that.utils.bitsToSize(this.value, true);\n            }\n          }\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          align: 'center',\n          verticalAlign: 'bottom',\n          layout: 'horizontal',\n          symbolRadius: 0\n        },\n        tooltip: {\n          formatter: function () {\n            return '<b>' + this.x + '<b><br/>' + this.series.name + ': <b>' + that.utils.bitsToSize(this.y, true) + '</b>';\n          }\n        },\n        plotOptions: {\n          series: {\n            marker: {\n              enabled: false\n            }\n          },\n          column: {\n            stacking: 'normal',\n            dataLabels: {\n              enabled: false\n              //color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'\n            }\n          }\n        },\n\n        series: [{\n          name: up,\n          color: '#E87B00',\n          data: []\n        }, {\n          name: down,\n          color: '#44367D',\n          data: []\n        }],\n        exporting: {\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  extraData = `Subscriber Rate\\r\\nSubscriber: ${subsId}\\r\\n${that.language['time_win']}: ${pipe.transform(params.startDate, 'MM/dd/yyyy')} - ${pipe.transform(params.endDate, 'MM/dd/yyyy')} [${timezoneName}]\\r\\nRate: ${params['rateSelected']}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.dateUtils.getChartFormat(data[i].startPeriodSec),\n                      'Max Up Rate(bps)': data[i].peakUsRate ? data[i].peakUsRate : 0,\n                      'Max Down Rate(bps)': data[i].peakDsRate ? data[i].peakDsRate : 0,\n                      'Average Up Rate(bps)': data[i].usRate ? data[i].usRate : 0,\n                      'Average Down Rate(bps)': data[i].dsRate ? data[i].dsRate : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('Subscriber_Rate_Report', dataExport, extraData);\n                }\n              }],\n              text: that.language['export']\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        }\n      };\n      let cData = [];\n      for (let i = 0; i < data.length; i++) {\n        categories.push(this.dateUtils.getChartFormat(data[i].startPeriodSec));\n        if (params['rateSelected'] == 'Average') {\n          upData.push(data[i].usRate);\n          downData.push(data[i].dsRate);\n        } else {\n          upData.push(data[i].peakUsRate);\n          downData.push(data[i].peakDsRate);\n        }\n      }\n      options.xAxis.categories = categories;\n      if (categories && categories.length <= 12) {\n        options.xAxis['tickInterval'] = 1;\n      } else if (categories && categories.length > 40) {\n        options.xAxis['tickInterval'] = Math.floor(categories.length / 25) + 2;\n      }\n      options.series[0].data = upData;\n      options.series[1].data = downData;\n      return options;\n    }\n    makeOptionsForMonthlyUsage(data, type, params) {\n      //data = JSON.parse(\"[{\\\"dateMonth\\\":\\\"2020-08\\\",\\\"upUsage\\\":12774687764,\\\"downUsage\\\":347449409818},{\\\"dateMonth\\\":\\\"2020-09\\\",\\\"upUsage\\\":16539630495,\\\"downUsage\\\":587600950182},{\\\"dateMonth\\\":\\\"2020-10\\\",\\\"upUsage\\\":14156405546,\\\"downUsage\\\":509860217630}]\");\n      var that = this;\n      let pipe = new DatePipe('en-US');\n      //let timezoneName = /\\((.*)\\)/.exec(new Date().toString())[1];\n      let timezoneName = 'UTC';\n      let date = new Date();\n      let monthCount = params.monthCount ? params.monthCount : 1;\n      let firstDay = new Date(date.getFullYear(), date.getMonth() - monthCount, 1);\n      let lastDay = new Date(date.getFullYear(), date.getMonth(), 0);\n      let startDate = this.dateUtils.getMonthYear(firstDay);\n      let subsId = '';\n      let endDate = this.dateUtils.getMonthYear(lastDay);\n      let subTitle = '';\n      let upUsage,\n        upUsageTotal = 0;\n      let downUsage,\n        downUsageTotal = 0;\n      let categories = [];\n      let seriesData1 = [];\n      let seriesData2 = [];\n      for (let i = 0; i < data.length; i++) {\n        //let period = this.dateUtils.getChartFormatDate(data[i].startPeriodSec, 'MM/yyyy');\n        let period = this.dateUtils.getChartFormatDateInUtc(data[i].startPeriodSec);\n        categories.push(period);\n        seriesData1.push(data[i].usOctets);\n        seriesData2.push(data[i].dsOctets);\n        upUsageTotal += data[i].usOctets ? data[i].usOctets : 0;\n        downUsageTotal += data[i].dsOctets ? data[i].dsOctets : 0;\n      }\n      let upUsageUnit = this.getStackedUnit(upUsageTotal);\n      let downUsageUnit = this.getStackedUnit(downUsageTotal);\n      upUsage = (upUsageTotal / upUsageUnit[0]).toFixed(2) + ' ' + upUsageUnit[1];\n      downUsage = (downUsageTotal / downUsageUnit[0]).toFixed(2) + ' ' + downUsageUnit[1];\n      let options = {\n        chart: {\n          type: 'column',\n          zoomType: \"xy\"\n        },\n        title: {\n          text: this.language['subscriberMonthlyUsage']\n        },\n        subtitle: {\n          text: subTitle\n        },\n        xAxis: {\n          categories: categories\n        },\n        yAxis: {\n          min: 0,\n          title: {\n            text: ''\n          },\n          labels: {\n            formatter: function () {\n              var m = this.value;\n              var unit = that.getStackedUnit(m);\n              return (this.value / unit[0]).toFixed(2) + ' ' + unit[1];\n            }\n          },\n          opposite: false,\n          tickLength: 2\n        },\n        lang: {\n          noData: that.language[\"No Data Available\"]\n        },\n        legend: {\n          reversed: false\n        },\n        plotOptions: {\n          column: {\n            stacking: 'normal'\n          },\n          series: {\n            //color: '#E87B00',\n            colors: [\"#E87B00\", \"#44367D\", \"#8bbc21\", \"#910000\", \"#1aadce\", \"#492970\", \"#f28f43\", \"#77a1e5\", \"#c42525\", \"#a6c96a\"],\n            cursor: 'pointer',\n            point: {\n              events: {}\n            }\n          }\n        },\n        series: [],\n        exporting: {\n          buttons: {\n            contextButton: {\n              menuItems: [{\n                textKey: 'downloadPDF',\n                text: this.language.exportPDF || 'Export PDF',\n                onclick: function () {\n                  this.exportChart({\n                    type: 'application/pdf'\n                  });\n                }\n              }, {\n                textKey: 'downloadCSV',\n                text: this.language.exportCsv || 'Export CSV',\n                onclick: function () {\n                  let dataExport = [];\n                  let extraData = '';\n                  extraData = `${that.language['subscriberMonthlyUsage']}\\r\\nSubscriber:\\r\\n${that.language['time_win']}: ${startDate} - ${endDate} [${timezoneName}]\\r\\n${that.language['upUsageTitle']}: ${upUsage}    ${that.language['downUsageTitle']}: ${downUsage}\\r\\n`;\n                  for (var i = 0; i < data.length; i++) {\n                    dataExport.push({\n                      'Date Time': that.dateUtils.getChartFormatDate(data[i].startPeriodSec, 'yyyy-MM'),\n                      'Up Usage(Byte)': data[i].usOctets ? data[i].usOctets : 0,\n                      'Down Usage(Byte)': data[i].dsOctets ? data[i].dsOctets : 0\n                    });\n                  }\n                  that.excel.downLoadCSV('SubscriberMonthlyUsageReport', dataExport, extraData);\n                }\n              }],\n              text: 'Export'\n              //className: 'export_menu',\n              // symbol: 'url(/assets/images/export.png)'\n            }\n          }\n        },\n\n        credits: {\n          enabled: false\n        },\n        tooltip: {\n          formatter: function () {\n            var m = this.y;\n            var name = this.x || this.point.name;\n            var unit = that.getStackedUnit(m);\n            return '<p><strong>' + name + '</strong><br/><span> ' + this.series.name + ': <strong>' + (this.y / unit[0]).toFixed(2) + ' ' + unit[1] + '</strong><br/></span></p>';\n          }\n        }\n      };\n      options.series = [{\n        name: this.language['upUsageTitle'],\n        data: seriesData1,\n        color: \"#E87B00\"\n      }, {\n        name: this.language['downUsageTitle'],\n        data: seriesData2,\n        color: \"#44367D\"\n      }];\n      options.xAxis['categories'] = categories;\n      subTitle = `<span style=\"font-size:16px; color:#ffffff\">...</span><span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\"> ${this.language['time_win']}: ${startDate} to ${endDate} [${timezoneName}]</span><br/>\n    <span style=\"font-family: Lato; color: #000000; font-size: 12px; line-height: 1.1640625;\">${this.language['upUsageTitle']}: ${upUsage}    ${this.language['downUsageTitle']}:  ${downUsage}</span>`;\n      options.subtitle.text = subTitle;\n      return options;\n    }\n    convertDate(ts) {\n      var date = new Date(ts);\n      var mm = (date.getMonth() + 1).toString();\n      var dd = date.getDate().toString();\n      var mmChars = mm.split('');\n      var ddChars = dd.split('');\n      return (mmChars[1] ? mm : \"0\" + mmChars[0]) + '/' + (ddChars[1] ? dd : \"0\" + ddChars[0]);\n    }\n    /**\r\n     * setTopEP\r\n     */\n    setTopEP(data) {\n      if (data) {\n        localStorage.setItem('calix.topep_data', JSON.stringify(data));\n      } else {\n        localStorage.removeItem('calix.topep_data');\n      }\n    }\n    getTopEP() {\n      return localStorage.getItem('calix.topep_data') ? JSON.parse(localStorage.getItem('calix.topep_data')) : [];\n    }\n    setTopApp(data) {\n      if (data) {\n        localStorage.setItem('calix.topapp_data', JSON.stringify(data));\n      } else {\n        localStorage.removeItem('calix.topapp_data');\n      }\n    }\n    getTopApp() {\n      return localStorage.getItem('calix.topapp_data') ? JSON.parse(localStorage.getItem('calix.topapp_data')) : [];\n    }\n    setTopLoc(data) {\n      if (data) {\n        localStorage.setItem('calix.toploc_data', JSON.stringify(data));\n      } else {\n        localStorage.removeItem('calix.toploc_data');\n      }\n    }\n    getTopLoc() {\n      return localStorage.getItem('calix.toploc_data') ? JSON.parse(localStorage.getItem('calix.toploc_data')) : [];\n    }\n    getStackedUnit(m) {\n      let unit;\n      if (m > 1099511627776) {\n        unit = [1099511627776, 'TB'];\n      } else if (m > 1073741824) {\n        unit = [1073741824, 'GB'];\n      } else if (m > 1048576) {\n        unit = [1048576, 'MB'];\n      } else if (m > 1024) {\n        unit = [1024, 'KB'];\n      } else {\n        unit = [1, ''];\n      }\n      return unit;\n    }\n    setNetworkRealTimeGraphData(key, data) {\n      if (data) {\n        localStorage.setItem(key, JSON.stringify(data));\n      } else {\n        localStorage.removeItem(key);\n      }\n    }\n    getNetworkRealTimeGraphData(key) {\n      this.defaultData['graphType'] = key;\n      return localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : this.defaultData;\n    }\n    getRealTimeGraphRestoreData(key) {\n      return this.restoreChartObj.hasOwnProperty(key) ? this.restoreChartObj[key] : false;\n    }\n    setRealTimeGraphRestoreData(key, restoreChartObj, reset) {\n      reset ? this.restoreChartObj = {} : this.restoreChartObj[key] = restoreChartObj;\n    }\n    /***end-aswin-24-05-2021-localstorage-realtime-graphdata-replay-integration */\n    removeTopNTrafficFromLS() {\n      let keys = ['TEP', 'TAPP', 'TLOC'];\n      keys.forEach(element => {\n        localStorage.removeItem(element);\n      });\n    }\n    bitsToSize(bits, round) {\n      let bytes = bits;\n      let sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];\n      if (bytes == 0) return '0';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      if (round) {\n        return Math.round(bytes / Math.pow(1000, i)) + ' ' + sizes[i];\n      }\n      if (i < 0) {\n        i = 0;\n      }\n      let n = 1;\n      if (Number.isInteger(+Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 1))) {\n        n = 0;\n      }\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), n) + ' ' + sizes[i];\n    }\n  }\n  TrafficeRealtimeOptionsManagerService.ɵfac = function TrafficeRealtimeOptionsManagerService_Factory(t) {\n    return new (t || TrafficeRealtimeOptionsManagerService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.FaUtilsService), i0.ɵɵinject(i3.DateUtilsService), i0.ɵɵinject(i4.ExportExcelService), i0.ɵɵinject(i5.CustomTranslateService), i0.ɵɵinject(i6.SsoAuthService));\n  };\n  TrafficeRealtimeOptionsManagerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TrafficeRealtimeOptionsManagerService,\n    factory: TrafficeRealtimeOptionsManagerService.ɵfac,\n    providedIn: 'root'\n  });\n  return TrafficeRealtimeOptionsManagerService;\n})();","map":null,"metadata":{},"sourceType":"module"}