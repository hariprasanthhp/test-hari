{"ast":null,"code":"import { filter, find, forEach } from 'min-dash';\nimport Refs from 'object-refs';\nimport { elementToString } from './Util';\nvar diRefs = new Refs({\n  name: 'bpmnElement',\n  enumerable: true\n}, {\n  name: 'di',\n  configurable: true\n});\n\n/**\n * Returns true if an element has the given meta-model type\n *\n * @param  {ModdleElement}  element\n * @param  {string}         type\n *\n * @return {boolean}\n */\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n */\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function (e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\nexport default function BpmnTreeWalker(handler, translate) {\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n\n  // Helpers //////////////////////\n\n  function contextual(fn, ctx) {\n    return function (e) {\n      fn(e, ctx);\n    };\n  }\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n  function visit(element, ctx) {\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(translate('already rendered {element}', {\n        element: elementToString(element)\n      }));\n    }\n\n    // call handler\n    return handler.element(element, ctx);\n  }\n  function visitRoot(element, diagram) {\n    return handler.root(element, diagram);\n  }\n  function visitIfDi(element, ctx) {\n    try {\n      var gfx = element.di && visit(element, ctx);\n      handled(element);\n      return gfx;\n    } catch (e) {\n      logError(e.message, {\n        element: element,\n        error: e\n      });\n      console.error(translate('failed to import {element}', {\n        element: elementToString(element)\n      }));\n      console.error(e);\n    }\n  }\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  // DI handling //////////////////////\n\n  function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n    if (bpmnElement) {\n      if (bpmnElement.di) {\n        logError(translate('multiple DI elements defined for {element}', {\n          element: elementToString(bpmnElement)\n        }), {\n          element: bpmnElement\n        });\n      } else {\n        diRefs.bind(bpmnElement, 'di');\n        bpmnElement.di = di;\n      }\n    } else {\n      logError(translate('no bpmnElement referenced in {element}', {\n        element: elementToString(di)\n      }), {\n        element: di\n      });\n    }\n  }\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n  function handlePlane(plane) {\n    registerDi(plane);\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n  // Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any)\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error(translate('diagram not part of bpmn:Definitions'));\n    }\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error(translate('no diagram to display'));\n    }\n\n    // load DI from selected diagram only\n    handleDiagram(diagram);\n    var plane = diagram.plane;\n    if (!plane) {\n      throw new Error(translate('no plane for {element}', {\n        element: elementToString(diagram)\n      }));\n    }\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n      if (!rootElement) {\n        throw new Error(translate('no process or collaboration to display'));\n      } else {\n        logError(translate('correcting missing bpmnElement on {plane} to {rootElement}', {\n          plane: elementToString(plane),\n          rootElement: elementToString(rootElement)\n        }));\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n    var ctx = visitRoot(rootElement, plane);\n    if (is(rootElement, 'bpmn:Process')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(translate('unsupported bpmnElement for {plane}: {rootElement}', {\n        plane: elementToString(plane),\n        rootElement: elementToString(rootElement)\n      }));\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  }\n  function handleDeferred() {\n    var fn;\n\n    // drain deferred until empty\n    while (deferred.length) {\n      fn = deferred.shift();\n      fn();\n    }\n  }\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n  function handleUnhandledProcesses(rootElements, ctx) {\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function (e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n    processes.forEach(contextual(handleProcess, ctx));\n  }\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n  function handleArtifact(artifact, context) {\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n  function handleArtifacts(artifacts, context) {\n    forEach(artifacts, function (e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function () {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n  function handleIoSpecification(ioSpecification, context) {\n    if (!ioSpecification) {\n      return;\n    }\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n  function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  }\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function () {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n  function handleLane(lane, context) {\n    deferred.push(function () {\n      var newContext = visitIfDi(lane, context);\n      if (lane.childLaneSet) {\n        handleLaneSet(lane.childLaneSet, newContext || context);\n      }\n      wireFlowNodeRefs(lane);\n    });\n  }\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n  function handleFlowElementsContainer(container, context) {\n    handleFlowElements(container.flowElements, context);\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n  }\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function (e) {\n      if (is(e, 'bpmn:SequenceFlow')) {\n        deferred.push(function () {\n          handleSequenceFlow(e, context);\n        });\n      } else if (is(e, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function () {\n          handleFlowNode(e, context);\n        });\n      } else if (is(e, 'bpmn:FlowNode')) {\n        handleFlowNode(e, context);\n      } else if (is(e, 'bpmn:DataObject')) {\n\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(e, 'bpmn:DataStoreReference')) {\n        handleDataElement(e, context);\n      } else if (is(e, 'bpmn:DataObjectReference')) {\n        handleDataElement(e, context);\n      } else {\n        logError(translate('unrecognized flowElement {element} in context {context}', {\n          element: elementToString(e),\n          context: context ? elementToString(context.businessObject) : 'null'\n        }), {\n          element: e,\n          context: context\n        });\n      }\n    });\n  }\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n  function handleCollaboration(collaboration) {\n    forEach(collaboration.participants, contextual(handleParticipant));\n    handleArtifacts(collaboration.artifacts);\n\n    // handle message flows latest in the process\n    deferred.push(function () {\n      handleMessageFlows(collaboration.messageFlows);\n    });\n  }\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function (flowNode) {\n      var lanes = flowNode.get('lanes');\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n\n  // API //////////////////////\n\n  return {\n    handleDeferred: handleDeferred,\n    handleDefinitions: handleDefinitions,\n    handleSubProcess: handleSubProcess,\n    registerDi: registerDi\n  };\n}","map":null,"metadata":{},"sourceType":"module"}