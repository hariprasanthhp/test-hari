{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, clone as svgClone, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { query as domQuery } from 'min-dom';\nimport { getVisual } from '../../util/GraphicsUtil';\nvar MARKER_TYPES = ['marker-start', 'marker-mid', 'marker-end'];\nvar NODES_CAN_HAVE_MARKER = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'];\n\n/**\r\n * Adds support for previews of moving/resizing elements.\r\n */\nexport default function PreviewSupport(elementRegistry, eventBus, canvas, styles) {\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n  this._styles = styles;\n  this._clonedMarkers = {};\n  var self = this;\n  eventBus.on('drag.cleanup', function () {\n    forEach(self._clonedMarkers, function (clonedMarker) {\n      svgRemove(clonedMarker);\n    });\n    self._clonedMarkers = {};\n  });\n}\nPreviewSupport.$inject = ['elementRegistry', 'eventBus', 'canvas', 'styles'];\n\n/**\r\n * Returns graphics of an element.\r\n *\r\n * @param {djs.model.Base} element\r\n *\r\n * @return {SVGElement}\r\n */\nPreviewSupport.prototype.getGfx = function (element) {\n  return this._elementRegistry.getGraphics(element);\n};\n\n/**\r\n * Adds a move preview of a given shape to a given svg group.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {SVGElement} group\r\n * @param {SVGElement} [gfx]\r\n *\r\n * @return {SVGElement} dragger\r\n */\nPreviewSupport.prototype.addDragger = function (element, group, gfx) {\n  gfx = gfx || this.getGfx(element);\n  var dragger = svgClone(gfx);\n  var bbox = gfx.getBoundingClientRect();\n  this._cloneMarkers(getVisual(dragger));\n  svgAttr(dragger, this._styles.cls('djs-dragger', [], {\n    x: bbox.top,\n    y: bbox.left\n  }));\n  svgAppend(group, dragger);\n  return dragger;\n};\n\n/**\r\n * Adds a resize preview of a given shape to a given svg group.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {SVGElement} group\r\n *\r\n * @return {SVGElement} frame\r\n */\nPreviewSupport.prototype.addFrame = function (shape, group) {\n  var frame = svgCreate('rect', {\n    class: 'djs-resize-overlay',\n    width: shape.width,\n    height: shape.height,\n    x: shape.x,\n    y: shape.y\n  });\n  svgAppend(group, frame);\n  return frame;\n};\n\n/**\r\n * Clone all markers referenced by a node and its child nodes.\r\n *\r\n * @param {SVGElement} gfx\r\n */\nPreviewSupport.prototype._cloneMarkers = function (gfx) {\n  var self = this;\n  if (gfx.childNodes) {\n    // TODO: use forEach once we drop PhantomJS\n    for (var i = 0; i < gfx.childNodes.length; i++) {\n      // recursively clone markers of child nodes\n      self._cloneMarkers(gfx.childNodes[i]);\n    }\n  }\n  if (!canHaveMarker(gfx)) {\n    return;\n  }\n  MARKER_TYPES.forEach(function (markerType) {\n    if (svgAttr(gfx, markerType)) {\n      var marker = getMarker(gfx, markerType, self._canvas.getContainer());\n      self._cloneMarker(gfx, marker, markerType);\n    }\n  });\n};\n\n/**\r\n * Clone marker referenced by an element.\r\n *\r\n * @param {SVGElement} gfx\r\n * @param {SVGElement} marker\r\n * @param {string} markerType\r\n */\nPreviewSupport.prototype._cloneMarker = function (gfx, marker, markerType) {\n  var markerId = marker.id;\n  var clonedMarker = this._clonedMarkers[markerId];\n  if (!clonedMarker) {\n    clonedMarker = svgClone(marker);\n    var clonedMarkerId = markerId + '-clone';\n    clonedMarker.id = clonedMarkerId;\n    svgClasses(clonedMarker).add('djs-dragger').add('djs-dragger-marker');\n    this._clonedMarkers[markerId] = clonedMarker;\n    var defs = domQuery('defs', this._canvas._svg);\n    if (!defs) {\n      defs = svgCreate('defs');\n      svgAppend(this._canvas._svg, defs);\n    }\n    svgAppend(defs, clonedMarker);\n  }\n  var reference = idToReference(this._clonedMarkers[markerId].id);\n  svgAttr(gfx, markerType, reference);\n};\n\n// helpers //////////\n\n/**\r\n * Get marker of given type referenced by node.\r\n *\r\n * @param {Node} node\r\n * @param {string} markerType\r\n * @param {Node} [parentNode]\r\n *\r\n * @param {Node}\r\n */\nfunction getMarker(node, markerType, parentNode) {\n  var id = referenceToId(svgAttr(node, markerType));\n  return domQuery('marker#' + id, parentNode || document);\n}\n\n/**\r\n * Get ID of fragment within current document from its functional IRI reference.\r\n * References may use single or double quotes.\r\n *\r\n * @param {string} reference\r\n *\r\n * @returns {string}\r\n */\nfunction referenceToId(reference) {\n  return reference.match(/url\\(['\"]?#([^'\"]*)['\"]?\\)/)[1];\n}\n\n/**\r\n * Get functional IRI reference for given ID of fragment within current document.\r\n *\r\n * @param {string} id\r\n *\r\n * @returns {string}\r\n */\nfunction idToReference(id) {\n  return 'url(#' + id + ')';\n}\n\n/**\r\n * Check wether node type can have marker attributes.\r\n *\r\n * @param {Node} node\r\n *\r\n * @returns {boolean}\r\n */\nfunction canHaveMarker(node) {\n  return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;\n}","map":null,"metadata":{},"sourceType":"module"}