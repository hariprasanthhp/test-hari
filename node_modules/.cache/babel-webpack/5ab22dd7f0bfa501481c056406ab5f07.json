{"ast":null,"code":"import { assign, forEach, pick } from 'min-dash';\nimport MoveHelper from './helper/MoveHelper';\nimport { add as collectionAdd, remove as collectionRemove } from '../../../util/Collections';\nimport { getMovedSourceAnchor, getMovedTargetAnchor } from './helper/AnchorsHelper';\n\n/**\n * A handler that implements reversible moving of shapes.\n */\nexport default function MoveShapeHandler(modeling) {\n  this._modeling = modeling;\n  this._helper = new MoveHelper(modeling);\n}\nMoveShapeHandler.$inject = ['modeling'];\nMoveShapeHandler.prototype.execute = function (context) {\n  var shape = context.shape,\n    delta = context.delta,\n    newParent = context.newParent || shape.parent,\n    newParentIndex = context.newParentIndex,\n    oldParent = shape.parent;\n  context.oldBounds = pick(shape, ['x', 'y', 'width', 'height']);\n\n  // save old parent in context\n  context.oldParent = oldParent;\n  context.oldParentIndex = collectionRemove(oldParent.children, shape);\n\n  // add to new parent at position\n  collectionAdd(newParent.children, shape, newParentIndex);\n\n  // update shape parent + position\n  assign(shape, {\n    parent: newParent,\n    x: shape.x + delta.x,\n    y: shape.y + delta.y\n  });\n  return shape;\n};\nMoveShapeHandler.prototype.postExecute = function (context) {\n  var shape = context.shape,\n    delta = context.delta,\n    hints = context.hints;\n  var modeling = this._modeling;\n  if (hints.layout !== false) {\n    forEach(shape.incoming, function (c) {\n      modeling.layoutConnection(c, {\n        connectionEnd: getMovedTargetAnchor(c, shape, delta)\n      });\n    });\n    forEach(shape.outgoing, function (c) {\n      modeling.layoutConnection(c, {\n        connectionStart: getMovedSourceAnchor(c, shape, delta)\n      });\n    });\n  }\n  if (hints.recurse !== false) {\n    this.moveChildren(context);\n  }\n};\nMoveShapeHandler.prototype.revert = function (context) {\n  var shape = context.shape,\n    oldParent = context.oldParent,\n    oldParentIndex = context.oldParentIndex,\n    delta = context.delta;\n\n  // restore previous location in old parent\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n\n  // revert to old position and parent\n  assign(shape, {\n    parent: oldParent,\n    x: shape.x - delta.x,\n    y: shape.y - delta.y\n  });\n  return shape;\n};\nMoveShapeHandler.prototype.moveChildren = function (context) {\n  var delta = context.delta,\n    shape = context.shape;\n  this._helper.moveRecursive(shape.children, delta, null);\n};\nMoveShapeHandler.prototype.getNewParent = function (context) {\n  return context.newParent || context.shape.parent;\n};","map":null,"metadata":{},"sourceType":"module"}