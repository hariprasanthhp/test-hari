{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { is } from '../../../util/ModelUtil';\nimport { isExpanded } from '../../../util/DiUtil';\nimport { LANE_MIN_DIMENSIONS, PARTICIPANT_MIN_DIMENSIONS, SUB_PROCESS_MIN_DIMENSIONS, TEXT_ANNOTATION_MIN_DIMENSIONS } from './ResizeBehavior';\nimport { getChildLanes } from '../util/LaneUtil';\nvar max = Math.max;\nexport default function SpaceToolBehavior(eventBus) {\n  eventBus.on('spaceTool.getMinDimensions', function (context) {\n    var shapes = context.shapes,\n      axis = context.axis,\n      start = context.start,\n      minDimensions = {};\n    forEach(shapes, function (shape) {\n      var id = shape.id;\n      if (is(shape, 'bpmn:Participant')) {\n        if (isHorizontal(axis)) {\n          minDimensions[id] = PARTICIPANT_MIN_DIMENSIONS;\n        } else {\n          minDimensions[id] = {\n            width: PARTICIPANT_MIN_DIMENSIONS.width,\n            height: getParticipantMinHeight(shape, start)\n          };\n        }\n      }\n      if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n        minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;\n      }\n      if (is(shape, 'bpmn:TextAnnotation')) {\n        minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;\n      }\n    });\n    return minDimensions;\n  });\n}\nSpaceToolBehavior.$inject = ['eventBus'];\n\n// helpers //////////\nfunction isHorizontal(axis) {\n  return axis === 'x';\n}\n\n/**\r\n * Get minimum height for participant taking lanes into account.\r\n *\r\n * @param {<djs.model.Shape>} participant\r\n * @param {number} start\r\n *\r\n * @returns {Object}\r\n */\nfunction getParticipantMinHeight(participant, start) {\n  var lanesMinHeight;\n  if (!hasChildLanes(participant)) {\n    return PARTICIPANT_MIN_DIMENSIONS.height;\n  }\n  lanesMinHeight = getLanesMinHeight(participant, start);\n  return max(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);\n}\nfunction hasChildLanes(element) {\n  return !!getChildLanes(element).length;\n}\nfunction getLanesMinHeight(participant, resizeStart) {\n  var lanes = getChildLanes(participant),\n    resizedLane;\n\n  // find the nested lane which is currently resized\n  resizedLane = findResizedLane(lanes, resizeStart);\n\n  // resized lane cannot shrink below the minimum height\n  // but remaining lanes' dimensions are kept intact\n  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;\n}\n\n/**\r\n * Find nested lane which is currently resized.\r\n *\r\n * @param {Array<djs.model.Shape>} lanes\r\n * @param {number} resizeStart\r\n */\nfunction findResizedLane(lanes, resizeStart) {\n  var i, lane, childLanes;\n  for (i = 0; i < lanes.length; i++) {\n    lane = lanes[i];\n\n    // resizing current lane or a lane nested\n    if (resizeStart >= lane.y && resizeStart <= lane.y + lane.height) {\n      childLanes = getChildLanes(lane);\n\n      // a nested lane is resized\n      if (childLanes.length) {\n        return findResizedLane(childLanes, resizeStart);\n      }\n\n      // current lane is the resized one\n      return lane;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}