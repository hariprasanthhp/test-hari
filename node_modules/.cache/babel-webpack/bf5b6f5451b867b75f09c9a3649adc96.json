{"ast":null,"code":"import inherits from 'inherits';\nimport { isObject, assign, forEach } from 'min-dash';\nimport BaseRenderer from 'diagram-js/lib/draw/BaseRenderer';\nimport { isExpanded, isEventSubProcess } from '../util/DiUtil';\nimport { getLabel } from '../features/label-editing/LabelUtil';\nimport { is } from '../util/ModelUtil';\nimport { createLine } from 'diagram-js/lib/util/RenderUtil';\nimport { isTypedEvent, isThrowEvent, isCollection, getDi, getSemantic, getCirclePath, getRoundRectPath, getDiamondPath, getRectPath, getFillColor, getStrokeColor } from './BpmnRenderUtil';\nimport { query as domQuery } from 'min-dom';\nimport { append as svgAppend, attr as svgAttr, create as svgCreate, classes as svgClasses } from 'tiny-svg';\nimport { rotate, transform, translate } from 'diagram-js/lib/util/SvgTransformUtil';\nimport Ids from 'ids';\nvar RENDERER_IDS = new Ids();\nvar TASK_BORDER_RADIUS = 10;\nvar INNER_OUTER_DIST = 3;\nvar DEFAULT_FILL_OPACITY = .95,\n  HIGH_FILL_OPACITY = .35;\nexport default function BpmnRenderer(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {\n  BaseRenderer.call(this, eventBus, priority);\n  var defaultFillColor = config && config.defaultFillColor,\n    defaultStrokeColor = config && config.defaultStrokeColor;\n  var rendererId = RENDERER_IDS.next();\n  var markers = {};\n  var computeStyle = styles.computeStyle;\n  function addMarker(id, options) {\n    var attrs = assign({\n      fill: 'black',\n      strokeWidth: 1,\n      strokeLinecap: 'round',\n      strokeDasharray: 'none'\n    }, options.attrs);\n    var ref = options.ref || {\n      x: 0,\n      y: 0\n    };\n    var scale = options.scale || 1;\n\n    // fix for safari / chrome / firefox bug not correctly\n    // resetting stroke dash array\n    if (attrs.strokeDasharray === 'none') {\n      attrs.strokeDasharray = [10000, 1];\n    }\n    var marker = svgCreate('marker');\n    svgAttr(options.element, attrs);\n    svgAppend(marker, options.element);\n    svgAttr(marker, {\n      id: id,\n      viewBox: '0 0 20 20',\n      refX: ref.x,\n      refY: ref.y,\n      markerWidth: 20 * scale,\n      markerHeight: 20 * scale,\n      orient: 'auto'\n    });\n    var defs = domQuery('defs', canvas._svg);\n    if (!defs) {\n      defs = svgCreate('defs');\n      svgAppend(canvas._svg, defs);\n    }\n    svgAppend(defs, marker);\n    markers[id] = marker;\n  }\n  function colorEscape(str) {\n    // only allow characters and numbers\n    return str.replace(/[^0-9a-zA-z]+/g, '_');\n  }\n  function marker(type, fill, stroke) {\n    var id = type + '-' + colorEscape(fill) + '-' + colorEscape(stroke) + '-' + rendererId;\n    if (!markers[id]) {\n      createMarker(id, type, fill, stroke);\n    }\n    return 'url(#' + id + ')';\n  }\n  function createMarker(id, type, fill, stroke) {\n    if (type === 'sequenceflow-end') {\n      var sequenceflowEnd = svgCreate('path');\n      svgAttr(sequenceflowEnd, {\n        d: 'M 1 5 L 11 10 L 1 15 Z'\n      });\n      addMarker(id, {\n        element: sequenceflowEnd,\n        ref: {\n          x: 11,\n          y: 10\n        },\n        scale: 0.5,\n        attrs: {\n          fill: stroke,\n          stroke: stroke\n        }\n      });\n    }\n    if (type === 'messageflow-start') {\n      var messageflowStart = svgCreate('circle');\n      svgAttr(messageflowStart, {\n        cx: 6,\n        cy: 6,\n        r: 3.5\n      });\n      addMarker(id, {\n        element: messageflowStart,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: {\n          x: 6,\n          y: 6\n        }\n      });\n    }\n    if (type === 'messageflow-end') {\n      var messageflowEnd = svgCreate('path');\n      svgAttr(messageflowEnd, {\n        d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z'\n      });\n      addMarker(id, {\n        element: messageflowEnd,\n        attrs: {\n          fill: fill,\n          stroke: stroke,\n          strokeLinecap: 'butt'\n        },\n        ref: {\n          x: 8.5,\n          y: 5\n        }\n      });\n    }\n    if (type === 'association-start') {\n      var associationStart = svgCreate('path');\n      svgAttr(associationStart, {\n        d: 'M 11 5 L 1 10 L 11 15'\n      });\n      addMarker(id, {\n        element: associationStart,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: {\n          x: 1,\n          y: 10\n        },\n        scale: 0.5\n      });\n    }\n    if (type === 'association-end') {\n      var associationEnd = svgCreate('path');\n      svgAttr(associationEnd, {\n        d: 'M 1 5 L 11 10 L 1 15'\n      });\n      addMarker(id, {\n        element: associationEnd,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: {\n          x: 12,\n          y: 10\n        },\n        scale: 0.5\n      });\n    }\n    if (type === 'conditional-flow-marker') {\n      var conditionalflowMarker = svgCreate('path');\n      svgAttr(conditionalflowMarker, {\n        d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z'\n      });\n      addMarker(id, {\n        element: conditionalflowMarker,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: {\n          x: -1,\n          y: 10\n        },\n        scale: 0.5\n      });\n    }\n    if (type === 'conditional-default-flow-marker') {\n      var conditionaldefaultflowMarker = svgCreate('path');\n      svgAttr(conditionaldefaultflowMarker, {\n        d: 'M 6 4 L 10 16'\n      });\n      addMarker(id, {\n        element: conditionaldefaultflowMarker,\n        attrs: {\n          stroke: stroke\n        },\n        ref: {\n          x: 0,\n          y: 10\n        },\n        scale: 0.5\n      });\n    }\n  }\n  function drawCircle(parentGfx, width, height, offset, attrs) {\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n    offset = offset || 0;\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n    if (attrs.fill === 'none') {\n      delete attrs.fillOpacity;\n    }\n    var cx = width / 2,\n      cy = height / 2;\n    var circle = svgCreate('circle');\n    svgAttr(circle, {\n      cx: cx,\n      cy: cy,\n      r: Math.round((width + height) / 4 - offset)\n    });\n    svgAttr(circle, attrs);\n    svgAppend(parentGfx, circle);\n    return circle;\n  }\n  function drawRect(parentGfx, width, height, r, offset, attrs) {\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n    offset = offset || 0;\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n    var rect = svgCreate('rect');\n    svgAttr(rect, {\n      x: offset,\n      y: offset,\n      width: width - offset * 2,\n      height: height - offset * 2,\n      rx: r,\n      ry: r\n    });\n    svgAttr(rect, attrs);\n    svgAppend(parentGfx, rect);\n    return rect;\n  }\n  function drawDiamond(parentGfx, width, height, attrs) {\n    var x_2 = width / 2;\n    var y_2 = height / 2;\n    var points = [{\n      x: x_2,\n      y: 0\n    }, {\n      x: width,\n      y: y_2\n    }, {\n      x: x_2,\n      y: height\n    }, {\n      x: 0,\n      y: y_2\n    }];\n    var pointsString = points.map(function (point) {\n      return point.x + ',' + point.y;\n    }).join(' ');\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n    var polygon = svgCreate('polygon');\n    svgAttr(polygon, {\n      points: pointsString\n    });\n    svgAttr(polygon, attrs);\n    svgAppend(parentGfx, polygon);\n    return polygon;\n  }\n  function drawLine(parentGfx, waypoints, attrs) {\n    attrs = computeStyle(attrs, ['no-fill'], {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'none'\n    });\n    var line = createLine(waypoints, attrs);\n    svgAppend(parentGfx, line);\n    return line;\n  }\n  function drawPath(parentGfx, d, attrs) {\n    attrs = computeStyle(attrs, ['no-fill'], {\n      strokeWidth: 2,\n      stroke: 'black'\n    });\n    var path = svgCreate('path');\n    svgAttr(path, {\n      d: d\n    });\n    svgAttr(path, attrs);\n    svgAppend(parentGfx, path);\n    return path;\n  }\n  function drawMarker(type, parentGfx, path, attrs) {\n    return drawPath(parentGfx, path, assign({\n      'data-marker': type\n    }, attrs));\n  }\n  function as(type) {\n    return function (parentGfx, element) {\n      return handlers[type](parentGfx, element);\n    };\n  }\n  function renderer(type) {\n    return handlers[type];\n  }\n  function renderEventContent(element, parentGfx) {\n    var event = getSemantic(element);\n    var isThrowing = isThrowEvent(event);\n    if (event.eventDefinitions && event.eventDefinitions.length > 1) {\n      if (event.parallelMultiple) {\n        return renderer('bpmn:ParallelMultipleEventDefinition')(parentGfx, element, isThrowing);\n      } else {\n        return renderer('bpmn:MultipleEventDefinition')(parentGfx, element, isThrowing);\n      }\n    }\n    if (isTypedEvent(event, 'bpmn:MessageEventDefinition')) {\n      return renderer('bpmn:MessageEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:TimerEventDefinition')) {\n      return renderer('bpmn:TimerEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:ConditionalEventDefinition')) {\n      return renderer('bpmn:ConditionalEventDefinition')(parentGfx, element);\n    }\n    if (isTypedEvent(event, 'bpmn:SignalEventDefinition')) {\n      return renderer('bpmn:SignalEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:EscalationEventDefinition')) {\n      return renderer('bpmn:EscalationEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:LinkEventDefinition')) {\n      return renderer('bpmn:LinkEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:ErrorEventDefinition')) {\n      return renderer('bpmn:ErrorEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition')) {\n      return renderer('bpmn:CancelEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:CompensateEventDefinition')) {\n      return renderer('bpmn:CompensateEventDefinition')(parentGfx, element, isThrowing);\n    }\n    if (isTypedEvent(event, 'bpmn:TerminateEventDefinition')) {\n      return renderer('bpmn:TerminateEventDefinition')(parentGfx, element, isThrowing);\n    }\n    return null;\n  }\n  function renderLabel(parentGfx, label, options) {\n    options = assign({\n      size: {\n        width: 100\n      }\n    }, options);\n    var text = textRenderer.createText(label || '', options);\n    svgClasses(text).add('djs-label');\n    svgAppend(parentGfx, text);\n    return text;\n  }\n  function renderEmbeddedLabel(parentGfx, element, align) {\n    var semantic = getSemantic(element);\n    return renderLabel(parentGfx, semantic.name, {\n      box: element,\n      align: align,\n      padding: 5,\n      style: {\n        fill: getStrokeColor(element, defaultStrokeColor)\n      }\n    });\n  }\n  function renderExternalLabel(parentGfx, element) {\n    var box = {\n      width: 90,\n      height: 30,\n      x: element.width / 2 + element.x,\n      y: element.height / 2 + element.y\n    };\n    return renderLabel(parentGfx, getLabel(element), {\n      box: box,\n      fitBox: true,\n      style: assign({}, textRenderer.getExternalStyle(), {\n        fill: getStrokeColor(element, defaultStrokeColor)\n      })\n    });\n  }\n  function renderLaneLabel(parentGfx, text, element) {\n    var textBox = renderLabel(parentGfx, text, {\n      box: {\n        height: 30,\n        width: element.height\n      },\n      align: 'center-middle',\n      style: {\n        fill: getStrokeColor(element, defaultStrokeColor)\n      }\n    });\n    var top = -1 * element.height;\n    transform(textBox, 0, -top, 270);\n  }\n  function createPathFromConnection(connection) {\n    var waypoints = connection.waypoints;\n    var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;\n    for (var i = 1; i < waypoints.length; i++) {\n      pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';\n    }\n    return pathData;\n  }\n  var handlers = this.handlers = {\n    'bpmn:Event': function (parentGfx, element, attrs) {\n      if (!('fillOpacity' in attrs)) {\n        attrs.fillOpacity = DEFAULT_FILL_OPACITY;\n      }\n      return drawCircle(parentGfx, element.width, element.height, attrs);\n    },\n    'bpmn:StartEvent': function (parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      var semantic = getSemantic(element);\n      if (!semantic.isInterrupting) {\n        attrs = {\n          strokeDasharray: '6',\n          strokeLinecap: 'round',\n          fill: getFillColor(element, defaultFillColor),\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        };\n      }\n      var circle = renderer('bpmn:Event')(parentGfx, element, attrs);\n      renderEventContent(element, parentGfx);\n      return circle;\n    },\n    'bpmn:MessageEventDefinition': function (parentGfx, element, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.235,\n          my: 0.315\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(element, defaultStrokeColor) : getFillColor(element, defaultFillColor);\n      var stroke = isThrowing ? getFillColor(element, defaultFillColor) : getStrokeColor(element, defaultStrokeColor);\n      var messagePath = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: stroke\n      });\n      return messagePath;\n    },\n    'bpmn:TimerEventDefinition': function (parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {\n        strokeWidth: 2,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {\n        xScaleFactor: 0.75,\n        yScaleFactor: 0.75,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.5,\n          my: 0.5\n        }\n      });\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 2,\n        strokeLinecap: 'square',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      for (var i = 0; i < 12; i++) {\n        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {\n          xScaleFactor: 0.75,\n          yScaleFactor: 0.75,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.5,\n            my: 0.5\n          }\n        });\n        var width = element.width / 2;\n        var height = element.height / 2;\n        drawPath(parentGfx, linePathData, {\n          strokeWidth: 1,\n          strokeLinecap: 'square',\n          transform: 'rotate(' + i * 30 + ',' + height + ',' + width + ')',\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        });\n      }\n      return circle;\n    },\n    'bpmn:EscalationEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:ConditionalEventDefinition': function (parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.222\n        }\n      });\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:LinkEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_LINK', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.57,\n          my: 0.263\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:ErrorEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ERROR', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.2,\n          my: 0.722\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:CancelEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {\n        xScaleFactor: 1.0,\n        yScaleFactor: 1.0,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.638,\n          my: -0.055\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      var path = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n      rotate(path, 45);\n      return path;\n    },\n    'bpmn:CompensateEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.22,\n          my: 0.5\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:SignalEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:MultipleEventDefinition': function (parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.222,\n          my: 0.36\n        }\n      });\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill\n      });\n    },\n    'bpmn:ParallelMultipleEventDefinition': function (parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {\n        xScaleFactor: 1.2,\n        yScaleFactor: 1.2,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.458,\n          my: 0.194\n        }\n      });\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(event, defaultStrokeColor),\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:EndEvent': function (parentGfx, element) {\n      var circle = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 4,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      renderEventContent(element, parentGfx, true);\n      return circle;\n    },\n    'bpmn:TerminateEventDefinition': function (parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 8, {\n        strokeWidth: 4,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return circle;\n    },\n    'bpmn:IntermediateEvent': function (parentGfx, element) {\n      var outer = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      /* inner */\n      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {\n        strokeWidth: 1,\n        fill: getFillColor(element, 'none'),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      renderEventContent(element, parentGfx);\n      return outer;\n    },\n    'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),\n    'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),\n    'bpmn:Activity': function (parentGfx, element, attrs) {\n      attrs = attrs || {};\n      if (!('fillOpacity' in attrs)) {\n        attrs.fillOpacity = DEFAULT_FILL_OPACITY;\n      }\n      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);\n    },\n    'bpmn:Task': function (parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n      renderEmbeddedLabel(parentGfx, element, 'center-middle');\n      attachTaskMarkers(parentGfx, element);\n      return rect;\n    },\n    'bpmn:ServiceTask': function (parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 12,\n          y: 18\n        }\n      });\n\n      /* service bg */\n      drawPath(parentGfx, pathDataBG, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {\n        abspos: {\n          x: 17.2,\n          y: 18\n        }\n      });\n\n      /* service fill */\n      drawPath(parentGfx, fillPathData, {\n        strokeWidth: 0,\n        fill: getFillColor(element, defaultFillColor)\n      });\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 17,\n          y: 22\n        }\n      });\n\n      /* service */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return task;\n    },\n    'bpmn:UserTask': function (parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var x = 15;\n      var y = 12;\n      var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user2 path */\n      drawPath(parentGfx, pathData2, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user3 path */\n      drawPath(parentGfx, pathData3, {\n        strokeWidth: 0.5,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return task;\n    },\n    'bpmn:ManualTask': function (parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {\n        abspos: {\n          x: 17,\n          y: 15\n        }\n      });\n\n      /* manual path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5,\n        // 0.25,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return task;\n    },\n    'bpmn:SendTask': function (parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: 21,\n        containerHeight: 14,\n        position: {\n          mx: 0.285,\n          my: 0.357\n        }\n      });\n\n      /* send path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getFillColor(element, defaultFillColor)\n      });\n      return task;\n    },\n    'bpmn:ReceiveTask': function (parentGfx, element) {\n      var semantic = getSemantic(element);\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData;\n      if (semantic.instantiate) {\n        drawCircle(parentGfx, 28, 28, 20 * 0.22, {\n          strokeWidth: 1\n        });\n        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {\n          abspos: {\n            x: 7.77,\n            y: 9.52\n          }\n        });\n      } else {\n        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n          xScaleFactor: 0.9,\n          yScaleFactor: 0.9,\n          containerWidth: 21,\n          containerHeight: 14,\n          position: {\n            mx: 0.3,\n            my: 0.4\n          }\n        });\n      }\n\n      /* receive path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return task;\n    },\n    'bpmn:ScriptTask': function (parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {\n        abspos: {\n          x: 15,\n          y: 20\n        }\n      });\n\n      /* script path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return task;\n    },\n    'bpmn:BusinessRuleTask': function (parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n      var businessHeaderPath = drawPath(parentGfx, headerPathData);\n      svgAttr(businessHeaderPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, '#aaaaaa'),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n      var businessPath = drawPath(parentGfx, headerData);\n      svgAttr(businessPath, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return task;\n    },\n    'bpmn:SubProcess': function (parentGfx, element, attrs) {\n      attrs = assign({\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      }, attrs);\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n      var expanded = isExpanded(element);\n      if (isEventSubProcess(element)) {\n        svgAttr(rect, {\n          strokeDasharray: '1,2'\n        });\n      }\n      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle');\n      if (expanded) {\n        attachTaskMarkers(parentGfx, element);\n      } else {\n        attachTaskMarkers(parentGfx, element, ['SubProcessMarker']);\n      }\n      return rect;\n    },\n    'bpmn:AdHocSubProcess': function (parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element);\n    },\n    'bpmn:Transaction': function (parentGfx, element) {\n      var outer = renderer('bpmn:SubProcess')(parentGfx, element);\n      var innerAttrs = styles.style(['no-fill', 'no-events'], {\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      /* inner path */\n      drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);\n      return outer;\n    },\n    'bpmn:CallActivity': function (parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element, {\n        strokeWidth: 5\n      });\n    },\n    'bpmn:Participant': function (parentGfx, element) {\n      var attrs = {\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      var lane = renderer('bpmn:Lane')(parentGfx, element, attrs);\n      var expandedPool = isExpanded(element);\n      if (expandedPool) {\n        drawLine(parentGfx, [{\n          x: 30,\n          y: 0\n        }, {\n          x: 30,\n          y: element.height\n        }], {\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        });\n        var text = getSemantic(element).name;\n        renderLaneLabel(parentGfx, text, element);\n      } else {\n        // Collapsed pool draw text inline\n        var text2 = getSemantic(element).name;\n        renderLabel(parentGfx, text2, {\n          box: element,\n          align: 'center-middle',\n          style: {\n            fill: getStrokeColor(element, defaultStrokeColor)\n          }\n        });\n      }\n      var participantMultiplicity = !!getSemantic(element).participantMultiplicity;\n      if (participantMultiplicity) {\n        renderer('ParticipantMultiplicityMarker')(parentGfx, element);\n      }\n      return lane;\n    },\n    'bpmn:Lane': function (parentGfx, element, attrs) {\n      var rect = drawRect(parentGfx, element.width, element.height, 0, assign({\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: HIGH_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      }, attrs));\n      var semantic = getSemantic(element);\n      if (semantic.$type === 'bpmn:Lane') {\n        var text = semantic.name;\n        renderLaneLabel(parentGfx, text, element);\n      }\n      return rect;\n    },\n    'bpmn:InclusiveGateway': function (parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      /* circle path */\n      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {\n        strokeWidth: 2.5,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return diamond;\n    },\n    'bpmn:ExclusiveGateway': function (parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {\n        xScaleFactor: 0.4,\n        yScaleFactor: 0.4,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.32,\n          my: 0.3\n        }\n      });\n      if (getDi(element).isMarkerVisible) {\n        drawPath(parentGfx, pathData, {\n          strokeWidth: 1,\n          fill: getStrokeColor(element, defaultStrokeColor),\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        });\n      }\n      return diamond;\n    },\n    'bpmn:ComplexGateway': function (parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {\n        xScaleFactor: 0.5,\n        yScaleFactor: 0.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.26\n        }\n      });\n\n      /* complex path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return diamond;\n    },\n    'bpmn:ParallelGateway': function (parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n        xScaleFactor: 0.6,\n        yScaleFactor: 0.6,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.2\n        }\n      });\n\n      /* parallel path */\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return diamond;\n    },\n    'bpmn:EventBasedGateway': function (parentGfx, element) {\n      var semantic = getSemantic(element);\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      /* outer circle path */\n      drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {\n        strokeWidth: 1,\n        fill: 'none',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var type = semantic.eventGatewayType;\n      var instantiate = !!semantic.instantiate;\n      function drawEvent() {\n        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {\n          xScaleFactor: 0.18,\n          yScaleFactor: 0.18,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.36,\n            my: 0.44\n          }\n        });\n        var attrs = {\n          strokeWidth: 2,\n          fill: getFillColor(element, 'none'),\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        };\n\n        /* event path */\n        drawPath(parentGfx, pathData, attrs);\n      }\n      if (type === 'Parallel') {\n        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n          xScaleFactor: 0.4,\n          yScaleFactor: 0.4,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.474,\n            my: 0.296\n          }\n        });\n        var parallelPath = drawPath(parentGfx, pathData);\n        svgAttr(parallelPath, {\n          strokeWidth: 1,\n          fill: 'none'\n        });\n      } else if (type === 'Exclusive') {\n        if (!instantiate) {\n          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);\n          svgAttr(innerCircle, {\n            strokeWidth: 1,\n            fill: 'none',\n            stroke: getStrokeColor(element, defaultStrokeColor)\n          });\n        }\n        drawEvent();\n      }\n      return diamond;\n    },\n    'bpmn:Gateway': function (parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      return drawDiamond(parentGfx, element.width, element.height, attrs);\n    },\n    'bpmn:SequenceFlow': function (parentGfx, element) {\n      var pathData = createPathFromConnection(element);\n      var fill = getFillColor(element, defaultFillColor),\n        stroke = getStrokeColor(element, defaultStrokeColor);\n      var attrs = {\n        strokeLinejoin: 'round',\n        markerEnd: marker('sequenceflow-end', fill, stroke),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      var path = drawPath(parentGfx, pathData, attrs);\n      var sequenceFlow = getSemantic(element);\n      var source;\n      if (element.source) {\n        source = element.source.businessObject;\n\n        // conditional flow marker\n        if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Activity')) {\n          svgAttr(path, {\n            markerStart: marker('conditional-flow-marker', fill, stroke)\n          });\n        }\n\n        // default marker\n        if (source.default && (source.$instanceOf('bpmn:Gateway') || source.$instanceOf('bpmn:Activity')) && source.default === sequenceFlow) {\n          svgAttr(path, {\n            markerStart: marker('conditional-default-flow-marker', fill, stroke)\n          });\n        }\n      }\n      return path;\n    },\n    'bpmn:Association': function (parentGfx, element, attrs) {\n      var semantic = getSemantic(element);\n      var fill = getFillColor(element, defaultFillColor),\n        stroke = getStrokeColor(element, defaultStrokeColor);\n      attrs = assign({\n        strokeDasharray: '0.5, 5',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      }, attrs || {});\n      if (semantic.associationDirection === 'One' || semantic.associationDirection === 'Both') {\n        attrs.markerEnd = marker('association-end', fill, stroke);\n      }\n      if (semantic.associationDirection === 'Both') {\n        attrs.markerStart = marker('association-start', fill, stroke);\n      }\n      return drawLine(parentGfx, element.waypoints, attrs);\n    },\n    'bpmn:DataInputAssociation': function (parentGfx, element) {\n      var fill = getFillColor(element, defaultFillColor),\n        stroke = getStrokeColor(element, defaultStrokeColor);\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:DataOutputAssociation': function (parentGfx, element) {\n      var fill = getFillColor(element, defaultFillColor),\n        stroke = getStrokeColor(element, defaultStrokeColor);\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:MessageFlow': function (parentGfx, element) {\n      var semantic = getSemantic(element),\n        di = getDi(element);\n      var fill = getFillColor(element, defaultFillColor),\n        stroke = getStrokeColor(element, defaultStrokeColor);\n      var pathData = createPathFromConnection(element);\n      var attrs = {\n        markerEnd: marker('messageflow-end', fill, stroke),\n        markerStart: marker('messageflow-start', fill, stroke),\n        strokeDasharray: '10, 12',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        strokeWidth: '1.5px',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      var path = drawPath(parentGfx, pathData, attrs);\n      if (semantic.messageRef) {\n        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);\n        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {\n          abspos: {\n            x: midPoint.x,\n            y: midPoint.y\n          }\n        });\n        var messageAttrs = {\n          strokeWidth: 1\n        };\n        if (di.messageVisibleKind === 'initiating') {\n          messageAttrs.fill = 'white';\n          messageAttrs.stroke = 'black';\n        } else {\n          messageAttrs.fill = '#888';\n          messageAttrs.stroke = 'white';\n        }\n        drawPath(parentGfx, markerPathData, messageAttrs);\n      }\n      return path;\n    },\n    'bpmn:DataObject': function (parentGfx, element) {\n      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.474,\n          my: 0.296\n        }\n      });\n      var elementObject = drawPath(parentGfx, pathData, {\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var semantic = getSemantic(element);\n      if (isCollection(semantic)) {\n        renderDataItemCollection(parentGfx, element);\n      }\n      return elementObject;\n    },\n    'bpmn:DataObjectReference': as('bpmn:DataObject'),\n    'bpmn:DataInput': function (parentGfx, element) {\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* input arrow path */\n      drawPath(parentGfx, arrowPathData, {\n        strokeWidth: 1\n      });\n      return elementObject;\n    },\n    'bpmn:DataOutput': function (parentGfx, element) {\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* output arrow path */\n      drawPath(parentGfx, arrowPathData, {\n        strokeWidth: 1,\n        fill: 'black'\n      });\n      return elementObject;\n    },\n    'bpmn:DataStoreReference': function (parentGfx, element) {\n      var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0,\n          my: 0.133\n        }\n      });\n      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {\n        strokeWidth: 2,\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      return elementStore;\n    },\n    'bpmn:BoundaryEvent': function (parentGfx, element) {\n      var semantic = getSemantic(element),\n        cancel = semantic.cancelActivity;\n      var attrs = {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n      if (!cancel) {\n        attrs.strokeDasharray = '6';\n        attrs.strokeLinecap = 'round';\n      }\n\n      // apply fillOpacity\n      var outerAttrs = assign({}, attrs, {\n        fillOpacity: 1\n      });\n\n      // apply no-fill\n      var innerAttrs = assign({}, attrs, {\n        fill: 'none'\n      });\n      var outer = renderer('bpmn:Event')(parentGfx, element, outerAttrs);\n\n      /* inner path */\n      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, innerAttrs);\n      renderEventContent(element, parentGfx);\n      return outer;\n    },\n    'bpmn:Group': function (parentGfx, element) {\n      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {\n        stroke: getStrokeColor(element, defaultStrokeColor),\n        strokeWidth: 1,\n        strokeDasharray: '8,3,1,3',\n        fill: 'none',\n        pointerEvents: 'none'\n      });\n      return group;\n    },\n    'label': function (parentGfx, element) {\n      return renderExternalLabel(parentGfx, element);\n    },\n    'bpmn:TextAnnotation': function (parentGfx, element) {\n      var style = {\n        'fill': 'none',\n        'stroke': 'none'\n      };\n      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n      drawPath(parentGfx, textPathData, {\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n      var text = getSemantic(element).text || '';\n      renderLabel(parentGfx, text, {\n        box: element,\n        align: 'left-top',\n        padding: 5,\n        style: {\n          fill: getStrokeColor(element, defaultStrokeColor)\n        }\n      });\n      return textElement;\n    },\n    'ParticipantMultiplicityMarker': function (parentGfx, element) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: element.width / 2 / element.width,\n          my: (element.height - 15) / element.height\n        }\n      });\n      drawMarker('participant-multiplicity', parentGfx, markerPath, {\n        strokeWidth: 2,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'SubProcessMarker': function (parentGfx, element) {\n      var markerRect = drawRect(parentGfx, 14, 14, 0, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      // Process marker is placed in the middle of the box\n      // therefore fixed values can be used here\n      translate(markerRect, element.width / 2 - 7.5, element.height - 20);\n      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {\n        xScaleFactor: 1.5,\n        yScaleFactor: 1.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 - 7.5) / element.width,\n          my: (element.height - 20) / element.height\n        }\n      });\n      drawMarker('sub-process', parentGfx, markerPath, {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'ParallelMarker': function (parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 + position.parallel) / element.width,\n          my: (element.height - 20) / element.height\n        }\n      });\n      drawMarker('parallel', parentGfx, markerPath, {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'SequentialMarker': function (parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 + position.seq) / element.width,\n          my: (element.height - 19) / element.height\n        }\n      });\n      drawMarker('sequential', parentGfx, markerPath, {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'CompensationMarker': function (parentGfx, element, position) {\n      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 + position.compensation) / element.width,\n          my: (element.height - 13) / element.height\n        }\n      });\n      drawMarker('compensation', parentGfx, markerMath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'LoopMarker': function (parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 + position.loop) / element.width,\n          my: (element.height - 7) / element.height\n        }\n      });\n      drawMarker('loop', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor),\n        strokeLinecap: 'round',\n        strokeMiterlimit: 0.5\n      });\n    },\n    'AdhocMarker': function (parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 + position.adhoc) / element.width,\n          my: (element.height - 15) / element.height\n        }\n      });\n      drawMarker('adhoc', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    }\n  };\n  function attachTaskMarkers(parentGfx, element, taskMarkers) {\n    var obj = getSemantic(element);\n    var subprocess = taskMarkers && taskMarkers.indexOf('SubProcessMarker') !== -1;\n    var position;\n    if (subprocess) {\n      position = {\n        seq: -21,\n        parallel: -22,\n        compensation: -42,\n        loop: -18,\n        adhoc: 10\n      };\n    } else {\n      position = {\n        seq: -3,\n        parallel: -6,\n        compensation: -27,\n        loop: 0,\n        adhoc: 10\n      };\n    }\n    forEach(taskMarkers, function (marker) {\n      renderer(marker)(parentGfx, element, position);\n    });\n    if (obj.isForCompensation) {\n      renderer('CompensationMarker')(parentGfx, element, position);\n    }\n    if (obj.$type === 'bpmn:AdHocSubProcess') {\n      renderer('AdhocMarker')(parentGfx, element, position);\n    }\n    var loopCharacteristics = obj.loopCharacteristics,\n      isSequential = loopCharacteristics && loopCharacteristics.isSequential;\n    if (loopCharacteristics) {\n      if (isSequential === undefined) {\n        renderer('LoopMarker')(parentGfx, element, position);\n      }\n      if (isSequential === false) {\n        renderer('ParallelMarker')(parentGfx, element, position);\n      }\n      if (isSequential === true) {\n        renderer('SequentialMarker')(parentGfx, element, position);\n      }\n    }\n  }\n  function renderDataItemCollection(parentGfx, element) {\n    var yPosition = (element.height - 18) / element.height;\n    var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {\n      xScaleFactor: 1,\n      yScaleFactor: 1,\n      containerWidth: element.width,\n      containerHeight: element.height,\n      position: {\n        mx: 0.33,\n        my: yPosition\n      }\n    });\n\n    /* collection path */\n    drawPath(parentGfx, pathData, {\n      strokeWidth: 2\n    });\n  }\n\n  // extension API, use at your own risk\n  this._drawPath = drawPath;\n}\ninherits(BpmnRenderer, BaseRenderer);\nBpmnRenderer.$inject = ['config.bpmnRenderer', 'eventBus', 'styles', 'pathMap', 'canvas', 'textRenderer'];\nBpmnRenderer.prototype.canRender = function (element) {\n  return is(element, 'bpmn:BaseElement');\n};\nBpmnRenderer.prototype.drawShape = function (parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};\nBpmnRenderer.prototype.drawConnection = function (parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};\nBpmnRenderer.prototype.getShapePath = function (element) {\n  if (is(element, 'bpmn:Event')) {\n    return getCirclePath(element);\n  }\n  if (is(element, 'bpmn:Activity')) {\n    return getRoundRectPath(element, TASK_BORDER_RADIUS);\n  }\n  if (is(element, 'bpmn:Gateway')) {\n    return getDiamondPath(element);\n  }\n  return getRectPath(element);\n};","map":null,"metadata":{},"sourceType":"module"}