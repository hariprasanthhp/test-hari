{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport inherits from 'inherits';\nimport { remove as collectionRemove, add as collectionAdd } from 'diagram-js/lib/util/Collections';\nimport { Label } from 'diagram-js/lib/model';\nimport { getBusinessObject, is } from '../../util/ModelUtil';\nimport { isAny } from './util/ModelingUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\nexport default function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {\n  CommandInterceptor.call(this, eventBus);\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n  var self = this;\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n      hints = context.hints || {},\n      connection;\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n  this.executed(['connection.layout', 'connection.create'], cropConnection);\n  this.reverted(['connection.layout'], function (e) {\n    delete e.context.cropped;\n  });\n\n  // BPMN + DI update //////////////////////\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n  function reverseUpdateParent(e) {\n    var context = e.context;\n    var element = context.shape || context.connection,\n      // oldParent is the (old) new parent, because we are undoing\n      oldParent = context.parent || context.newParent;\n    self.updateParent(element, oldParent);\n  }\n  this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(updateParent));\n  this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n      oldRoot = context.oldRoot,\n      children = oldRoot.children;\n    forEach(children, function (child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n  this.executed(['canvas.updateRoot'], updateRoot);\n  this.reverted(['canvas.updateRoot'], updateRoot);\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n    self.updateBounds(shape);\n  }\n  this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n    updateBounds(event);\n  }));\n  this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function (event) {\n    if (event.element.type === 'label') {\n      updateBounds({\n        context: {\n          shape: event.element\n        }\n      });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n  this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));\n  this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n  this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n  this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n\n  // update conditional/default flows\n  this.executed('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n      connection = context.connection,\n      oldSource = context.oldSource,\n      newSource = context.newSource,\n      connectionBo = getBusinessObject(connection),\n      oldSourceBo = getBusinessObject(oldSource),\n      newSourceBo = getBusinessObject(newSource);\n\n    // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, ['bpmn:Activity', 'bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway'])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n      delete connectionBo.conditionExpression;\n    }\n\n    // remove default from old source flow on reconnect to new source\n    // if source changed\n    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {\n      context.oldDefault = oldSourceBo.default;\n      delete oldSourceBo.default;\n    }\n  }));\n  this.reverted('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n      connection = context.connection,\n      oldSource = context.oldSource,\n      newSource = context.newSource,\n      connectionBo = getBusinessObject(connection),\n      oldSourceBo = getBusinessObject(oldSource),\n      newSourceBo = getBusinessObject(newSource);\n\n    // add condition to connection on revert reconnect to new source\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    }\n\n    // add default to old source on revert reconnect to new source\n    if (context.oldDefault) {\n      oldSourceBo.default = context.oldDefault;\n      delete newSourceBo.default;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n  this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));\n  this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));\n}\ninherits(BpmnUpdater, CommandInterceptor);\nBpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking', 'translate'];\n\n// implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function (context) {\n  var shape = context.shape,\n    businessObject = shape.businessObject,\n    host = shape.host;\n  businessObject.attachedToRef = host && host.businessObject;\n};\nBpmnUpdater.prototype.updateParent = function (element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  }\n\n  // data stores in collaborations are handled separately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') && element.parent && is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n  var parentShape = element.parent;\n  var businessObject = element.businessObject,\n    parentBusinessObject = parentShape && parentShape.businessObject,\n    parentDi = parentBusinessObject && parentBusinessObject.di;\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n  this.updateDiParent(businessObject.di, parentDi);\n};\nBpmnUpdater.prototype.updateBounds = function (shape) {\n  var di = shape.businessObject.di;\n  var target = shape instanceof Label ? this._getLabel(di) : di;\n  var bounds = target.bounds;\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\nBpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {\n  if (oldContainment === newContainment) {\n    return;\n  }\n  var oldRefs, newRefs;\n  if (is(oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};\n\n// update existing sourceElement and targetElement di information\nBpmnUpdater.prototype.updateDiConnection = function (di, newSource, newTarget) {\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n};\nBpmnUpdater.prototype.updateDiParent = function (di, parentDi) {\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n  if (di.$parent === parentDi) {\n    return;\n  }\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n  return element;\n}\nBpmnUpdater.prototype.getLaneSet = function (container) {\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n  return laneSet;\n};\nBpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {\n  var containment,\n    translate = this._translate;\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n  if (is(businessObject, 'bpmn:Lane')) {\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n    containment = 'lanes';\n  } else if (is(businessObject, 'bpmn:FlowElement')) {\n    if (newParent) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n      }\n    }\n    containment = 'flowElements';\n  } else if (is(businessObject, 'bpmn:Artifact')) {\n    while (newParent && !is(newParent, 'bpmn:Process') && !is(newParent, 'bpmn:SubProcess') && !is(newParent, 'bpmn:Collaboration')) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n    containment = 'artifacts';\n  } else if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n  } else if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n      definitions;\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n  if (!containment) {\n    throw new Error(translate('no parent for {element} in {parent}', {\n      element: businessObject.id,\n      parent: newParent.id\n    }));\n  }\n  var children;\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n    collectionRemove(children, businessObject);\n    if (newParent) {\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n      diChildren.push(businessObject);\n    }\n  }\n};\nBpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\nBpmnUpdater.prototype.updateConnection = function (context) {\n  var connection = context.connection,\n    businessObject = getBusinessObject(connection),\n    newSource = getBusinessObject(connection.source),\n    newTarget = getBusinessObject(connection.target),\n    visualParent;\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n      businessObject.sourceRef = newSource;\n    }\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n      businessObject.targetRef = newTarget;\n    }\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n    visualParent = context.parent || context.newParent || newTarget;\n    this.updateSemanticParent(businessObject, newTarget, visualParent);\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n    this.updateSemanticParent(businessObject, newSource, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTarget;\n  }\n  this.updateConnectionWaypoints(connection);\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n};\n\n// helpers //////////////////////\n\nBpmnUpdater.prototype._getLabel = function (di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n  return di.label;\n};\n\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\nfunction ifBpmn(fn) {\n  return function (event) {\n    var context = event.context,\n      element = context.shape || context.connection;\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}