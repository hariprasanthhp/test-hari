{"ast":null,"code":"import { filter } from 'min-dash';\nimport { eachElement } from 'diagram-js/lib/util/Elements';\nimport { getLanesRoot, getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\n\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @param {Modeling} modeling\n * @param {SpaceTool} spaceTool\n */\nexport default function AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\nAddLaneHandler.$inject = ['modeling', 'spaceTool'];\nAddLaneHandler.prototype.preExecute = function (context) {\n  var spaceTool = this._spaceTool,\n    modeling = this._modeling;\n  var shape = context.shape,\n    location = context.location;\n  var lanesRoot = getLanesRoot(shape);\n  var isRoot = lanesRoot === shape,\n    laneParent = isRoot ? shape : shape.parent;\n  var existingChildLanes = getChildLanes(laneParent);\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    modeling.createShape({\n      type: 'bpmn:Lane'\n    }, {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    }, laneParent);\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n  eachElement(lanesRoot, function (element) {\n    allAffected.push(element);\n\n    // handle element labels in the diagram root\n    if (element.label) {\n      allAffected.push(element.label);\n    }\n    if (element === shape) {\n      return [];\n    }\n    return filter(element.children, function (c) {\n      return c !== shape;\n    });\n  });\n  var offset = location === 'top' ? -120 : 120,\n    lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\n    spacePos = lanePosition + (location === 'top' ? 10 : -10),\n    direction = location === 'top' ? 'n' : 's';\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, {\n    x: 0,\n    y: offset\n  }, direction, spacePos);\n\n  // (2) create new lane at open space\n  context.newLane = modeling.createShape({\n    type: 'bpmn:Lane'\n  }, {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  }, laneParent);\n};","map":null,"metadata":{},"sourceType":"module"}