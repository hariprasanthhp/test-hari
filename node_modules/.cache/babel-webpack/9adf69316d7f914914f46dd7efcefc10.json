{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { getResizedSourceAnchor, getResizedTargetAnchor } from './helper/AnchorsHelper';\n\n/**\n * Replace shape by adding new shape and removing old shape. Incoming and outgoing connections will\n * be kept if possible.\n *\n * @class\n * @constructor\n *\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function ReplaceShapeHandler(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\nReplaceShapeHandler.$inject = ['modeling', 'rules'];\n\n/**\n * Add new shape.\n *\n * @param {Object} context\n * @param {djs.model.Shape} context.oldShape\n * @param {Object} context.newData\n * @param {string} context.newData.type\n * @param {number} context.newData.x\n * @param {number} context.newData.y\n * @param {Object} [hints]\n */\nReplaceShapeHandler.prototype.preExecute = function (context) {\n  var self = this,\n    modeling = this._modeling,\n    rules = this._rules;\n  var oldShape = context.oldShape,\n    newData = context.newData,\n    hints = context.hints || {},\n    newShape;\n  function canReconnect(source, target, connection) {\n    return rules.allowed('connection.reconnect', {\n      connection: connection,\n      source: source,\n      target: target\n    });\n  }\n\n  // (1) add new shape at given position\n  var position = {\n    x: newData.x,\n    y: newData.y\n  };\n  var oldBounds = {\n    x: oldShape.x,\n    y: oldShape.y,\n    width: oldShape.width,\n    height: oldShape.height\n  };\n  newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent, hints);\n\n  // (2) update host\n  if (oldShape.host) {\n    modeling.updateAttachment(newShape, oldShape.host);\n  }\n\n  // (3) adopt all children from old shape\n  var children;\n  if (hints.moveChildren !== false) {\n    children = oldShape.children.slice();\n    modeling.moveElements(children, {\n      x: 0,\n      y: 0\n    }, newShape, hints);\n  }\n\n  // (4) reconnect connections to new shape if possible\n  var incoming = oldShape.incoming.slice(),\n    outgoing = oldShape.outgoing.slice();\n  forEach(incoming, function (connection) {\n    var source = connection.source,\n      allowed = canReconnect(source, newShape, connection);\n    if (allowed) {\n      self.reconnectEnd(connection, newShape, getResizedTargetAnchor(connection, newShape, oldBounds), hints);\n    }\n  });\n  forEach(outgoing, function (connection) {\n    var target = connection.target,\n      allowed = canReconnect(newShape, target, connection);\n    if (allowed) {\n      self.reconnectStart(connection, newShape, getResizedSourceAnchor(connection, newShape, oldBounds), hints);\n    }\n  });\n};\n\n/**\n * Remove old shape.\n */\nReplaceShapeHandler.prototype.postExecute = function (context) {\n  var oldShape = context.oldShape;\n  this._modeling.removeShape(oldShape);\n};\nReplaceShapeHandler.prototype.execute = function (context) {};\nReplaceShapeHandler.prototype.revert = function (context) {};\nReplaceShapeHandler.prototype.createShape = function (shape, position, target, hints) {\n  return this._modeling.createShape(shape, position, target, hints);\n};\nReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint, hints) {\n  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);\n};\nReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint, hints) {\n  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);\n};","map":null,"metadata":{},"sourceType":"module"}