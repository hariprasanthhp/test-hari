{"ast":null,"code":"import { classes as svgClasses, remove as svgRemove } from 'tiny-svg';\nimport { addBendpoint } from './BendpointUtil';\nimport { translate } from '../../util/SvgTransformUtil';\nimport { isReverse } from './BendpointMove';\nvar RECONNECT_START = 'reconnectStart',\n  RECONNECT_END = 'reconnectEnd',\n  UPDATE_WAYPOINTS = 'updateWaypoints';\nvar MARKER_OK = 'connect-ok',\n  MARKER_NOT_OK = 'connect-not-ok',\n  MARKER_CONNECT_HOVER = 'connect-hover',\n  MARKER_CONNECT_UPDATING = 'djs-updating',\n  MARKER_ELEMENT_HIDDEN = 'djs-element-hidden';\nvar HIGH_PRIORITY = 1100;\n\n/**\n * Preview connection while moving bendpoints.\n */\nexport default function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {\n  this._injector = injector;\n  var connectionPreview = injector.get('connectionPreview', false);\n  eventBus.on('bendpoint.move.start', function (event) {\n    var context = event.context,\n      bendpointIndex = context.bendpointIndex,\n      connection = context.connection,\n      insert = context.insert,\n      waypoints = connection.waypoints,\n      newWaypoints = waypoints.slice();\n    context.waypoints = waypoints;\n    if (insert) {\n      // insert placeholder for new bendpoint\n      newWaypoints.splice(bendpointIndex, 0, {\n        x: event.x,\n        y: event.y\n      });\n    }\n    connection.waypoints = newWaypoints;\n\n    // add dragger gfx\n    var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer('overlays'));\n    svgClasses(draggerGfx).add('djs-dragging');\n    canvas.addMarker(connection, MARKER_ELEMENT_HIDDEN);\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on('bendpoint.move.hover', function (event) {\n    var context = event.context,\n      allowed = context.allowed,\n      hover = context.hover,\n      type = context.type;\n    if (hover) {\n      canvas.addMarker(hover, MARKER_CONNECT_HOVER);\n      if (type === UPDATE_WAYPOINTS) {\n        return;\n      }\n      if (allowed) {\n        canvas.removeMarker(hover, MARKER_NOT_OK);\n        canvas.addMarker(hover, MARKER_OK);\n      } else if (allowed === false) {\n        canvas.removeMarker(hover, MARKER_OK);\n        canvas.addMarker(hover, MARKER_NOT_OK);\n      }\n    }\n  });\n  eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      hover = context.hover,\n      target = context.target;\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);\n    }\n  });\n  eventBus.on('bendpoint.move.move', function (event) {\n    var context = event.context,\n      allowed = context.allowed,\n      bendpointIndex = context.bendpointIndex,\n      draggerGfx = context.draggerGfx,\n      hover = context.hover,\n      type = context.type,\n      connection = context.connection,\n      source = connection.source,\n      target = connection.target,\n      newWaypoints = connection.waypoints.slice(),\n      bendpoint = {\n        x: event.x,\n        y: event.y\n      },\n      hints = context.hints || {},\n      drawPreviewHints = {};\n    if (connectionPreview) {\n      if (hints.connectionStart) {\n        drawPreviewHints.connectionStart = hints.connectionStart;\n      }\n      if (hints.connectionEnd) {\n        drawPreviewHints.connectionEnd = hints.connectionEnd;\n      }\n      if (type === RECONNECT_START) {\n        if (isReverse(context)) {\n          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;\n          drawPreviewHints.source = target;\n          drawPreviewHints.target = hover || source;\n          newWaypoints = newWaypoints.reverse();\n        } else {\n          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;\n          drawPreviewHints.source = hover || source;\n          drawPreviewHints.target = target;\n        }\n      } else if (type === RECONNECT_END) {\n        if (isReverse(context)) {\n          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;\n          drawPreviewHints.source = hover || target;\n          drawPreviewHints.target = source;\n          newWaypoints = newWaypoints.reverse();\n        } else {\n          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;\n          drawPreviewHints.source = source;\n          drawPreviewHints.target = hover || target;\n        }\n      } else {\n        drawPreviewHints.noCropping = true;\n        drawPreviewHints.noLayout = true;\n        newWaypoints[bendpointIndex] = bendpoint;\n      }\n      if (type === UPDATE_WAYPOINTS) {\n        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);\n      }\n      drawPreviewHints.waypoints = newWaypoints;\n      connectionPreview.drawPreview(context, allowed, drawPreviewHints);\n    }\n    translate(draggerGfx, event.x, event.y);\n  }, this);\n  eventBus.on(['bendpoint.move.end', 'bendpoint.move.cancel'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      connection = context.connection,\n      draggerGfx = context.draggerGfx,\n      hover = context.hover,\n      target = context.target,\n      waypoints = context.waypoints;\n    connection.waypoints = waypoints;\n\n    // remove dragger gfx\n    svgRemove(draggerGfx);\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n    canvas.removeMarker(connection, MARKER_ELEMENT_HIDDEN);\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_OK);\n      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);\n    }\n    if (connectionPreview) {\n      connectionPreview.cleanUp(context);\n    }\n  });\n}\nBendpointMovePreview.$inject = ['bendpointMove', 'injector', 'eventBus', 'canvas'];","map":null,"metadata":{},"sourceType":"module"}