{"ast":null,"code":"/**\n* Custom events v3.0.10 (2020-12-21)\n*\n* (c) 2012-2020 Black Label\n*\n* License: Creative Commons Attribution (CC)\n*/\n\n/* global Highcharts setTimeout clearTimeout module:true */\n/* eslint no-loop-func: 0 */\n\n/**\n * @namespace customEvents\n **/\n\n(function (factory) {\n  if (typeof module === 'object' && module.exports) {\n    factory['default'] = factory;\n    module.exports = factory;\n  } else if (typeof define === 'function' && define.amd) {\n    define('highcharts-custom-events', ['highcharts'], function (Highcharts) {\n      factory(Highcharts);\n      factory.Highcharts = Highcharts;\n      return factory;\n    });\n  } else {\n    factory(Highcharts);\n  }\n})(function (HC) {\n  /* global Highcharts :true, window */\n\n  'use strict';\n\n  var UNDEFINED,\n    DBLCLICK = 'dblclick',\n    TOUCHSTART = 'touchstart',\n    CLICK = 'click',\n    pick = HC.pick,\n    wrap = HC.wrap,\n    merge = HC.merge,\n    addEvent = HC.addEvent,\n    isTouchDevice = HC.isTouchDevice,\n    defaultOptions = HC.getOptions().plotOptions,\n    axisProto = HC.Axis && HC.Axis.prototype,\n    plotLineOrBandProto = HC.PlotLineOrBand && HC.PlotLineOrBand.prototype,\n    seriesTypes = HC.seriesTypes,\n    seriesProto = HC.Series && HC.Series.prototype,\n    isObject,\n    isNumber,\n    isArray,\n    objectEach,\n    customEvents,\n    proto,\n    methods;\n\n  /*\n   * Back compatibility\n   */\n\n  isArray = HC.isArray || function (obj) {\n    var str = Object.prototype.toString.call(obj);\n    return str === '[object Array]' || str === '[object Array Iterator]';\n  };\n  objectEach = HC.objectEach || function (obj, fn, ctx) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        fn.call(ctx, obj[key], key, obj);\n      }\n    }\n  };\n  isNumber = HC.isNumber || function (n) {\n    return typeof n === 'number' && !isNaN(n);\n  };\n  isObject = HC.isObject || function (obj) {\n    return obj && typeof obj === 'object';\n  };\n\n  /**\n   * WRAPPED FUNCTIONS\n   */\n\n  // reset exis events\n  if (plotLineOrBandProto) {\n    // # condition for highmaps and custom builds\n    wrap(plotLineOrBandProto, 'render', function (proceed) {\n      var defaultEvents = this.options && this.options.events;\n\n      // reset default events on plot lines or bands\n      if (defaultEvents) {\n        defaultEvents = false;\n      }\n      return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n  }\n  if (seriesProto) {\n    // # condition for highmaps and custom builds\n    wrap(seriesProto, 'init', function (proceed, chart, options) {\n      var chartOptions = chart.options,\n        plotOptions = chartOptions.plotOptions,\n        seriesOptions = chartOptions.plotOptions.series,\n        userOptions = merge(seriesOptions, plotOptions[this.type], options),\n        userOptionsEvents = userOptions && userOptions.events,\n        userOptionsPointEvents = userOptions && userOptions.point && userOptions.point.events; // Fixed #70\n\n      // reset default events on series and series point\n      options.events = {};\n      options.point = {\n        events: {}\n      };\n\n      // Add support for legendItemClick\n      if (userOptionsEvents) {\n        options.events = {\n          legendItemClick: userOptionsEvents && userOptionsEvents.legendItemClick\n        };\n      }\n\n      // Add support for legendItemClick in pie chart\n      if (userOptionsPointEvents) {\n        options.point.events = {\n          legendItemClick: userOptionsPointEvents && userOptionsPointEvents.legendItemClick,\n          select: userOptionsPointEvents && userOptionsPointEvents.select,\n          unselect: userOptionsPointEvents && userOptionsPointEvents.unselect,\n          click: userOptionsPointEvents && userOptionsPointEvents.click,\n          mouseOut: userOptionsPointEvents && userOptionsPointEvents.mouseOut,\n          mouseOver: userOptionsPointEvents && userOptionsPointEvents.mouseOver\n        };\n      }\n\n      // attach events to custom object, which is used in attach event\n      options.customEvents = {\n        series: userOptionsEvents,\n        point: userOptionsPointEvents\n      };\n\n      // call default action\n      proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n  }\n  HC.Chart.prototype.customEvent = {\n    /**\n     * @description Example: [HC.Series, ['drawPoints', 'drawDataLabels']]\n     * @memberof customEvents\n     * @returns {Array} array of pairs: prototype, array of methods to wrap\n     **/\n    getEventsProtoMethods: function () {\n      var protoMethods = [[HC.Tick, ['addLabel']], [HC.Axis, ['render']], [HC.Axis, ['drawCrosshair']], [HC.Chart, ['setTitle']], [HC.Legend, ['renderItem']], [HC.PlotLineOrBand, ['render']], [HC.Series, ['drawPoints', 'drawDataLabels']]];\n\n      // support for extra series\n      objectEach(seriesTypes, function (fn, seriesType) {\n        protoMethods.push([seriesTypes[seriesType], ['drawPoints', 'drawDataLabels']]);\n      });\n      return protoMethods;\n    },\n    /**\n     * @description Init method, based on getEventsProtoMethods() array. Iterates on array of prototypes and methods to wrap\n     * @memberof customEvents\n     **/\n    init: function () {\n      var eventsProtoMethods = this.getEventsProtoMethods(); // array of pairs [object, [methods]]\n\n      eventsProtoMethods.forEach(function (protoMethod) {\n        if (isArray(protoMethod)) {\n          proto = protoMethod[0] && protoMethod[0].prototype;\n          methods = protoMethod[1];\n          if (proto) {\n            methods.forEach(function (method) {\n              customEvents.attach(proto, method);\n            });\n          }\n        }\n      });\n    },\n    /**\n     * @description Wraps methods i.e drawPoints to extract SVG element and set an event by calling customEvents.add()\n     * @param {Object} proto Highcharts prototype i.e Highcharts.Series.prototype\n     * @param {Object} hcMethod name of wrapped method i.e drawPoints\n     * @memberof customEvents\n     **/\n    attach: function (proto, hcMethod) {\n      wrap(proto, hcMethod, function (proceed, param) {\n        var eventElement = {\n            events: UNDEFINED,\n            element: UNDEFINED\n          },\n          proceedObject,\n          len,\n          j;\n\n        //  call default actions\n        proceedObject = proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n\n        //\tcall\n        eventElement = customEvents.eventElement[hcMethod].call(this, param);\n\n        //  stop, when events and SVG element do not exist\n        if (!eventElement.events && !eventElement.eventsSubtitle && !eventElement.eventsPoint) {\n          return proceedObject;\n        }\n        if (eventElement.eventsPoint) {\n          len = eventElement.elementPoint.length;\n\n          // attach events per each point\n          for (j = 0; j < len; j++) {\n            if (eventElement.elementPoint[j]) {\n              var elemPoint = pick(eventElement.elementPoint[j].graphic, eventElement.elementPoint[j]);\n              if (elemPoint && elemPoint !== UNDEFINED) {\n                customEvents.add(elemPoint, eventElement.eventsPoint, eventElement.elementPoint[j], eventElement, true);\n              }\n            }\n          }\n        }\n\n        // attach event to subtitle\n        if (eventElement.eventsSubtitle) {\n          customEvents.add(eventElement.elementSubtitle, eventElement.eventsSubtitle, eventElement, this);\n        }\n\n        // attach event to each datalabal and add reference to each point\n        if (eventElement.dataLabelsPoints) {\n          var dataLabelsPoints = eventElement.dataLabelsPoints;\n          len = dataLabelsPoints.length;\n          for (j = 0; j < len; j++) {\n            customEvents.add(dataLabelsPoints[j].dataLabel, eventElement.events, {\n              dataLabel: dataLabelsPoints[j].dataLabel,\n              point: dataLabelsPoints[j]\n            }, this);\n          }\n        }\n\n        // attach event to stackLabels\n        if (eventElement.eventsStackLabel) {\n          customEvents.add(eventElement.elementStackLabel, eventElement.eventsStackLabel, eventElement, this);\n        }\n        customEvents.add(eventElement.element, eventElement.events, eventElement, this);\n        return proceedObject;\n      });\n    },\n    /**\n     * @description adds event on a SVG element\n     * @param {Object} SVGelem graphic element\n     * @param {Object} events object with all events\n     * @param {Object} elemObj \"this\" object, which is available in the event\n     * @param {Object} series chart series\n     * @memberof customEvents\n     **/\n    add: function (SVGelem, events, elemObj, eventElement, isPoint) {\n      var eventObject = eventElement.eventObject || elemObj.eventObject,\n        //\tFix series reference #89\n        isSeries = elemObj.isSeries || eventElement.isSeries;\n\n      // stop when SVG element does not exist\n      if (!SVGelem || !SVGelem.element) {\n        return false;\n      }\n      for (var action in events) {\n        (function (event) {\n          if (events.hasOwnProperty(event) && !SVGelem[event]) {\n            if (isTouchDevice && event === DBLCLICK) {\n              //  #30 - fallback for iPad\n\n              var tapped = false;\n              addEvent(SVGelem.element, TOUCHSTART, function (e) {\n                e.preventDefault();\n                if (isSeries) {\n                  // #93\n                  var chart = eventObject.chart,\n                    normalizedEvent = chart.pointer.normalize(e);\n                  if (!eventObject.directTouch) {\n                    elemObj = eventObject.searchPoint(normalizedEvent, eventObject.kdDimensions === 1);\n                  }\n                  e.point = elemObj; //\t#89 point reference in mouse event\n                }\n\n                if (eventObject && !isPoint || eventObject && isNumber(eventObject.value)) {\n                  // #95 \n                  eventObject.value = elemObj.textStr;\n                  elemObj = eventObject;\n                }\n                if (elemObj && elemObj.textStr) {\n                  // labels\n                  elemObj.value = elemObj.textStr;\n                }\n                if (elemObj && elemObj.drilldown) {\n                  // #114 - drillUp - undefined ddDupes []\n                  elemObj.doDrilldown(undefined, undefined, e);\n                }\n                if (!tapped) {\n                  tapped = setTimeout(function () {\n                    tapped = null;\n                    if (events[CLICK] && elemObj && elemObj.drilldown === undefined) {\n                      events[CLICK].call(elemObj, e); //\tcall single click action\n                    }\n                  }, 300);\n                } else {\n                  clearTimeout(tapped);\n                  tapped = null;\n                  if (elemObj && elemObj.drilldown === undefined) {\n                    events[event].call(elemObj, e);\n                  }\n                }\n                return false;\n              });\n            } else {\n              addEvent(SVGelem.element, event, function (e) {\n                e.stopPropagation();\n                if (isSeries) {\n                  // #108, #93 - references in e.point and this after chart.update()\n                  var chart = eventObject.chart,\n                    normalizedEvent = chart.pointer.normalize(e);\n                  if (!eventObject.directTouch) {\n                    elemObj = eventObject.searchPoint(normalizedEvent, eventObject.kdDimensions === 1);\n                  }\n                  e.point = elemObj; //\t#89 point reference in mouse event\n                }\n\n                if (eventObject && !isPoint || eventObject && isNumber(eventObject.value)) {\n                  // #95 wrong reference for axis labels\n                  eventObject.value = elemObj.textStr || eventObject.value; // #95, #98 wrong reference for axis labels\n                  elemObj = eventObject;\n                }\n                if (elemObj && elemObj.textStr) {\n                  // labels\n                  elemObj.value = elemObj.textStr;\n                }\n                if (isPoint && event === 'click' && elemObj.series && elemObj.series.options && elemObj.series.options.allowPointSelect) {\n                  var defaultFunction = function (event) {\n                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift\n                    // for Opera.\n                    if (elemObj.select) {\n                      // #2911\n                      elemObj.select(null, e.ctrlKey || e.metaKey || e.shiftKey);\n                    }\n                  };\n                  HC.fireEvent(elemObj, event, e, defaultFunction);\n                }\n                if (elemObj && elemObj.drilldown) {\n                  // #114 - drillUp - undefined ddDupes []\n                  elemObj.doDrilldown(undefined, undefined, e);\n                } else if (events && events[event]) {\n                  events[event].call(elemObj, e);\n                }\n                return false;\n              });\n            }\n            SVGelem[event] = function () {\n              return true;\n            };\n          }\n        })(action);\n      }\n    },\n    eventElement: {\n      /**\n      * @typedef {Object} eventElement\n      **/\n      /**\n       * @description Extracts SVG elements from points\n       * @property {Object} eventsPoint events for point\n       * @property {Array} elementPoint array of SVG point elements\n       * @property {Object} eventObject object kept in this on i.e click\n       * @return {Object} { events: object, element: object }\n       * @memberof customEvents\n       **/\n      addLabel: function () {\n        var parent = this.parent,\n          axis = this.axis,\n          axisOptions = axis.options,\n          eventsPoint = axisOptions.labels && axisOptions.labels.events,\n          elementPoint = [this.label],\n          len,\n          i;\n        if (parent) {\n          var step = this; // current label\n\n          while (step) {\n            if (isArray(step)) {\n              len = step.length;\n              for (i = 0; i < len; i++) {\n                elementPoint.push(step[i].label);\n              }\n            } else {\n              elementPoint.push(step.label);\n            }\n            step = step.parent;\n          }\n        }\n        return {\n          eventsPoint: eventsPoint,\n          elementPoint: elementPoint,\n          eventObject: {\n            axis: axis,\n            isFirst: this.isFirst,\n            isLast: this.isLast,\n            chart: axis.chart,\n            dateTimeLabelFormat: axisOptions.dateTimeLabelFormats,\n            value: this.pos,\n            pos: this.pos\n          }\n        };\n      },\n      /**\n       * @description Extracts SVG elements from title and subtitle\n       * @property {Object} events events for title\n       * @property {Array} elementPoint title SVG element\n       * @property {Object} eventsSubtitle events for subtitle\n       * @property {Array} elementSubtitle subtitle SVG element\n       * @return {Object} {event: object, element: object, eventsSubtitle: object, elementSubtitle: object }\n       * @memberof customEvents\n       **/\n      setTitle: function () {\n        var events = this.options.title && this.options.title.events,\n          element = this.title,\n          eventsSubtitle = this.options.subtitle && this.options.subtitle.events,\n          elementSubtitle = this.subtitle;\n        return {\n          events: events,\n          element: element,\n          eventsSubtitle: eventsSubtitle,\n          elementSubtitle: elementSubtitle\n        };\n      },\n      /**\n       * @description Extracts SVG elements from dataLabels\n       * @property {Object} events events for dataLabels\n       * @property {Array} element dataLabels SVG element\n       * @return {Object} { events: object, element: object }\n       * @memberof customEvents\n       **/\n      drawDataLabels: function () {\n        var dataLabelsGroup = this.dataLabelsGroup,\n          dataLabelEvents = dataLabelsGroup && this.options.dataLabels.events;\n        return {\n          events: dataLabelEvents,\n          element: dataLabelsGroup,\n          dataLabelsPoints: this.points\n        };\n      },\n      /**\n       * @description Extracts SVG elements from axis title and stackLabels\n       * @property {Object} events events for axis title\n       * @property {Array} element axis title SVG element\n       * @property {Object} eventsPoint events for stacklabels\n       * @property {Array} elementPoint stacklabels SVG element\n       * @property {Object} eventsStackLabel events for stacklabels\n       * @property {Array} elementStackLabel stacklabels group SVG element\n       * @return {Object} { events: object, element: object, eventsPoint: object, elementPoint: object, eventsStackLabel: object, elementStackLabel: object }\n       * @memberof customEvents\n       **/\n      render: function () {\n        var stackLabels = this.options.stackLabels,\n          events,\n          element,\n          eventsPoint,\n          elementPoint,\n          eventsStackLabel,\n          elementStackLabel;\n        if (this.axisTitle) {\n          events = this.options.title.events;\n          element = this.axisTitle;\n        }\n        if (stackLabels && stackLabels.enabled) {\n          eventsPoint = stackLabels.events;\n          elementPoint = this.stacks || this.stacking.stacks;\n          eventsStackLabel = stackLabels.events;\n          elementStackLabel = this.stackTotalGroup || this.stacking.stackTotalGroup;\n        }\n        return {\n          events: events,\n          element: element,\n          eventsPoint: eventsPoint,\n          elementPoint: elementPoint,\n          eventsStackLabel: eventsStackLabel,\n          elementStackLabel: elementStackLabel\n        };\n      },\n      /**\n       * @description Extracts SVG elements from series and series points\n       * @property {Object} events events for series\n       * @property {Array} element series SVG element\n       * @property {Object} events events for series points\n       * @property {Array} element series points SVG element\n       * @return {Object} { events: object, element: object, eventsPoint: object, elementPoint: object }\n       * @memberof customEvents\n       **/\n      drawPoints: function () {\n        var op = this.options,\n          type = this.type,\n          events = op.customEvents ? op.customEvents.series : op.events,\n          element = this.group,\n          eventsPoint = op.customEvents ? op.customEvents.point : op.point.events,\n          elementPoint;\n        if (defaultOptions[type] && defaultOptions[type].marker && !this.bubblePadding) {\n          elementPoint = [this.markerGroup]; //\tget markers when enabled\n        } else {\n          elementPoint = this.points; //\textract points\n        }\n\n        if (!this.kdTree && !this.buildingKdTree) {\n          this.buildKDTree(); //\t#86, missing reference to point on first mouseover\n        }\n\n        return {\n          events: events,\n          element: element,\n          eventsPoint: eventsPoint,\n          elementPoint: elementPoint,\n          eventObject: this,\n          isSeries: true\n        };\n      },\n      /**\n       * @description Extracts SVG elements from legend item\n       * @property {Object} events events for legend item\n       * @property {Array} element legend item SVG element\n       * @return {Object} { events: object, element: object }\n       * @memberof customEvents\n       **/\n      renderItem: function (item) {\n        return {\n          events: this.options.itemEvents,\n          element: item.legendGroup,\n          eventObject: item\n        };\n      },\n      /**\n       * @description Extracts SVG elements from crosshair\n       * @property {Object} events events for crosshair\n       * @property {Array} element crosshair SVG element\n       * @return {Object} { events: object, element: object }\n       * @memberof customEvents\n       **/\n      drawCrosshair: function () {\n        var cross = this.cross,\n          crosshairOptions = this.options.crosshair;\n        if (cross) {\n          cross.css({\n            'pointer-events': 'auto'\n          });\n        }\n        return {\n          events: crosshairOptions && crosshairOptions.events,\n          element: cross\n        };\n      }\n    }\n  };\n  customEvents = HC.Chart.prototype.customEvent;\n  customEvents.init();\n});","map":null,"metadata":{},"sourceType":"script"}