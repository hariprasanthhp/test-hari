{"ast":null,"code":"import { mid, setSnapped } from 'diagram-js/lib/features/snapping/SnapUtil';\nimport { isCmd } from 'diagram-js/lib/features/keyboard/KeyboardUtil';\nimport { getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { is } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { some } from 'min-dash';\nvar HIGHER_PRIORITY = 1250;\nvar BOUNDARY_TO_HOST_THRESHOLD = 40;\nvar TARGET_BOUNDS_PADDING = 20,\n  TASK_BOUNDS_PADDING = 10;\nvar TARGET_CENTER_PADDING = 20;\nvar AXES = ['x', 'y'];\nvar abs = Math.abs;\n\n/**\r\n * Snap during connect.\r\n *\r\n * @param {EventBus} eventBus\r\n */\nexport default function BpmnConnectSnapping(eventBus) {\n  eventBus.on(['connect.hover', 'connect.move', 'connect.end'], HIGHER_PRIORITY, function (event) {\n    var context = event.context,\n      canExecute = context.canExecute,\n      start = context.start,\n      hover = context.hover,\n      source = context.source,\n      target = context.target;\n\n    // do NOT snap on CMD\n    if (event.originalEvent && isCmd(event.originalEvent)) {\n      return;\n    }\n    if (!context.initialConnectionStart) {\n      context.initialConnectionStart = context.connectionStart;\n    }\n\n    // snap hover\n    if (canExecute && hover) {\n      snapToShape(event, hover, getTargetBoundsPadding(hover));\n    }\n    if (hover && isAnyType(canExecute, ['bpmn:Association', 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation', 'bpmn:SequenceFlow'])) {\n      context.connectionStart = mid(start);\n\n      // snap hover\n      if (isAny(hover, ['bpmn:Event', 'bpmn:Gateway'])) {\n        snapToPosition(event, mid(hover));\n      }\n\n      // snap hover\n      if (isAny(hover, ['bpmn:Task', 'bpmn:SubProcess'])) {\n        snapToTargetMid(event, hover);\n      }\n\n      // snap source and target\n      if (is(source, 'bpmn:BoundaryEvent') && target === source.host) {\n        snapBoundaryEventLoop(event);\n      }\n    } else if (isType(canExecute, 'bpmn:MessageFlow')) {\n      if (is(start, 'bpmn:Event')) {\n        // snap start\n        context.connectionStart = mid(start);\n      }\n      if (is(hover, 'bpmn:Event')) {\n        // snap hover\n        snapToPosition(event, mid(hover));\n      }\n    } else {\n      // un-snap source\n      context.connectionStart = context.initialConnectionStart;\n    }\n  });\n}\nBpmnConnectSnapping.$inject = ['eventBus'];\n\n// helpers //////////\n\n// snap to target if event in target\nfunction snapToShape(event, target, padding) {\n  AXES.forEach(function (axis) {\n    var dimensionForAxis = getDimensionForAxis(axis, target);\n    if (event[axis] < target[axis] + padding) {\n      setSnapped(event, axis, target[axis] + padding);\n    } else if (event[axis] > target[axis] + dimensionForAxis - padding) {\n      setSnapped(event, axis, target[axis] + dimensionForAxis - padding);\n    }\n  });\n}\n\n// snap to target mid if event in target mid\nfunction snapToTargetMid(event, target) {\n  var targetMid = mid(target);\n  AXES.forEach(function (axis) {\n    if (isMid(event, target, axis)) {\n      setSnapped(event, axis, targetMid[axis]);\n    }\n  });\n}\n\n// snap to prevent loop overlapping boundary event\nfunction snapBoundaryEventLoop(event) {\n  var context = event.context,\n    source = context.source,\n    target = context.target;\n  if (isReverse(context)) {\n    return;\n  }\n  var sourceMid = mid(source),\n    orientation = getOrientation(sourceMid, target, -10),\n    axes = [];\n  if (/top|bottom/.test(orientation)) {\n    axes.push('x');\n  }\n  if (/left|right/.test(orientation)) {\n    axes.push('y');\n  }\n  axes.forEach(function (axis) {\n    var coordinate = event[axis],\n      newCoordinate;\n    if (abs(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD) {\n      if (coordinate > sourceMid[axis]) {\n        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD;\n      } else {\n        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD;\n      }\n      setSnapped(event, axis, newCoordinate);\n    }\n  });\n}\nfunction snapToPosition(event, position) {\n  setSnapped(event, 'x', position.x);\n  setSnapped(event, 'y', position.y);\n}\nfunction isType(attrs, type) {\n  return attrs && attrs.type === type;\n}\nfunction isAnyType(attrs, types) {\n  return some(types, function (type) {\n    return isType(attrs, type);\n  });\n}\nfunction getDimensionForAxis(axis, element) {\n  return axis === 'x' ? element.width : element.height;\n}\nfunction getTargetBoundsPadding(target) {\n  if (is(target, 'bpmn:Task')) {\n    return TASK_BOUNDS_PADDING;\n  } else {\n    return TARGET_BOUNDS_PADDING;\n  }\n}\nfunction isMid(event, target, axis) {\n  return event[axis] > target[axis] + TARGET_CENTER_PADDING && event[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;\n}\nfunction isReverse(context) {\n  var hover = context.hover,\n    source = context.source;\n  return hover && source && hover === source;\n}","map":null,"metadata":{},"sourceType":"module"}