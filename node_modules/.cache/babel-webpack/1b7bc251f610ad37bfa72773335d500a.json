{"ast":null,"code":"import * as Highcharts from 'highcharts/highstock';\nimport more from 'highcharts/highcharts-more';\nimport StreamgraphModule from 'highcharts/modules/streamgraph';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../../app-services/translate.service\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"../../../shared/services/convertor.service\";\nimport * as i4 from \"src/app/shared-utils/date-utils.service\";\nimport * as i5 from \"src/app/shared/services/sso-auth.service\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"highcharts-angular\";\nfunction StreamPathChartComponent_div_0_span_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 16);\n    i0.ɵɵelement(1, \"i\", 17);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.upRate, \" \");\n  }\n}\nfunction StreamPathChartComponent_div_0_span_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵelement(1, \"i\", 19);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.downRate, \"\");\n  }\n}\nfunction StreamPathChartComponent_div_0_highcharts_chart_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"highcharts-chart\", 20);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"Highcharts\", ctx_r3.highcharts)(\"options\", ctx_r3.streamOptions)(\"callbackFunction\", ctx_r3.chartCallback);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"background-color\": a0\n  };\n};\nfunction StreamPathChartComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵelementStart(1, \"div\", 2);\n    i0.ɵɵelementStart(2, \"div\", 3);\n    i0.ɵɵelementStart(3, \"div\", 4);\n    i0.ɵɵelementStart(4, \"span\", 5);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"a\", 6);\n    i0.ɵɵlistener(\"click\", function StreamPathChartComponent_div_0_Template_a_click_6_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.toggleUpStream();\n    });\n    i0.ɵɵelement(7, \"span\", 7);\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"a\", 8);\n    i0.ɵɵlistener(\"click\", function StreamPathChartComponent_div_0_Template_a_click_9_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.toggleDownStream();\n    });\n    i0.ɵɵelement(10, \"span\", 7);\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(12, \"span\", 9);\n    i0.ɵɵtext(13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"div\", 10);\n    i0.ɵɵelementStart(15, \"span\", 11);\n    i0.ɵɵtemplate(16, StreamPathChartComponent_div_0_span_16_Template, 3, 1, \"span\", 12);\n    i0.ɵɵtemplate(17, StreamPathChartComponent_div_0_span_17_Template, 3, 1, \"span\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(18, \"div\", 14);\n    i0.ɵɵtemplate(19, StreamPathChartComponent_div_0_highcharts_chart_19_Template, 1, 3, \"highcharts-chart\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵpropertyInterpolate(\"title\", ctx_r0.chartName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.chartName, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(10, _c0, ctx_r0.isUpStreamVisible === true ? \"#0027FF\" : \"grey\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.language.up, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(12, _c0, ctx_r0.isDownStreamVisible === true ? \"#00d0ff\" : \"grey\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.language.down, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r0.language.interval, \" 1 sec\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isUpStreamVisible);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isDownStreamVisible);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.load);\n  }\n}\nmore(Highcharts);\nStreamgraphModule(Highcharts);\nexport let StreamPathChartComponent = /*#__PURE__*/(() => {\n  class StreamPathChartComponent {\n    constructor(customTranslateService, http, convertorService, dateUtilsService, sso) {\n      this.customTranslateService = customTranslateService;\n      this.http = http;\n      this.convertorService = convertorService;\n      this.dateUtilsService = dateUtilsService;\n      this.sso = sso;\n      this.load = true;\n      this.title = 'myHighchart';\n      this.highcharts = Highcharts;\n      this.yAxixTitle = '';\n      this.pageAvailable = false;\n      this.windowLen = 5;\n      this.lastData = [0, 0];\n      this.chartData = [0, 0];\n      this.lastChartDataObj = {};\n      this.triggerReloadChart = false;\n      this.msgLen = 0;\n      this.inc = 0;\n      this.isDownStreamVisible = true;\n      this.isUpStreamVisible = true;\n      this.conversions = {\n        'bps': 1,\n        'Kbps': 1000,\n        'Mbps': 1000000,\n        'Gbps': 1000000000,\n        'Tbps': 1000000000000,\n        'pps': 1,\n        'Kpps': 1000,\n        'Mpps': 1000000,\n        'Gpps': 1000000000,\n        'Tpps': 1000000000000\n      };\n      this.reloadChart = false;\n      this.sizes = {\n        'bps': 1,\n        'Kbps': 1000,\n        'Mbps': 1000000,\n        'Gbps': 1000000000,\n        'Tbps': 1000000000000,\n        'pps': 1,\n        'Kpps': 1000,\n        'Mpps': 1000000,\n        'Gpps': 1000000000,\n        'Tpps': 1000000000000\n      };\n    }\n    ngOnInit() {\n      this.language = this.customTranslateService.defualtLanguage;\n      if (this.language) {\n        this.pageAvailable = true;\n      }\n      this.customTranslateService.selectedLanguage.subscribe(data => {\n        this.language = data;\n      });\n    }\n    ngOnChanges(changes) {\n      ////console.log(changes.windowLen);\n      let v1, v2;\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (changes.data && changes.data.currentValue && this.data) {\n        this.msgLen++;\n        this.originalData = changes.data.currentValue;\n        let upRate = this.bitsToSize(this.data[0]);\n        let downRate = this.bitsToSize(this.data[1]);\n        console.log(this.data);\n        if (this.chartName.toLowerCase() === 'rate') {\n          console.log('Up Rate - ', upRate);\n          console.log('Down Rate - ', downRate);\n        } else {\n          console.log('Up Packet Rate - ', upRate);\n          console.log('Down Packer Rate - ', downRate);\n        }\n        // if (this.currentData) {\n        //   this.lastData = this.currentData;\n        // } else {\n        //   this.chartData = [0, 0];\n        // }\n        if (this.currentData) {\n          this.lastData = this.currentData;\n          this.chartData = this.currentData;\n        } else {\n          this.lastData = [0, 0];\n          this.chartData = [0, 0];\n        }\n        this.currentData = this.data;\n      }\n      if (changes.windowLen && changes.windowLen.currentValue && this.data) {\n        //console.log(this.lastChartDataObj);\n        // let keys = Object.keys(this.lastChartDataObj);\n        // let length = keys.length;\n        // if (length) {\n        //   for (let i = 0; i < length; i++) {\n        //     if (!this.lastChartDataObj[keys[i]]) {\n        //       continue;\n        //     }\n        //     let indexV1 = sizes.indexOf(this.lastChartDataObj[keys[i]][2]);\n        //     let indexV2 = sizes.indexOf(this.yAxixTitle);\n        //     if (indexV1 > indexV2) {\n        //       let diff = indexV1 - indexV2;\n        //       for (let j = diff; j > 0; j--) {\n        //         this.lastChartDataObj[keys[i]][0] = this.lastChartDataObj[keys[i]][0] * 1000;\n        //         this.lastChartDataObj[keys[i]][1] = this.lastChartDataObj[keys[i]][1] * 1000;\n        //         this.lastChartDataObj[keys[i]][2] = this.yAxixTitle;\n        //       }\n        //     } else if (indexV2 > indexV1) {\n        //       let diff = indexV2 - indexV1;\n        //       for (let j = diff; j > 0; j--) {\n        //         this.lastChartDataObj[keys[i]][0] = this.lastChartDataObj[keys[i]][0] / 1000;\n        //         this.lastChartDataObj[keys[i]][1] = this.lastChartDataObj[keys[i]][1] / 1000;\n        //         this.lastChartDataObj[keys[i]][2] = this.yAxixTitle;\n        //       }\n        //     }\n        //   }\n        // }\n        this.time = this.dateUtilsService.getCurrentUtcTime() * 1000;\n        this.triggerReloadChart = false;\n        this.load = true;\n        this.yAxixTitle = this.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n        this.lastChartDataObj = this.history ? this.history : {};\n        if (Object.keys(this.lastChartDataObj).length) {\n          this.lastData = this.data;\n          this.chartData = this.data;\n          this.rebuildData();\n        } else {\n          console.log('intial call for load chart');\n          this.buildNewChart();\n        }\n        //console.log('history', this.history);\n      }\n    }\n\n    buildChart() {\n      console.log('chart reloaded');\n      this.time = this.dateUtilsService.getCurrentUtcTime() * 1000;\n      this.streamOptions = {};\n      let timezoneDetected = this.timezoneDetected();\n      let loadTime = this.time + timezoneDetected;\n      let windowLen = 5 * -60;\n      var chartxaxis = {\n        type: 'datetime',\n        tickPixelInterval: 150\n      };\n      var charcredits = {\n        enabled: false\n      };\n      var chartyaxis = {\n        gridLineDashStyle: 'longdash',\n        opposite: false,\n        startOnTick: false,\n        endOnTick: false,\n        title: {\n          text: this.yAxixTitle,\n          style: {\n            fontWeight: 'bold',\n            textAlign: 'left'\n          }\n        },\n        labels: {\n          align: 'left',\n          x: 0,\n          y: 0,\n          formatter: function () {\n            return Math.abs(this.value);\n          }\n        }\n      };\n      let that = this;\n      this.streamOptions = {\n        time: {\n          useUTC: false\n        },\n        chart: {\n          backgroundColor: \"#FFFFFF\",\n          type: 'areaspline',\n          zoomType: 'x',\n          height: 220,\n          margin: {},\n          animation: false,\n          renderTo: 'custom-mirrot-chart',\n          events: {\n            load: function () {\n              let sizes = that.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n              var series = this.series;\n              that.interval = setInterval(function () {\n                that.inc++;\n                let data = that.transformData(that.currentData, that.lastData, that.chartData);\n                that.chartData = data;\n                if (!data[0]) {\n                  data[0] = 0;\n                }\n                if (!data[1]) {\n                  data[1] = 0;\n                }\n                let upRate = that.bitsToSize(data[0]);\n                let downRate = that.bitsToSize(data[1]);\n                let vArr1 = upRate.split(\" \");\n                let vArr2 = downRate.split(\" \");\n                let upRateValue = vArr1[0];\n                let downRateValue = vArr2[0];\n                let upRateUnit = vArr1[1] ? vArr1[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let downRateUnit = vArr2[1] ? vArr2[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let maxUnit = '';\n                if (data[0] || data[1]) {\n                  if (data[0] > data[1]) {\n                    maxUnit = vArr1[1];\n                  } else {\n                    maxUnit = vArr2[1];\n                  }\n                } else {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit == 'undefined') {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit != undefined && that.yAxixTitle != maxUnit && (data[0] || data[1])) {\n                  console.log(`scale changed from ${that.yAxixTitle} to ${maxUnit}`);\n                  //console.log(data);\n                  that.yAxixTitle = maxUnit;\n                  that.streamOptions.yAxis.title.text = that.yAxixTitle;\n                  var time = loadTime + that.inc * 1000;\n                  let key = that.removeLast3Chars(time);\n                  //that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.rebuildData();\n                  return;\n                }\n                if (typeof maxUnit === 'string') {\n                  that.yAxixTitle = maxUnit;\n                }\n                let v1 = parseFloat(vArr1[0]);\n                let v2 = parseFloat(vArr2[0]);\n                if ((data[0] || data[1]) && data[0] < data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV2 - indexV1;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v1 = v1 / 1000;\n                    }\n                  }\n                  //console.log(\"after manu v1\", v1);\n                  //v1 = v1 / 1000;\n                }\n\n                if ((data[0] || data[1]) && data[0] > data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV1 - indexV2;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v2 = v2 / 1000;\n                    }\n                  }\n                  //console.log(\"originafter manu v2\", v2);\n                }\n\n                if (data) {\n                  var time = loadTime + that.inc * 1000;\n                  let num = parseFloat(Highcharts.numberFormat(Math.abs(v1), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.upRate = `${upRateValue} ${upRateUnit}`;\n                  num = parseFloat(Highcharts.numberFormat(Math.abs(v2), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.downRate = `${downRateValue} ${downRateUnit}`;\n                  var x = time,\n                    y = v1;\n                  series[0].addPoint([x, y], true, true);\n                  var sx = time,\n                    sy = -v2;\n                  series[1].addPoint([sx, sy], true, true);\n                  let key = that.removeLast3Chars(time);\n                  that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.removeOldKeys();\n                }\n              }, 1000);\n            }\n          }\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        title: {\n          text: ''\n        },\n        //subtitle: chartsubtitle,\n        xAxis: chartxaxis,\n        yAxis: chartyaxis,\n        credits: charcredits,\n        plotOptions: {\n          areaspline: {\n            lineWidth: 1,\n            marker: {\n              enabled: false\n            },\n            fillOpacity: 0.75\n          },\n          spline: {\n            animation: false,\n            marker: {\n              enabled: false,\n              radius: 0.9,\n              lineWidth: 0.7\n            }\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            //console.log(this.point);\n            let dateValue = this.point.x - timezoneDetected;\n            var d = new Date(dateValue);\n            var months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n            let num = parseFloat(Highcharts.numberFormat(Math.abs(this.point.y), 2));\n            let datakey = that.removeLast3Chars(this.point.x);\n            // console.log(that.lastChartDataObj);\n            // console.log(this.point.x);\n            //console.log(that.lastChartDataObj[datakey]);\n            let unit = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][2] : '';\n            let sizes = that.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n            if (num < 1) {\n              //num *= 1000;\n              let index = sizes.indexOf(that.yAxixTitle);\n              if (index >= 1) {\n                index = index - 1;\n              }\n              if (index === -1) {\n                index = 0;\n              }\n              let rate = that.yAxixTitle;\n              if (this.point.y < 0) {\n                let indexV1 = sizes.indexOf(that.yAxixTitle);\n                rate = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][4] : that.yAxixTitle;\n                let indexV2 = sizes.indexOf(rate);\n                let diff = indexV1 - indexV2;\n                if (diff) {\n                  for (let i = diff; i > 0; i--) {\n                    num = num * 1000;\n                  }\n                }\n              } else {\n                let indexV1 = sizes.indexOf(that.yAxixTitle);\n                rate = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][3] : that.yAxixTitle;\n                let indexV2 = sizes.indexOf(rate);\n                let diff = indexV1 - indexV2;\n                if (diff) {\n                  for (let i = diff; i > 0; i--) {\n                    num = num * 1000;\n                  }\n                }\n              }\n              return `<b> ${d.getDate()}-${months[d.getMonth()]} ${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}  </b><br/>\n                 ${this.series.name}stream: ${num} ${rate}`;\n            } else {\n              let rate = that.yAxixTitle;\n              if (this.point.y < 0 && Math.abs(this.point.y) > 1000) {\n                let indexV1 = sizes.indexOf(that.yAxixTitle);\n                rate = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][4] : that.yAxixTitle;\n                let indexV2 = sizes.indexOf(rate);\n                let diff = indexV2 - indexV1;\n                if (diff) {\n                  for (let i = diff; i > 0; i--) {\n                    num = num / 1000;\n                  }\n                  this.point.y = num;\n                }\n              } else if (this.point.y > 0 && Math.abs(this.point.y) > 1000) {\n                let indexV1 = sizes.indexOf(that.yAxixTitle);\n                rate = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][3] : that.yAxixTitle;\n                let indexV2 = sizes.indexOf(rate);\n                let diff = indexV2 - indexV1;\n                if (diff) {\n                  for (let i = diff; i > 0; i--) {\n                    num = num / 1000;\n                  }\n                  this.point.y = num;\n                }\n              }\n              return `<b> ${d.getDate()}-${months[d.getMonth()]} ${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}  </b><br/>\n                 ${this.series.name}stream: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${unit ? unit : that.yAxixTitle}`;\n            }\n          }\n        },\n        legend: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        series: [{\n          name: 'Up',\n          data: function () {\n            var data = [],\n              time = loadTime,\n              i;\n            for (i = -300; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][0] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][0] : 0;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            return data;\n          }()\n        }, {\n          name: 'Down',\n          data: function () {\n            // generate an array of random data\n            var data = [],\n              time = loadTime,\n              i;\n            for (i = -300; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              let value = that.lastChartDataObj[key] ? that.lastChartDataObj[key][1] : 0;\n              if (that.reloadChart && !value) {\n                value = that.lastChartDataObj[key - 1] ? that.lastChartDataObj[key - 1][0] : 0;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              value = value * -1;\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            ////console.log(data);\n            return data;\n          }()\n        }]\n      };\n    }\n    chartCallback(chart) {}\n    toggleDownStream() {\n      if (this.streamOptions.series[1].visible) {\n        this.streamOptions.series[1].visible = false;\n        this.isDownStreamVisible = false;\n      } else {\n        this.streamOptions.series[1].visible = true;\n        this.isDownStreamVisible = true;\n      }\n      //this.streamOptions = Object.assign({}, this.streamOptions);\n      this.rebuildData();\n    }\n    toggleUpStream() {\n      if (this.streamOptions.series[0].visible) {\n        this.streamOptions.series[0].visible = false;\n        this.isUpStreamVisible = false;\n      } else {\n        this.streamOptions.series[0].visible = true;\n        this.isUpStreamVisible = true;\n      }\n      this.rebuildData();\n      //this.streamOptions = Object.assign({}, this.streamOptions);\n    }\n\n    ngOnDestroy() {\n      this.streamOptions = {};\n      clearInterval(this.interval);\n      clearInterval(this.interval2);\n      this.interval = null;\n      this.interval2 = null;\n    }\n    // transformData(currentData: any, lastData: any, data: any): any {\n    //   if (this.chartName.toLowerCase() === 'rate') {\n    //     // console.log(\"current api value\", currentData);\n    //     // console.log(\"last api value\", lastData);\n    //     // console.log(\"last chart value\", data);\n    //   }\n    //   if (typeof lastData[0] == 'undefined' || isNaN(lastData[0])) {\n    //     lastData[0] = 0;\n    //   }\n    //   if (typeof lastData[1] == 'undefined' || isNaN(lastData[1])) {\n    //     lastData[1] = 0;\n    //   }\n    //   let chartData = [];\n    //   for (let i = 0; i < currentData.length; i++) {\n    //     let delta = parseFloat(currentData[i]) - parseFloat(lastData[i]);\n    //     //delta = Math.abs(delta);\n    //     if (!parseFloat(currentData[i]) && !parseFloat(lastData[i])) {\n    //       data[i] = 0;\n    //     }\n    //     let deltaRate = delta / 15;\n    //     let value = Math.abs(parseFloat(data[i]) + deltaRate);\n    //     chartData.push(value);\n    //   }\n    //   return chartData;\n    // }\n    transformData(currentData, lastData, data) {\n      if (this.chartName.toLowerCase() === 'rate') {\n        // console.log(\"last chart value\", data);\n      }\n      if (!lastData || !lastData.length) {\n        lastData = [0, 0];\n      }\n      let chartData = [];\n      for (let i = 0; i < currentData.length; i++) {\n        let delta = parseFloat(currentData[i]) - parseFloat(lastData[i]);\n        if (!parseFloat(currentData[i]) && !parseFloat(lastData[i])) {\n          data[i] = 0;\n        }\n        let deltaRate = delta / 15;\n        let value = parseFloat(data[i]) + deltaRate;\n        chartData.push(value);\n      }\n      if (!chartData[0] && !chartData[1] && (currentData[0] || currentData[1]) && this.msgLen > 2) {\n        chartData = currentData;\n      }\n      return chartData;\n    }\n    bitsToSize(bits) {\n      let bytes = parseFloat(bits);\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && this.chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && this.chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1000));\n      //return Math.round(bytes / Math.pow(1024, i)) + ' ' + sizes[i];\n      return Highcharts.numberFormat(Math.abs(bytes / Math.pow(1000, i)), 2) + ' ' + sizes[i];\n    }\n    removeLast3Chars(str) {\n      str = str.toString();\n      str = str.slice(0, -3);\n      str = parseInt(str);\n      return str;\n    }\n    removeOldKeys() {\n      let keys = Object.keys(this.lastChartDataObj);\n      let len = keys.length;\n      if (len > 300) {\n        let obj = this.lastChartDataObj;\n        let removeLen = len - 300;\n        for (let i = 0; i < removeLen; i++) {\n          delete obj[keys[i]];\n        }\n        this.lastChartDataObj = obj;\n        console.log(\"removal of old chart length\", Object.keys(this.lastChartDataObj).length);\n      }\n    }\n    getPacketRate(bits) {\n      //console.log(bits);\n      //let bytes: any = bits / 15;\n      let bytes = bits;\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      if (bytes == 0 && this.chartName.toLowerCase() === 'rate') return '0 bps';\n      if (bytes == 0 && this.chartName.toLowerCase() === 'packet') return '0 pps';\n      var i = Math.floor(Math.log(bytes) / Math.log(1024));\n      return Math.round(bytes / Math.pow(1000, i)) + ' ' + sizes[i];\n    }\n    timezoneDetected() {\n      var dtDate = new Date('1/1/' + new Date().getUTCFullYear());\n      var intOffset = 10000;\n      var intMonth;\n      for (intMonth = 0; intMonth < 12; intMonth++) {\n        dtDate.setUTCMonth(dtDate.getUTCMonth() + 1);\n        if (intOffset > dtDate.getTimezoneOffset() * -1) {\n          intOffset = dtDate.getTimezoneOffset() * -1;\n        }\n      }\n      return intOffset * 60 * 1000;\n    }\n    rebuildData() {\n      let sizes = this.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n      let keys = Object.keys(this.lastChartDataObj);\n      let length = keys.length;\n      if (length) {\n        let time = new Date().getTime() + parseInt(this.sso.getRealtimeDelay()),\n          i;\n        for (i = -299; i <= 0; i += 1) {\n          let timeKey = time + i * 1000;\n          let key = this.removeLast3Chars(timeKey);\n          if (typeof this.lastChartDataObj[key] == 'undefined' && typeof this.lastChartDataObj[key - 1] !== 'undefined') {\n            this.lastChartDataObj[key] = this.lastChartDataObj[key - 1];\n          } else if (typeof this.lastChartDataObj[key] == 'undefined' && typeof this.lastChartDataObj[key - 2] !== 'undefined') {\n            this.lastChartDataObj[key] = this.lastChartDataObj[key - 2];\n          }\n        }\n        //console.log(this.lastChartDataObj);\n        this.reloadChart = true;\n        this.buildNewChart();\n      }\n    }\n    buildNewChart() {\n      var _a, _b;\n      console.log('chart reloaded');\n      this.time = this.dateUtilsService.getCurrentUtcTime() * 1000;\n      this.streamOptions = {};\n      //let timezoneDetected = this.timezoneDetected()\n      // let timezoneDetected = 0;\n      // let timezoneDetected = -75 * 1000;\n      let timezoneDetected = parseInt(this.sso.getRealtimeDelay());\n      let loadTime = new Date().getTime();\n      var chartxaxis = {\n        type: 'datetime',\n        tickPixelInterval: 120\n      };\n      var charcredits = {\n        enabled: false\n      };\n      var chartyaxis = {\n        gridLineDashStyle: 'longdash',\n        opposite: false,\n        startOnTick: false,\n        endOnTick: false,\n        title: {\n          text: this.yAxixTitle,\n          margin: 40\n          // style: {\n          //   fontWeight: 'bold',\n          //   textAlign: 'left'\n          // }\n        },\n\n        labels: {\n          align: 'left',\n          x: -35,\n          //y: 100,\n          // padding: 50,\n          formatter: function () {\n            return Math.abs(this.value);\n          }\n        }\n      };\n      let that = this;\n      this.streamOptions = {\n        time: {\n          useUTC: false\n        },\n        chart: {\n          type: 'areaspline',\n          //marginLeft: 100,\n          height: 220,\n          events: {\n            load: function () {\n              let sizes = that.chartName.toLowerCase() === 'rate' ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n              var series = this.series;\n              that.interval = setInterval(function () {\n                that.inc++;\n                let data = that.transformData(that.currentData, that.lastData, that.chartData);\n                that.chartData = data;\n                if (!data[0]) {\n                  data[0] = 0;\n                }\n                if (!data[1]) {\n                  data[1] = 0;\n                }\n                let upRate = that.bitsToSize(data[0]);\n                let downRate = that.bitsToSize(data[1]);\n                let vArr1 = upRate.split(\" \");\n                let vArr2 = downRate.split(\" \");\n                let upRateValue = vArr1[0];\n                let downRateValue = vArr2[0];\n                let upRateUnit = vArr1[1] ? vArr1[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let downRateUnit = vArr2[1] ? vArr2[1] : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                let maxUnit = '';\n                upRateUnit = upRateUnit == 'undefined' ? that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps' : upRateUnit;\n                downRateUnit = downRateUnit == 'undefined' ? that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps' : downRateUnit;\n                if (data[0] || data[1]) {\n                  if (data[0] > data[1]) {\n                    maxUnit = vArr1[1];\n                  } else {\n                    maxUnit = vArr2[1];\n                  }\n                } else {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit == 'undefined') {\n                  maxUnit = that.yAxixTitle ? that.yAxixTitle : that.chartName.toLowerCase() === 'rate' ? 'bps' : 'pps';\n                }\n                if (maxUnit != undefined && that.yAxixTitle != maxUnit && (data[0] || data[1])) {\n                  console.log(`scale changed from ${that.yAxixTitle} to ${maxUnit}`);\n                  //console.log(data);\n                  that.yAxixTitle = maxUnit;\n                  that.streamOptions.yAxis.title.text = that.yAxixTitle;\n                  // var time = (new Date()).getTime() + timezoneDetected;\n                  // let key = that.removeLast3Chars(time);\n                  //that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.rebuildData();\n                  return;\n                }\n                if (typeof maxUnit === 'string') {\n                  that.yAxixTitle = maxUnit;\n                }\n                let v1 = parseFloat(vArr1[0]);\n                let v2 = parseFloat(vArr2[0]);\n                if ((data[0] || data[1]) && data[0] < data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV2 - indexV1;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v1 = v1 / 1000;\n                    }\n                  }\n                  //console.log(\"after manu v1\", v1);\n                  //v1 = v1 / 1000;\n                }\n\n                if ((data[0] || data[1]) && data[0] > data[1] && vArr1[1] !== vArr2[1]) {\n                  let indexV1 = sizes.indexOf(vArr1[1]);\n                  let indexV2 = sizes.indexOf(vArr2[1]);\n                  let diff = indexV1 - indexV2;\n                  if (diff) {\n                    for (let i = diff; i > 0; i--) {\n                      v2 = v2 / 1000;\n                    }\n                  }\n                  //console.log(\"originafter manu v2\", v2);\n                }\n\n                if (data) {\n                  var time = new Date().getTime() + timezoneDetected;\n                  let num = parseFloat(Highcharts.numberFormat(Math.abs(v1), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.upRate = `${upRateValue} ${upRateUnit}`;\n                  num = parseFloat(Highcharts.numberFormat(Math.abs(v2), 2));\n                  if (num < 1) {\n                    //num *= 1000;\n                  }\n                  that.removeOldKeys();\n                  that.downRate = `${downRateValue} ${downRateUnit}`;\n                  var x = time,\n                    y = v1;\n                  series[0].addPoint([x, y], true, true);\n                  var sx = time,\n                    sy = -v2;\n                  series[1].addPoint([sx, sy], true, true);\n                  let key = that.removeLast3Chars(time);\n                  that.lastChartDataObj[key] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                  that.lastChartDataObj[key + 1] = [data[0], data[1], that.yAxixTitle, upRateUnit, downRateUnit];\n                }\n              }, 1000);\n            }\n          }\n        },\n        title: {\n          text: ''\n        },\n        colors: ['#0027FF', '#5ACFEA'],\n        //colors: ['#FF8238', '#836EE8'],\n        xAxis: chartxaxis,\n        yAxis: chartyaxis,\n        credits: charcredits,\n        plotOptions: {\n          areaspline: {\n            lineWidth: 1,\n            marker: {\n              enabled: false\n            },\n            fillOpacity: 0.75\n          },\n          spline: {\n            animation: false,\n            marker: {\n              enabled: false,\n              radius: 0.9,\n              lineWidth: 0.7\n            }\n          }\n        },\n        tooltip: {\n          formatter: function () {\n            //console.log(this.point);\n            // let dateValue = this.point.x - timezoneDetected;\n            // var dateStr = that.concatDateTime(dateValue);\n            // var months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n            // let num = parseFloat(Highcharts.numberFormat(Math.abs(this.point.y), 2));\n            // let datakey = that.removeLast3Chars(this.point.x)\n            // let unit = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][2] : '';\n            // let sizes = (that.chartName.toLowerCase() === 'rate') ? ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'] : ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];\n            let dateValue = this.point.x;\n            var dateStr = that.dateUtilsService.getLocalRealtimeDateFormat(dateValue);\n            let datakey = that.removeLast3Chars(this.point.x);\n            let unit = that.lastChartDataObj[datakey] ? that.lastChartDataObj[datakey][2] : '';\n            if (this.series.name == 'up') {\n              return `<b> ${dateStr}  </b><br/>\n  ${that.language.Upstream}: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle}`;\n            }\n            if (this.series.name == 'down') {\n              return `<b> ${dateStr}  </b><br/>\n  ${that.language.Downstream}: ${Highcharts.numberFormat(Math.abs(this.point.y), 2)} ${that.yAxixTitle}`;\n            }\n          }\n        },\n        legend: {\n          enabled: false\n        },\n        exporting: {\n          enabled: false\n        },\n        series: [{\n          name: ((_a = that === null || that === void 0 ? void 0 : that.language) === null || _a === void 0 ? void 0 : _a.upStream) ? that.language.upStream : 'up',\n          data: function () {\n            var data = [],\n              time = new Date().getTime() + timezoneDetected,\n              i;\n            for (i = -299; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][0] : that.lastChartDataObj[key - 1] && that.lastChartDataObj[key - 1][0] ? that.lastChartDataObj[key - 1][0] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][0] : that.lastChartDataObj[key - 2] && that.lastChartDataObj[key - 2][0] ? that.lastChartDataObj[key - 2][0] : 0;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            return data;\n          }()\n        }, {\n          name: ((_b = that === null || that === void 0 ? void 0 : that.language) === null || _b === void 0 ? void 0 : _b.downStream) ? that.language.downStream : 'down',\n          data: function () {\n            // generate an array of random data\n            var data = [],\n              time = new Date().getTime() + timezoneDetected,\n              i;\n            //console.log(\" series\", that.lastChartDataObj)\n            for (i = -299; i <= 0; i += 1) {\n              let timeKey = time + i * 1000;\n              let key = that.removeLast3Chars(timeKey);\n              // let value = that.lastChartDataObj[key] ? that.lastChartDataObj[key][1] : 0;\n              // if (that.reloadChart && !value) {\n              //   value = that.lastChartDataObj[key - 1] ? that.lastChartDataObj[key - 1][0] : 0;\n              // }\n              let value = typeof that.lastChartDataObj[key] !== 'undefined' ? that.lastChartDataObj[key][1] : that.lastChartDataObj[key - 1] && that.lastChartDataObj[key - 1][1] ? that.lastChartDataObj[key - 1][1] : 0;\n              if (that.reloadChart && !value) {\n                value = typeof that.lastChartDataObj[key - 1] !== 'undefined' ? that.lastChartDataObj[key - 1][1] : that.lastChartDataObj[key - 2] && that.lastChartDataObj[key - 2][1] ? that.lastChartDataObj[key - 2][1] : 0;\n              }\n              if (that.lastChartDataObj[key]) {\n                that.lastChartDataObj[key][1] = value;\n              }\n              if (value) {\n                value = value / that.sizes[that.yAxixTitle];\n              }\n              value = value * -1;\n              data.push({\n                x: timeKey,\n                y: value\n              });\n            }\n            ////console.log(data);\n            return data;\n          }()\n        }]\n      };\n      this.streamOptions.series[0].visible = this.isUpStreamVisible;\n      this.streamOptions.series[1].visible = this.isDownStreamVisible;\n      this.streamOptions = Object.assign({}, this.streamOptions);\n    }\n    concatDateTime(dateTime) {\n      const d = new Date(dateTime);\n      return `${this.roundingDigit(d.getDate())}-${d.toLocaleString('default', {\n        month: 'short'\n      })} ${this.roundingDigit(d.getHours())}:${this.roundingDigit(d.getMinutes())}:${this.roundingDigit(d.getSeconds())}`;\n    }\n    roundingDigit(digit) {\n      return digit < 10 ? `0${digit}` : digit;\n    }\n  }\n  StreamPathChartComponent.ɵfac = function StreamPathChartComponent_Factory(t) {\n    return new (t || StreamPathChartComponent)(i0.ɵɵdirectiveInject(i1.TranslateService), i0.ɵɵdirectiveInject(i2.HttpClient), i0.ɵɵdirectiveInject(i3.ConvertorService), i0.ɵɵdirectiveInject(i4.DateUtilsService), i0.ɵɵdirectiveInject(i5.SsoAuthService));\n  };\n  StreamPathChartComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: StreamPathChartComponent,\n    selectors: [[\"ngx-stream-path-chart\"]],\n    inputs: {\n      chartName: \"chartName\",\n      yAxixTitle: \"yAxixTitle\",\n      data: \"data\",\n      windowLen: \"windowLen\",\n      time: \"time\",\n      history: \"history\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"analytic-widget\", 4, \"ngIf\"], [1, \"analytic-widget\"], [1, \"analytic-widget-header\"], [1, \"d-flex\", \"justify-content-between\"], [1, \"mx-2\"], [1, \"widget-title\", 3, \"title\"], [1, \"legend-label\", \"toggle-up\", 3, \"click\"], [1, \"legend-glyph\", 3, \"ngStyle\"], [1, \"legend-label\", \"toggle-down\", 3, \"click\"], [1, \"interval\"], [1, \"mx-2\", 2, \"text-align\", \"right\"], [1, \"traffic-volume\", \"monitor-status-normal\"], [\"style\", \"color: #0027FF;\", 4, \"ngIf\"], [\"style\", \"color: #5ACFEA;\", 4, \"ngIf\"], [1, \"analytic-widget-body\"], [\"id\", \"custom-mirrot-chart\", \"style\", \"width: 100%; display: block;\", 3, \"Highcharts\", \"options\", \"callbackFunction\", 4, \"ngIf\"], [2, \"color\", \"#0027FF\"], [\"aria-hidden\", \"true\", 1, \"fa\", \"fa-arrow-up\"], [2, \"color\", \"#5ACFEA\"], [\"aria-hidden\", \"true\", 1, \"fa\", \"fa-arrow-down\"], [\"id\", \"custom-mirrot-chart\", 2, \"width\", \"100%\", \"display\", \"block\", 3, \"Highcharts\", \"options\", \"callbackFunction\"]],\n    template: function StreamPathChartComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, StreamPathChartComponent_div_0_Template, 20, 14, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.pageAvailable);\n      }\n    },\n    directives: [i6.NgIf, i6.NgStyle, i7.HighchartsChartComponent],\n    styles: [\".highcharts-data-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{min-width:320px;max-width:800px;margin:1em auto}.highcharts-data-table[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{font-family:Verdana,sans-serif;border-collapse:collapse;border:1px solid #EBEBEB;margin:10px auto;text-align:center;width:100%;max-width:500px}.highcharts-data-table[_ngcontent-%COMP%]   caption[_ngcontent-%COMP%]{padding:1em 0;font-size:1.2em;color:#555}.highcharts-data-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{font-weight:600;padding:.5em}.highcharts-data-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   caption[_ngcontent-%COMP%]{padding:.5em}.highcharts-data-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%], .highcharts-data-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:nth-child(even){background:#f8f8f8}.highcharts-data-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{background:#f1f7ff}.analytic-widget[_ngcontent-%COMP%]   .analytic-widget-header[_ngcontent-%COMP%]{display:block}.analytic-widget[_ngcontent-%COMP%]   .analytic-widget-header-cell[_ngcontent-%COMP%]{display:block;padding:5px 5px 5px 10px;position:relative}.analytic-widget[_ngcontent-%COMP%]   .legend-glyph[_ngcontent-%COMP%]{display:inline-block;margin-left:4px;margin-right:4px;width:10px;height:10px;border-radius:6px}.analytic-widget[_ngcontent-%COMP%]   .legend-label[_ngcontent-%COMP%]{display:inline-block;font-size:12px;padding-right:8px;margin-right:4px;border-color:#e1dfec;background-color:#eae8f3;border-width:1px;text-decoration:none;cursor:pointer}.analytic-widget[_ngcontent-%COMP%]   .interval[_ngcontent-%COMP%]{background:#efefef;padding:2px 7px;font-size:11px;border-radius:2px;color:#666;margin-right:20px}.analytic-widget[_ngcontent-%COMP%]   .traffic-volume.monitor-status-normal[_ngcontent-%COMP%]{margin-top:0;background-color:#eae8f3;border-color:#e1dfec;border-width:1px;font-size:12px}\"]\n  });\n  return StreamPathChartComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}