{"ast":null,"code":"import { is } from '../../../../util/ModelUtil';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { collectLanes, getLanesRoot } from '../../../modeling/util/LaneUtil';\nimport { LANE_MIN_DIMENSIONS } from '../ResizeBehavior';\nvar abs = Math.abs,\n  min = Math.min,\n  max = Math.max;\nfunction addToTrbl(trbl, attr, value, choice) {\n  var current = trbl[attr];\n\n  // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}\nfunction addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}\nfunction addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}\nvar LANE_RIGHT_PADDING = 20,\n  LANE_LEFT_PADDING = 50,\n  LANE_TOP_PADDING = 20,\n  LANE_BOTTOM_PADDING = 20;\nexport function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {\n  var lanesRoot = getLanesRoot(laneShape);\n  var isFirst = true,\n    isLast = true;\n\n  // max top/bottom size for lanes\n  var allLanes = collectLanes(lanesRoot, [lanesRoot]);\n  var laneTrbl = asTRBL(laneShape);\n  var maxTrbl = {},\n    minTrbl = {};\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_DIMENSIONS.width;\n  } else if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_DIMENSIONS.width;\n  }\n  allLanes.forEach(function (other) {\n    var otherTrbl = asTRBL(other);\n    if (/n/.test(resizeDirection)) {\n      if (otherTrbl.top < laneTrbl.top - 10) {\n        isFirst = false;\n      }\n\n      // max top size (based on next element)\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_DIMENSIONS.height);\n      }\n\n      // min top size (based on self or nested element)\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);\n      }\n    }\n    if (/s/.test(resizeDirection)) {\n      if (otherTrbl.bottom > laneTrbl.bottom + 10) {\n        isLast = false;\n      }\n\n      // max bottom size (based on previous element)\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);\n      }\n\n      // min bottom size (based on self or nested element)\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_DIMENSIONS.height);\n      }\n    }\n  });\n\n  // max top/bottom/left/right size based on flow nodes\n  var flowElements = lanesRoot.children.filter(function (s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n  flowElements.forEach(function (flowElement) {\n    var flowElementTrbl = asTRBL(flowElement);\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}","map":null,"metadata":{},"sourceType":"module"}