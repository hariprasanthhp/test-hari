{"ast":null,"code":"import { assign, filter, forEach, isNumber } from 'min-dash';\nimport { asTRBL } from '../../layout/LayoutUtil';\nimport { getBBox } from '../../util/Elements';\nimport { getDirection } from './SpaceUtil';\nimport { hasPrimaryModifier } from '../../util/Mouse';\nimport { set as setCursor } from '../../util/Cursor';\nimport { selfAndAllChildren } from '../../util/Elements';\nvar abs = Math.abs,\n  round = Math.round;\nvar AXIS_TO_DIMENSION = {\n  x: 'width',\n  y: 'height'\n};\nvar CURSOR_CROSSHAIR = 'crosshair';\nvar DIRECTION_TO_TRBL = {\n  n: 'top',\n  w: 'left',\n  s: 'bottom',\n  e: 'right'\n};\nvar HIGH_PRIORITY = 1500;\nvar DIRECTION_TO_OPPOSITE = {\n  n: 's',\n  w: 'e',\n  s: 'n',\n  e: 'w'\n};\nvar PADDING = 20;\n\n/**\n * Add or remove space by moving and resizing elements.\n *\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Rules} rules\n * @param {ToolManager} toolManager\n * @param {Mouse} mouse\n */\nexport default function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {\n  this._canvas = canvas;\n  this._dragging = dragging;\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._rules = rules;\n  this._toolManager = toolManager;\n  this._mouse = mouse;\n  var self = this;\n  toolManager.registerTool('space', {\n    tool: 'spaceTool.selection',\n    dragging: 'spaceTool'\n  });\n  eventBus.on('spaceTool.selection.end', function (event) {\n    eventBus.once('spaceTool.selection.ended', function () {\n      self.activateMakeSpace(event.originalEvent);\n    });\n  });\n  eventBus.on('spaceTool.move', HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      initialized = context.initialized;\n    if (!initialized) {\n      initialized = context.initialized = self.init(event, context);\n    }\n    if (initialized) {\n      ensureConstraints(event);\n    }\n  });\n  eventBus.on('spaceTool.end', function (event) {\n    var context = event.context,\n      axis = context.axis,\n      direction = context.direction,\n      movingShapes = context.movingShapes,\n      resizingShapes = context.resizingShapes,\n      start = context.start;\n    if (!context.initialized) {\n      return;\n    }\n    ensureConstraints(event);\n    var delta = {\n      x: 0,\n      y: 0\n    };\n    delta[axis] = round(event['d' + axis]);\n    self.makeSpace(movingShapes, resizingShapes, delta, direction, start);\n    eventBus.once('spaceTool.ended', function (event) {\n      // activate space tool selection after make space\n      self.activateSelection(event.originalEvent, true, true);\n    });\n  });\n}\nSpaceTool.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules', 'toolManager', 'mouse'];\n\n/**\n * Activate space tool selection.\n *\n * @param {Object} event\n * @param {boolean} autoActivate\n */\nSpaceTool.prototype.activateSelection = function (event, autoActivate, reactivate) {\n  this._dragging.init(event, 'spaceTool.selection', {\n    autoActivate: autoActivate,\n    cursor: CURSOR_CROSSHAIR,\n    data: {\n      context: {\n        reactivate: reactivate\n      }\n    },\n    trapClick: false\n  });\n};\n\n/**\n * Activate space tool make space.\n *\n * @param  {MouseEvent} event\n */\nSpaceTool.prototype.activateMakeSpace = function (event) {\n  this._dragging.init(event, 'spaceTool', {\n    autoActivate: true,\n    cursor: CURSOR_CROSSHAIR,\n    data: {\n      context: {}\n    }\n  });\n};\n\n/**\n * Make space.\n *\n * @param  {Array<djs.model.Shape>} movingShapes\n * @param  {Array<djs.model.Shape>} resizingShapes\n * @param  {Object} delta\n * @param  {number} delta.x\n * @param  {number} delta.y\n * @param  {string} direction\n * @param  {number} start\n */\nSpaceTool.prototype.makeSpace = function (movingShapes, resizingShapes, delta, direction, start) {\n  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction, start);\n};\n\n/**\n * Initialize make space and return true if that was successful.\n *\n * @param {Object} event\n * @param {Object} context\n *\n * @return {boolean}\n */\nSpaceTool.prototype.init = function (event, context) {\n  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',\n    delta = event['d' + axis],\n    start = event[axis] - delta;\n  if (abs(delta) < 5) {\n    return false;\n  }\n\n  // invert delta to remove space when moving left\n  if (delta < 0) {\n    delta *= -1;\n  }\n\n  // invert delta to add/remove space when removing/adding space if modifier key is pressed\n  if (hasPrimaryModifier(event)) {\n    delta *= -1;\n  }\n  var direction = getDirection(axis, delta);\n  var root = this._canvas.getRootElement();\n  var children = selfAndAllChildren(root, true);\n  var elements = this.calculateAdjustments(children, axis, delta, start);\n  var minDimensions = this._eventBus.fire('spaceTool.getMinDimensions', {\n    axis: axis,\n    direction: direction,\n    shapes: elements.resizingShapes,\n    start: start\n  });\n  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);\n  assign(context, elements, {\n    axis: axis,\n    direction: direction,\n    spaceToolConstraints: spaceToolConstraints,\n    start: start\n  });\n  setCursor('resize-' + (axis === 'x' ? 'ew' : 'ns'));\n  return true;\n};\n\n/**\n * Get elements to be moved and resized.\n *\n * @param  {Array<djs.model.Shape>} elements\n * @param  {string} axis\n * @param  {number} delta\n * @param  {number} start\n *\n * @return {Object}\n */\nSpaceTool.prototype.calculateAdjustments = function (elements, axis, delta, start) {\n  var rules = this._rules;\n  var movingShapes = [],\n    resizingShapes = [];\n  forEach(elements, function (element) {\n    if (!element.parent || isConnection(element)) {\n      return;\n    }\n    var shapeStart = element[axis],\n      shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];\n\n    // shape to be moved\n    if (delta > 0 && shapeStart > start || delta < 0 && shapeEnd < start) {\n      return movingShapes.push(element);\n    }\n\n    // shape to be resized\n    if (shapeStart < start && shapeEnd > start && rules.allowed('shape.resize', {\n      shape: element\n    })) {\n      return resizingShapes.push(element);\n    }\n  });\n  return {\n    movingShapes: movingShapes,\n    resizingShapes: resizingShapes\n  };\n};\nSpaceTool.prototype.toggle = function () {\n  if (this.isActive()) {\n    return this._dragging.cancel();\n  }\n  var mouseEvent = this._mouse.getLastMoveEvent();\n  this.activateSelection(mouseEvent, !!mouseEvent);\n};\nSpaceTool.prototype.isActive = function () {\n  var context = this._dragging.context();\n  return context && /^spaceTool/.test(context.prefix);\n};\n\n// helpers //////////\n\nfunction addPadding(trbl) {\n  return {\n    top: trbl.top - PADDING,\n    right: trbl.right + PADDING,\n    bottom: trbl.bottom + PADDING,\n    left: trbl.left - PADDING\n  };\n}\nfunction ensureConstraints(event) {\n  var context = event.context,\n    spaceToolConstraints = context.spaceToolConstraints;\n  if (!spaceToolConstraints) {\n    return;\n  }\n  var x, y;\n  if (isNumber(spaceToolConstraints.left)) {\n    x = Math.max(event.x, spaceToolConstraints.left);\n    event.dx = event.dx + x - event.x;\n    event.x = x;\n  }\n  if (isNumber(spaceToolConstraints.right)) {\n    x = Math.min(event.x, spaceToolConstraints.right);\n    event.dx = event.dx + x - event.x;\n    event.x = x;\n  }\n  if (isNumber(spaceToolConstraints.top)) {\n    y = Math.max(event.y, spaceToolConstraints.top);\n    event.dy = event.dy + y - event.y;\n    event.y = y;\n  }\n  if (isNumber(spaceToolConstraints.bottom)) {\n    y = Math.min(event.y, spaceToolConstraints.bottom);\n    event.dy = event.dy + y - event.y;\n    event.y = y;\n  }\n}\nfunction getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {\n  var movingShapes = elements.movingShapes,\n    resizingShapes = elements.resizingShapes;\n  if (!resizingShapes.length) {\n    return;\n  }\n  var spaceToolConstraints = {},\n    min,\n    max;\n  forEach(resizingShapes, function (resizingShape) {\n    var resizingShapeBBox = asTRBL(resizingShape);\n\n    // find children that are not moving or resizing\n    var nonMovingResizingChildren = filter(resizingShape.children, function (child) {\n      return !isConnection(child) && !isLabel(child) && !includes(movingShapes, child) && !includes(resizingShapes, child);\n    });\n\n    // find children that are moving\n    var movingChildren = filter(resizingShape.children, function (child) {\n      return !isConnection(child) && !isLabel(child) && includes(movingShapes, child);\n    });\n    var minOrMax, nonMovingResizingChildrenBBox, movingChildrenBBox;\n    if (nonMovingResizingChildren.length) {\n      nonMovingResizingChildrenBBox = addPadding(asTRBL(getBBox(nonMovingResizingChildren)));\n      minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];\n      if (direction === 'n') {\n        spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;\n      } else if (direction === 'w') {\n        spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;\n      } else if (direction === 's') {\n        spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;\n      } else if (direction === 'e') {\n        spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;\n      }\n    }\n    if (movingChildren.length) {\n      movingChildrenBBox = addPadding(asTRBL(getBBox(movingChildren)));\n      minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];\n      if (direction === 'n') {\n        spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;\n      } else if (direction === 'w') {\n        spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;\n      } else if (direction === 's') {\n        spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;\n      } else if (direction === 'e') {\n        spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;\n      }\n    }\n    var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];\n    if (resizingShapeMinDimensions) {\n      if (direction === 'n') {\n        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];\n        spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;\n      } else if (direction === 'w') {\n        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];\n        spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;\n      } else if (direction === 's') {\n        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];\n        spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;\n      } else if (direction === 'e') {\n        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];\n        spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;\n      }\n    }\n  });\n  return spaceToolConstraints;\n}\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}","map":null,"metadata":{},"sourceType":"module"}