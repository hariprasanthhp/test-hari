{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { event as domEvent, closest as domClosest } from 'min-dom';\nimport Hammer from 'hammerjs';\nimport { toPoint } from '../../util/Event';\nvar MIN_ZOOM = 0.2,\n  MAX_ZOOM = 4;\nvar mouseEvents = ['mousedown', 'mouseup', 'mouseover', 'mouseout', 'click', 'dblclick'];\nfunction log() {\n\n  // console.log.apply(console, arguments);\n}\nfunction get(service, injector) {\n  return injector.get(service, false);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  if (typeof event.stopPropagation === 'function') {\n    event.stopPropagation();\n  } else if (event.srcEvent && typeof event.srcEvent.stopPropagation === 'function') {\n    // iPhone & iPad\n    event.srcEvent.stopPropagation();\n  }\n  if (typeof event.stopImmediatePropagation === 'function') {\n    event.stopImmediatePropagation();\n  }\n}\nfunction createTouchRecognizer(node) {\n  function stopMouse(event) {\n    forEach(mouseEvents, function (e) {\n      domEvent.bind(node, e, stopEvent, true);\n    });\n  }\n  function allowMouse(event) {\n    setTimeout(function () {\n      forEach(mouseEvents, function (e) {\n        domEvent.unbind(node, e, stopEvent, true);\n      });\n    }, 500);\n  }\n  domEvent.bind(node, 'touchstart', stopMouse, true);\n  domEvent.bind(node, 'touchend', allowMouse, true);\n  domEvent.bind(node, 'touchcancel', allowMouse, true);\n\n  // A touch event recognizer that handles\n  // touch events only (we know, we can already handle\n  // mouse events out of the box)\n\n  var recognizer = new Hammer.Manager(node, {\n    inputClass: Hammer.TouchInput,\n    recognizers: [],\n    domEvents: true\n  });\n  var tap = new Hammer.Tap();\n  var pan = new Hammer.Pan({\n    threshold: 10\n  });\n  var press = new Hammer.Press();\n  var pinch = new Hammer.Pinch();\n  var doubleTap = new Hammer.Tap({\n    event: 'doubletap',\n    taps: 2\n  });\n  pinch.requireFailure(pan);\n  pinch.requireFailure(press);\n  recognizer.add([pan, press, pinch, doubleTap, tap]);\n  recognizer.reset = function (force) {\n    var recognizers = this.recognizers,\n      session = this.session;\n    if (session.stopped) {\n      return;\n    }\n    log('recognizer', 'stop');\n    recognizer.stop(force);\n    setTimeout(function () {\n      var i, r;\n      log('recognizer', 'reset');\n      for (i = 0; r = recognizers[i]; i++) {\n        r.reset();\n        r.state = 8; // FAILED STATE\n      }\n\n      session.curRecognizer = null;\n    }, 0);\n  };\n  recognizer.on('hammer.input', function (event) {\n    if (event.srcEvent.defaultPrevented) {\n      recognizer.reset(true);\n    }\n  });\n  return recognizer;\n}\n\n/**\n * A plugin that provides touch events for elements.\n *\n * @param {EventBus} eventBus\n * @param {InteractionEvents} interactionEvents\n */\nexport default function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {\n  // optional integrations\n  var dragging = get('dragging', injector),\n    move = get('move', injector),\n    contextPad = get('contextPad', injector),\n    palette = get('palette', injector);\n\n  // the touch recognizer\n  var recognizer;\n  function handler(type) {\n    return function (event) {\n      log('element', type, event);\n      interactionEvents.fire(type, event);\n    };\n  }\n  function getGfx(target) {\n    var node = domClosest(target, 'svg, .djs-element', true);\n    return node;\n  }\n  function initEvents(svg) {\n    // touch recognizer\n    recognizer = createTouchRecognizer(svg);\n    recognizer.on('doubletap', handler('element.dblclick'));\n    recognizer.on('tap', handler('element.click'));\n    function startGrabCanvas(event) {\n      log('canvas', 'grab start');\n      var lx = 0,\n        ly = 0;\n      function update(e) {\n        var dx = e.deltaX - lx,\n          dy = e.deltaY - ly;\n        canvas.scroll({\n          dx: dx,\n          dy: dy\n        });\n        lx = e.deltaX;\n        ly = e.deltaY;\n      }\n      function end(e) {\n        recognizer.off('panmove', update);\n        recognizer.off('panend', end);\n        recognizer.off('pancancel', end);\n        log('canvas', 'grab end');\n      }\n      recognizer.on('panmove', update);\n      recognizer.on('panend', end);\n      recognizer.on('pancancel', end);\n    }\n    function startGrab(event) {\n      var gfx = getGfx(event.target),\n        element = gfx && elementRegistry.get(gfx);\n\n      // recognizer\n      if (move && canvas.getRootElement() !== element) {\n        log('element', 'move start', element, event, true);\n        return move.start(event, element, true);\n      } else {\n        startGrabCanvas(event);\n      }\n    }\n    function startZoom(e) {\n      log('canvas', 'zoom start');\n      var zoom = canvas.zoom(),\n        mid = e.center;\n      function update(e) {\n        var ratio = 1 - (1 - e.scale) / 1.50,\n          newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));\n        canvas.zoom(newZoom, mid);\n        stopEvent(e);\n      }\n      function end(e) {\n        recognizer.off('pinchmove', update);\n        recognizer.off('pinchend', end);\n        recognizer.off('pinchcancel', end);\n        recognizer.reset(true);\n        log('canvas', 'zoom end');\n      }\n      recognizer.on('pinchmove', update);\n      recognizer.on('pinchend', end);\n      recognizer.on('pinchcancel', end);\n    }\n    recognizer.on('panstart', startGrab);\n    recognizer.on('press', startGrab);\n    recognizer.on('pinchstart', startZoom);\n  }\n  if (dragging) {\n    // simulate hover during dragging\n    eventBus.on('drag.move', function (event) {\n      var originalEvent = event.originalEvent;\n      if (!originalEvent || originalEvent instanceof MouseEvent) {\n        return;\n      }\n      var position = toPoint(originalEvent);\n\n      // this gets really expensive ...\n      var node = document.elementFromPoint(position.x, position.y),\n        gfx = getGfx(node),\n        element = gfx && elementRegistry.get(gfx);\n      if (element !== event.hover) {\n        if (event.hover) {\n          dragging.out(event);\n        }\n        if (element) {\n          dragging.hover({\n            element: element,\n            gfx: gfx\n          });\n          event.hover = element;\n          event.hoverGfx = gfx;\n        }\n      }\n    });\n  }\n  if (contextPad) {\n    eventBus.on('contextPad.create', function (event) {\n      var node = event.pad.html;\n\n      // touch recognizer\n      var padRecognizer = createTouchRecognizer(node);\n      padRecognizer.on('panstart', function (event) {\n        log('context-pad', 'panstart', event);\n        contextPad.trigger('dragstart', event, true);\n      });\n      padRecognizer.on('press', function (event) {\n        log('context-pad', 'press', event);\n        contextPad.trigger('dragstart', event, true);\n      });\n      padRecognizer.on('tap', function (event) {\n        log('context-pad', 'tap', event);\n        contextPad.trigger('click', event);\n      });\n    });\n  }\n  if (palette) {\n    eventBus.on('palette.create', function (event) {\n      var node = event.container;\n\n      // touch recognizer\n      var padRecognizer = createTouchRecognizer(node);\n      padRecognizer.on('panstart', function (event) {\n        log('palette', 'panstart', event);\n        palette.trigger('dragstart', event, true);\n      });\n      padRecognizer.on('press', function (event) {\n        log('palette', 'press', event);\n        palette.trigger('dragstart', event, true);\n      });\n      padRecognizer.on('tap', function (event) {\n        log('palette', 'tap', event);\n        palette.trigger('click', event);\n      });\n    });\n  }\n  eventBus.on('canvas.init', function (event) {\n    initEvents(event.svg);\n  });\n}\nTouchInteractionEvents.$inject = ['injector', 'canvas', 'eventBus', 'elementRegistry', 'interactionEvents', 'touchFix'];","map":null,"metadata":{},"sourceType":"module"}