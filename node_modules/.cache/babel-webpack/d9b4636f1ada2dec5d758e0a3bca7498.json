{"ast":null,"code":"import { assign } from 'min-dash';\nimport { toPoint } from '../../util/Event';\n\n/**\n * Initiates canvas scrolling if current cursor point is close to a border.\n * Cancelled when current point moves back inside the scrolling borders\n * or cancelled manually.\n *\n * Default options :\n *   scrollThresholdIn: [ 20, 20, 20, 20 ],\n *   scrollThresholdOut: [ 0, 0, 0, 0 ],\n *   scrollRepeatTimeout: 15,\n *   scrollStep: 10\n *\n * Threshold order:\n *   [ left, top, right, bottom ]\n */\nexport default function AutoScroll(config, eventBus, canvas) {\n  this._canvas = canvas;\n  this._opts = assign({\n    scrollThresholdIn: [20, 20, 20, 20],\n    scrollThresholdOut: [0, 0, 0, 0],\n    scrollRepeatTimeout: 15,\n    scrollStep: 10\n  }, config);\n  var self = this;\n  eventBus.on('drag.move', function (e) {\n    var point = self._toBorderPoint(e);\n    self.startScroll(point);\n  });\n  eventBus.on(['drag.cleanup'], function () {\n    self.stopScroll();\n  });\n}\nAutoScroll.$inject = ['config.autoScroll', 'eventBus', 'canvas'];\n\n/**\n * Starts scrolling loop.\n * Point is given in global scale in canvas container box plane.\n *\n * @param  {Object} point { x: X, y: Y }\n */\nAutoScroll.prototype.startScroll = function (point) {\n  var canvas = this._canvas;\n  var opts = this._opts;\n  var self = this;\n  var clientRect = canvas.getContainer().getBoundingClientRect();\n  var diff = [point.x, point.y, clientRect.width - point.x, clientRect.height - point.y];\n  this.stopScroll();\n  var dx = 0,\n    dy = 0;\n  for (var i = 0; i < 4; i++) {\n    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {\n      if (i === 0) {\n        dx = opts.scrollStep;\n      } else if (i == 1) {\n        dy = opts.scrollStep;\n      } else if (i == 2) {\n        dx = -opts.scrollStep;\n      } else if (i == 3) {\n        dy = -opts.scrollStep;\n      }\n    }\n  }\n  if (dx !== 0 || dy !== 0) {\n    canvas.scroll({\n      dx: dx,\n      dy: dy\n    });\n    this._scrolling = setTimeout(function () {\n      self.startScroll(point);\n    }, opts.scrollRepeatTimeout);\n  }\n};\nfunction between(val, start, end) {\n  if (start < val && val < end) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Stops scrolling loop.\n */\nAutoScroll.prototype.stopScroll = function () {\n  clearTimeout(this._scrolling);\n};\n\n/**\n * Overrides defaults options.\n *\n * @param  {Object} options\n */\nAutoScroll.prototype.setOptions = function (options) {\n  this._opts = assign({}, this._opts, options);\n};\n\n/**\n * Converts event to a point in canvas container plane in global scale.\n *\n * @param  {Event} event\n * @return {Point}\n */\nAutoScroll.prototype._toBorderPoint = function (event) {\n  var clientRect = this._canvas._container.getBoundingClientRect();\n  var globalPosition = toPoint(event.originalEvent);\n  return {\n    x: globalPosition.x - clientRect.left,\n    y: globalPosition.y - clientRect.top\n  };\n};","map":null,"metadata":{},"sourceType":"module"}