{"ast":null,"code":"import { environment } from 'src/environments/environment';\nimport $ from 'jquery';\nvar props = {\n  qlik: {}\n};\nvar config = environment.QLIK_CONFIG;\nvar appId = environment.APP_ID;\nvar chart_id = {\n  'Mobile Message': 'jpgcbe',\n  'CSV Download': 'LeLMuB',\n  'Facebook': 'Lvtqh'\n};\n// export function getSegmentList(app) {\n//     return new Promise((resolve, reject) => {\n//         try {\n//             app.getList('BookmarkList', function (reply) {\n//                 let list = reply.qBookmarkList.qItems, newList = [];\n//                 newList = list.map((ele, i) => {\n//                     let segment = {}, title;\n//                     segment.segmentId = ele.qInfo.qId;\n//                     segment.segmentName = ele.qData.title\n//                     if (segment.segmentName && segment.segmentName.includes('InfoXD')) {\n//                         title = segment.segmentName.split('~');\n//                         segment.segmentName = title[1];\n//                         segment.segmentType = title[2];\n//                         segment.subscriberCount = {};//                         \n//                         return segment;\n//                     }\n//                 })\n//                 newList = newList.filter(ele => ele !== undefined)\n//                 resolve(newList);\n//             })\n//         }\n//         catch (error) {\n//             reject(error);\n//         }\n//     })\n// }\nexport function getSegmentList(app) {\n  return new Promise((resolve, reject) => {\n    try {\n      let Genericid = null;\n      app.getList('BookmarkList', function (reply) {\n        let list = reply.qBookmarkList.qItems,\n          newList = [];\n        newList = list.map((ele, i) => {\n          let segment = {},\n            title;\n          segment.segmentId = ele.qInfo.qId;\n          segment.segmentName = ele.qData.title;\n          if (segment.segmentName && segment.segmentName.includes('InfoXD')) {\n            title = segment.segmentName.split('~');\n            segment.segmentName = title[1];\n            segment.segmentType = title[2];\n            segment.subscriberCount = {};\n            app.createGenericObject({\n              subscriber_count: {\n                qStringExpression: \"$(=replace(vSubscriber_Count,'{$','{'&chr(39)& '\" + segment.segmentId + \"' &chr(39)))\"\n              }\n            }, function (reply) {\n              if (reply) {\n                segment.subscriberCount = +reply.subscriber_count.replace(',', '');\n                Genericid = reply.qInfo.qId;\n              }\n            });\n            return segment;\n          }\n        });\n        newList = newList.filter(ele => ele !== undefined);\n        app.destroySessionObject(Genericid);\n        resolve(newList);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport function getRecommendedSegments(app) {\n  return new Promise((resolve, reject) => {\n    try {\n      app.createCube({\n        \"qInitialDataFetch\": [{\n          \"qHeight\": 20,\n          \"qWidth\": 3\n        }],\n        \"qDimensions\": [{\n          \"qDef\": {\n            \"qFieldDefs\": [\"=Primary_Seg_Name\"]\n          },\n          \"qNullSuppression\": true,\n          \"qOtherTotalSpec\": {\n            \"qOtherMode\": \"OTHER_OFF\",\n            \"qSuppressOther\": true,\n            \"qOtherSortMode\": \"OTHER_SORT_DESCENDING\",\n            \"qOtherCounted\": {\n              \"qv\": \"5\"\n            },\n            \"qOtherLimitMode\": \"OTHER_GE_LIMIT\"\n          }\n        }, {\n          \"qDef\": {\n            \"qFieldDefs\": [\"=Upsell_Category\"]\n          },\n          \"qNullSuppression\": true,\n          \"qOtherTotalSpec\": {\n            \"qOtherMode\": \"OTHER_OFF\",\n            \"qSuppressOther\": true,\n            \"qOtherSortMode\": \"OTHER_SORT_DESCENDING\",\n            \"qOtherCounted\": {\n              \"qv\": \"5\"\n            },\n            \"qOtherLimitMode\": \"OTHER_GE_LIMIT\"\n          }\n        }],\n        \"qMeasures\": [{\n          \"qDef\": {\n            \"qDef\": \"$(vSubscribers_Recommended)\"\n          },\n          \"qLabel\": \"$(vSubscribers_Recommended)\",\n          \"qLibraryId\": null,\n          \"qSortBy\": {\n            \"qSortByState\": 0,\n            \"qSortByFrequency\": 0,\n            \"qSortByNumeric\": 0,\n            \"qSortByAscii\": 1,\n            \"qSortByLoadOrder\": 0,\n            \"qSortByExpression\": 0,\n            \"qExpression\": {\n              \"qv\": \" \"\n            }\n          }\n        }],\n        \"qSuppressZero\": false,\n        \"qSuppressMissing\": false,\n        \"qMode\": \"S\",\n        \"qInterColumnSortOrder\": [],\n        \"qStateName\": \"$\"\n      }, reply => {\n        let arr = [],\n          segments = [];\n        arr = reply.qHyperCube.qDataPages[0].qMatrix.map(ele => {\n          let arr1 = [];\n          arr1 = ele.map(val => val.qText);\n          return arr1;\n        });\n        // console.log(arr);\n        segments = arr.map(ele => {\n          let obj = {};\n          obj.segmentName = ele[0];\n          obj.segmentType = ele[1];\n          obj.subscriberCount = +ele[2].replace(',', '');\n          return obj;\n        });\n        // console.log(segments)\n        resolve(segments);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport function downloadQSReports(app, type) {\n  return new Promise((resolve, reject) => {\n    try {\n      app.visualization.get(chart_id[type]).then(function (vis) {\n        vis.exportData({\n          format: 'CSV_C'\n        }).then(function (link) {\n          window.open(link);\n          resolve();\n        });\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport function downloadCSVSegmentFilters(segment_id, segment_type, filters, app) {\n  return new Promise((resolve, reject) => {\n    if (segment_type === 'Saved') {\n      app.bookmark.apply(segment_id);\n      resolve();\n    } else if (segment_type === 'Recommended') {\n      if (filters && Object.keys(filters).length === 0) {\n        app.clearAll();\n      }\n      app.field('Recommended_UUID').selectMatch(segment_id);\n      if (filters && filters.region) {\n        let values = filters.region.split(';');\n        app.field('region').selectValues([...values]);\n      }\n      if (filters && filters.location) {\n        let values = filters.location.split(';');\n        app.field('location').selectValues([...values]);\n      }\n      if (filters && filters.servicegrp) {\n        let values = filters.servicegrp.split(';');\n        app.field('servicegrp').selectValues([...values]);\n      }\n      if (filters && filters.propensity) {\n        let values = filters.propensity.split(';');\n        app.field('propensity').selectValues([...values]);\n      }\n      if (filters && filters.zipcode) {\n        app.field('zipplusfour').clear();\n        let values = filters.zipcode.split(';');\n        app.field('zipcode').selectValues([...values]);\n      }\n      resolve();\n    } else {\n      reject('Invalid Segment Type');\n    }\n  });\n}\nexport function getRecommendedSegmentAdditionalFilters(app, obj_id) {\n  return new Promise((resolve, reject) => {\n    app.getObject(obj_id).then(model => {\n      let field = model.layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n      //    console.log(field)\n      model.getHyperCubeData('/qHyperCubeDef', [{\n        qTop: 0,\n        qLeft: 0,\n        qWidth: 2,\n        qHeight: 5000\n      }]).then(data => {\n        let list = data[0].qMatrix,\n          finalList = [],\n          result = {};\n        finalList = [...list].map(elem => {\n          let obj = {};\n          obj[field] = elem[0].qText;\n          return obj;\n        });\n        result = {\n          \"message\": \"Successfully initiated\",\n          \"data\": finalList\n        };\n        console.log(result);\n        //  model.close();\n        resolve(result);\n      });\n    });\n  });\n}\nexport function getHomeInsightsKPI(app) {\n  return new Promise((resolve, reject) => {\n    app.createGenericObject({\n      All_Subscribers: {\n        qStringExpression: \"=${vTotalSubscribers}\"\n      },\n      All_Subscribers_Percentage: {\n        qStringExpression: \"=${vTotalSubscribersPercentage}\"\n      },\n      Streaming_Subscribers: {\n        qStringExpression: \"=${vStreaming}\"\n      },\n      Streaming_Subscribers_Percentage: {\n        qStringExpression: \"=${vStreamingSubscribersPercentage}\"\n      },\n      Gaming_Subscribers: {\n        qStringExpression: \"=${vGaming}\"\n      },\n      Gaming_Subscribers_Percentage: {\n        qStringExpression: \"=${vGamingSubscribersPercentage}\"\n      },\n      Work_From_Home_Subscribers: {\n        qStringExpression: \"=${vWFH}\"\n      },\n      Work_From_Home_Subscribers_Percentage: {\n        qStringExpression: \"=${vWFHSubscribersPercentage}\"\n      },\n      Acquisition_Rate: {\n        qStringExpression: \"=${vAcquisitionRate}\"\n      },\n      Acquisition_Rate_Percentage: {\n        qStringExpression: \"=${vAcquisitionRatePercentage}\"\n      },\n      Churn_Rate: {\n        qStringExpression: \"=${vChurnRate}\"\n      },\n      Churn_Rate_Percentage: {\n        qStringExpression: \"=${vChurnRatePercentage}\"\n      },\n      ARPU: {\n        qStringExpression: \"=${vARPU}\"\n      },\n      ARPU_Percentage: {\n        qStringExpression: \"=${vARPUPercentage}\"\n      },\n      New_Subscribers_Per_Day: {\n        qStringExpression: \"=${vNewSubsPerDay}\"\n      },\n      New_Subscribers_Per_Day_Percentage: {\n        qStringExpression: \"=${vNewSubsPerDayPercentage}\"\n      }\n    }, function (reply) {\n      if (reply) {\n        resolve(reply);\n      }\n    });\n  });\n}\nexport function getSegmentSize(app) {\n  return new Promise((resolve, reject) => {\n    try {\n      app.createCube({\n        \"qInitialDataFetch\": [{\n          \"qHeight\": 20,\n          \"qWidth\": 3\n        }],\n        \"qDimensions\": [{\n          \"qDef\": {\n            \"qFieldDefs\": [\"=$(vSerialNumber)\"]\n          },\n          \"qNullSuppression\": true,\n          \"qOtherTotalSpec\": {\n            \"qOtherMode\": \"OTHER_OFF\",\n            \"qSuppressOther\": true,\n            \"qOtherSortMode\": \"OTHER_SORT_DESCENDING\",\n            \"qOtherCounted\": {\n              \"qv\": \"5\"\n            },\n            \"qOtherLimitMode\": \"OTHER_GE_LIMIT\"\n          }\n        }, {\n          \"qDef\": {\n            \"qFieldDefs\": [\"=$(vChannelName)\"]\n          },\n          \"qNullSuppression\": true,\n          \"qOtherTotalSpec\": {\n            \"qOtherMode\": \"OTHER_OFF\",\n            \"qSuppressOther\": true,\n            \"qOtherSortMode\": \"OTHER_SORT_DESCENDING\",\n            \"qOtherCounted\": {\n              \"qv\": \"5\"\n            },\n            \"qOtherLimitMode\": \"OTHER_GE_LIMIT\"\n          }\n        }],\n        \"qMeasures\": [{\n          \"qDef\": {\n            \"qDef\": \"$(vSegmentSize)\"\n          },\n          \"qLabel\": \"$(vSegmentSize)\",\n          \"qLibraryId\": null,\n          \"qSortBy\": {\n            \"qSortByState\": 0,\n            \"qSortByFrequency\": 0,\n            \"qSortByNumeric\": 0,\n            \"qSortByAscii\": 1,\n            \"qSortByLoadOrder\": 0,\n            \"qSortByExpression\": 0,\n            \"qExpression\": {\n              \"qv\": \" \"\n            }\n          }\n        }],\n        \"qSuppressZero\": false,\n        \"qSuppressMissing\": false,\n        \"qMode\": \"S\",\n        \"qInterColumnSortOrder\": [],\n        \"qStateName\": \"$\"\n      }, reply => {\n        let returnArray = [];\n        reply.qHyperCube.qDataPages[0].qMatrix.forEach(el => {\n          let mapping = el.map(el => el.qText);\n          let returnObject = {\n            serialNo: mapping[0],\n            channelName: mapping[1],\n            segmentSize: mapping[2]\n          };\n          returnArray.push(returnObject);\n        });\n        resolve(returnArray);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nfunction initQlikConnection(baseUrl, qlikTicket) {\n  let checkFile;\n  return new Promise((resolve, reject) => {\n    try {\n      if (checkFile || document.getElementById('loadJSCSSFile')) {\n        // resolve(checkFile);\n        // document.getElementById('loadJSCSSFile').remove();\n      }\n      // window.onload();\n\n      if (!document.getElementById('loadJSCSSFile')) {\n        const jsFileLoad = document.createElement('script');\n        jsFileLoad.src = `${baseUrl}/assets/external/requirejs/require.js?qlikTicket=${qlikTicket}`;\n        jsFileLoad.id = 'loadJSCSSFile';\n        document.head.appendChild(jsFileLoad);\n        jsFileLoad.loaded = new Promise((resolve, reject) => {\n          jsFileLoad.onload = () => {\n            resolve();\n          };\n          jsFileLoad.onerror = () => {\n            reject();\n          };\n        });\n        checkFile = Promise.all([jsFileLoad.loaded]);\n        resolve(checkFile);\n      }\n\n      // const cssFileLoad = document.createElement('link');\n      // cssFileLoad.href = `${baseUrl}/autogenerated/qlik-styles.css`;\n      // cssFileLoad.type = 'text/css';\n      // cssFileLoad.rel = 'stylesheet';\n      // document.head.appendChild(cssFileLoad);\n      // cssFileLoad.loaded = new Promise((resolve, reject) => {\n      //   cssFileLoad.onload = () => {\n      //     resolve();\n      //   };\n      //   cssFileLoad.onerror = () => {\n      //     reject();\n      //   };\n      // });\n      // checkFile = Promise.all([jsFileLoad.loaded, cssFileLoad.loaded])\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n;\nexport function openQlikConnection(qlikTicket) {\n  config = environment.QLIK_CONFIG;\n  console.log('APP OPENING', qlikTicket);\n  var url = `${(config.isSecure ? 'https://' : 'http://') + config.host + (config.port ? `:${config.port}` : '') + config.prefix}resources`;\n  return new Promise((resolve, reject) => {\n    try {\n      initQlikConnection(url, qlikTicket).then(res => {\n        window.require.config({\n          baseUrl: url,\n          paths: {\n            qlik: `${url}/js/qlik?qlikTicket=${qlikTicket}`\n          },\n          config: {\n            text: {\n              useXhr() {\n                return true;\n              }\n            }\n          }\n        });\n        window.require([\"js/qlik\"], function (qlik) {\n          qlik.setOnError(function (error) {\n            // console.log('APP OPENING', error)\n\n            // reject(error)\n          });\n          props[\"qlik\"] = qlik;\n          console.log('APP OPENING', qlik);\n          resolve(qlik);\n        });\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport function openApp() {\n  appId = environment.APP_ID;\n  return new Promise((resolve, reject) => {\n    try {\n      const {\n        qlik\n      } = props;\n      var app = qlik.openApp(appId, config);\n      resolve(app);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport function openApp_aq() {\n  appId = environment.APP_ID_AQUISITION;\n  return new Promise((resolve, reject) => {\n    try {\n      const {\n        qlik\n      } = props;\n      var app = qlik.openApp(appId, config);\n      resolve(app);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport function qlikLogout() {\n  config = environment.QLIK_CONFIG;\n  const URL = `${config.isSecure ? 'https://' : 'http://'}${config.host}${config.port ? ':' + config.port : ''}${config.prefix}qps/user`;\n  $.ajax({\n    type: 'DELETE',\n    url: URL,\n    success: function (data) {\n      //window.location.reload(true)\n    }\n  });\n}\n\n//","map":null,"metadata":{},"sourceType":"module"}