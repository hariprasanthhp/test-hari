{"ast":null,"code":"function CronJob(CronTime, spawn) {\n  function fnWrap(cmd) {\n    let command;\n    let args;\n    switch (typeof cmd) {\n      case 'string':\n        args = cmd.split(' ');\n        command = args.shift();\n        return spawn.bind(undefined, command, args);\n      case 'object':\n        command = cmd && cmd.command;\n        if (command) {\n          args = cmd.args;\n          const options = cmd.options;\n          return spawn.bind(undefined, command, args, options);\n        }\n        break;\n    }\n    return cmd;\n  }\n  function CJ(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) {\n    let _cronTime = cronTime;\n    let argCount = 0;\n    for (let i = 0; i < arguments.length; i++) {\n      if (arguments[i] !== undefined) {\n        argCount++;\n      }\n    }\n    if (typeof cronTime !== 'string' && argCount === 1) {\n      // crontime is an object...\n      onTick = cronTime.onTick;\n      onComplete = cronTime.onComplete;\n      context = cronTime.context;\n      startNow = cronTime.start || cronTime.startNow || cronTime.startJob;\n      timeZone = cronTime.timeZone;\n      runOnInit = cronTime.runOnInit;\n      _cronTime = cronTime.cronTime;\n      utcOffset = cronTime.utcOffset;\n      unrefTimeout = cronTime.unrefTimeout;\n    }\n    this.context = context || this;\n    this._callbacks = [];\n    this.onComplete = fnWrap(onComplete);\n    this.cronTime = new CronTime(_cronTime, timeZone, utcOffset);\n    this.unrefTimeout = unrefTimeout;\n    addCallback.call(this, fnWrap(onTick));\n    if (runOnInit) {\n      this.lastExecution = new Date();\n      fireOnTick.call(this);\n    }\n    if (startNow) {\n      start.call(this);\n    }\n    return this;\n  }\n  const addCallback = function (callback) {\n    if (typeof callback === 'function') {\n      this._callbacks.push(callback);\n    }\n  };\n  CJ.prototype.addCallback = addCallback;\n  CJ.prototype.setTime = function (time) {\n    if (typeof time !== 'object') {\n      // crontime is an object...\n      throw new Error('time must be an instance of CronTime.');\n    }\n    const wasRunning = this.running;\n    this.stop();\n    this.cronTime = time;\n    if (wasRunning) this.start();\n  };\n  CJ.prototype.nextDate = function () {\n    return this.cronTime.sendAt();\n  };\n  const fireOnTick = function () {\n    for (let i = this._callbacks.length - 1; i >= 0; i--) {\n      this._callbacks[i].call(this.context, this.onComplete);\n    }\n  };\n  CJ.prototype.fireOnTick = fireOnTick;\n  CJ.prototype.nextDates = function (i) {\n    return this.cronTime.sendAt(i);\n  };\n  const start = function () {\n    if (this.running) {\n      return;\n    }\n    const MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n    const self = this;\n    let timeout = this.cronTime.getTimeout();\n    let remaining = 0;\n    let startTime;\n    if (this.cronTime.realDate) {\n      this.runOnce = true;\n    }\n    function _setTimeout(timeout) {\n      startTime = Date.now();\n      self._timeout = setTimeout(callbackWrapper, timeout);\n      if (self.unrefTimeout && typeof self._timeout.unref === 'function') {\n        self._timeout.unref();\n      }\n    }\n\n    // The callback wrapper checks if it needs to sleep another period or not\n    // and does the real callback logic when it's time.\n    function callbackWrapper() {\n      const diff = startTime + timeout - Date.now();\n      if (diff > 0) {\n        let newTimeout = self.cronTime.getTimeout();\n        if (newTimeout > diff) {\n          newTimeout = diff;\n        }\n        remaining += newTimeout;\n      }\n\n      // If there is sleep time remaining, calculate how long and go to sleep\n      // again. This processing might make us miss the deadline by a few ms\n      // times the number of sleep sessions. Given a MAXDELAY of almost a\n      // month, this should be no issue.\n      self.lastExecution = new Date();\n      if (remaining) {\n        if (remaining > MAXDELAY) {\n          remaining -= MAXDELAY;\n          timeout = MAXDELAY;\n        } else {\n          timeout = remaining;\n          remaining = 0;\n        }\n        _setTimeout(timeout);\n      } else {\n        // We have arrived at the correct point in time.\n\n        self.running = false;\n\n        // start before calling back so the callbacks have the ability to stop the cron job\n        if (!self.runOnce) {\n          self.start();\n        }\n        self.fireOnTick();\n      }\n    }\n    if (timeout >= 0) {\n      this.running = true;\n\n      // Don't try to sleep more than MAXDELAY ms at a time.\n\n      if (timeout > MAXDELAY) {\n        remaining = timeout - MAXDELAY;\n        timeout = MAXDELAY;\n      }\n      _setTimeout(timeout);\n    } else {\n      this.stop();\n    }\n  };\n  CJ.prototype.start = start;\n  CJ.prototype.lastDate = function () {\n    return this.lastExecution;\n  };\n\n  /**\n   * Stop the cronjob.\n   */\n  CJ.prototype.stop = function () {\n    if (this._timeout) clearTimeout(this._timeout);\n    this.running = false;\n    if (typeof this.onComplete === 'function') {\n      this.onComplete();\n    }\n  };\n  return CJ;\n}\nmodule.exports = CronJob;","map":null,"metadata":{},"sourceType":"script"}