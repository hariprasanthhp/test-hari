{"ast":null,"code":"import { forEach, assign } from 'min-dash';\nimport { delegate as domDelegate, query as domQuery, queryAll as domQueryAll } from 'min-dom';\nimport { isPrimaryButton, isAuxiliaryButton } from '../../util/Mouse';\nimport { append as svgAppend, attr as svgAttr, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { createLine, updateLine } from '../../util/RenderUtil';\nfunction allowAll(event) {\n  return true;\n}\nfunction allowPrimaryAndAuxiliary(event) {\n  return isPrimaryButton(event) || isAuxiliaryButton(event);\n}\nvar LOW_PRIORITY = 500;\n\n/**\n * A plugin that provides interaction events for diagram elements.\n *\n * It emits the following events:\n *\n *   * element.click\n *   * element.contextmenu\n *   * element.dblclick\n *   * element.hover\n *   * element.mousedown\n *   * element.mousemove\n *   * element.mouseup\n *   * element.out\n *\n * Each event is a tuple { element, gfx, originalEvent }.\n *\n * Canceling the event via Event#preventDefault()\n * prevents the original DOM operation.\n *\n * @param {EventBus} eventBus\n */\nexport default function InteractionEvents(eventBus, elementRegistry, styles) {\n  var self = this;\n\n  /**\n   * Fire an interaction event.\n   *\n   * @param {string} type local event name, e.g. element.click.\n   * @param {DOMEvent} event native event\n   * @param {djs.model.Base} [element] the diagram element to emit the event on;\n   *                                   defaults to the event target\n   */\n  function fire(type, event, element) {\n    if (isIgnored(type, event)) {\n      return;\n    }\n    var target, gfx, returnValue;\n    if (!element) {\n      target = event.delegateTarget || event.target;\n      if (target) {\n        gfx = target;\n        element = elementRegistry.get(gfx);\n      }\n    } else {\n      gfx = elementRegistry.getGraphics(element);\n    }\n    if (!gfx || !element) {\n      return;\n    }\n    returnValue = eventBus.fire(type, {\n      element: element,\n      gfx: gfx,\n      originalEvent: event\n    });\n    if (returnValue === false) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n\n  // TODO(nikku): document this\n  var handlers = {};\n  function mouseHandler(localEventName) {\n    return handlers[localEventName];\n  }\n  function isIgnored(localEventName, event) {\n    var filter = ignoredFilters[localEventName] || isPrimaryButton;\n\n    // only react on left mouse button interactions\n    // except for interaction events that are enabled\n    // for secundary mouse button\n    return !filter(event);\n  }\n  var bindings = {\n    click: 'element.click',\n    contextmenu: 'element.contextmenu',\n    dblclick: 'element.dblclick',\n    mousedown: 'element.mousedown',\n    mousemove: 'element.mousemove',\n    mouseover: 'element.hover',\n    mouseout: 'element.out',\n    mouseup: 'element.mouseup'\n  };\n  var ignoredFilters = {\n    'element.contextmenu': allowAll,\n    'element.mousedown': allowPrimaryAndAuxiliary,\n    'element.mouseup': allowPrimaryAndAuxiliary,\n    'element.click': allowPrimaryAndAuxiliary,\n    'element.dblclick': allowPrimaryAndAuxiliary\n  };\n\n  // manual event trigger //////////\n\n  /**\n   * Trigger an interaction event (based on a native dom event)\n   * on the target shape or connection.\n   *\n   * @param {string} eventName the name of the triggered DOM event\n   * @param {MouseEvent} event\n   * @param {djs.model.Base} targetElement\n   */\n  function triggerMouseEvent(eventName, event, targetElement) {\n    // i.e. element.mousedown...\n    var localEventName = bindings[eventName];\n    if (!localEventName) {\n      throw new Error('unmapped DOM event name <' + eventName + '>');\n    }\n    return fire(localEventName, event, targetElement);\n  }\n  var ELEMENT_SELECTOR = 'svg, .djs-element';\n\n  // event handling ///////\n\n  function registerEvent(node, event, localEvent, ignoredFilter) {\n    var handler = handlers[localEvent] = function (event) {\n      fire(localEvent, event);\n    };\n    if (ignoredFilter) {\n      ignoredFilters[localEvent] = ignoredFilter;\n    }\n    handler.$delegate = domDelegate.bind(node, ELEMENT_SELECTOR, event, handler);\n  }\n  function unregisterEvent(node, event, localEvent) {\n    var handler = mouseHandler(localEvent);\n    if (!handler) {\n      return;\n    }\n    domDelegate.unbind(node, event, handler.$delegate);\n  }\n  function registerEvents(svg) {\n    forEach(bindings, function (val, key) {\n      registerEvent(svg, key, val);\n    });\n  }\n  function unregisterEvents(svg) {\n    forEach(bindings, function (val, key) {\n      unregisterEvent(svg, key, val);\n    });\n  }\n  eventBus.on('canvas.destroy', function (event) {\n    unregisterEvents(event.svg);\n  });\n  eventBus.on('canvas.init', function (event) {\n    registerEvents(event.svg);\n  });\n\n  // hit box updating ////////////////\n\n  eventBus.on(['shape.added', 'connection.added'], function (event) {\n    var element = event.element,\n      gfx = event.gfx;\n    eventBus.fire('interactionEvents.createHit', {\n      element: element,\n      gfx: gfx\n    });\n  });\n\n  // Update djs-hit on change.\n  // A low priortity is necessary, because djs-hit of labels has to be updated\n  // after the label bounds have been updated in the renderer.\n  eventBus.on(['shape.changed', 'connection.changed'], LOW_PRIORITY, function (event) {\n    var element = event.element,\n      gfx = event.gfx;\n    eventBus.fire('interactionEvents.updateHit', {\n      element: element,\n      gfx: gfx\n    });\n  });\n  eventBus.on('interactionEvents.createHit', LOW_PRIORITY, function (event) {\n    var element = event.element,\n      gfx = event.gfx;\n    self.createDefaultHit(element, gfx);\n  });\n  eventBus.on('interactionEvents.updateHit', function (event) {\n    var element = event.element,\n      gfx = event.gfx;\n    self.updateDefaultHit(element, gfx);\n  });\n\n  // hit styles ////////////\n\n  var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');\n  var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');\n  var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');\n  var HIT_TYPES = {\n    'all': ALL_HIT_STYLE,\n    'click-stroke': CLICK_STROKE_HIT_STYLE,\n    'stroke': STROKE_HIT_STYLE\n  };\n  function createHitStyle(classNames, attrs) {\n    attrs = assign({\n      stroke: 'white',\n      strokeWidth: 15\n    }, attrs || {});\n    return styles.cls(classNames, ['no-fill', 'no-border'], attrs);\n  }\n\n  // style helpers ///////////////\n\n  function applyStyle(hit, type) {\n    var attrs = HIT_TYPES[type];\n    if (!attrs) {\n      throw new Error('invalid hit type <' + type + '>');\n    }\n    svgAttr(hit, attrs);\n    return hit;\n  }\n  function appendHit(gfx, hit) {\n    svgAppend(gfx, hit);\n  }\n\n  // API\n\n  /**\n   * Remove hints on the given graphics.\n   *\n   * @param {SVGElement} gfx\n   */\n  this.removeHits = function (gfx) {\n    var hits = domQueryAll('.djs-hit', gfx);\n    forEach(hits, svgRemove);\n  };\n\n  /**\n   * Create default hit for the given element.\n   *\n   * @param {djs.model.Base} element\n   * @param {SVGElement} gfx\n   *\n   * @return {SVGElement} created hit\n   */\n  this.createDefaultHit = function (element, gfx) {\n    var waypoints = element.waypoints,\n      isFrame = element.isFrame,\n      boxType;\n    if (waypoints) {\n      return this.createWaypointsHit(gfx, waypoints);\n    } else {\n      boxType = isFrame ? 'stroke' : 'all';\n      return this.createBoxHit(gfx, boxType, {\n        width: element.width,\n        height: element.height\n      });\n    }\n  };\n\n  /**\n   * Create hits for the given waypoints.\n   *\n   * @param {SVGElement} gfx\n   * @param {Array<Point>} waypoints\n   *\n   * @return {SVGElement}\n   */\n  this.createWaypointsHit = function (gfx, waypoints) {\n    var hit = createLine(waypoints);\n    applyStyle(hit, 'stroke');\n    appendHit(gfx, hit);\n    return hit;\n  };\n\n  /**\n   * Create hits for a box.\n   *\n   * @param {SVGElement} gfx\n   * @param {string} hitType\n   * @param {Object} attrs\n   *\n   * @return {SVGElement}\n   */\n  this.createBoxHit = function (gfx, type, attrs) {\n    attrs = assign({\n      x: 0,\n      y: 0\n    }, attrs);\n    var hit = svgCreate('rect');\n    applyStyle(hit, type);\n    svgAttr(hit, attrs);\n    appendHit(gfx, hit);\n    return hit;\n  };\n\n  /**\n   * Update default hit of the element.\n   *\n   * @param  {djs.model.Base} element\n   * @param  {SVGElement} gfx\n   *\n   * @return {SVGElement} updated hit\n   */\n  this.updateDefaultHit = function (element, gfx) {\n    var hit = domQuery('.djs-hit', gfx);\n    if (!hit) {\n      return;\n    }\n    if (element.waypoints) {\n      updateLine(hit, element.waypoints);\n    } else {\n      svgAttr(hit, {\n        width: element.width,\n        height: element.height\n      });\n    }\n    return hit;\n  };\n  this.fire = fire;\n  this.triggerMouseEvent = triggerMouseEvent;\n  this.mouseHandler = mouseHandler;\n  this.registerEvent = registerEvent;\n  this.unregisterEvent = unregisterEvent;\n}\nInteractionEvents.$inject = ['eventBus', 'elementRegistry', 'styles'];\n\n/**\n * An event indicating that the mouse hovered over an element\n *\n * @event element.hover\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has left an element\n *\n * @event element.out\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has clicked an element\n *\n * @event element.click\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has double clicked an element\n *\n * @event element.dblclick\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has gone down on an element.\n *\n * @event element.mousedown\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has gone up on an element.\n *\n * @event element.mouseup\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the context menu action is triggered\n * via mouse or touch controls.\n *\n * @event element.contextmenu\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {SVGElement} gfx\n * @property {Event} originalEvent\n */","map":null,"metadata":{},"sourceType":"module"}