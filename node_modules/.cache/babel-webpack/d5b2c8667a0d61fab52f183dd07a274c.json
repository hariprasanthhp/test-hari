{"ast":null,"code":"import { asTRBL, getOrientation, getMid } from '../../layout/LayoutUtil';\nimport { find, reduce } from 'min-dash';\n\n// padding to detect element placement\nvar PLACEMENT_DETECTION_PAD = 10;\nexport var DEFAULT_DISTANCE = 50;\nvar DEFAULT_MAX_DISTANCE = 250;\n\n/**\n * Get free position starting from given position.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Function} getNextPosition\n *\n * @return {Point}\n */\nexport function findFreePosition(source, element, position, getNextPosition) {\n  var connectedAtPosition;\n  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {\n    position = getNextPosition(element, position, connectedAtPosition);\n  }\n  return position;\n}\n\n/**\n * Returns function that returns next position.\n *\n * @param {Object} nextPositionDirection\n * @param {Object} [nextPositionDirection.x]\n * @param {Object} [nextPositionDirection.y]\n *\n * @returns {Function}\n */\nexport function generateGetNextPosition(nextPositionDirection) {\n  return function (element, previousPosition, connectedAtPosition) {\n    var nextPosition = {\n      x: previousPosition.x,\n      y: previousPosition.y\n    };\n    ['x', 'y'].forEach(function (axis) {\n      var nextPositionDirectionForAxis = nextPositionDirection[axis];\n      if (!nextPositionDirectionForAxis) {\n        return;\n      }\n      var dimension = axis === 'x' ? 'width' : 'height';\n      var margin = nextPositionDirectionForAxis.margin,\n        minDistance = nextPositionDirectionForAxis.minDistance;\n      if (margin < 0) {\n        nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);\n      } else {\n        nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);\n      }\n    });\n    return nextPosition;\n  };\n}\n\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\nexport function getConnectedAtPosition(source, position, element) {\n  var bounds = {\n    x: position.x - element.width / 2,\n    y: position.y - element.height / 2,\n    width: element.width,\n    height: element.height\n  };\n  var closure = getAutoPlaceClosure(source, element);\n  return find(closure, function (target) {\n    if (target === element) {\n      return false;\n    }\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n    return orientation === 'intersect';\n  });\n}\n\n/**\n* Compute optimal distance between source and target based on existing connections to and from source.\n* Assumes left-to-right and top-to-down modeling.\n*\n* @param {djs.model.Shape} source\n* @param {Object} [hints]\n* @param {number} [hints.defaultDistance]\n* @param {string} [hints.direction]\n* @param {Function} [hints.filter]\n* @param {Function} [hints.getWeight]\n* @param {number} [hints.maxDistance]\n* @param {string} [hints.reference]\n*\n* @return {number}\n*/\nexport function getConnectedDistance(source, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  // targets > sources by default\n  function getDefaultWeight(connection) {\n    return connection.source === source ? 1 : -1;\n  }\n  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,\n    direction = hints.direction || 'e',\n    filter = hints.filter,\n    getWeight = hints.getWeight || getDefaultWeight,\n    maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,\n    reference = hints.reference || 'start';\n  if (!filter) {\n    filter = noneFilter;\n  }\n  function getDistance(a, b) {\n    if (direction === 'n') {\n      if (reference === 'start') {\n        return asTRBL(a).top - asTRBL(b).bottom;\n      } else if (reference === 'center') {\n        return asTRBL(a).top - getMid(b).y;\n      } else {\n        return asTRBL(a).top - asTRBL(b).top;\n      }\n    } else if (direction === 'w') {\n      if (reference === 'start') {\n        return asTRBL(a).left - asTRBL(b).right;\n      } else if (reference === 'center') {\n        return asTRBL(a).left - getMid(b).x;\n      } else {\n        return asTRBL(a).left - asTRBL(b).left;\n      }\n    } else if (direction === 's') {\n      if (reference === 'start') {\n        return asTRBL(b).top - asTRBL(a).bottom;\n      } else if (reference === 'center') {\n        return getMid(b).y - asTRBL(a).bottom;\n      } else {\n        return asTRBL(b).bottom - asTRBL(a).bottom;\n      }\n    } else {\n      if (reference === 'start') {\n        return asTRBL(b).left - asTRBL(a).right;\n      } else if (reference === 'center') {\n        return getMid(b).x - asTRBL(a).right;\n      } else {\n        return asTRBL(b).right - asTRBL(a).right;\n      }\n    }\n  }\n  var sourcesDistances = source.incoming.filter(filter).map(function (connection) {\n    var weight = getWeight(connection);\n    var distance = weight < 0 ? getDistance(connection.source, source) : getDistance(source, connection.source);\n    return {\n      id: connection.source.id,\n      distance: distance,\n      weight: weight\n    };\n  });\n  var targetsDistances = source.outgoing.filter(filter).map(function (connection) {\n    var weight = getWeight(connection);\n    var distance = weight > 0 ? getDistance(source, connection.target) : getDistance(connection.target, source);\n    return {\n      id: connection.target.id,\n      distance: distance,\n      weight: weight\n    };\n  });\n  var distances = sourcesDistances.concat(targetsDistances).reduce(function (accumulator, currentValue) {\n    accumulator[currentValue.id + '__weight_' + currentValue.weight] = currentValue;\n    return accumulator;\n  }, {});\n  var distancesGrouped = reduce(distances, function (accumulator, currentValue) {\n    var distance = currentValue.distance,\n      weight = currentValue.weight;\n    if (distance < 0 || distance > maxDistance) {\n      return accumulator;\n    }\n    if (!accumulator[String(distance)]) {\n      accumulator[String(distance)] = 0;\n    }\n    accumulator[String(distance)] += 1 * weight;\n    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {\n      accumulator.distance = distance;\n    }\n    return accumulator;\n  }, {});\n  return distancesGrouped.distance || defaultDistance;\n}\n\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n *\n * @return {Array<djs.model.Shape>}\n */\nfunction getAutoPlaceClosure(source) {\n  var allConnected = getConnected(source);\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n  return allConnected;\n}\nfunction getConnected(element) {\n  return getTargets(element).concat(getSources(element));\n}\nfunction getSources(shape) {\n  return shape.incoming.map(function (connection) {\n    return connection.source;\n  });\n}\nfunction getTargets(shape) {\n  return shape.outgoing.map(function (connection) {\n    return connection.target;\n  });\n}\nfunction noneFilter() {\n  return true;\n}","map":null,"metadata":{},"sourceType":"module"}