{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WT = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst websocket_constructor_js_1 = require(\"./websocket-constructor.js\");\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = (0, debug_1.default)(\"engine.io-client:webtransport\"); // debug()\nclass WT extends transport_js_1.Transport {\n  get name() {\n    return \"webtransport\";\n  }\n  doOpen() {\n    // @ts-ignore\n    if (typeof WebTransport !== \"function\") {\n      return;\n    }\n    // @ts-ignore\n    this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n    this.transport.closed.then(() => {\n      debug(\"transport closed gracefully\");\n      this.onClose();\n    }).catch(err => {\n      debug(\"transport closed due to %s\", err);\n      this.onError(\"webtransport error\", err);\n    });\n    // note: we could have used async/await, but that would require some additional polyfills\n    this.transport.ready.then(() => {\n      this.transport.createBidirectionalStream().then(stream => {\n        const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n        const reader = stream.readable.pipeThrough(decoderStream).getReader();\n        const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();\n        encoderStream.readable.pipeTo(stream.writable);\n        this.writer = encoderStream.writable.getWriter();\n        const read = () => {\n          reader.read().then(({\n            done,\n            value\n          }) => {\n            if (done) {\n              debug(\"session is closed\");\n              return;\n            }\n            debug(\"received chunk: %o\", value);\n            this.onPacket(value);\n            read();\n          }).catch(err => {\n            debug(\"an error occurred while reading: %s\", err);\n          });\n        };\n        read();\n        const packet = {\n          type: \"open\"\n        };\n        if (this.query.sid) {\n          packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n        }\n        this.writer.write(packet).then(() => this.onOpen());\n      });\n    });\n  }\n  write(packets) {\n    this.writable = false;\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      this.writer.write(packet).then(() => {\n        if (lastPacket) {\n          (0, websocket_constructor_js_1.nextTick)(() => {\n            this.writable = true;\n            this.emitReserved(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n  doClose() {\n    var _a;\n    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n  }\n}\nexports.WT = WT;","map":null,"metadata":{},"sourceType":"script"}